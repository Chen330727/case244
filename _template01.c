#line 1 "template01-cpp.c"
#line 1 "<built-in>"
#line 1 "<command-line>"
#line 1 "/usr/include/stdc-predef.h"
#line 1 "<command-line>"
#line 1 "template01-cpp.c"
#if 700 < 700
  #undef 700
  #define 700 700
#endif
#if _GNU_SOURCE
#include <stdint.h>
#include <string.h>
#include <fenv.h>
#endif



#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdlib.h"
#include <stdlib.h>
#line 2 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdio.h"
#include <stdio.h>
#line 3 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stddef.h"
#include <stddef.h>
#line 4 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdbool.h"
#include <stdbool.h>
#line 5 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdarg.h"
#include <stdarg.h>
#line 6 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/string.h"
#include <string.h>
#line 7 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/float.h"
#include <float.h>
#line 8 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/limits.h"
#include <limits.h>
#line 9 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/math.h"
#include <math.h>
#line 10 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/time.h"
#include <time.h>
#line 11 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/sys/time.h"
#include <sys/time.h>
#line 12 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/sys/resource.h"
#include <sys/resource.h>
#line 13 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"

#if _OPENMP
# include <omp.h>
# define OMP(x) _Pragma(#x)
#elif 1

# define OMP(x)

# include <mpi.h>
static int mpi_rank, mpi_npe;
# define tid() mpi_rank
# define pid() mpi_rank
# define npe() mpi_npe

#else

# define OMP(x)

#endif
#line 46 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#undef HUGE
#define HUGE ((double)1e30)

#define _NVARMAX 65536
#define is_constant(v) ((v).i >= _NVARMAX)
#define constant(v) (is_constant(v) ? _constant[(v).i - _NVARMAX] : HUGE)

#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))
#define sq(x) ((x)*(x))
#define cube(x) ((x)*(x)*(x))
#define sign(x) ((x) > 0 ? 1 : -1)
#define noise() (1. - 2.*rand()/(double)RAND_MAX)
#define clamp(x,a,b) ((x) < (a) ? (a) : (x) > (b) ? (b) : (x))

#define unmap(x,y)

#define trash(x)


#define systderr stderr
#define systdout stdout

#if 1
FILE * qstderr (void);
FILE * qstdout (void);
FILE * ferr = NULL, * fout = NULL;
#define not_mpi_compatible()\
do {\
  if (npe() > 1) {\
    fprintf (ferr, "%s() is not compatible with MPI (yet)\n", __func__);\
    exit (1);\
  }\
} while(0)\

#line 80

# define system(command) (pid() == 0 ? system(command) : 0)
#else
# define qstderr() stderr
# define qstdout() stdout
# define ferr stderr
# define fout stdout
# define not_mpi_compatible()
#endif



static inline void qassert (const char * file, int line, const char * cond) {
  fprintf (ferr, "%s:%d: Assertion `%s' failed.\n", file, line, cond);
  abort();
}
#line 104 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#define sysmalloc malloc
#define syscalloc calloc
#define sysrealloc realloc
#define sysfree free
#define systrdup strdup

#if MTRACE

struct {
  FILE * fp;
  size_t total, max;
  size_t overhead, maxoverhead;
  size_t nr;
  size_t startrss, maxrss;
  char * fname;
} pmtrace;

typedef struct {
  char * func, * file;
  size_t max, total;
  int line, id;
} pmfunc;

typedef struct {
  size_t id, size;
} pmdata;

static pmfunc * pmfuncs = NULL;
static int pmfuncn = 0;

static int pmfunc_index (const char * func, const char * file, int line)
{
  pmfunc * p = pmfuncs;
  for (int i = 0; i < pmfuncn; i++, p++)
    if (p->line == line && !strcmp(func, p->func) && !strcmp(file, p->file))
      return p->id;
  pmfuncn++;
  pmfuncs = (pmfunc *) sysrealloc (pmfuncs, pmfuncn*sizeof(pmfunc));
  p = &pmfuncs[pmfuncn - 1];
  memset (p, 0, sizeof(pmfunc));
  p->func = systrdup(func);
  p->file = systrdup(file);
  p->line = line;
  p->id = pmfuncn;
  if (pmtrace.fp)
    fprintf (pmtrace.fp, "@ %d %s %s %d\n", pmfuncn, func, file, line);
  return pmfuncn;
}

static void pmfunc_trace (pmfunc * f, char c)
{
  if (pmtrace.fp)
    fprintf (pmtrace.fp, "%c %d %ld %ld %ld",
      c, f->id, pmtrace.nr, pmtrace.total, f->total);
#if _GNU_SOURCE
  if (pmtrace.nr % 1 == 0) {
    struct rusage usage;
    getrusage (RUSAGE_SELF, &usage);
    if (pmtrace.fp)
      fprintf (pmtrace.fp, " %ld", usage.ru_maxrss*1024);
    if (!pmtrace.nr)
      pmtrace.startrss = usage.ru_maxrss;
    if (usage.ru_maxrss > pmtrace.maxrss)
      pmtrace.maxrss = usage.ru_maxrss;
  }
#endif
  if (pmtrace.fp)
    fputc ('\n', pmtrace.fp);
  pmtrace.nr++;
}

static void * pmfunc_alloc (pmdata * d, size_t size,
       const char * func, const char * file, int line,
       char c)
{
  if (!(d != NULL)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 179, "d != NULL");
  OMP (omp critical)
  {
    d->id = pmfunc_index(func, file, line);
    d->size = size;
    pmfunc * f = &pmfuncs[d->id - 1];
    f->total += size;
    if (f->total > f->max)
      f->max = f->total;
    pmtrace.total += size;
    pmtrace.overhead += sizeof(pmdata);
    if (pmtrace.total > pmtrace.max) {
      pmtrace.max = pmtrace.total;
      pmtrace.maxoverhead = pmtrace.overhead;
    }
    pmfunc_trace (f, c);
  }
  return ((char *)d) + sizeof(pmdata);
}

static void * pmfunc_free (void * ptr, char c)
{
  if (!ptr)
    return ptr;
  pmdata * d = (pmdata *) (((char *)ptr) - sizeof(pmdata));
  if (d->id < 1 || d->id > pmfuncn) {
    fputs ("*** MTRACE: ERROR!: corrupted free()", ferr);
    if (d->size == 0)
      fputs (", possible double free()", ferr);
    else
      fputs (", not traced?", ferr);
    fputs (", aborting...\n", ferr);
    abort();
    return ptr;
  }
  else
  OMP (omp critical)
  {
    pmfunc * f = &pmfuncs[d->id - 1];
    if (f->total < d->size) {
      fprintf (ferr, "*** MTRACE: ERROR!: %ld < %ld: corrupted free()?\n",
        f->total, d->size);
      abort();
    }
    else
      f->total -= d->size;
    if (pmtrace.total < d->size) {
      fprintf (ferr, "*** MTRACE: ERROR!: %ld < %ld: corrupted free()?\n",
        pmtrace.total, d->size);
      abort();
    }
    else {
      pmtrace.total -= d->size;
      pmtrace.overhead -= sizeof(pmdata);
    }
    d->id = 0;
    d->size = 0;
    pmfunc_trace (f, c);
  }
  return d;
}

static void * pmalloc (size_t size,
         const char * func, const char * file, int line)
{
  return pmfunc_alloc ((pmdata *) sysmalloc (sizeof(pmdata) + size),
         size, func, file, line, '+');
}

static void * pcalloc (size_t nmemb, size_t size,
         const char * func, const char * file, int line)
{
  void * p = pmalloc (nmemb*size, func, file, line);
  return memset (p, 0, nmemb*size);
}

static void * prealloc (void * ptr, size_t size,
   const char * func, const char * file, int line)
{
  return pmfunc_alloc ((pmdata *) sysrealloc (pmfunc_free(ptr, '<'),
           sizeof(pmdata) + size),
         size, func, file, line, '>');
}

static void pfree (void * ptr,
     const char * func, const char * file, int line)
{
  sysfree (pmfunc_free (ptr, '-'));
}

static char * pstrdup (const char * s,
         const char * func, const char * file, int line)
{
  char * d = (char *) pmalloc (strlen(s) + 1, func, file, line);
  return strcpy (d, s);
}

#if MTRACE < 3
static int pmaxsort (const void * a, const void * b) {
  const pmfunc * p1 = a, * p2 = b;
  return p1->max < p2->max;
}
#endif

static int ptotalsort (const void * a, const void * b) {
  const pmfunc * p1 = (const pmfunc *) a, * p2 = (const pmfunc *) b;
  return p1->total < p2->total;
}

static void pmfuncs_free()
{
  pmfunc * p = pmfuncs;
  for (int i = 0; i < pmfuncn; i++, p++) {
    sysfree (p->func);
    sysfree (p->file);
  }
  sysfree (pmfuncs);
}

void pmuntrace (void)
{
#if MTRACE < 3
  fprintf (ferr,
    "*** MTRACE: max resident  set size: %10ld bytes\n"
    "*** MTRACE: max traced memory size: %10ld bytes"
    " (tracing overhead %.1g%%)\n"
    "%10s    %20s   %s\n",
    pmtrace.maxrss*1024,
    pmtrace.max, pmtrace.maxoverhead*100./pmtrace.max,
    "max bytes", "function", "file");
  qsort (pmfuncs, pmfuncn, sizeof(pmfunc), pmaxsort);
  pmfunc * p = pmfuncs;
  for (int i = 0; i < pmfuncn && p->max > 0; i++, p++)
    fprintf (ferr, "%10ld    %20s   %s:%d\n",
      p->max, p->func, p->file, p->line);

  if (pmtrace.fp) {
    char * fname = pmtrace.fname, * s;
    while ((s = strchr(fname,'/')))
      fname = s + 1;

    fputs ("load(\"`echo $BASILISK`/mtrace.plot\")\n", pmtrace.fp);
    fprintf (pmtrace.fp,
      "plot '%s' u 3:($6-%g) w l t 'ru_maxrss - %.3g',"
      "total(\"%s\") w l t 'total'",
      fname,
      pmtrace.startrss*1024.,
      pmtrace.startrss*1024.,
      fname);
    pmfunc * p = pmfuncs;
    for (int i = 0; i < pmfuncn && p->max > 0.01*pmtrace.max; i++, p++)
      fprintf (pmtrace.fp,
        ",func(\"%s\",%d) w l t '%s'",
        fname, p->id, p->func);
    fputc ('\n', pmtrace.fp);
    fprintf (ferr,
      "*** MTRACE: To get a graph use: tail -n 2 %s | gnuplot -persist\n",
      fname);
    fclose (pmtrace.fp);
    pmtrace.fp = NULL;
    sysfree (pmtrace.fname);
  }
#endif

  if (pmtrace.total > 0) {
    qsort (pmfuncs, pmfuncn, sizeof(pmfunc), ptotalsort);
    pmfunc * p = pmfuncs;
    for (int i = 0; i < pmfuncn && p->total > 0; i++, p++)
      fprintf (ferr, "%s:%d: error: %ld bytes leaked here\n",
        p->file, p->line, p->total);
    pmfuncs_free();
    exit(1);
  }
  else {
#if MTRACE < 3
    fputs ("*** MTRACE: No memory leaks\n", ferr);
#endif
    pmfuncs_free();
  }
}

#else
# define pmalloc(s,func,file,line) malloc(s)
# define pcalloc(n,s,func,file,line) calloc(n,s)
# define prealloc(p,s,func,file,line) realloc(p,s)
# define pfree(p,func,file,line) free(p)
# define pstrdup(s,func,file,line) strdup(s)
#endif







typedef struct {
  void * p;
  long max, len;
} Array;

Array * array_new()
{
  Array * a = ((Array *) pmalloc ((1)*sizeof(Array),__func__,__FILE__,__LINE__));
  a->p = NULL;
  a->max = a->len = 0;
  return a;
}

void array_free (Array * a)
{
  pfree (a->p,__func__,__FILE__,__LINE__);
  pfree (a,__func__,__FILE__,__LINE__);
}

void array_append (Array * a, void * elem, size_t size)
{
  if (a->len + size >= a->max) {
    a->max += max (size, 4096);
    a->p = prealloc (a->p, a->max,__func__,__FILE__,__LINE__);
  }
  memcpy (((char *)a->p) + a->len, elem, size);
  a->len += size;
}

void * array_shrink (Array * a)
{
  void * p = prealloc (a->p, a->len,__func__,__FILE__,__LINE__);
  pfree (a,__func__,__FILE__,__LINE__);
  return p;
}



#if TRACE == 1
#include <extrae_user_events.h>

typedef struct {
  Array index, stack;
  extrae_type_t type;
} Trace;

Trace trace_func = {
  {NULL, 0, 0}, {NULL, 0, 0},
  60000010,
};

Trace trace_mpi_func = {
  {NULL, 0, 0}, {NULL, 0, 0},
  60000011,
};

static int lookup_func (Array * a, const char * func)
{
  for (int i = 0; i < a->len/sizeof(char *); i++) {
    char * s = ((char **)a->p)[i];
    if (!strcmp (func, s))
      return i + 1;
  }
  char * s = pstrdup (func,__func__,__FILE__,__LINE__);
  array_append (a, &s, sizeof(char *));
  return a->len;
}

static void trace_push (Trace * t, const char * func)
{
  int value = lookup_func (&t->index, func);
  Extrae_eventandcounters (t->type, value);
  array_append (&t->stack, &value, sizeof(int));
}

static void trace_pop (Trace * t, const char * func)
{
  if (!(t->stack.len > 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 451, "t->stack.len > 0");
  t->stack.len -= sizeof(int);
  int value = t->stack.len > 0 ?
    ((int *)t->stack.p)[t->stack.len/sizeof(int) - 1] : 0;
  Extrae_eventandcounters (t->type, value);
}

static void trace_define (Trace * t, char * description)
{
  if (t->index.len > 0) {
    extrae_value_t values[t->index.len/sizeof(char *) + 1];
    char * names[t->index.len/sizeof(char *) + 1],
      ** func = (char **) t->index.p;
    names[0] = "OTHER";
    values[0] = 0;
    unsigned len = 1;
    for (int i = 0; i < t->index.len/sizeof(char *); i++, func++) {
      names[len] = *func;
      values[len++] = i + 1;
    }
    Extrae_define_event_type (&t->type, description, &len, values, names);
  }
}

static void trace_free (Trace * t)
{
  char ** func = (char **) t->index.p;
  for (int i = 0; i < t->index.len/sizeof(char *); i++, func++)
    pfree (*func,__func__,__FILE__,__LINE__);
  pfree (t->index.p,__func__,__FILE__,__LINE__);
  pfree (t->stack.p,__func__,__FILE__,__LINE__);
}

static void trace_off()
{
  trace_define (&trace_func, "Basilisk functions");
  trace_define (&trace_mpi_func, "Basilisk functions (MPI-related)");
  trace_free (&trace_func);
  trace_free (&trace_mpi_func);
}






# define tracing(func, file, line) trace_push (&trace_func, func)
# define end_tracing(func, file, line) trace_pop (&trace_func, func)

#elif TRACE

typedef struct {
  char * func, * file;
  int line, calls;
  double total, self;
#if 1
  double min, max;
#endif
} TraceIndex;

struct {
  Array stack, index;
  double t0;
} Trace = {
  {NULL, 0, 0}, {NULL, 0, 0},
  -1
};

static void trace_add (const char * func, const char * file, int line,
         double total, double self)
{
  TraceIndex * t = (TraceIndex *) Trace.index.p;
  int i, len = Trace.index.len/sizeof(TraceIndex);
  for (i = 0; i < len; i++, t++)
    if (t->line == line && !strcmp (func, t->func) && !strcmp (file, t->file))
      break;
  if (i == len) {
    TraceIndex t = {pstrdup(func,__func__,__FILE__,__LINE__), pstrdup(file,__func__,__FILE__,__LINE__), line, 1, total, self};
    array_append (&Trace.index, &t, sizeof(TraceIndex));
  }
  else
    t->calls++, t->total += total, t->self += self;
}

static void tracing (const char * func, const char * file, int line)
{
  struct timeval tv;
  gettimeofday (&tv, NULL);
  if (Trace.t0 < 0)
    Trace.t0 = tv.tv_sec + tv.tv_usec/1e6;
  double t[2] = {(tv.tv_sec - Trace.t0) + tv.tv_usec/1e6, 0.};
  array_append (&Trace.stack, t, 2*sizeof(double));




}

static void end_tracing (const char * func, const char * file, int line)
{
  struct timeval tv;
  gettimeofday (&tv, NULL);
  double te = (tv.tv_sec - Trace.t0) + tv.tv_usec/1e6;
  double * t = (double *) Trace.stack.p;
  if (!(Trace.stack.len >= 2*sizeof(double))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 555, "Trace.stack.len >= 2*sizeof(double)");
  t += Trace.stack.len/sizeof(double) - 2;
  Trace.stack.len -= 2*sizeof(double);
  double dt = te - t[0];




  trace_add (func, file, line, dt, dt - t[1]);
  if (Trace.stack.len >= 2*sizeof(double)) {
    t -= 2;
    t[1] += dt;
  }
}

static int compar_self (const void * p1, const void * p2)
{
  const TraceIndex * t1 = p1, * t2 = p2;
  return t1->self < t2->self;
}

#if 1
static int compar_func (const void * p1, const void * p2)
{
  const TraceIndex * t1 = p1, * t2 = p2;
  if (t1->line != t2->line)
    return t1->line < t2->line;
  return strcmp (t1->file, t2->file);
}
#endif

void trace_print (FILE * fp, double threshold)
{
  int i, len = Trace.index.len/sizeof(TraceIndex);
  double total = 0.;
  TraceIndex * t;
  Array * index = array_new();
  for (i = 0, t = (TraceIndex *) Trace.index.p; i < len; i++, t++)
    array_append (index, t, sizeof(TraceIndex)), total += t->self;
#if 1
  qsort (index->p, len, sizeof(TraceIndex), compar_func);
  double tot[len], self[len], min[len], max[len];
  for (i = 0, t = (TraceIndex *) index->p; i < len; i++, t++)
    tot[i] = t->total, self[i] = t->self;
  MPI_Reduce (self, min, len, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);
  MPI_Reduce (self, max, len, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
  MPI_Reduce (pid() ? self : MPI_IN_PLACE,
       self, len, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce (pid() ? tot : MPI_IN_PLACE,
       tot, len, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  total = 0.;
  for (i = 0, t = (TraceIndex *) index->p; i < len; i++, t++)
    t->total = tot[i]/npe(), t->self = self[i]/npe(),
      t->max = max[i], t->min = min[i], total += t->self;
#endif
  qsort (index->p, len, sizeof(TraceIndex), compar_self);
  fprintf (fp, "   calls    total     self   %% total   function\n");
  for (i = 0, t = (TraceIndex *) index->p; i < len; i++, t++)
    if (t->self*100./total > threshold) {
      fprintf (fp, "%8d   %6.2f   %6.2f     %4.1f%%",
        t->calls, t->total, t->self, t->self*100./total);
#if 1
      fprintf (fp, " (%4.1f%% - %4.1f%%)", t->min*100./total, t->max*100./total);
#endif
      fprintf (fp, "   %s():%s:%d\n", t->func, t->file, t->line);
    }
  fflush (fp);
  array_free (index);
  for (i = 0, t = (TraceIndex *) Trace.index.p; i < len; i++, t++)
    t->calls = t->total = t->self = 0.;
}

static void trace_off()
{
  trace_print (fout, 0.);

  int i, len = Trace.index.len/sizeof(TraceIndex);
  TraceIndex * t;
  for (i = 0, t = (TraceIndex *) Trace.index.p; i < len; i++, t++)
    pfree (t->func,__func__,__FILE__,__LINE__), pfree (t->file,__func__,__FILE__,__LINE__);

  pfree (Trace.index.p,__func__,__FILE__,__LINE__);
  Trace.index.p = NULL;
  Trace.index.len = Trace.index.max = 0;

  pfree (Trace.stack.p,__func__,__FILE__,__LINE__);
  Trace.stack.p = NULL;
  Trace.stack.len = Trace.stack.max = 0;
}

#else
# define tracing(...)
# define end_tracing(...)
#endif



#if _OPENMP

#define tid() omp_get_thread_num()
#define pid() 0
#define npe() omp_get_num_threads()
#define mpi_all_reduce(v,type,op)
#define mpi_all_reduce_array(v,type,op,elem)

#elif 1

static bool in_prof = false;
static double prof_start, _prof;
#define prof_start(name)\
  if (!(!in_prof)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 665, "!in_prof"); in_prof = true;\
  prof_start = MPI_Wtime();\

#line 667

#define prof_stop()\
  if (!(in_prof)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 669, "in_prof"); in_prof = false;\
  _prof = MPI_Wtime();\
  mpi_time += _prof - prof_start;\

#line 672


#if FAKE_MPI
#define mpi_all_reduce(v,type,op)
#define mpi_all_reduce_array(v,type,op,elem)
#else
     
int mpi_all_reduce0 (void *sendbuf, void *recvbuf, int count,
       MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)
{tracing("mpi_all_reduce0","/home/xiangbin2/basilisk_new/basilisk/src/common.h",679);
  { int _ret= MPI_Allreduce (sendbuf, recvbuf, count, datatype, op, comm);end_tracing("mpi_all_reduce0","/home/xiangbin2/basilisk_new/basilisk/src/common.h",682);return _ret;}
end_tracing("mpi_all_reduce0","/home/xiangbin2/basilisk_new/basilisk/src/common.h",683);}
#define mpi_all_reduce(v,type,op) {\
  prof_start ("mpi_all_reduce");\
  union { int a; float b; double c;} global;\
  mpi_all_reduce0 (&(v), &global, 1, type, op, MPI_COMM_WORLD);\
  memcpy (&(v), &global, sizeof (v));\
  prof_stop();\
}\

#line 691

#define mpi_all_reduce_array(v,type,op,elem) {\
  prof_start ("mpi_all_reduce");\
  type global[elem], tmp[elem];\
  for (int i = 0; i < elem; i++)\
    tmp[i] = (v)[i];\
  MPI_Datatype datatype;\
  if (!strcmp(#type, "double")) datatype = MPI_DOUBLE;\
  else if (!strcmp(#type, "int")) datatype = MPI_INT;\
  else if (!strcmp(#type, "long")) datatype = MPI_LONG;\
  else if (!strcmp(#type, "bool")) datatype = MPI_C_BOOL;\
  else {\
    fprintf (stderr, "unknown reduction type '%s'\n", #type);\
    fflush (stderr);\
    abort();\
  }\
  mpi_all_reduce0 (tmp, global, elem, datatype, op, MPI_COMM_WORLD);\
  for (int i = 0; i < elem; i++)\
    (v)[i] = global[i];\
  prof_stop();\
}\

#line 712


#endif

#define QFILE FILE

FILE * qstderr (void)
{
  static QFILE * fp = NULL;
  if (!fp) {
    if (mpi_rank > 0) {
      char name[80];
      sprintf (name, "log-%d", mpi_rank);
      fp = fopen (name, "w");
    }
    else
      fp = systderr;
  }
  return fp;
}

FILE * qstdout (void)
{
  static QFILE * fp = NULL;
  if (!fp) {
    if (mpi_rank > 0) {
      char name[80];
      sprintf (name, "out-%d", mpi_rank);
      fp = fopen (name, "w");
    }
    else
      fp = systdout;
  }
  return fp;
}

static void finalize (void)
{
  MPI_Finalize();
}

void mpi_init()
{
  int initialized;
  MPI_Initialized (&initialized);
  if (!initialized) {
    MPI_Init (NULL, NULL);
    MPI_Comm_set_errhandler (MPI_COMM_WORLD, MPI_ERRORS_ARE_FATAL);
    atexit (finalize);
  }
  MPI_Comm_rank (MPI_COMM_WORLD, &mpi_rank);
  MPI_Comm_size (MPI_COMM_WORLD, &mpi_npe);
  srand (mpi_rank + 1);
  if (ferr == NULL) {
    if (mpi_rank > 0) {
      ferr = fopen ("/dev/null", "w");
      fout = fopen ("/dev/null", "w");
    }
    else {
      ferr = systderr;
      fout = systdout;
    }
    char * etrace = getenv ("MALLOC_TRACE"), name[80];
    if (etrace && mpi_rank > 0) {
      sprintf (name, "%s-%d", etrace, mpi_rank);
      setenv ("MALLOC_TRACE", name, 1);
    }
#if MTRACE == 1
    etrace = getenv ("MTRACE");
    if (!etrace)
      etrace = "mtrace";
    if (mpi_rank > 0) {
      sprintf (name, "%s-%d", etrace, mpi_rank);
      pmtrace.fp = fopen (name, "w");
      pmtrace.fname = systrdup(name);
    }
    else {
      pmtrace.fp = fopen (etrace, "w");
      pmtrace.fname = systrdup(etrace);
    }
#endif
  }
}

#else

#define tid() 0
#define pid() 0
#define npe() 1
#define mpi_all_reduce(v,type,op)
#define mpi_all_reduce_array(v,type,op,elem)

#endif

#define OMP_PARALLEL() OMP(omp parallel)

#define NOT_UNUSED(x) (void)(x)

#define VARIABLES ;
#define _index(a,m) (a.i)
#define val(a,k,l,m) data(k,l,m)[_index(a,m)]

double _val_higher_dimension = 0.;
#line 823 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#if (_GNU_SOURCE || __APPLE__) && !_OPENMP && !_CADNA
double undefined;
# if __APPLE__
# include <stdint.h>
# include "fp_osx.h"
# endif
# define enable_fpe(flags) feenableexcept (flags)
# define disable_fpe(flags) fedisableexcept (flags)
static void set_fpe (void) {
  int64_t lnan = 0x7ff0000000000001;
  if (!(sizeof (int64_t) == sizeof (double))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 833, "sizeof (int64_t) == sizeof (double)");
  memcpy (&undefined, &lnan, sizeof (double));
  enable_fpe (FE_DIVBYZERO|FE_INVALID);
}
#else
# define undefined ((double) DBL_MAX)
# define enable_fpe(flags)
# define disable_fpe(flags)
static void set_fpe (void) {}
#endif


typedef struct {
  long n;
  long tn;
  int depth;
  int maxdepth;
} Grid;
Grid * grid = NULL;

double X0 = 0., Y0 = 0., Z0 = 0.;

double L0 = 1.;


int N = 64;




typedef struct { int i; } scalar;

typedef struct {
  scalar x;

  scalar y;




} vector;

typedef struct {
  scalar * x;

  scalar * y;




} vectorl;

typedef struct {
  vector x;

  vector y;




} tensor;

struct { int x, y, z; } Period = {false, false, false};

typedef struct {
  double x, y, z;
} coord;

OMP(omp declare reduction (+ : coord :
      omp_out.x += omp_in.x,
      omp_out.y += omp_in.y,
      omp_out.z += omp_in.z))
#line 917 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
void normalize (coord * n)
{
  double norm = 0.;
  
    norm += sq(n->x);
    
#line 921
norm += sq(n->y);
  norm = sqrt(norm);
  
    n->x /= norm;
    
#line 924
n->y /= norm;
}

struct _origin { double x, y, z; };

void origin (struct _origin p) {
  X0 = p.x; Y0 = p.y; Z0 = p.z;
}

void size (double L) {
  L0 = L;
}

double zero (double s0, double s1, double s2) { return 0.; }






  enum { right, left, top, bottom };



int nboundary = 2*2;



#define dirichlet(expr) (2.*(expr) - val(_s,0,0,0))
#define dirichlet_homogeneous() (- val(_s,0,0,0))
#define dirichlet_face(expr) (expr)
#define dirichlet_face_homogeneous() (0.)
#define neumann(expr) (Delta*(expr) + val(_s,0,0,0))
#define neumann_homogeneous() (val(_s,0,0,0))

double * _constant = NULL;
size_t datasize = 0;
typedef struct _Point Point;

#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/boundaries.h"


typedef struct _Boundary Boundary;

struct _Boundary {
  void (* destroy) (Boundary * b);
  void (* level) (const Boundary * b, scalar * list, int l);

  void (* restriction) (const Boundary * b, scalar * list, int l);
};

static Boundary ** boundaries = NULL;

void add_boundary (Boundary * b) {
  int len = 0;
  if (boundaries) {
    Boundary ** i = boundaries;
    while (*i++) len++;
  }
  boundaries = (Boundary * *) prealloc (boundaries, (len + 2)*sizeof(Boundary *),__func__,__FILE__,__LINE__);
  boundaries[len] = b;
  boundaries[len+1] = NULL;
}

void free_boundaries() {
  if (!boundaries)
    return;
  Boundary ** i = boundaries, * b;
  while ((b = *i++))
    if (b->destroy)
      b->destroy (b);
    else
      pfree (b,__func__,__FILE__,__LINE__);
  pfree (boundaries,__func__,__FILE__,__LINE__);
  boundaries = NULL;
}
#line 47 "/home/xiangbin2/basilisk_new/basilisk/src/grid/boundaries.h"
typedef struct {
  Boundary parent;
  int d;
} BoxBoundary;
#line 964 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"



typedef struct {
  double (** boundary) (Point, Point, scalar, void *);
  double (** boundary_homogeneous) (Point, Point, scalar, void *);
  double (* gradient) (double, double, double);
  void (* delete) (scalar);
  char * name;
  struct {
    int x;

    int y;




  } d;
  vector v;
  int face;
  bool nodump, freed;
  int block;
  scalar * depends;

  
#line 19 "/home/xiangbin2/basilisk_new/basilisk/src/grid/stencils.h"
bool input, output;
  int width;
  int dirty;
  
#line 18 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"
void (* prolongation) (Point, scalar);
  void (* restriction) (Point, scalar);
  
#line 9 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
void (* refine) (Point, scalar);
  
#line 97
void (* coarsen) (Point, scalar);
  
#line 82 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
vector n;
  
#line 210 "./././my-embed-tree.h"
void (* embed_gradient) (Point, scalar, coord *);
  
#line 179 "././embed-update-2.h"
bool third;
  
#line 28 "././my-vof-css-test.h"
scalar * tracers, c;
  bool inverse;
  bool khaki;
  
#line 456 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
vector height;
  
#line 608 "././embed-solid.h"
scalar f1;
  scalar f2;
  
#line 12 "./././linear2-tree-2.h"
scalar ff6;
  
#line 198 "././././my-distance.h"
scalar surface2;
  
#line 21 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
scalar phi;
  
#line 22 "././my-tension.h"
double sigma;
  
#line 178 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
scalar surface;

#line 987 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
} _Attributes;

static _Attributes * _attribute = NULL;






int list_len (scalar * list)
{
  if (!list) return 0;
  int ns = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ ns++;}}
  return ns;
}

scalar * list_append (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) prealloc (list, (len + 2)*sizeof(scalar),__func__,__FILE__,__LINE__);
  list[len] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_prepend (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) prealloc (list, (len + 2)*sizeof(scalar),__func__,__FILE__,__LINE__);
  for (int i = len; i >= 1; i--)
    list[i] = list[i-1];
  list[0] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_add (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  return list_append (list, s);
}

int list_lookup (scalar * l, scalar s)
{
  if (l != NULL)
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s1=*_i;(&s1)->i>=0;s1=*++_i){
      if (s1.i == s.i)
 return true;}}
  return false;
}

scalar * list_copy (scalar * l)
{
  scalar * list = NULL;
  if (l != NULL)
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      list = list_append (list, s);}}
  return list;
}

scalar * list_concat (scalar * l1, scalar * l2)
{
  scalar * l3 = list_copy (l1);
  {scalar*_i=(scalar*)( l2);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    l3 = list_append (l3, s);}}
  return l3;
}

void list_print (scalar * l, FILE * fp)
{
  int i = 0;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (fp, "%s%s", i++ == 0 ? "{" : ",", _attribute[s.i].name);}}
  fputs (i > 0 ? "}\n" : "{}\n", fp);
}

int vectors_len (vector * list)
{
  if (!list) return 0;
  int nv = 0;
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ nv++;}}
  return nv;
}

vector * vectors_append (vector * list, vector v)
{
  int len = vectors_len (list);
  list = (vector *) prealloc (list, (len + 2)*sizeof(vector),__func__,__FILE__,__LINE__);
  list[len] = v;
  list[len + 1] = (vector){{-1}};
  return list;
}

vector * vectors_add (vector * list, vector v)
{
  {vector*_i=(vector*)( list);if(_i)for(vector w=*_i;(&w)->x.i>=0;w=*++_i){ {
    bool id = true;
    
      if (w.x.i != v.x.i)
 id = false;
      
#line 1088
if (w.y.i != v.y.i)
 id = false;
    if (id)
      return list;
  }}}
  return vectors_append (list, v);
}

vector * vectors_copy (vector * l)
{
  vector * list = NULL;
  if (l != NULL)
    {vector*_i=(vector*)( l);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      list = vectors_append (list, v);}}
  return list;
}

vector * vectors_from_scalars (scalar * s)
{
  vector * list = NULL;
  while (s->i >= 0) {
    vector v;
     {
      if (!(s->i >= 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 1111, "s->i >= 0");
      v.x = *s++;
    } 
#line 1110
{
      if (!(s->i >= 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 1111, "s->i >= 0");
      v.y = *s++;
    }
    list = vectors_append (list, v);
  }
  return list;
}

int tensors_len (tensor * list)
{
  if (!list) return 0;
  int nt = 0;
  {tensor*_i=(tensor*)( list);if(_i)for(tensor t=*_i;(&t)->x.x.i>=0;t=*++_i){ nt++;}}
  return nt;
}

tensor * tensors_append (tensor * list, tensor t)
{
  int len = tensors_len (list);
  list = (tensor *) prealloc (list, (len + 2)*sizeof(tensor),__func__,__FILE__,__LINE__);
  list[len] = t;
  list[len + 1] = (tensor){{{-1}}};
  return list;
}

tensor * tensors_from_vectors (vector * v)
{
  tensor * list = NULL;
  while (v->x.i >= 0) {
    tensor t;
     {
      if (!(v->x.i >= 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 1142, "v->x.i >= 0");
      t.x = *v++;
    } 
#line 1141
{
      if (!(v->y.i >= 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/common.h", 1142, "v->x.i >= 0");
      t.y = *v++;
    }
    list = tensors_append (list, t);
  }
  return list;
}

static inline bool is_vertex_scalar (scalar s)
{
  
    if (_attribute[s.i].d.x != -1)
      return false;
    
#line 1153
if (_attribute[s.i].d.y != -1)
      return false;
  return true;
}

scalar * all = NULL;
scalar * baseblock = NULL;



scalar (* init_scalar) (scalar, const char *);
scalar (* init_vertex_scalar) (scalar, const char *);
vector (* init_vector) (vector, const char *);
tensor (* init_tensor) (tensor, const char *);
vector (* init_face_vector) (vector, const char *);





typedef struct _Event Event;
typedef int (* Expr) (int *, double *, Event *);

struct _Event {
  int last, nexpr;
  int (* action) (const int, const double, Event *);
  Expr expr[3];
  int * arrayi;
  double * arrayt;
  char * file;
  int line;
  char * name;
  double t;
  int i, a;
  void * data;
  Event * next;
};

static Event * Events = NULL;

int iter = 0, inext = 0;
double t = 0, tnext = 0;
void init_events (void);
void event_register (Event event);
static void _init_solver (void);

void init_solver()
{
  Events = pmalloc (sizeof (Event),__func__,__FILE__,__LINE__);
  Events[0].last = 1;
  _attribute = pcalloc (datasize/sizeof(double), sizeof (_Attributes),__func__,__FILE__,__LINE__);
  int n = datasize/sizeof(double);
  all = (scalar *) pmalloc (sizeof (scalar)*(n + 1),__func__,__FILE__,__LINE__);
  baseblock = (scalar *) pmalloc (sizeof (scalar)*(n + 1),__func__,__FILE__,__LINE__);
  for (int i = 0; i < n; i++)
    baseblock[i].i = all[i].i = i;
  baseblock[n].i = all[n].i = -1;
#if _CADNA
  cadna_init (-1);
#endif
#if 1
  mpi_init();
#elif MTRACE == 1
  char * etrace = getenv ("MTRACE");
  pmtrace.fp = fopen (etrace ? etrace : "mtrace", "w");
  pmtrace.fname = systrdup (etrace ? etrace : "mtrace");
#endif
}



#if 1
static double mpi_time = 0.;
#endif

typedef struct {
  clock_t c;
  struct timeval tv;
  double tm;
} timer;

timer timer_start (void)
{
  timer t;
  t.c = clock();
  gettimeofday (&t.tv, NULL);
#if 1
  t.tm = mpi_time;
#endif
  return t;
}

double timer_elapsed (timer t)
{
  struct timeval tvend;
  gettimeofday (&tvend, NULL);
  return ((tvend.tv_sec - t.tv.tv_sec) +
   (tvend.tv_usec - t.tv.tv_usec)/1e6);
}



const vector zerof = {{_NVARMAX+0},{_NVARMAX+1}};
const vector unityf = {{_NVARMAX+2},{_NVARMAX+3}};
const scalar unity = {_NVARMAX+4};
const scalar zeroc = {_NVARMAX+5};



        vector fm = {{_NVARMAX+2},{_NVARMAX+3}};
        scalar cm = {_NVARMAX+4};
#line 1277 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
static FILE ** qpopen_pipes = NULL;

FILE * qpopen (const char * command, const char * type)
{
  if (pid() > 0)
    return fopen ("/dev/null", type);
  FILE * fp = popen (command, type);
  if (fp) {
    FILE ** i = qpopen_pipes;
    int n = 0;
    while (i && *i) { n++; i++; }
    qpopen_pipes = (FILE * *) prealloc (qpopen_pipes, (n + 2)*sizeof(FILE *),__func__,__FILE__,__LINE__);
    qpopen_pipes[n] = fp;
    qpopen_pipes[n+1] = NULL;
  }
  return fp;
}

int qpclose (FILE * fp)
{
  if (pid() > 0)
    return fclose (fp);
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i == fp)
      *i = (FILE *) 1;
    i++;
  }
  return pclose (fp);
}

static void qpclose_all()
{
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i != (FILE *) 1)
      pclose (*i);
    i++;
  }
  pfree (qpopen_pipes,__func__,__FILE__,__LINE__);
  qpopen_pipes = NULL;
}






FILE * lfopen (const char * name, const char * mode)
{
  char fname[80];
  sprintf (fname, "%s-%d", name, pid());
  return fopen (fname, mode);
}



void * matrix_new (int n, int p, size_t size)
{
  void ** m = ((void * *) pmalloc ((n)*sizeof(void *),__func__,__FILE__,__LINE__));
  char * a = ((char *) pmalloc ((n*p*size)*sizeof(char),__func__,__FILE__,__LINE__));
  for (int i = 0; i < n; i++)
    m[i] = a + i*p*size;
  return m;
}

double matrix_inverse (double ** m, int n, double pivmin)
{
  int indxc[n], indxr[n], ipiv[n];
  int i, icol = 0, irow = 0, j, k, l, ll;
  double big, dum, pivinv, minpiv = HUGE;

  for (j = 0; j < n; j++)
    ipiv[j] = -1;

  for (i = 0; i < n; i++) {
    big = 0.0;
    for (j = 0; j < n; j++)
      if (ipiv[j] != 0)
 for (k = 0; k < n; k++) {
   if (ipiv[k] == -1) {
     if (fabs (m[j][k]) >= big) {
       big = fabs (m[j][k]);
       irow = j;
       icol = k;
     }
   }
 }
    ipiv[icol]++;
    if (irow != icol)
      for (l = 0; l < n; l++)
 do { double __tmp = m[irow][l]; m[irow][l] = m[icol][l]; m[icol][l] = __tmp; } while(0);
    indxr[i] = irow;
    indxc[i] = icol;
    if (fabs (m[icol][icol]) <= pivmin)
      return 0.;
    if (fabs (m[icol][icol]) < minpiv)
      minpiv = fabs (m[icol][icol]);
    pivinv = 1.0/m[icol][icol];
    m[icol][icol] = 1.0;
    for (l = 0; l < n; l++) m[icol][l] *= pivinv;
    for (ll = 0; ll < n; ll++)
      if (ll != icol) {
 dum = m[ll][icol];
 m[ll][icol] = 0.0;
 for (l = 0; l < n; l++)
   m[ll][l] -= m[icol][l]*dum;
      }
  }
  for (l = n - 1; l >= 0; l--) {
    if (indxr[l] != indxc[l])
      for (k = 0; k < n; k++)
 do { double __tmp = m[k][indxr[l]]; m[k][indxr[l]] = m[k][indxc[l]]; m[k][indxc[l]] = __tmp; } while(0);
  }
  return minpiv;
}

void matrix_free (void * m)
{
  pfree (((void **) m)[0],__func__,__FILE__,__LINE__);
  pfree (m,__func__,__FILE__,__LINE__);
}



typedef void (* free_solver_func) (void);

static Array * free_solver_funcs = NULL;

void free_solver_func_add (free_solver_func func)
{
  if (!free_solver_funcs)
    free_solver_funcs = array_new();
  array_append (free_solver_funcs, &func, sizeof(free_solver_func));
}



static char * display_defaults = NULL;

struct _display {
  const char * commands;
  bool overwrite;
};

static void free_display_defaults() {
  pfree (display_defaults,__func__,__FILE__,__LINE__);
}

void display (struct _display p)
{
  if (display_defaults == NULL)
    free_solver_func_add (free_display_defaults);
  if (p.overwrite) {
    pfree (display_defaults,__func__,__FILE__,__LINE__);
    display_defaults = pmalloc (strlen(p.commands) + 2,__func__,__FILE__,__LINE__);
    strcpy (display_defaults, "@");
    strcat (display_defaults, p.commands);
  }
  else {
    if (!display_defaults)
      display_defaults = pstrdup ("@",__func__,__FILE__,__LINE__);
    display_defaults =
      prealloc (display_defaults,
        strlen(display_defaults) + strlen(p.commands) + 1,__func__,__FILE__,__LINE__);
    strcat (display_defaults, p.commands);
  }
}







#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/stencils.h"
#line 17 "/home/xiangbin2/basilisk_new/basilisk/src/grid/stencils.h"










typedef struct {
  const char * fname;
  int line;
  int first;
  int face;
  bool vertex;
} ForeachData;


#define foreach_stencil() {\
  static ForeachData _loop = {\
    __FILE__, __LINE__,\
    1, 0, 0\
  };\
  if (baseblock) for (scalar s = baseblock[0], * i = baseblock;\
  s.i >= 0; i++, s = *i) {\
    _attribute[s.i].input = _attribute[s.i].output = false;\
    _attribute[s.i].width = 0;\
  }\
  int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);\
  Point point = {0}; NOT_UNUSED (point);\

#line 48


#define end_foreach_stencil()\
  end_stencil (&_loop);\
  _loop.first = 0;\
}\

#line 54


#define foreach_vertex_stencil() foreach_stencil() _loop.vertex = true;
#define end_foreach_vertex_stencil() end_foreach_stencil()

#define foreach_face_stencil() foreach_stencil()
#define end_foreach_face_stencil() end_foreach_stencil()

#define foreach_visible_stencil(...) foreach_stencil()
#define end_foreach_visible_stencil(...) end_foreach_stencil()

#define _stencil_is_face_x() { _loop.face |= (1 << 0);
#define end__stencil_is_face_x() }
#define _stencil_is_face_y() { _loop.face |= (1 << 1);
#define end__stencil_is_face_y() }
#define _stencil_is_face_z() { _loop.face |= (1 << 2);
#define end__stencil_is_face_z() }

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, bool overflow);
void stencil_val_a (Point p, scalar s, int i, int j, int k, bool input,
      const char * file, int line);

#define _stencil_val(a,_i,_j,_k)\
  stencil_val (point, a, _i, _j, _k, __FILE__, __LINE__, false)\

#line 79

#define _stencil_val_o(a,_i,_j,_k)\
  stencil_val (point, a, _i, _j, _k, __FILE__, __LINE__, true)\

#line 82

#define _stencil_val_a(a,_i,_j,_k)\
  stencil_val_a (point, a, _i, _j, _k, false, __FILE__, __LINE__)\

#line 85

#define _stencil_val_r(a,_i,_j,_k)\
  stencil_val_a (point, a, _i, _j, _k, true, __FILE__, __LINE__)\

#line 88


#define _stencil_fine(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_fine_a(a,_i,_j,_k) _stencil_val_a(a,_i,_j,_k)
#define _stencil_fine_r(a,_i,_j,_k) _stencil_val_r(a,_i,_j,_k)

#define _stencil_coarse(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_coarse_a(a,_i,_j,_k) _stencil_val_a(a,_i,_j,_k)
#define _stencil_coarse_r(a,_i,_j,_k) _stencil_val_r(a,_i,_j,_k)

#define r_assign(x)
#define _assign(x)

#define _stencil_neighbor(i,j,k)
#define _stencil_child(i,j,k)
#define _stencil_aparent(i,j,k)
#define _stencil_aparent_a(i,j,k)
#define _stencil_aparent_r(i,j,k)

#define _stencil_neighborp(i,j,k) neighborp(i,j,k)

int _stencil_nop;
#define _stencil_val_higher_dimension (_stencil_nop = 1)
#define _stencil__val_constant(a,_i,_j,_k) (_stencil_nop = 1)

typedef void _stencil_undefined;

#define o_stencil -2







static inline bool scalar_is_dirty (scalar s)
{
  if (_attribute[s.i].dirty)
    return true;
  scalar * depends = _attribute[s.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      return true;}}
  return false;
}




static inline bool scalar_depends_from (scalar a, scalar b)
{
  scalar * depends = _attribute[a.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (s.i == b.i)
      return true;}}
  return false;
}







void boundary_internal (scalar * list, const char * fname, int line);
void (* boundary_face) (vectorl);







void end_stencil (ForeachData * loop)
{
  scalar * listc = NULL, * dirty = NULL;
  vectorl listf = {NULL};
  bool flux = false;




  {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    bool write = _attribute[s.i].output, read = _attribute[s.i].input;




    {





      if (read && scalar_is_dirty (s)) {





 if (_attribute[s.i].face) {
   if (_attribute[s.i].width > 0)
     listc = list_append (listc, s);
   else if (!write) {
     scalar sn = _attribute[s.i].v.x.i >= 0 ? _attribute[s.i].v.x : s;
     
       if (_attribute[s.i].v.x.i == s.i) {




  if (_attribute[sn.i].boundary[left] || _attribute[sn.i].boundary[right])
    listc = list_append (listc, s);
  else if (_attribute[s.i].dirty != 2) {
    listf.x = list_append (listf.x, s);
    flux = true;
  }
       }
       
#line 194
if (_attribute[s.i].v.y.i == s.i) {




  if (_attribute[sn.i].boundary[bottom] || _attribute[sn.i].boundary[top])
    listc = list_append (listc, s);
  else if (_attribute[s.i].dirty != 2) {
    listf.y = list_append (listf.y, s);
    flux = true;
  }
       }
   }
 }





 else if (_attribute[s.i].width > 0)
   listc = list_append (listc, s);
      }





      if (write) {
 if (2 > 1 && !loop->vertex && loop->first) {
   bool vertex = true;
   
     if (_attribute[s.i].d.x != -1)
       vertex = false;
     
#line 225
if (_attribute[s.i].d.y != -1)
       vertex = false;
   if (vertex)
     fprintf (ferr,
       "%s:%d: warning: vertex scalar '%s' should be assigned with"
       " a foreach_vertex() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 if (_attribute[s.i].face) {
   if (loop->face == 0 && loop->first)
     fprintf (ferr,
       "%s:%d: warning: face vector '%s' should be assigned with"
       " a foreach_face() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 else if (loop->face) {
   if (_attribute[s.i].v.x.i < 0) {
     int d = 1, i = 0;
      {
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.x.i = s.i;
  _attribute[s.i].boundary[left] = _attribute[s.i].boundary[right] = NULL;





       }
       d *= 2, i++;
     } 
#line 243
{
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.y.i = s.i;
  _attribute[s.i].boundary[bottom] = _attribute[s.i].boundary[top] = NULL;





       }
       d *= 2, i++;
     }
     if (!_attribute[s.i].face && loop->first)
       fprintf (ferr,
         "%s:%d: warning: scalar '%s' should be assigned with "
         "a foreach_face(x|y|z) loop\n",
         loop->fname, loop->line, _attribute[s.i].name);
   }
   else {
     char * name = NULL;
     if (_attribute[s.i].name) {
       name = pstrdup (_attribute[s.i].name,__func__,__FILE__,__LINE__);
       char * s = name + strlen(name) - 1;
       while (s != name && *s != '.') s--;
       if (s != name) *s = '\0';
     }
     struct { int x, y, z; } input, output;
     vector v = _attribute[s.i].v;

     
       input.x = _attribute[v.x.i].input, output.x = _attribute[v.x.i].output;
       
#line 273
input.y = _attribute[v.y.i].input, output.y = _attribute[v.y.i].output;

     init_face_vector (v, name);


     
       _attribute[v.x.i].input = input.x, _attribute[v.x.i].output = output.x;
       
#line 279
_attribute[v.y.i].input = input.y, _attribute[v.y.i].output = output.y;





     pfree (name,__func__,__FILE__,__LINE__);
   }
 }
 else if (loop->vertex) {
   bool vertex = true;
   
     if (_attribute[s.i].d.x != -1)
       vertex = false;
     
#line 291
if (_attribute[s.i].d.y != -1)
       vertex = false;
   if (!vertex) {
     char * name = NULL;
     if (_attribute[s.i].name) name = pstrdup (_attribute[s.i].name,__func__,__FILE__,__LINE__);
     init_vertex_scalar (s, name);
     
       _attribute[s.i].v.x.i = -1;
       
#line 298
_attribute[s.i].v.y.i = -1;




     pfree (name,__func__,__FILE__,__LINE__);
   }
 }





 dirty = list_append (dirty, s);
 {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
   if (scalar_depends_from (d, s))
     dirty = list_append (dirty, d);}}
      }
    }
  }}}




  if (flux) {
#line 335 "/home/xiangbin2/basilisk_new/basilisk/src/grid/stencils.h"
    boundary_face (listf);
    
      pfree (listf.x,__func__,__FILE__,__LINE__);
      
#line 337
pfree (listf.y,__func__,__FILE__,__LINE__);
  }




  if (listc) {






    boundary_internal (listc, loop->fname, loop->line);
    pfree (listc,__func__,__FILE__,__LINE__);
  }





  if (dirty) {






    {scalar*_i=(scalar*)( dirty);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = true;}}
    pfree (dirty,__func__,__FILE__,__LINE__);
  }
}
#line 1452 "/home/xiangbin2/basilisk_new/basilisk/src/common.h"
#line 14 "template01-cpp.c"
#line 1 "grid/quadtree.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/quadtree.h"


#line 1 "grid/tree.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#line 1 "grid/mempool.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/mempool.h"





typedef struct _Pool Pool;

struct _Pool {
  Pool * next;
};

typedef struct {
  char * first, * lastb;
  size_t size;
  size_t poolsize;
  Pool * pool, * last;
} Mempool;

typedef struct {
  char * next;
} FreeBlock;

Mempool * mempool_new (size_t poolsize, size_t size)
{

  if (!(poolsize % 8 == 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/mempool.h", 26, "poolsize % 8 == 0");
  if (!(size >= sizeof(FreeBlock))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/mempool.h", 27, "size >= sizeof(FreeBlock)");


  poolsize = min(1 << 20, poolsize + sizeof(Pool));
  Mempool * m = ((Mempool *) pcalloc (1, sizeof(Mempool),__func__,__FILE__,__LINE__));
  m->poolsize = poolsize;
  m->size = size;
  return m;
}

void mempool_destroy (Mempool * m)
{
  Pool * p = m->pool;
  while (p) {
    Pool * next = p->next;
    pfree (p,__func__,__FILE__,__LINE__);
    p = next;
  }
  pfree (m,__func__,__FILE__,__LINE__);
}

void * mempool_alloc (Mempool * m)
{
  if (!m->first) {

    Pool * p = (Pool *) pmalloc (m->poolsize,__func__,__FILE__,__LINE__);
    p->next = NULL;
    if (m->last)
      m->last->next = p;
    else
      m->pool = p;
    m->last = p;
    m->first = m->lastb = ((char *)m->last) + sizeof(Pool);
    FreeBlock * b = (FreeBlock *) m->first;
    b->next = NULL;
  }
  void * ret = m->first;
  FreeBlock * b = (FreeBlock *) ret;
  char * next = b->next;
  if (!next) {
    m->lastb += m->size;
    next = m->lastb;
    if (next + m->size > ((char *) m->last) + m->poolsize)
      next = NULL;
    else {
      FreeBlock * b = (FreeBlock *) next;
      b->next = NULL;
    }
  }
  m->first = next;
#if TRASH
  double * v = (double *) ret;
  for (int i = 0; i < m->size/sizeof(double); i++)
    v[i] = undefined;
#endif
  return ret;
}

void * mempool_alloc0 (Mempool * m)
{
  void * ret = mempool_alloc (m);
  memset (ret, 0, m->size);
  return ret;
}

void mempool_free (Mempool * m, void * p)
{
#if TRASH
  double * v = (double *) p;
  for (int i = 0; i < m->size/sizeof(double); i++)
    v[i] = undefined;
#endif
  FreeBlock * b = (FreeBlock *) p;
  b->next = m->first;
  m->first = (char *) p;
}
#line 2 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"




#line 1 "grid/memindex/range.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
#line 15 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
typedef struct {
  void ** p;
  int size;
} Memalloc;

typedef struct {
  int start, end;
} Memrange;
#line 34 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
void memrange_alloc (Memrange * r, Memalloc * mem, int i)
{
  if (r->start == r->end) {
    r->start = i;
    r->end = i + 1;
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = pcalloc (1, m->size,__func__,__FILE__,__LINE__);
      *m->p = (char *)(*m->p) - i*m->size;
    }
  }
  else if (i >= r->end) {
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = prealloc ((char *)(*m->p) + r->start*m->size,
         m->size*(i + 1 - r->start),__func__,__FILE__,__LINE__);
      *m->p = (char *)(*m->p) - r->start*m->size;
      memset ((char *)(*m->p) + r->end*m->size, 0, (i - r->end + 1)*m->size);
    }
    r->end = i + 1;
  }
  else if (i < r->start) {
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = prealloc ((char *)(*m->p) + r->start*m->size, m->size*(r->end - i),__func__,__FILE__,__LINE__);
      memmove ((char *)(*m->p) + (r->start - i)*m->size, *m->p,
        m->size*(r->end - r->start));
      memset ((char *)(*m->p), 0, (r->start - i)*m->size);
      *m->p = (char *)(*m->p) - i*m->size;
    }
    r->start = i;
  }
}
#line 73 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
bool memrange_free (Memrange * r, Memalloc * mem, int i)
{
  if (i == r->start) {
    if (i == r->end - 1) {
      for (Memalloc * m = mem; m->p; m++) {
 pfree ((char *)(*m->p) + r->start*m->size,__func__,__FILE__,__LINE__);
 *m->p = NULL;
      }
      r->start = r->end = 0;
      return true;
    }
    else {
      for (i = i + 1; i < r->end &&
      !*(void **)((char *)(*mem->p) + i*mem->size); i++);
      for (Memalloc * m = mem; m->p; m++) {
 memmove ((char *)(*m->p) + r->start*m->size,
   (char *)(*m->p) + i*m->size, m->size*(r->end - i));
 *m->p = prealloc ((char *)(*m->p) + r->start*m->size,
    m->size*(r->end - i),__func__,__FILE__,__LINE__);
 *m->p = (char *)(*m->p) - i*m->size;
      }
      r->start = i;
    }
  }
  else if (i == r->end - 1) {
    for (i = i - 1; i >= r->start &&
    !*(void **)((char *)(*mem->p) + i*mem->size); i--);
    r->end = i + 1;
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = prealloc ((char *)(*m->p) + r->start*m->size,
         m->size*(r->end - r->start),__func__,__FILE__,__LINE__);
      *m->p = (char *)(*m->p) - r->start*m->size;
    }
  }
  else {
    if (!(i > r->start && i < r->end)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h", 108, "i > r->start && i < r->end");
    for (Memalloc * m = mem; m->p; m++)
      memset ((char *)(*m->p) + i*m->size, 0, m->size);
  }
  return false;
}







struct _Memindex {
  Memrange r1;

  Memrange * r2;







  char *** b;



};
#line 171 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
struct _Memindex * mem_new (int len)
{
  struct _Memindex * m = pcalloc (1, sizeof (struct _Memindex),__func__,__FILE__,__LINE__);
  return m;
}





void mem_destroy (struct _Memindex * m, int len)
{

  for (int i = m->r1.start; i < m->r1.end; i++)
    if (m->b[i]) {






      pfree (m->b[i] + m->r2[i].start,__func__,__FILE__,__LINE__);
    }
  if (m->b) {
    pfree (m->r2 + m->r1.start,__func__,__FILE__,__LINE__);



  }

  if (m->b)
    pfree (m->b + m->r1.start,__func__,__FILE__,__LINE__);
  pfree (m,__func__,__FILE__,__LINE__);
}
#line 218 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
void mem_assign (struct _Memindex * m, int i, int j, int len, void * b)
{
  Memalloc mem[] = {{(void **)&m->b, sizeof(char **)},
      {(void **)&m->r2, sizeof(Memrange)},
      {NULL}};
  memrange_alloc (&m->r1, mem, i);
  Memalloc mem1[] = {{(void **)&m->b[i], sizeof(char *)},
       {NULL}};
  memrange_alloc (&m->r2[i], mem1, j);
  ((m)->b[i][j]) = b;
}
#line 259 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
void mem_free (struct _Memindex * m, int i, int j, int len)
{
  Memalloc mem[] = {{(void **)&m->b[i], sizeof(char *)},
      {NULL}};
  if (memrange_free (&m->r2[i], mem, j)) {
    Memalloc mem[] = {{(void **)&m->b, sizeof(char **)},
        {(void **)&m->r2, sizeof(Memrange)},
        {NULL}};
    memrange_free (&m->r1, mem, i);
  }
}
#line 305 "/home/xiangbin2/basilisk_new/basilisk/src/grid/memindex/range.h"
#define foreach_mem(_m, _len, _i) {\
  Point point = {0};\
  for (point.i = max(Period.x*2, (_m)->r1.start);\
       point.i < min(_len - Period.x*2, (_m)->r1.end);\
       point.i += _i)\
    if ((_m)->b[point.i])\
      for (point.j = max(Period.y*2, (_m)->r2[point.i].start);\
    point.j < min(_len - Period.y*2, (_m)->r2[point.i].end);\
    point.j += _i)\
 if ((_m)->b[point.i][point.j]) {\

#line 315

#define end_foreach_mem() }}
#line 7 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#line 24 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
typedef struct {
  unsigned short flags;

  unsigned short neighbors;
  int pid;
} Cell;

enum {
  active = 1 << 0,
  leaf = 1 << 1,
  border = 1 << 2,
  vertex = 1 << 3,
  user = 4,

  face_x = 1 << 0

  , face_y = 1 << 1




};

#define is_active(cell) ((cell).flags & active)
#define is_leaf(cell) ((cell).flags & leaf)
#define is_coarse() ((cell).neighbors > 0)
#define is_border(cell) ((cell).flags & border)
#define is_local(cell) ((cell).pid == pid())
#define is_vertex(cell) ((cell).flags & vertex)



typedef struct {
  int i;

  int j;




} IndexLevel;

typedef struct {
  IndexLevel * p;
  int n, nm;
} CacheLevel;

typedef struct {
  int i;

  int j;




  int level, flags;
} Index;

typedef struct {
  Index * p;
  int n, nm;
} Cache;



typedef struct {
  struct _Memindex * m;
  Mempool * pool;
  long nc;
  int len;
} Layer;

static size_t _size (size_t depth)
{
  return (1 << depth) + 2*2;
}

static size_t poolsize (size_t depth, size_t size)
{




  return sq(_size(depth))*size;



}

static Layer * new_layer (int depth)
{
  Layer * l = ((Layer *) pmalloc ((1)*sizeof(Layer),__func__,__FILE__,__LINE__));
  l->len = _size (depth);
  if (depth == 0)
    l->pool = NULL;
  else {
    size_t size = sizeof(Cell) + datasize;


    l->pool = mempool_new (poolsize (depth, size), (1 << 2)*size);
  }
  l->m = mem_new (l->len);
  l->nc = 0;
  return l;
}

static void destroy_layer (Layer * l)
{
  if (l->pool)
    mempool_destroy (l->pool);
  mem_destroy (l->m, l->len);
  pfree (l,__func__,__FILE__,__LINE__);
}



typedef struct {
  Grid g;
  Layer ** L;

  Cache leaves;
  Cache faces;
  Cache vertices;
  Cache refined;
  CacheLevel * active;
  CacheLevel * prolongation;
  CacheLevel * boundary;

  CacheLevel * restriction;

  bool dirty;
} Tree;



struct _Point {

  int i;

  int j;




  int level;
#ifdef foreach_block
  int l;
  #define _BLOCK_INDEX , point.l
#else
  #define _BLOCK_INDEX
#endif
};
static Point last_point;



static void cache_level_append (CacheLevel * c, Point p)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (IndexLevel *) prealloc (c->p, (c->nm)*sizeof(IndexLevel),__func__,__FILE__,__LINE__);
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->n++;
}

static void cache_level_shrink (CacheLevel * c)
{
  if (c->nm > (c->n/128 + 1)*128) {
    c->nm = (c->n/128 + 1)*128;
    if (!(c->nm > c->n)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h", 200, "c->nm > c->n");
    c->p = (IndexLevel *) prealloc (c->p, sizeof (Index)*c->nm,__func__,__FILE__,__LINE__);
  }
}

static void cache_append (Cache * c, Point p, unsigned short flags)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (Index *) prealloc (c->p, (c->nm)*sizeof(Index),__func__,__FILE__,__LINE__);
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->p[c->n].level = p.level;
  c->p[c->n].flags = flags;
  c->n++;
}

void cache_shrink (Cache * c)
{
  cache_level_shrink ((CacheLevel *)c);
}
#line 243 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#define allocated(k,l,n) (((point.i+k) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+k) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+k] && (point.j+l) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+k].start && (point.j+l) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+k].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+k][point.j+l])\
                               )\

#line 245

#define NEIGHBOR(k,l,n) (((((Tree *)grid)->L[point.level]->m)->b[point.i+k][point.j+l])\
                            )\

#line 248

#define PARENT(k,l,n) (((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k][(point.j+2)/2+l])\
                                                    )\

#line 251

#define allocated_child(k,l,n) (level < depth() &&\
         ((2*point.i-2 +k) >= (((Tree *)grid)->L[point.level+1]->m)->r1.start && (2*point.i-2 +k) < (((Tree *)grid)->L[point.level+1]->m->r1.end) && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k] && (2*point.j-2 +l) >= (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +k].start && (2*point.j-2 +l) < (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +k].end && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k][2*point.j-2 +l])\
\
                             )\

#line 256

#define CHILD(k,l,n) (((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k][2*point.j-2 +l])\
                                                )\

#line 259

#line 284 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#define CELL(m) (*((Cell *)(m)))


#define depth() (grid->depth)
#define aparent(k,l,n) CELL(PARENT(k,l,n))
#define child(k,l,n) CELL(CHILD(k,l,n))


#define cell CELL(NEIGHBOR(0,0,0))
#define neighbor(k,l,n) CELL(NEIGHBOR(k,l,n))
#define neighborp(l,m,n) (Point) {\
    point.i + l,\
\
    point.j + m,\
\
\
\
\
    point.level\
    _BLOCK_INDEX\
}\

#line 305



#define data(k,l,n) ((double *) (NEIGHBOR(k,l,n) + sizeof(Cell)))
#define fine(a,k,p,n) ((double *) (CHILD(k,p,n) + sizeof(Cell)))[_index(a,n)]
#define coarse(a,k,p,n) ((double *) (PARENT(k,p,n) + sizeof(Cell)))[_index(a,n)]

#define POINT_VARIABLES\
  VARIABLES\
  int level = point.level; NOT_UNUSED(level);\
\
\
\
  struct { int x, y; } child = {\
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1\
  };\
\
\
\
\
\
  NOT_UNUSED(child);\
  Point parent = point; NOT_UNUSED(parent);\
  parent.level--;\
  parent.i = (point.i + 2)/2;\
\
  parent.j = (point.j + 2)/2;\
\

#line 341


#line 1 "grid/foreach_cell.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/foreach_cell.h"
#line 66 "/home/xiangbin2/basilisk_new/basilisk/src/grid/foreach_cell.h"
#define foreach_cell_root(root)\
  {\
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);\
    Point point = {0};\
\
\
\
    struct { int l, i, j, stage; } stack[20];\
\
\
\
\
    int _s = -1;\
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };\
    while (_s >= 0) {\
      int stage;\
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };\
      if (!allocated (0,0,0))\
 continue;\
      switch (stage) {\
      case 0: {\
 POINT_VARIABLES;\
\

#line 89

#define end_foreach_cell_root()\
        if (point.level < grid->depth) {\
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };\
          { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };\
        }\
        break;\
      }\
\
\
\
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };\
       { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;\
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };\
       { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;\
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;\
\
      }\
    }\
  }\

#line 123


#define foreach_cell() {\
\
\
\
  Point root = {2,2,0};\
\
\
\
  foreach_cell_root (root)\

#line 134

#define end_foreach_cell() end_foreach_cell_root() }

#define foreach_cell_all() {\
  Point root = {0};\
  for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)\
\
    for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++)\
\
\
\
\
 foreach_cell_root (root)\

#line 147

#define end_foreach_cell_all() end_foreach_cell_root() }

#define foreach_cell_post_root(condition, root)\
  {\
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);\
    Point point = {0};\
\
\
\
    struct { int l, i, j, stage; } stack[20];\
\
\
\
\
    int _s = -1;\
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };\
    while (_s >= 0) {\
      int stage;\
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };\
      if (!allocated (0,0,0))\
 continue;\
      switch (stage) {\
      case 0: {\
        POINT_VARIABLES;\
 if (point.level == grid->depth) {\
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };\
 }\
 else {\
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };\
   if (condition)\
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };\
 }\
 break;\
      }\
\
\
\
\
\
\
\
      case 1:\
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };\
 if (condition)\
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };\
 break;\
      case 2:\
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };\
 if (condition)\
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };\
 break;\
      case 3:\
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };\
 if (condition)\
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };\
 break;\
\
      default: {\
        POINT_VARIABLES;\
\

#line 244

#define end_foreach_cell_post_root()\
      }\
      }\
    }\
  }\

#line 250


#define foreach_cell_post(condition)\
  {\
\
\
\
    Point root = {2,2,0};\
\
\
\
    foreach_cell_post_root(condition, root)\

#line 262

#define end_foreach_cell_post() end_foreach_cell_post_root() }

#define foreach_cell_post_all(condition) {\
  Point root = {0};\
  for (root.i = 0; root.i <= 2*2; root.i++)\
\
    for (root.j = 0; root.j <= 2*2; root.j++)\
\
\
\
\
 foreach_cell_post_root (condition, root)\

#line 275

#define end_foreach_cell_post_all() end_foreach_cell_post_root() }

#define foreach_leaf() foreach_cell()\
  if (is_leaf (cell)) {\
    if (is_active(cell) && is_local(cell)) {\

#line 281

#define end_foreach_leaf() } continue; } end_foreach_cell()
#line 344 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#line 361 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#define foreach_child() {\
  int _i = 2*point.i - 2, _j = 2*point.j - 2;\
  point.level++;\
  for (int _k = 0; _k < 2; _k++) {\
    point.i = _i + _k;\
    for (int _l = 0; _l < 2; _l++) {\
      point.j = _j + _l;\
      POINT_VARIABLES;\

#line 369

#define end_foreach_child()\
    }\
  }\
  point.i = (_i + 2)/2; point.j = (_j + 2)/2;\
  point.level--;\
}\

#line 376

#define foreach_child_break() _k = _l = 2
#line 407 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#define is_refined_check() ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) &&\
    point.i > 0 && point.i < (1 << level) + 2*2 - 1\
\
    && point.j > 0 && point.j < (1 << level) + 2*2 - 1\
\
\
\
\
    )\

#line 416


#define foreach_cache(_cache) {\
  OMP_PARALLEL() {\
  int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);\
  Point point = {0};\
  point.i = 2;\
\
  point.j = 2;\
\
\
\
\
  int _k; unsigned short _flags; NOT_UNUSED(_flags);\
  OMP(omp for schedule(static))\
  for (_k = 0; _k < _cache.n; _k++) {\
    point.i = _cache.p[_k].i;\
\
    point.j = _cache.p[_k].j;\
\
\
\
\
    point.level = _cache.p[_k].level;\
    _flags = _cache.p[_k].flags;\
    POINT_VARIABLES;\

#line 442

#define end_foreach_cache() } } }

#define foreach_cache_level(_cache,_l) {\
  OMP_PARALLEL() {\
  int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);\
  Point point = {0};\
  point.i = 2;\
\
  point.j = 2;\
\
\
\
\
  point.level = _l;\
  int _k;\
  OMP(omp for schedule(static))\
  for (_k = 0; _k < _cache.n; _k++) {\
    point.i = _cache.p[_k].i;\
\
    point.j = _cache.p[_k].j;\
\
\
\
\
    POINT_VARIABLES;\

#line 468

#define end_foreach_cache_level() } } }

#define foreach_boundary_level(_l) {\
  if (_l <= depth()) {\
    { if (((Tree *)grid)->dirty) update_cache_f(); };\
    CacheLevel _boundary = ((Tree *)grid)->boundary[_l];\
    foreach_cache_level (_boundary,_l)\

#line 476

#define end_foreach_boundary_level() end_foreach_cache_level(); }}



#define foreach_boundary(_b) {\
  for (int _l = depth(); _l >= 0; _l--)\
    foreach_boundary_level(_l) {\
      if ((- cell.pid - 1) == _b)\
 for (int _d = 0; _d < 2; _d++) {\
   for (int _i = -1; _i <= 1; _i += 2) {\
     if (_d == 0) ig = _i; else if (_d == 1) jg = _i; else kg = _i;\
     if (allocated(-ig,-jg,-kg) &&\
  is_leaf (neighbor(-ig,-jg,-kg)) &&\
  !(neighbor(-ig,-jg,-kg).pid < 0) &&\
  is_local(neighbor(-ig,-jg,-kg))) {\
       point.i -= ig; x -= ig*Delta/2.;\
\
       point.j -= jg; y -= jg*Delta/2.;\
\
\
\
\

#line 499

#define end_foreach_boundary()\
       point.i += ig; x += ig*Delta/2.;\
\
       point.j += jg; y += jg*Delta/2.;\
\
\
\
\
            }\
   }\
   ig = jg = kg = 0;\
 }\
    } end_foreach_boundary_level(); }\

#line 513


#define foreach_halo(_name,_l) {\
  if (_l <= depth()) {\
    { if (((Tree *)grid)->dirty) update_cache_f(); };\
    CacheLevel _cache = ((Tree *)grid)->_name[_l];\
    foreach_cache_level (_cache, _l)\

#line 520

#define end_foreach_halo() end_foreach_cache_level(); }}

#line 1 "grid/neighbors.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/neighbors.h"
#line 17 "/home/xiangbin2/basilisk_new/basilisk/src/grid/neighbors.h"
#define foreach_neighbor(_s) {\
  int _nn = _s + 0 ? _s + 0 : 2;\
  int _i = point.i, _j = point.j;\
  for (int _k = - _nn; _k <= _nn; _k++) {\
    point.i = _i + _k;\
    for (int _l = - _nn; _l <= _nn; _l++) {\
      point.j = _j + _l;\
      POINT_VARIABLES;\

#line 25

#define end_foreach_neighbor()\
    }\
  }\
  point.i = _i; point.j = _j;\
}\

#line 31

#define foreach_neighbor_break() _k = _l = _nn + 1
#line 524 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"

static inline bool has_local_children (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    if (is_local(cell))
      return true;end_foreach_child()}
  return false;
}

static inline void cache_append_face (Point point, unsigned short flags)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  Tree * q = ((Tree *)grid);
  cache_append (&q->faces, point, flags);

  if (!is_vertex(cell)) {
    cache_append (&q->vertices, point, 0);
    cell.flags |= vertex;
  }
  
    if ((flags & face_y) && !is_vertex(neighbor(1,0,0))) {
      cache_append (&q->vertices, neighborp(1,0,0), 0);
      neighbor(1,0,0).flags |= vertex;
    }
    
#line 543
if ((flags & face_x) && !is_vertex(neighbor(0,1,0))) {
      cache_append (&q->vertices, neighborp(0,1,0), 0);
      neighbor(0,1,0).flags |= vertex;
    }
#line 557 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
}



static void update_cache_f (void)
{
  Tree * q = ((Tree *)grid);

  {foreach_cache (q->vertices)
    if (level <= depth() && allocated(0,0,0))
      cell.flags &= ~vertex;end_foreach_cache();}


  q->leaves.n = q->faces.n = q->vertices.n = 0;
  for (int l = 0; l <= depth(); l++)
    q->active[l].n = q->prolongation[l].n =
      q->boundary[l].n = q->restriction[l].n = 0;

  const unsigned short fboundary = 1 << user;
  {foreach_cell() {



    if (is_local(cell) && is_active(cell)) {


      cache_level_append (&q->active[level], point);
    }
#line 601 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
    if (!(cell.pid < 0)) {

      {foreach_neighbor (2)
 if (allocated(0,0,0) && (cell.pid < 0) && !(cell.flags & fboundary)) {
   cache_level_append (&q->boundary[level], point);
   cell.flags |= fboundary;
 }end_foreach_neighbor()}
    }

    else if (level > 0 && is_local(aparent(0,0,0)))
      cache_level_append (&q->restriction[level], point);

    if (is_leaf (cell)) {
      if (is_local(cell)) {
 cache_append (&q->leaves, point, 0);

 unsigned short flags = 0;
 
   if ((neighbor(-1,0,0).pid < 0) || (!is_leaf(neighbor(-1,0,0)) && !neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) ||
       is_leaf(neighbor(-1,0,0)))
     flags |= face_x;
   
#line 619
if ((neighbor(0,-1,0).pid < 0) || (!is_leaf(neighbor(0,-1,0)) && !neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) ||
       is_leaf(neighbor(0,-1,0)))
     flags |= face_y;
 if (flags)
   cache_append (&q->faces, point, flags);
 
   if ((neighbor(1,0,0).pid < 0) || (!is_leaf(neighbor(1,0,0)) && !neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) ||
       (!is_local(neighbor(1,0,0)) && is_leaf(neighbor(1,0,0))))
     cache_append (&q->faces, neighborp(1,0,0), face_x);
   
#line 625
if ((neighbor(0,1,0).pid < 0) || (!is_leaf(neighbor(0,1,0)) && !neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) ||
       (!is_local(neighbor(0,1,0)) && is_leaf(neighbor(0,1,0))))
     cache_append (&q->faces, neighborp(0,1,0), face_y);

 for (int i = 0; i <= 1; i++)

   for (int j = 0; j <= 1; j++)




       if (!is_vertex(neighbor(i,j,k))) {
  cache_append (&q->vertices, neighborp(i,j,k), 0);
  neighbor(i,j,k).flags |= vertex;
       }

        if (cell.neighbors > 0)
   cache_level_append (&q->prolongation[level], point);
      }
      else if (!(cell.pid < 0) || is_local(aparent(0,0,0))) {

 unsigned short flags = 0;
 
   if (allocated(-1,0,0) &&
       is_local(neighbor(-1,0,0)) && (!is_leaf(neighbor(-1,0,0)) && !neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))
     flags |= face_x;
   
#line 648
if (allocated(0,-1,0) &&
       is_local(neighbor(0,-1,0)) && (!is_leaf(neighbor(0,-1,0)) && !neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))
     flags |= face_y;
 if (flags)
   cache_append_face (point, flags);
 
   if (allocated(1,0,0) && is_local(neighbor(1,0,0)) &&
       (!is_leaf(neighbor(1,0,0)) && !neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0))
     cache_append_face (neighborp(1,0,0), face_x);
   
#line 654
if (allocated(0,1,0) && is_local(neighbor(0,1,0)) &&
       (!is_leaf(neighbor(0,1,0)) && !neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0))
     cache_append_face (neighborp(0,1,0), face_y);
      }

      continue;

    }
  }end_foreach_cell();}


  cache_shrink (&q->leaves);
  cache_shrink (&q->faces);
  cache_shrink (&q->vertices);
  for (int l = 0; l <= depth(); l++) {
    cache_level_shrink (&q->active[l]);
    cache_level_shrink (&q->prolongation[l]);
    cache_level_shrink (&q->boundary[l]);
    cache_level_shrink (&q->restriction[l]);
}

  q->dirty = false;


  for (int l = depth(); l >= 0; l--)
    {foreach_boundary_level (l)
      cell.flags &= ~fboundary;end_foreach_boundary_level();}



  grid->n = q->leaves.n;

#if !1
  grid->tn = grid->n;
  grid->maxdepth = grid->depth;
#endif
}

#define foreach() { if (((Tree *)grid)->dirty) update_cache_f(); }; foreach_cache(((Tree *)grid)->leaves)
#define end_foreach() end_foreach_cache()

#define foreach_face_generic()\
  { if (((Tree *)grid)->dirty) update_cache_f(); };\
  foreach_cache(((Tree *)grid)->faces) 
#line 716

#define end_foreach_face_generic() end_foreach_cache()

#define is_face_x() { int ig = -1; VARIABLES; if (_flags & face_x) {
#define end_is_face_x() }}


#define is_face_y() { int jg = -1; VARIABLES; if (_flags & face_y) {
#define end_is_face_y() }}






#define foreach_vertex()\
  { if (((Tree *)grid)->dirty) update_cache_f(); };\
  foreach_cache(((Tree *)grid)->vertices) {\
    x -= Delta/2.;\
\
    y -= Delta/2.;\
\
\
\
\

#line 742

#define end_foreach_vertex() } end_foreach_cache()
#line 734 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#define foreach_level(l) {\
  if (l <= depth()) {\
    { if (((Tree *)grid)->dirty) update_cache_f(); };\
    CacheLevel _active = ((Tree *)grid)->active[l];\
    foreach_cache_level (_active,l)\

#line 739

#define end_foreach_level() end_foreach_cache_level(); }}

#define foreach_coarse_level(l) foreach_level(l) if (!is_leaf(cell)) {
#define end_foreach_coarse_level() } end_foreach_level()

#define foreach_level_or_leaf(l) {\
  for (int _l1 = l; _l1 >= 0; _l1--)\
    foreach_level(_l1)\
      if (_l1 == l || is_leaf (cell)) {\

#line 749

#define end_foreach_level_or_leaf() } end_foreach_level(); }

#if TRASH
# undef trash
# define trash(list) reset(list, undefined)
#endif

void reset (void * alist, double val)
{
  scalar * list = (scalar *) alist;
  Tree * q = ((Tree *)grid);

  for (int l = 0; l <= depth(); l++) {
    Layer * L = q->L[l];
    {foreach_mem (L->m, L->len, 1) {
      point.level = l;
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 if (!is_constant(s))
   for (int b = 0; b < _attribute[s.i].block; b++)
     data(0,0,0)[s.i + b] = val;
      }}}
    }end_foreach_mem();}
  }
}

static CacheLevel * cache_level_resize (CacheLevel * name, int a)
{
  for (int i = 0; i <= depth() - a; i++)
    pfree (name[i].p,__func__,__FILE__,__LINE__);
  pfree (name,__func__,__FILE__,__LINE__);
  return ((CacheLevel *) pcalloc (depth() + 1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
}

static void update_depth (int inc)
{
  Tree * q = ((Tree *)grid);
  grid->depth += inc;
  q->L = &(q->L[-1]);
  q->L = (Layer * *) prealloc (q->L, (grid->depth + 2)*sizeof(Layer *),__func__,__FILE__,__LINE__);
  q->L = &(q->L[1]);
  if (inc > 0)
    q->L[grid->depth] = new_layer (grid->depth);
  q->active = cache_level_resize (q->active, inc);
  q->prolongation = cache_level_resize (q->prolongation, inc);
  q->boundary = cache_level_resize (q->boundary, inc);
  q->restriction = cache_level_resize (q->restriction, inc);
}
#line 823 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
typedef void (* PeriodicFunction) (struct _Memindex *, int, int, int, void *);

static void periodic_function (struct _Memindex * m, int i, int j, int len, void * b,
          PeriodicFunction f)
{
  f(m, i, j, len, b);
  if (Period.x) {
    int nl = len - 2*2;
    for (int l = - 1; l <= 1; l += 2)
      for (int n = i + l*nl; n >= 0 && n < len; n += l*nl)
 f(m, n, j, len, b);
    if (Period.y)
      for (int l = - 1; l <= 1; l += 2)
 for (int n = j + l*nl; n >= 0 && n < len; n += l*nl) {
   f(m, i, n, len, b);
   for (int o = - 1; o <= 1; o += 2)
     for (int p = i + o*nl; p >= 0 && p < len; p += o*nl)
       f(m, p, n, len, b);
 }
  }
  else if (Period.y) {
    int nl = len - 2*2;
    for (int l = - 1; l <= 1; l += 2)
      for (int n = j + l*nl; n >= 0 && n < len; n += l*nl)
 f(m, i, n, len, b);
  }
}

static void assign_periodic (struct _Memindex * m, int i, int j, int len, void * b)
{
  periodic_function (m, i, j, len, b, mem_assign);
}

static void free_periodic (struct _Memindex * m, int i, int j, int len)
{
  periodic_function (m, i, j, len, NULL, (PeriodicFunction) mem_free);
}
#line 938 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
static void alloc_children (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (point.level == grid->depth)
    update_depth (+1);
  else if (allocated_child(0,0,0))
    return;


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  L->nc++;
  size_t len = sizeof(Cell) + datasize;
  char * b = (char *) mempool_alloc0 (L->pool);
  int i = 2*point.i - 2;
  for (int k = 0; k < 2; k++, i++) {




    int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++) {
      assign_periodic (L->m, i, j, L->len, b);
      b += len;
    }
#line 971 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
  }

  int pid = cell.pid;
  {foreach_child() {
    cell.pid = pid;
#if TRASH
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      val(s,0,0,0) = undefined;}}
#endif
  }end_foreach_child()}
}
#line 1000 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
static void free_children (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  Layer * L = ((Tree *)grid)->L[point.level + 1];
  int i = 2*point.i - 2, j = 2*point.j - 2;
  if (!(((L->m)->b[i][j]))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h", 1005, "mem_data (L->m,i,j)");
  mempool_free (L->pool, ((L->m)->b[i][j]));
  for (int k = 0; k < 2; k++)
    for (int l = 0; l < 2; l++)
      free_periodic (L->m, i + k, j + l, L->len);
  if (--L->nc == 0) {
    destroy_layer (L);
    if (!(point.level + 1 == grid->depth)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h", 1012, "point.level + 1 == grid->depth");
    update_depth (-1);
  }
}
#line 1041 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
void increment_neighbors (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  ((Tree *)grid)->dirty = true;
  if (cell.neighbors++ == 0)
    alloc_children (point);
  {foreach_neighbor (2/2)
    if (cell.neighbors++ == 0)
      alloc_children (point);end_foreach_neighbor()}
  cell.neighbors--;
}

void decrement_neighbors (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  ((Tree *)grid)->dirty = true;
  {foreach_neighbor (2/2)
    if (allocated(0,0,0)) {
      cell.neighbors--;
      if (cell.neighbors == 0)
 free_children (point);
    }end_foreach_neighbor()}
  if (cell.neighbors) {
    int pid = cell.pid;
    {foreach_child() {
      cell.flags = 0;
      cell.pid = pid;
    }end_foreach_child()}
  }
}

void realloc_scalar (int size)
{

  Tree * q = ((Tree *)grid);
  size_t oldlen = sizeof(Cell) + datasize;
  size_t newlen = oldlen + size;
  datasize += size;

  Layer * L = q->L[0];
  {foreach_mem (L->m, L->len, 1) {




    char * p = (char *) prealloc (((L->m)->b[point.i][point.j]),
     newlen*sizeof(char),__func__,__FILE__,__LINE__);
    assign_periodic (L->m, point.i, point.j, L->len, p);





  }end_foreach_mem();}

  for (int l = 1; l <= depth(); l++) {
    Layer * L = q->L[l];
    Mempool * oldpool = L->pool;
    L->pool = mempool_new (poolsize (l, newlen), (1 << 2)*newlen);
    {foreach_mem (L->m, L->len, 2) {
      char * new = (char *) mempool_alloc (L->pool);







      for (int k = 0; k < 2; k++)
 for (int o = 0; o < 2; o++) {
   memcpy (new, ((L->m)->b[point.i + k][point.j + o]), oldlen);
   assign_periodic (L->m, point.i + k, point.j + o, L->len, new);
   new += newlen;
 }
#line 1124 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
    }end_foreach_mem();}
    mempool_destroy (oldpool);
  }
}



#define VN v.x
#define VT v.y
#define VR v.z




#if 1
# define disable_fpe_for_mpi() disable_fpe (FE_DIVBYZERO|FE_INVALID)
# define enable_fpe_for_mpi() enable_fpe (FE_DIVBYZERO|FE_INVALID)
#else
# define disable_fpe_for_mpi()
# define enable_fpe_for_mpi()
#endif

static inline void no_restriction (Point point, scalar s);

static bool normal_neighbor (Point point, scalar * scalars, vector * vectors)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  for (int k = 1; k <= 2; k++)
    {
      for (int i = -k; i <= k; i += 2*k)
 if ((allocated(i,0,0) && !(neighbor(i,0,0).pid < 0))) {
   Point neighbor = neighborp(i,0,0);
   int id = (- cell.pid - 1);
   {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    
       val(s,0,0,0) = _attribute[s.i].boundary[id](neighbor, point, s, NULL);}}
   {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
     {
       scalar vn = VN;
       val(v.x,0,0,0) = _attribute[vn.i].boundary[id](neighbor, point, v.x, NULL);

       scalar vt = VT;
       val(v.y,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.y, NULL);





     }}}
   return true;
 }
      
#line 1152
for (int i = -k; i <= k; i += 2*k)
 if ((allocated(0,i,0) && !(neighbor(0,i,0).pid < 0))) {
   Point neighbor = neighborp(0,i,0);
   int id = (- cell.pid - 1);
   {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    
       val(s,0,0,0) = _attribute[s.i].boundary[id](neighbor, point, s, NULL);}}
   {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
     {
       scalar vn = VN;
       val(v.y,0,0,0) = _attribute[vn.i].boundary[id](neighbor, point, v.y, NULL);

       scalar vt = VT;
       val(v.x,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.x, NULL);





     }}}
   return true;
 }}
  return false;
}

static bool diagonal_neighbor_2D (Point point,
      scalar * scalars, vector * vectors)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  for (int k = 1; k <= 2; k++)



      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if (allocated(i,j,0) && (allocated(i,j,0) && !(neighbor(i,j,0).pid < 0)) &&
       allocated(i,0,0) && (neighbor(i,0,0).pid < 0) &&
       allocated(0,j,0) && (neighbor(0,j,0).pid < 0)) {
     Point n = neighborp(i,j,0),
       n1 = neighborp(i,0,0), n2 = neighborp(0,j,0);
     int id1 = (- neighbor(i,0,0).pid - 1), id2 = (- neighbor(0,j,0).pid - 1);
     {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
  val(s,0,0,0) = (_attribute[s.i].boundary[id1](n,n1,s,NULL) +
         _attribute[s.i].boundary[id2](n,n2,s,NULL) -
         val(s,i,j,0));}}
     {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
       {
  scalar vt = VT, vn = VN;
  val(v.x,0,0,0) = (_attribute[vt.i].boundary[id1](n,n1,v.x,NULL) +
    _attribute[vn.i].boundary[id2](n,n2,v.x,NULL) -
    val(v.x,i,j,0));
  val(v.y,0,0,0) = (_attribute[vn.i].boundary[id1](n,n1,v.y,NULL) +
    _attribute[vt.i].boundary[id2](n,n2,v.y,NULL) -
    val(v.y,i,j,0));






       }}}
     return true;
   }

  return false;
}

static bool diagonal_neighbor_3D (Point point,
      scalar * scalars, vector * vectors)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
#line 1266 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
  return false;
}



static Point tangential_neighbor_x (Point point, bool * zn)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if ((allocated(0,j,0) && !(neighbor(0,j,0).pid < 0)) || (allocated(-1,j,0) && !(neighbor(-1,j,0).pid < 0))) {
 *zn = false;
 return neighborp(0,j,0);
      }







    }
  return (Point){.level = -1};
}

#line 1271
static Point tangential_neighbor_y (Point point, bool * zn)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if ((allocated(j,0,0) && !(neighbor(j,0,0).pid < 0)) || (allocated(j,-1,0) && !(neighbor(j,-1,0).pid < 0))) {
 *zn = false;
 return neighborp(j,0,0);
      }







    }
  return (Point){.level = -1};
}


static inline bool is_boundary_point (Point point) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  return (cell.pid < 0);
}

static void box_boundary_level (const Boundary * b, scalar * list, int l)
{
  disable_fpe_for_mpi();
  scalar * scalars = NULL;
  vector * vectors = NULL, * faces = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i) {
 if (_attribute[s.i].face)
   faces = vectors_add (faces, _attribute[s.i].v);
 else
   vectors = vectors_add (vectors, _attribute[s.i].v);
      }
      else if (_attribute[s.i].v.x.i < 0 && _attribute[s.i].boundary[0])
 scalars = list_add (scalars, s);
    }}}

  {foreach_boundary_level (l) {
    if (!normal_neighbor (point, scalars, vectors) &&
 !diagonal_neighbor_2D (point, scalars, vectors) &&
 !diagonal_neighbor_3D (point, scalars, vectors)) {

      {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

   val(s,0,0,0) = undefined;}}
      {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){

   {
     val(v.x,0,0,0) = undefined;
     
#line 1323
val(v.y,0,0,0) = undefined;}}}
    }
    if (faces) {
      int id = (- cell.pid - 1);
      
 for (int i = -1; i <= 1; i += 2) {

   if ((allocated(i,0,0) && !(neighbor(i,0,0).pid < 0))) {
     Point neighbor = neighborp(i,0,0);
     {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {
       scalar vn = VN;
       if (_attribute[vn.i].boundary[id])
 
    val(v.x,(i + 1)/2,0,0) = _attribute[vn.i].boundary[id](neighbor, point, v.x, NULL);
     }}}
   }

   else if (i == -1) {

     bool zn;
     Point neighbor = tangential_neighbor_x (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- neighbor(-1,0,0).pid - 1) : (- cell.pid - 1);
       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {

  scalar vt = VT;



 
    val(v.x,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.x, NULL);
       }}}
     }
     else

       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
 
    val(v.x,0,0,0) = 0.;}}
   }

 }
 
#line 1328
for (int i = -1; i <= 1; i += 2) {

   if ((allocated(0,i,0) && !(neighbor(0,i,0).pid < 0))) {
     Point neighbor = neighborp(0,i,0);
     {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {
       scalar vn = VN;
       if (_attribute[vn.i].boundary[id])
 
    val(v.y,0,(i + 1)/2,0) = _attribute[vn.i].boundary[id](neighbor, point, v.y, NULL);
     }}}
   }

   else if (i == -1) {

     bool zn;
     Point neighbor = tangential_neighbor_y (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- neighbor(0,-1,0).pid - 1) : (- cell.pid - 1);
       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {

  scalar vt = VT;



 
    val(v.y,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.y, NULL);
       }}}
     }
     else

       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
 
    val(v.y,0,0,0) = 0.;}}
   }

 }
    }
  }end_foreach_boundary_level();}

  pfree (scalars,__func__,__FILE__,__LINE__);
  pfree (vectors,__func__,__FILE__,__LINE__);
  pfree (faces,__func__,__FILE__,__LINE__);
  enable_fpe_for_mpi();
}



#undef VN
#undef VT
#define VN _attribute[s.i].v.x
#define VT _attribute[s.i].v.y

static double masked_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0., n = 0.;
  {foreach_child()
    if (!(cell.pid < 0) && val(s,0,0,0) != HUGE)
      sum += val(s,0,0,0), n++;end_foreach_child()}
  return n ? sum/n : HUGE;
}


static double masked_average_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0., n = 0.;
  {foreach_child()
    if (child.x < 0 && (!(cell.pid < 0) || !(neighbor(1,0,0).pid < 0)) &&
 val(s,1,0,0) != HUGE)
      sum += val(s,1,0,0), n++;end_foreach_child()}
  return n ? sum/n : HUGE;
}

#line 1391
static double masked_average_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0., n = 0.;
  {foreach_child()
    if (child.y < 0 && (!(cell.pid < 0) || !(neighbor(0,1,0).pid < 0)) &&
 val(s,0,1,0) != HUGE)
      sum += val(s,0,1,0), n++;end_foreach_child()}
  return n ? sum/n : HUGE;
}

static void masked_boundary_restriction (const Boundary * b,
      scalar * list, int l)
{
  scalar * scalars = NULL;
  vector * faces = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i && _attribute[s.i].face)
 faces = vectors_add (faces, _attribute[s.i].v);
      else
 scalars = list_add (scalars, s);
    }}}

  {foreach_halo (restriction, l) {
    {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      val(s,0,0,0) = masked_average (parent, s);}}
    {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      { {
 double average = masked_average_x (parent, v.x);
 if ((neighbor(-1,0,0).pid < 0))
   val(v.x,0,0,0) = average;
 if ((neighbor(1,0,0).pid < 0))
   val(v.x,1,0,0) = average;
      } 
#line 1418
{
 double average = masked_average_y (parent, v.y);
 if ((neighbor(0,-1,0).pid < 0))
   val(v.y,0,0,0) = average;
 if ((neighbor(0,1,0).pid < 0))
   val(v.y,0,1,0) = average;
      }}}}
  }end_foreach_halo();}

  pfree (scalars,__func__,__FILE__,__LINE__);
  pfree (faces,__func__,__FILE__,__LINE__);
}
#line 1454 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
static void free_cache (CacheLevel * c)
{
  for (int l = 0; l <= depth(); l++)
    pfree (c[l].p,__func__,__FILE__,__LINE__);
  pfree (c,__func__,__FILE__,__LINE__);
}

void free_grid (void)
{
  if (!grid)
    return;
  free_boundaries();
  Tree * q = ((Tree *)grid);
  pfree (q->leaves.p,__func__,__FILE__,__LINE__);
  pfree (q->faces.p,__func__,__FILE__,__LINE__);
  pfree (q->vertices.p,__func__,__FILE__,__LINE__);
  pfree (q->refined.p,__func__,__FILE__,__LINE__);


  Layer * L = q->L[0];
  {foreach_mem (L->m, L->len, 1) {



    pfree (((L->m)->b[point.i][point.j]),__func__,__FILE__,__LINE__);



  }end_foreach_mem();}
  for (int l = 0; l <= depth(); l++)
    destroy_layer (q->L[l]);
  q->L = &(q->L[-1]);
  pfree (q->L,__func__,__FILE__,__LINE__);
  free_cache (q->active);
  free_cache (q->prolongation);
  free_cache (q->boundary);
  free_cache (q->restriction);
  pfree (q,__func__,__FILE__,__LINE__);
  grid = NULL;
}

static void refine_level (int depth);

     
void init_grid (int n)
{tracing("init_grid","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h",1498);

  if (!(sizeof(Cell) % 8 == 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h", 1501, "sizeof(Cell) % 8 == 0");

  free_grid();
  int depth = 0;
  while (n > 1) {
    if (n % 2) {
      fprintf (ferr, "tree: N must be a power-of-two\n");
      exit (1);
    }
    n /= 2;
    depth++;
  }
  Tree * q = ((Tree *) pcalloc (1, sizeof(Tree),__func__,__FILE__,__LINE__));
  grid = (Grid *) q;
  grid->depth = 0;


  q->L = ((Layer * *) pmalloc ((2)*sizeof(Layer *),__func__,__FILE__,__LINE__));

  q->L[0] = NULL; q->L = &(q->L[1]);

  Layer * L = new_layer (0);
  q->L[0] = L;
#line 1537 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
  for (int i = Period.x*2; i < L->len - Period.x*2; i++)
    for (int j = Period.y*2; j < L->len - Period.y*2; j++)
      assign_periodic (L->m, i, j, L->len,
         (char *) pcalloc (1, sizeof(Cell) + datasize,__func__,__FILE__,__LINE__));
  CELL(((L->m)->b[2][2])).flags |= leaf;
  if (pid() == 0)
    CELL(((L->m)->b[2][2])).flags |= active;
  for (int k = - 2*(1 - Period.x); k <= 2*(1 - Period.x); k++)
    for (int l = -2*(1 - Period.y); l <= 2*(1 - Period.y); l++)
      CELL(((L->m)->b[2 +k][2 +l])).pid =
 (k < 0 ? -1 - left :
  k > 0 ? -1 - right :
  l > 0 ? -1 - top :
  l < 0 ? -1 - bottom :
  0);
  CELL(((L->m)->b[2][2])).pid = 0;
#line 1575 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
  q->active = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->prolongation = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->boundary = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->restriction = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->dirty = true;
  N = 1 << depth;
#if 1
  void mpi_boundary_new();
  mpi_boundary_new();
#endif

  Boundary * b = ((Boundary *) pcalloc (1, sizeof(Boundary),__func__,__FILE__,__LINE__));
  b->level = box_boundary_level;
  b->restriction = masked_boundary_restriction;
  add_boundary (b);
  refine_level (depth);
  reset (all, 0.);
  { if (((Tree *)grid)->dirty) update_cache_f(); };
end_tracing("init_grid","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h",1593);}


void check_two_one (void)
{
  {foreach_leaf()
    if (level > 0)
      for (int k = -1; k <= 1; k++)
 for (int l = -1; l <= 1; l++) {

   int i = (point.i + 2)/2 + k;
   int j = (point.j + 2)/2 + l;
   double x = ((i - 2 + 0.5)*(1./(1 << point.level))*2. - 0.5);
   double y = ((j - 2 + 0.5)*(1./(1 << point.level))*2. - 0.5);
   if (x > -0.5 && x < 0.5 && y > -0.5 && y < 0.5 &&
       !(aparent(k,l,0).flags & active)) {
     FILE * fp = fopen("check_two_one_loc", "w");
     fprintf (fp,
       "# %d %d\n"
       "%g %g\n%g %g\n",
       k, l,
       (((point.i - 2) + 0.5)*(1./(1 << point.level)) - 0.5),
       (((point.j - 2) + 0.5)*(1./(1 << point.level)) - 0.5),
       x, y);
     fclose (fp);





     if (!(false)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h", 1623, "false");
   }
 }end_foreach_leaf();}
}


struct _locate { double x, y, z; };

Point locate (struct _locate p)
{
  for (int l = depth(); l >= 0; l--) {
    Point point = {0};int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
    point.level = l;
    int n = 1 << point.level;
    point.i = (p.x - X0)/L0*n + 2;

    point.j = (p.y - Y0)/L0*n + 2;




    if (point.i >= 0 && point.i < n + 2*2

 && point.j >= 0 && point.j < n + 2*2




 ) {
      if (allocated(0,0,0) && is_local(cell) && is_leaf(cell))
 return point;
    }
    else
      break;
  }
  Point point = {0};int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  point.level = -1;
  return point;
}



bool tree_is_full()
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
  return (grid->tn == 1L << grid->maxdepth*2);
}

#line 1 "grid/tree-common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"



#line 1 "grid/multigrid-common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"


#line 1 "grid/cartesian-common.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"
#line 1 "grid/events.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/events.h"







static void event_error (Event * ev, const char * s)
{
  fprintf (ferr, "%s:%d: error: %s\n", ev->file, ev->line, s);
  exit (1);
}

static void init_event (Event * ev)
{
  if (ev->arrayi || ev->arrayt) {
    ev->i = ev->t = -1;
    if (ev->arrayi)
      ev->i = ev->arrayi[0];
    else
      ev->t = ev->arrayt[0];
    ev->a = 1;
    ev->expr[1] = NULL;
  }
  else {
    if (ev->nexpr > 0) {
      Expr init = NULL, cond = NULL, inc = NULL;
      for (int j = 0; j < ev->nexpr; j++) {
 int i = -123456; double t = i;
 (* ev->expr[j]) (&i, &t, ev);
 if (i == -123456 && t == -123456) {

   if (cond)
     event_error (ev, "events can only use a single condition");
   cond = ev->expr[j];
 }
 else {

   int i1 = i; double t1 = t;
   (* ev->expr[j]) (&i1, &t1, ev);
   if (i1 == i && t1 == t) {


     if (init)
       event_error (ev, "events can only use a single initialisation");
     init = ev->expr[j];
   }
   else {

     if (inc)
       event_error (ev, "events can only use a single increment");
     inc = ev->expr[j];
   }
 }
      }
      ev->expr[0] = init;
      ev->expr[1] = cond;
      ev->expr[2] = inc;
      ev->nexpr = 0;
    }
    ev->i = ev->t = -1;
    if (ev->expr[0]) {
      (* ev->expr[0]) (&ev->i, &ev->t, ev);
      if (ev->i == 1234567890 || ev->t == 1234567890) {
 ev->i = 1234567890; ev->t = -1;
      }
    }
    else if (ev->expr[2]) {
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (ev->i != -1)
 ev->i = 0;
      if (ev->t != -1)
 ev->t = 0;
    }
  }
}

enum { event_done, event_alive, event_stop };

static int event_finished (Event * ev)
{
  ev->t = ev->i = -1;
  return event_done;
}

void event_register (Event event) {
  if (!(Events)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/events.h", 87, "Events");
  if (!(!event.last)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/events.h", 88, "!event.last");
  int n = 0, parent = -1;
  for (Event * ev = Events; !ev->last; ev++) {
    if (!strcmp (event.name, ev->name)) {
      if (!(parent < 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/events.h", 92, "parent < 0");
      parent = n;
    }
    n++;
  }
  if (parent < 0) {
    Events = (Event *) prealloc (Events, (n + 2)*sizeof(Event),__func__,__FILE__,__LINE__);
    Events[n] = event;
    Events[n].next = NULL;
    Events[n + 1].last = true;
    init_event (&Events[n]);
  }
  else {
    Event * ev = ((Event *) pcalloc (1, sizeof(Event),__func__,__FILE__,__LINE__));
    *ev = Events[parent];
    Events[parent] = event;
    Events[parent].next = ev;
    init_event (&Events[parent]);
  }
}

static int event_cond (Event * ev, int i, double t)
{
  if (!ev->expr[1])
    return true;
  return (* ev->expr[1]) (&i, &t, ev);
}
#line 131 "/home/xiangbin2/basilisk_new/basilisk/src/grid/events.h"
static int event_do (Event * ev, bool action)
{
  if ((iter > ev->i && t > ev->t) || !event_cond (ev, iter, t))
    return event_finished (ev);
  if (iter == ev->i || fabs (t - ev->t) <= 1e-9) {
    if (action) {
      bool finished = false;
      for (Event * e = ev; e; e = e->next) {



 if ((* e->action) (iter, t, e))
   finished = true;
      }
      if (finished) {
 event_finished (ev);
 return event_stop;
      }
    }
    if (ev->arrayi) {
      ev->i = ev->arrayi[ev->a++];
      if (ev->i < 0)
 return event_finished (ev);
    }
    if (ev->arrayt) {
      ev->t = ev->arrayt[ev->a++];
      if (ev->t < 0)
 return event_finished (ev);
    }
    else if (ev->expr[2]) {
      int i0 = ev->i;
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (i0 == -1 && ev->i != i0)
 ev->i += iter + 1;
      if (!event_cond (ev, iter + 1, ev->t))
 return event_finished (ev);
    }
    else if (ev->expr[0] && !ev->expr[1])
      return event_finished (ev);
  }
  return event_alive;
}

static void end_event_do (bool action)
{




  for (Event * ev = Events; !ev->last; ev++)
    if (ev->i == 1234567890 && action)
      for (Event * e = ev; e; e = e->next) {



 e->action (iter, t, e);
      }
}

int events (bool action)
{





  if (iter == 0)
    for (Event * ev = Events; !ev->last; ev++)
      init_event (ev);

  int cond = 0, cond1 = 0;
  inext = 1234567890; tnext = HUGE;
  for (Event * ev = Events; !ev->last && !cond; ev++)
    if (ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond = 1;
  for (Event * ev = Events; !ev->last; ev++) {
    int status = event_do (ev, action);
    if (status == event_stop) {
      end_event_do (action);
      return 0;
    }
    if (status == event_alive && ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond1 = 1;
    if (ev->t > t && ev->t < tnext)
      tnext = ev->t;
    if (ev->i > iter && ev->i < inext)
      inext = ev->i;
  }
  if ((!cond || cond1) && (tnext != HUGE || inext != 1234567890)) {
    inext = iter + 1;
    return 1;
  }
  end_event_do (action);
  return 0;
}

void event (const char * name)
{
  for (Event * ev = Events; !ev->last; ev++)
    if (!strcmp (ev->name, name))
      for (Event * e = ev; e; e = e->next) {



 (* e->action) (0, 0, e);
      }
}

double dtnext (double dt)
{
  if (tnext != HUGE && tnext > t) {
    unsigned int n = (tnext - t)/dt;
    if (!(n < INT_MAX)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/events.h", 245, "n < INT_MAX");
    if (n == 0)
      dt = tnext - t;
    else {
      double dt1 = (tnext - t)/n;
      if (dt1 > dt + 1e-9)
 dt = (tnext - t)/(n + 1);
      else if (dt1 < dt)
 dt = dt1;
      tnext = t + dt;
    }
  }
  else
    tnext = t + dt;
  return dt;
}
#line 2 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"

void (* debug) (Point);

#define _val_constant(a,k,l,m) ((const double) _constant[a.i -_NVARMAX])
#define diagonalize(a)
#define val_diagonal(a,k,l,m) ((k) == 0 && (l) == 0 && (m) == 0)

#undef VARIABLES
#define VARIABLES\
  double Delta = L0*(1./(1 << point.level));\
  double Delta_x = Delta;\
\
  double Delta_y = Delta;\
\
\
\
\
\
  double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; NOT_UNUSED(x);\
\
  double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0;\
\
\
\
 NOT_UNUSED(y);\
\
\
\
  double z = 0.;\
\
  NOT_UNUSED(z);\
\
  NOT_UNUSED(Delta);\
  NOT_UNUSED(Delta_x);\
\
  NOT_UNUSED(Delta_y);\
\
\
\
\
\
  ;\

#line 44


#line 1 "grid/fpe.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/fpe.h"


#include <signal.h>
#include <unistd.h>

static int gdb()
{
  if (last_point.level >= 0) {
    debug (last_point);
    fputc ('\n', ferr);
    fflush (ferr);
  }
  char command[80];
  sprintf (command, "exec xterm -e 'gdb -p %d' & xterm -e 'gnuplot plot -'",
    getpid());
  return system (command);
}

static void caught_abort (int sig)
{
  fprintf (ferr, "Caught signal %d (Aborted)\n", sig);
  gdb();
}

static void caught_fpe (int sig)
{
  fprintf (ferr, "Caught signal %d (Floating Point Exception)\n", sig);
  gdb();
  exit (1);
}

static void caught_segfault (int sig)
{
  fprintf (ferr, "Caught signal %d (Segmentation Fault)\n", sig);
  gdb();
  exit (2);
}

void catch_fpe (void)
{
  struct sigaction act;
  act.sa_handler = caught_fpe;
  sigemptyset (&act.sa_mask);
  act.sa_flags = 0;
  last_point.level = -1;
  sigaction (8, &act, NULL);
  act.sa_handler = caught_segfault;
  sigaction (11, &act, NULL);
  act.sa_handler = caught_abort;
  act.sa_flags = SA_RESETHAND;
  sigaction (6, &act, NULL);
}
#line 47 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"

#define end_foreach_face()



static void init_block_scalar (scalar sb, const char * name, const char * ext,
          int n, int block)
{
  char bname[strlen(name) + strlen(ext) + 10];
  if (n == 0) {
    sprintf (bname, "%s%s", name, ext);
    _attribute[sb.i].block = block;
    init_scalar (sb, bname);
    baseblock = list_append (baseblock, sb);
  }
  else {
    sprintf (bname, "%s%d%s", name, n, ext);
    _attribute[sb.i].block = - n;
    init_scalar (sb, bname);
  }
  all = list_append (all, sb);
}

scalar new_block_scalar (const char * name, const char * ext, int block)
{
  int nvar = datasize/sizeof(double);

  scalar s = {0};
  while (s.i < nvar) {
    int n = 0;
    scalar sb = s;
    while (sb.i < nvar && n < block && _attribute[sb.i].freed)
      n++, sb.i++;
    if (n >= block) {
      for (sb.i = s.i, n = 0; n < block; n++, sb.i++)
 init_block_scalar (sb, name, ext, n, block);
      trash (((scalar []){s, {-1}}));
      return s;
    }
    s.i = sb.i + 1;
  }


  s = (scalar){nvar};
  if (!(nvar + block <= _NVARMAX)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h", 91, "nvar + block <= _NVARMAX");
  _attribute = (_Attributes *) prealloc (_attribute, (nvar + block)*sizeof(_Attributes),__func__,__FILE__,__LINE__);
  memset (&_attribute[nvar], 0, block*sizeof (_Attributes));
  for (int n = 0; n < block; n++, nvar++) {
    scalar sb = (scalar){nvar};
    init_block_scalar (sb, name, ext, n, block);
  }

  realloc_scalar (block*sizeof(double));
  trash (((scalar []){s, {-1}}));
  return s;
}

scalar new_scalar (const char * name)
{
  return new_block_scalar (name, "", 1);
}

scalar new_vertex_scalar (const char * name)
{
  scalar s = new_block_scalar (name, "", 1);
  init_vertex_scalar (s, NULL);
  return s;
}

scalar new_block_vertex_scalar (const char * name, int block)
{
  scalar s = new_block_scalar (name, "", block);
  for (int i = 0; i < block; i++) {
    scalar sb = {s.i + i};
    init_vertex_scalar (sb, NULL);
  }
  return s;
}

static vector alloc_block_vector (const char * name, int block)
{
  vector v;
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  
    v.x = new_block_scalar (name, ext.x, block);
    
#line 131
v.y = new_block_scalar (name, ext.y, block);
  return v;
}

vector new_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_vector (v, NULL);
  return v;
}

vector new_face_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_face_vector (v, NULL);
  return v;
}

vector new_block_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    
      vb.x.i = v.x.i + i;
      
#line 155
vb.y.i = v.y.i + i;
    init_vector (vb, NULL);
    
      _attribute[vb.x.i].block = - i;
      
#line 158
_attribute[vb.y.i].block = - i;
  }
  
    _attribute[v.x.i].block = block;
    
#line 161
_attribute[v.y.i].block = block;
  return v;
}

vector new_block_face_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    
      vb.x.i = v.x.i + i;
      
#line 171
vb.y.i = v.y.i + i;
    init_face_vector (vb, NULL);
    
      _attribute[vb.x.i].block = - i;
      
#line 174
_attribute[vb.y.i].block = - i;
  }
  
    _attribute[v.x.i].block = block;
    
#line 177
_attribute[v.y.i].block = block;
  return v;
}

tensor new_tensor (const char * name)
{
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {"%s.x", "%s.y", "%s.z"};
  tensor t;
   {
    sprintf (cname, ext.x, name);
    t.x = new_vector (cname);
  } 
#line 186
{
    sprintf (cname, ext.y, name);
    t.y = new_vector (cname);
  }
  init_tensor (t, NULL);
  return t;
}

tensor new_symmetric_tensor (const char * name)
{
  char cname[strlen(name) + 5];
  struct { char * x, * y, * z; } ext = {"%s.x.x", "%s.y.y", "%s.z.z"};
  tensor t;
   {
    sprintf (cname, ext.x, name);
    t.x.x = new_scalar(cname);
  } 
#line 199
{
    sprintf (cname, ext.y, name);
    t.y.y = new_scalar(cname);
  }

    sprintf (cname, "%s.x.y", name);
    t.x.y = new_scalar(cname);
    t.y.x = t.x.y;
#line 219 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"
  init_tensor (t, NULL);
  return t;
}

static int nconst = 0;

void init_const_scalar (scalar s, const char * name, double val)
{
  if (s.i - _NVARMAX >= nconst) {
    nconst = s.i - _NVARMAX + 1;
    _constant = (double *) prealloc (_constant, (nconst)*sizeof(double),__func__,__FILE__,__LINE__);
  }
  _constant[s.i - _NVARMAX] = val;
}

scalar new_const_scalar (const char * name, int i, double val)
{
  scalar s = (scalar){i + _NVARMAX};
  init_const_scalar (s, name, val);
  return s;
}

void init_const_vector (vector v, const char * name, double * val)
{
  
    init_const_scalar (v.x, name, *val++);
    
#line 244
init_const_scalar (v.y, name, *val++);
}

vector new_const_vector (const char * name, int i, double * val)
{
  vector v;
  
    v.x.i = _NVARMAX + i++;
    
#line 251
v.y.i = _NVARMAX + i++;
  init_const_vector (v, name, val);
  return v;
}

void scalar_clone (scalar a, scalar b)
{
  char * name = _attribute[a.i].name;
  double (** boundary) (Point, Point, scalar, void *) = _attribute[a.i].boundary;
  double (** boundary_homogeneous) (Point, Point, scalar, void *) =
    _attribute[a.i].boundary_homogeneous;
  if (!(_attribute[b.i].block > 0 && _attribute[a.i].block == _attribute[b.i].block)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h", 262, "b.block > 0 && a.block == b.block");
  pfree (_attribute[a.i].depends,__func__,__FILE__,__LINE__);
  _attribute[a.i] = _attribute[b.i];
  _attribute[a.i].name = name;
  _attribute[a.i].boundary = boundary;
  _attribute[a.i].boundary_homogeneous = boundary_homogeneous;
  for (int i = 0; i < nboundary; i++) {
    _attribute[a.i].boundary[i] = _attribute[b.i].boundary[i];
    _attribute[a.i].boundary_homogeneous[i] = _attribute[b.i].boundary_homogeneous[i];
  }
  _attribute[a.i].depends = list_copy (_attribute[b.i].depends);
}

scalar * list_clone (scalar * l)
{
  scalar * list = NULL;
  int nvar = datasize/sizeof(double), map[nvar];
  for (int i = 0; i < nvar; i++)
    map[i] = -1;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    scalar c = _attribute[s.i].block > 1 ? new_block_scalar("c", "", _attribute[s.i].block) :
      new_scalar("c");
    scalar_clone (c, s);
    map[s.i] = c.i;
    list = list_append (list, c);
  }}}
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    {
      if (_attribute[s.i].v.x.i >= 0 && map[_attribute[s.i].v.x.i] >= 0)
 _attribute[s.i].v.x.i = map[_attribute[s.i].v.x.i];
      
#line 290
if (_attribute[s.i].v.y.i >= 0 && map[_attribute[s.i].v.y.i] >= 0)
 _attribute[s.i].v.y.i = map[_attribute[s.i].v.y.i];}}}
  return list;
}

void delete (scalar * list)
{
  if (all == NULL)
    return;

  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    for (int i = 0; i < _attribute[f.i].block; i++) {
      scalar fb = {f.i + i};
      if (_attribute[f.i].delete)
 _attribute[f.i].delete (fb);
      pfree (_attribute[fb.i].name,__func__,__FILE__,__LINE__); _attribute[fb.i].name = NULL;
      pfree (_attribute[fb.i].boundary,__func__,__FILE__,__LINE__); _attribute[fb.i].boundary = NULL;
      pfree (_attribute[fb.i].boundary_homogeneous,__func__,__FILE__,__LINE__); _attribute[fb.i].boundary_homogeneous = NULL;
      pfree (_attribute[fb.i].depends,__func__,__FILE__,__LINE__); _attribute[fb.i].depends = NULL;
      _attribute[fb.i].freed = true;
    }
  }}}

  if (list == all) {
    all[0].i = -1;
    baseblock[0].i = -1;
    return;
  }

  trash (list);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    if (_attribute[f.i].block > 0) {
      scalar * s = all;
      for (; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[_attribute[f.i].block].i >= 0; s++)
   s[0] = s[_attribute[f.i].block];
 s->i = -1;
      }
      for (s = baseblock; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[1].i >= 0; s++)
   s[0] = s[1];
 s->i = -1;
      }
    }
  }}}
}

void free_solver()
{
  if (!(_val_higher_dimension == 0.)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h", 341, "_val_higher_dimension == 0.");

  if (free_solver_funcs) {
    free_solver_func * a = (free_solver_func *) free_solver_funcs->p;
    for (int i = 0; i < free_solver_funcs->len/sizeof(free_solver_func); i++)
      a[i] ();
    array_free (free_solver_funcs);
  }

  delete (all);
  pfree (all,__func__,__FILE__,__LINE__); all = NULL;
  pfree (baseblock,__func__,__FILE__,__LINE__); baseblock = NULL;
  for (Event * ev = Events; !ev->last; ev++) {
    Event * e = ev->next;
    while (e) {
      Event * next = e->next;
      pfree (e,__func__,__FILE__,__LINE__);
      e = next;
    }
  }

  pfree (Events,__func__,__FILE__,__LINE__); Events = NULL;
  pfree (_attribute,__func__,__FILE__,__LINE__); _attribute = NULL;
  pfree (_constant,__func__,__FILE__,__LINE__); _constant = NULL;
  free_grid();
  qpclose_all();
#if TRACE
  trace_off();
#endif
#if MTRACE
  pmuntrace();
#endif
#if _CADNA
  cadna_end();
#endif
}



void (* boundary_level) (scalar *, int l);
void (* boundary_face) (vectorl);




void boundary_flux (vector * list) __attribute__ ((deprecated));

void boundary_flux (vector * list)
{
  vectorl list1 = {NULL};
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
    {
      list1.x = list_append (list1.x, v.x);
      
#line 393
list1.y = list_append (list1.y, v.y);}}}
  boundary_face (list1);
  
    pfree (list1.x,__func__,__FILE__,__LINE__);
    
#line 396
pfree (list1.y,__func__,__FILE__,__LINE__);
}

static scalar * list_add_depends (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  scalar * list1 = list;
  {scalar*_i=(scalar*)( _attribute[s.i].depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      list1 = list_add_depends (list1, d);}}
  return list_append (list1, s);
}

     
void boundary_internal (scalar * list, const char * fname, int line)
{tracing("boundary_internal","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",412);
  if (list == NULL)
    {end_tracing("boundary_internal","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",415);return;}
  scalar * listc = NULL;
  vectorl listf = {NULL};
  bool flux = false;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].block > 0) {
      if (scalar_is_dirty (s)) {
 if (_attribute[s.i].face && _attribute[s.i].dirty != 2)
   {
     if (_attribute[s.i].v.x.i == s.i)
       listf.x = list_add (listf.x, s), flux = true;
     
#line 424
if (_attribute[s.i].v.y.i == s.i)
       listf.y = list_add (listf.y, s), flux = true;}
 if (!is_constant(cm) && _attribute[cm.i].dirty)
   listc = list_add_depends (listc, cm);
 if (_attribute[s.i].face != 2)
   listc = list_add_depends (listc, s);
      }




    }}}
  if (flux) {
    boundary_face (listf);
    
      pfree (listf.x,__func__,__FILE__,__LINE__);
      
#line 439
pfree (listf.y,__func__,__FILE__,__LINE__);
  }
  if (listc) {
    boundary_level (listc, -1);
    {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = false;}}
    pfree (listc,__func__,__FILE__,__LINE__);
  }
end_tracing("boundary_internal","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",447);}

void cartesian_boundary_level (scalar * list, int l)
{
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, l); };
}

void cartesian_boundary_face (vectorl list)
{
  
    {scalar*_i=(scalar*)( list.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
    
#line 457
{scalar*_i=(scalar*)( list.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
}

static double symmetry (Point point, Point neighbor, scalar s, void * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  return val(s,0,0,0);
}

static double antisymmetry (Point point, Point neighbor, scalar s, void * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  return -val(s,0,0,0);
}

double (* default_scalar_bc[]) (Point, Point, scalar, void *) = {
  symmetry, symmetry, symmetry, symmetry, symmetry, symmetry
};

scalar cartesian_init_scalar (scalar s, const char * name)
{

  char * pname;
  if (name) {
    pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
    pname = pstrdup (name,__func__,__FILE__,__LINE__);
  }
  else
    pname = _attribute[s.i].name;
  int block = _attribute[s.i].block;
  double (** boundary) (Point, Point, scalar, void *) = _attribute[s.i].boundary;
  double (** boundary_homogeneous) (Point, Point, scalar, void *) =
    _attribute[s.i].boundary_homogeneous;

  _attribute[s.i] = (const _Attributes){0};
  _attribute[s.i].name = pname;
  _attribute[s.i].block = block == 0 ? 1 : block;

  _attribute[s.i].boundary = boundary ? boundary :
    (double (**)(Point, Point, scalar, void *))
    pmalloc (nboundary*sizeof (void (*)()),__func__,__FILE__,__LINE__);
  _attribute[s.i].boundary_homogeneous = boundary_homogeneous ? boundary_homogeneous :
    (double (**)(Point, Point, scalar, void *))
    pmalloc (nboundary*sizeof (void (*)()),__func__,__FILE__,__LINE__);
  for (int b = 0; b < nboundary; b++)
    _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] =
      b < 2*2 ? default_scalar_bc[b] : symmetry;
  _attribute[s.i].gradient = NULL;
   {
    _attribute[s.i].d.x = 0;
    _attribute[s.i].v.x.i = -1;
  } 
#line 504
{
    _attribute[s.i].d.y = 0;
    _attribute[s.i].v.y.i = -1;
  }
  _attribute[s.i].face = false;
  return s;
}

scalar cartesian_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  
    _attribute[s.i].d.x = -1;
    
#line 516
_attribute[s.i].d.y = -1;
  for (int d = 0; d < nboundary; d++)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
  return s;
}

double (* default_vector_bc[]) (Point, Point, scalar, void *) = {
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry
};

vector cartesian_init_vector (vector v, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.x);
      init_scalar (v.x, cname);
    }
    else
      init_scalar (v.x, NULL);
    _attribute[v.x.i].v = v;
  } 
#line 531
{
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.y);
      init_scalar (v.y, cname);
    }
    else
      init_scalar (v.y, NULL);
    _attribute[v.y.i].v = v;
  }

  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] =
      d < 2*2 ? default_vector_bc[d] : antisymmetry;
  return v;
}

vector cartesian_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
   {
    _attribute[v.x.i].d.x = -1;
    _attribute[v.x.i].face = true;
  } 
#line 551
{
    _attribute[v.y.i].d.y = -1;
    _attribute[v.y.i].face = true;
  }
  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
  return v;
}

tensor cartesian_init_tensor (tensor t, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.x);
      init_vector (t.x, cname);
    }
    else
      init_vector (t.x, NULL);
  } 
#line 563
{
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.y);
      init_vector (t.y, cname);
    }
    else
      init_vector (t.y, NULL);
  }






    for (int b = 0; b < nboundary; b++) {
      _attribute[t.x.x.i].boundary[b] = _attribute[t.y.x.i].boundary[b] =
 _attribute[t.x.x.i].boundary_homogeneous[b] = _attribute[t.y.y.i].boundary_homogeneous[b] =
 b < 2*2 ? default_scalar_bc[b] : symmetry;
      _attribute[t.x.y.i].boundary[b] = _attribute[t.y.y.i].boundary[b] =
 _attribute[t.x.y.i].boundary_homogeneous[b] = _attribute[t.y.x.i].boundary_homogeneous[b] =
 b < 2*2 ? default_vector_bc[b] : antisymmetry;
    }



  return t;
}

struct OutputCells {
  FILE * fp;
  coord c;
  double size;
};

void output_cells (struct OutputCells p)
{
  if (!p.fp) p.fp = fout;
  {foreach() {
    bool inside = true;
    coord o = {x,y,z};
    
      if (inside && p.size > 0. &&
   (o.x > p.c.x + p.size || o.x < p.c.x - p.size))
 inside = false;
      
#line 605
if (inside && p.size > 0. &&
   (o.y > p.c.y + p.size || o.y < p.c.y - p.size))
 inside = false;
    if (inside) {
      Delta /= 2.;



      fprintf (p.fp, "%g %g\n%g %g\n%g %g\n%g %g\n%g %g\n\n",
        x - Delta, y - Delta,
        x - Delta, y + Delta,
        x + Delta, y + Delta,
        x + Delta, y - Delta,
        x - Delta, y - Delta);
#line 633 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"
    }
  }end_foreach();}
  fflush (p.fp);
}


static void output_cells_internal (FILE * fp)
{
  output_cells ((struct OutputCells){fp});
}


static char * replace_ (const char * vname)
{
  char * name = pstrdup (vname,__func__,__FILE__,__LINE__), * c = name;
  while (*c != '\0') {
    if (*c == '.')
      *c = '_';
    c++;
  }
  return name;
}

static void debug_plot (FILE * fp, const char * name, const char * cells,
   const char * stencil)
{
  char * vname = replace_ (name);
  fprintf (fp,
    "  load 'debug.plot'\n"
    "  v=%s\n"




    "  plot '%s' w l lc 0, "
    "'%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 1 title columnhead(3+3*v)",





    vname, cells, stencil);
  pfree (vname,__func__,__FILE__,__LINE__);
}

void cartesian_debug (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  char name[80] = "cells";
  if (pid() > 0)
    sprintf (name, "cells-%d", pid());
  FILE * fp = fopen (name, "w");
  output_cells ((struct OutputCells){fp, (coord){x,y,z}, 4.*Delta});
  fclose (fp);

  char stencil[80] = "stencil";
  if (pid() > 0)
    sprintf (stencil, "stencil-%d", pid());
  fp = fopen (stencil, "w");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){



    fprintf (fp, "x y %s ", _attribute[v.i].name);}}



  fputc ('\n', fp);
#line 712 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"
    for (int k = -2; k <= 2; k++)
      for (int l = -2; l <= 2; l++) {
 {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
   fprintf (fp, "%g %g ",
     x + k*Delta + _attribute[v.i].d.x*Delta/2.,
     y + l*Delta + _attribute[v.i].d.y*Delta/2.);
   if (allocated(k,l,0))
     fprintf (fp, "%g ", val(v,k,l,0));
   else
     fputs ("n/a ", fp);
 }}}
 fputc ('\n', fp);
      }
#line 742 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"
  fclose (fp);

  fp = fopen ("debug.plot", "w");
  fprintf (fp,
    "set term x11\n"
    "set size ratio -1\n"
    "set key outside\n");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    char * name = replace_ (_attribute[s.i].name);
    fprintf (fp, "%s = %d\n", name, s.i);
    pfree (name,__func__,__FILE__,__LINE__);
  }}}
  fclose (fp);

  fprintf (ferr, "Last point stencils can be displayed using (in gnuplot)\n");
  debug_plot (ferr, _attribute[0].name, name, stencil);
  fflush (ferr);

  fp = fopen ("plot", "w");
  debug_plot (fp, _attribute[0].name, name, stencil);
  fclose (fp);
}

void cartesian_methods()
{
  init_scalar = cartesian_init_scalar;
  init_vertex_scalar = cartesian_init_vertex_scalar;
  init_vector = cartesian_init_vector;
  init_tensor = cartesian_init_tensor;
  init_face_vector = cartesian_init_face_vector;
  boundary_level = cartesian_boundary_level;
  boundary_face = cartesian_boundary_face;
  debug = cartesian_debug;
}

tensor init_symmetric_tensor (tensor t, const char * name)
{
  return init_tensor (t, name);
}

struct _interpolate {
  scalar v;
  double x, y, z;
};

static double interpolate_linear (Point point, struct _interpolate p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar v = p.v;







  x = (p.x - x)/Delta - _attribute[v.i].d.x/2.;
  y = (p.y - y)/Delta - _attribute[v.i].d.y/2.;
  int i = sign(x), j = sign(y);
  x = fabs(x); y = fabs(y);

  return ((val(v,0,0,0)*(1. - x) + val(v,i,0,0)*x)*(1. - y) +
   (val(v,0,j,0)*(1. - x) + val(v,i,j,0)*x)*y);
#line 816 "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h"
}

     
double interpolate (struct _interpolate p)
{tracing("interpolate","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",819);
  scalar v = p.v;
  boundary_internal ((scalar *)((scalar[]){v,{-1}}), "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h", 822);
  Point point = locate ((struct _locate){p.x, p.y, p.z});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (point.level < 0)
    {end_tracing("interpolate","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",825);return HUGE;}
  { double _ret= interpolate_linear (point, p);end_tracing("interpolate","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",826);return _ret;}
end_tracing("interpolate","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",827);}

     
void interpolate_array (scalar * list, coord * a, int n, double * v, bool linear)
{tracing("interpolate_array","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",830);
  boundary_internal ((scalar *)list, "/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h", 832);
  int j = 0;
  for (int i = 0; i < n; i++) {
    Point point = locate ((struct _locate){a[i].x, a[i].y, a[i].z});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
    if (point.level >= 0) {
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 v[j++] = !linear ? val(s,0,0,0) :
   interpolate_linear (point,
         (struct _interpolate){s, a[i].x, a[i].y, a[i].z});}}
    }
    else
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 v[j++] = HUGE;}}
  }
#if 1
  if (pid() == 0)
    MPI_Reduce (MPI_IN_PLACE, v, n*list_len(list), MPI_DOUBLE,
  MPI_MIN, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce (v, v, n*list_len(list), MPI_DOUBLE,
  MPI_MIN, 0, MPI_COMM_WORLD);
#endif
end_tracing("interpolate_array","/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h",854);}



typedef int bid;

bid new_bid()
{
  int b = nboundary++;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].boundary = (double (**)(Point, Point, scalar, void *))
      prealloc (_attribute[s.i].boundary, nboundary*sizeof (void (*)()),__func__,__FILE__,__LINE__);
    _attribute[s.i].boundary_homogeneous = (double (**)(Point, Point, scalar, void *))
      prealloc (_attribute[s.i].boundary_homogeneous, nboundary*sizeof (void (*)()),__func__,__FILE__,__LINE__);
  }}}
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    if (_attribute[s.i].v.x.i < 0)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] = symmetry;
    else if (_attribute[s.i].v.x.i == s.i) {
      vector v = _attribute[s.i].v;
      
 _attribute[v.y.i].boundary[b] = _attribute[v.y.i].boundary_homogeneous[b] = symmetry;
 
#line 875
_attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] = symmetry;
      _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] =
 _attribute[v.x.i].face ? NULL : antisymmetry;
    }
  }}}
  return b;
}



static double periodic_bc (Point point, Point neighbor, scalar s, void * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  return HUGE;
}

static void periodic_boundary (int d)
{

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (is_vertex_scalar (s))
      _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
    else
      _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = periodic_bc;}}

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (_attribute[s.i].face) {
      vector v = _attribute[s.i].v;
      _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
    }}}

  default_scalar_bc[d] = periodic_bc;
  default_vector_bc[d] = periodic_bc;
}

void periodic (int dir)
{



    if (!(dir <= bottom)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/cartesian-common.h", 914, "dir <= bottom");




  int c = dir/2;
  periodic_boundary (2*c);
  periodic_boundary (2*c + 1);
  (&Period.x)[c] = true;
}


double getvalue (Point point, scalar s, int i, int j, int k)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  return val(s,i,j,k);
}

void default_stencil (Point p, scalar * list)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].input = true, _attribute[s.i].width = 2;}}
}




static void write_stencil_index (int * index)
{
  fprintf (qstderr(), "[%d", index[0]);
  for (int d = 1; d < 2; d++)
    fprintf (qstderr(), ",%d", index[d]);
  fputs ("]", qstderr());
}

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, bool overflow)
{
  if (is_constant(s) || s.i < 0)
    return;
  int index[] = {i, j, k};
  for (int d = 0; d < 2; d++)
    index[d] += (&p.i)[d];
  bool central = true;
  for (int d = 0; d < 2; d++) {
    if (!overflow && (index[d] > 2 || index[d] < - 2)) {
      fprintf (qstderr(), "%s:%d: error: stencil overflow: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (qstderr(), "\n");
      fflush (qstderr());
      abort();
    }
    if (index[d] != 0)
      central = false;
  }
  if (central) {
    if (!_attribute[s.i].output)
      _attribute[s.i].input = true;
  }
  else {
    _attribute[s.i].input = true;
    int d = 0;
     {
      if ((!_attribute[s.i].face || _attribute[s.i].v.x.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    } 
#line 976
{
      if ((!_attribute[s.i].face || _attribute[s.i].v.y.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    }
  }
}

void stencil_val_a (Point p, scalar s, int i, int j, int k, bool input,
      const char * file, int line)
{
  if (is_constant(s) || s.i < 0)
    abort();
  int index[] = {i, j, k};
  for (int d = 0; d < 2; d++)
    index[d] += (&p.i)[d];
  for (int d = 0; d < 2; d++)
    if (index[d] != 0) {
      fprintf (qstderr(), "%s:%d: error: illegal write: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (qstderr(), "\n");
      fflush (qstderr());
      abort();
    }
  if (input && !_attribute[s.i].output)
    _attribute[s.i].input = true;
  _attribute[s.i].output = true;
}
#line 4 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"

#ifndef foreach_level_or_leaf
# define foreach_level_or_leaf foreach_level
# define end_foreach_level_or_leaf end_foreach_level
#endif

#ifndef foreach_coarse_level
# define foreach_coarse_level foreach_level
# define end_foreach_coarse_level end_foreach_level
#endif










void (* restriction) (scalar *);

static inline void restriction_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0.;
  {foreach_child()
    sum += val(s,0,0,0);end_foreach_child()}
  val(s,0,0,0) = sum/(1 << 2);
}

static inline void restriction_volume_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

#line 35
if(!is_constant(cm)){{
  double sum = 0.;
  {foreach_child()
    sum += val(cm,0,0,0)*val(s,0,0,0);end_foreach_child()}
  val(s,0,0,0) = sum/(1 << 2)/(val(cm,0,0,0) + 1e-30);
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);

#line 35
{
  double sum = 0.;
  {foreach_child()
    sum += _const_cm*val(s,0,0,0);end_foreach_child()}
  val(s,0,0,0) = sum/(1 << 2)/(_const_cm + 1e-30);
}}

#line 40
}

static inline void face_average (Point point, vector v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
   {




      val(v.x,0,0,0) = (fine(v.x,0,0,0) + fine(v.x,0,1,0))/2.;
      val(v.x,1,0,0) = (fine(v.x,2,0,0) + fine(v.x,2,1,0))/2.;






  } 
#line 44
{




      val(v.y,0,0,0) = (fine(v.y,0,0,0) + fine(v.y,1,0,0))/2.;
      val(v.y,0,1,0) = (fine(v.y,0,2,0) + fine(v.y,1,2,0))/2.;






  }
}

static inline void restriction_face (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  face_average (point, _attribute[s.i].v);
}

static inline void restriction_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  for (int i = 0; i <= 1; i++) {
    val(s,i,0,0) = fine(s,2*i,0,0);

    val(s,i,1,0) = fine(s,2*i,2,0);





  }
}

static inline void no_restriction (Point point, scalar s) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;}

static inline void no_data (Point point, scalar s) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    val(s,0,0,0) = HUGE;end_foreach_child()}
}

void wavelet (scalar s, scalar w)
{
  restriction (((scalar[]){s,{-1}}));
  for (int l = grid->maxdepth - 1; l >= 0; l--) {
    {foreach_coarse_level (l) {
      {foreach_child()
        val(w,0,0,0) = val(s,0,0,0);end_foreach_child()}
      _attribute[s.i].prolongation (point, s);
      {foreach_child() {
        double sp = val(s,0,0,0);
        val(s,0,0,0) = val(w,0,0,0);

        val(w,0,0,0) -= sp;
      }end_foreach_child()}
    }end_foreach_coarse_level();}
    boundary_level (((scalar[]){w,{-1}}), l + 1);
  }

  {foreach_level(0)
    val(w,0,0,0) = val(s,0,0,0);end_foreach_level();}
  boundary_level (((scalar[]){w,{-1}}), 0);
}

void inverse_wavelet (scalar s, scalar w)
{
  {foreach_level(0)
    val(s,0,0,0) = val(w,0,0,0);end_foreach_level();}
  boundary_level (((scalar[]){s,{-1}}), 0);
  for (int l = 0; l <= grid->maxdepth - 1; l++) {
    {foreach_coarse_level (l) {
      _attribute[s.i].prolongation (point, s);
      {foreach_child()
        val(s,0,0,0) += val(w,0,0,0);end_foreach_child()}
    }end_foreach_coarse_level();}
    boundary_level (((scalar[]){s,{-1}}), l + 1);
  }
}

static inline double bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



    return (9.*coarse(s,0,0,0) +
     3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
     coarse(s,child.x,child.y,0))/16.;
#line 140 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    val(s,0,0,0) = bilinear (point, s);end_foreach_child()}
}

static inline double quadratic (double a, double b, double c)
{
  return (30.*a + 5.*b - 3.*c)/32.;
}

static inline double biquadratic (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



  return
    quadratic (quadratic (coarse(s,0,0,0),
     coarse(s,child.x,0,0),
     coarse(s,-child.x,0,0)),
        quadratic (coarse(s,0,child.y,0),
     coarse(s,child.x,child.y,0),
     coarse(s,-child.x,child.y,0)),
        quadratic (coarse(s,0,-child.y,0),
     coarse(s,child.x,-child.y,0),
     coarse(s,-child.x,-child.y,0)));




}

static inline double biquadratic_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



  return (36.*val(s,0,0,0) + 18.*(val(s,-1,0,0) + val(s,0,-1,0)) - 6.*(val(s,1,0,0) + val(s,0,1,0)) +
   9.*val(s,-1,-1,0) - 3.*(val(s,1,-1,0) + val(s,-1,1,0)) + val(s,1,1,0))/64.;




}

static inline void refine_biquadratic (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    val(s,0,0,0) = biquadratic (point, s);end_foreach_child()}
}

static inline void refine_linear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

#line 194
if(!is_constant(cm)){{
  coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0));
      
#line 198
g.y = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0));}
  else
    {
      g.x = (val(s,1,0,0) - val(s,-1,0,0))/2.;
      
#line 201
g.y = (val(s,0,1,0) - val(s,0,-1,0))/2.;}

  double sc = val(s,0,0,0), cmc = 4.*val(cm,0,0,0), sum = val(cm,0,0,0)*(1 << 2);
  {foreach_child() {
    val(s,0,0,0) = sc;
    
      val(s,0,0,0) += child.x*g.x*val(cm,-child.x,0,0)/cmc;
      
#line 207
val(s,0,0,0) += child.y*g.y*val(cm,0,-child.y,0)/cmc;
    sum -= val(cm,0,0,0);
  }end_foreach_child()}
  if (!(fabs(sum) < 1e-10)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h", 210, "fabs(sum) < 1e-10");
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);

#line 194
{
  coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0));
      
#line 198
g.y = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0));}
  else
    {
      g.x = (val(s,1,0,0) - val(s,-1,0,0))/2.;
      
#line 201
g.y = (val(s,0,1,0) - val(s,0,-1,0))/2.;}

  double sc = val(s,0,0,0), cmc = 4.*_const_cm, sum = _const_cm*(1 << 2);
  {foreach_child() {
    val(s,0,0,0) = sc;
    
      val(s,0,0,0) += child.x*g.x*_const_cm/cmc;
      
#line 207
val(s,0,0,0) += child.y*g.y*_const_cm/cmc;
    sum -= _const_cm;
  }end_foreach_child()}
  if (!(fabs(sum) < 1e-10)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h", 210, "fabs(sum) < 1e-10");
}}

#line 211
}

static inline void refine_reset (Point point, scalar v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    val(v,0,0,0) = 0.;end_foreach_child()}
}

static inline void refine_injection (Point point, scalar v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double val = val(v,0,0,0);
  {foreach_child()
    val(v,0,0,0) = val;end_foreach_child()}
}

static scalar multigrid_init_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  _attribute[s.i].prolongation = refine_bilinear;
  _attribute[s.i].restriction = restriction_average;
  return s;
}

static scalar multigrid_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_vertex_scalar (s, name);
  _attribute[s.i].restriction = restriction_vertex;
  return s;
}

static vector multigrid_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  
    _attribute[v.y.i].restriction = no_restriction;
    
#line 245
_attribute[v.x.i].restriction = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  return v;
}

void multigrid_debug (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  cartesian_debug (point);

  FILE * plot = fopen ("plot", "a");
  if (point.level > 0) {
    char name[80] = "coarse";
    if (pid() > 0)
      sprintf (name, "coarse-%d", pid());
    FILE * fp = fopen (name, "w");
#line 271 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"
      double xc = x - child.x*Delta/2., yc = y - child.y*Delta/2.;
      for (int k = 0; k <= 1; k++)
 for (int l = 0; l <= 1; l++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){
     fprintf (fp, "%g %g %g ",
       xc + k*child.x*Delta*2. + _attribute[v.i].d.x*Delta,
       yc + l*child.y*Delta*2. + _attribute[v.i].d.y*Delta,
       coarse(v,k*child.x,l*child.y,0));}}
   fputc ('\n', fp);
 }
      fprintf (ferr, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
#line 302 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }

  if (is_coarse()) {
    char name[80] = "fine";
    if (pid() > 0)
      sprintf (name, "fine-%d", pid());
    FILE * fp = fopen (name, "w");
#line 324 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"
      double xf = x - Delta/4., yf = y - Delta/4.;
      for (int k = -2; k <= 3; k++)
 for (int l = -2; l <= 3; l++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
     fprintf (fp, "%g %g ",
       xf + k*Delta/2. + _attribute[v.i].d.x*Delta/4.,
       yf + l*Delta/2. + _attribute[v.i].d.y*Delta/4.);
     if (allocated_child(k,l,0))
       fprintf (fp, "%g ", fine(v,k,l,0));
     else
       fputs ("n/a ", fp);
   }}}
   fputc ('\n', fp);
 }
      fprintf (ferr, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
#line 362 "/home/xiangbin2/basilisk_new/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }
  fflush (ferr);
  fclose (plot);
}

static void multigrid_restriction (scalar * list)
{
  scalar * listdef = NULL, * listc = NULL, * list2 = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);
     
#line 381
list2 = list_add (list2, _attribute[s.i].v.y);}
 else
   list2 = list_add (list2, s);
      }
    }}}

  if (listdef || listc) {
    for (int l = depth() - 1; l >= 0; l--) {
      {foreach_coarse_level(l) {
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
  
     _attribute[s.i].restriction (point, s);
 }}}
      }end_foreach_coarse_level();}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list2, l); };
    }
    pfree (listdef,__func__,__FILE__,__LINE__);
    pfree (listc,__func__,__FILE__,__LINE__);
    pfree (list2,__func__,__FILE__,__LINE__);
  }
}

void multigrid_methods()
{
  cartesian_methods();
  debug = multigrid_debug;
  init_scalar = multigrid_init_scalar;
  init_vertex_scalar = multigrid_init_vertex_scalar;
  init_face_vector = multigrid_init_face_vector;
  restriction = multigrid_restriction;
}







void subtree_size (scalar size, bool leaves)
{




  foreach_stencil()
    {_stencil_val_a(size,0,0,0);  }end_foreach_stencil();




  {
#line 428
foreach()
    val(size,0,0,0) = 1;end_foreach();}





  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar[]){size,{-1}}), depth()); };
  for (int l = depth() - 1; l >= 0; l--) {
    {foreach_coarse_level(l) {
      double sum = !leaves;
      {foreach_child()
 sum += val(size,0,0,0);end_foreach_child()}
      val(size,0,0,0) = sum;
    }end_foreach_coarse_level();}
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar[]){size,{-1}}), l); };
  }
}
#line 5 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"




#line 21 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
int refine_cell (Point point, scalar * list, int flag, Cache * refined)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int nr = 0;


  if (level > 0)
    for (int k = 0; k != 2*child.x; k += child.x)

      for (int l = 0; l != 2*child.y; l += child.y)




   if (aparent(k,l,m).pid >= 0 && is_leaf(aparent(k,l,m))) {
     Point p = point;


     p.level = point.level - 1;
     p.i = (point.i + 2)/2 + k;
     do { if (p.i < 2) p.i += 1 << p.level; else if (p.i >= 2 + (1 << p.level)) p.i -= 1 << p.level; } while(0);

       p.j = (point.j + 2)/2 + l;
       do { if (p.j < 2) p.j += 1 << p.level; else if (p.j >= 2 + (1 << p.level)) p.j -= 1 << p.level; } while(0);





     nr += refine_cell (p, list, flag, refined);
     aparent(k,l,m).flags |= flag;
   }



  increment_neighbors (point);

  int cflag = is_active(cell) ? (active|leaf) : leaf;
  {foreach_child()
    cell.flags |= cflag;end_foreach_child()}


  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (is_local(cell) || _attribute[s.i].face)
      _attribute[s.i].refine (point, s);}}


  cell.flags &= ~leaf;

#if 1
  if (is_border(cell)) {
    {foreach_child() {
      bool bord = false;
      {foreach_neighbor() {
 if (!is_local(cell) || (level > 0 && !is_local(aparent(0,0,0)))) {
   bord = true; foreach_neighbor_break();
 }
 if (is_refined_check())
   {foreach_child()
     if (!is_local(cell)) {
       bord = true; foreach_child_break();
     }end_foreach_child()}
 if (bord)
   foreach_neighbor_break();
      }end_foreach_neighbor()}
      if (bord)
 cell.flags |= border;
    }end_foreach_child()}
    if (refined)
      cache_append (refined, point, cell.flags);
    nr++;
  }
#endif
  return nr;
}





bool coarsen_cell (Point point, scalar * list)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



  int pid = cell.pid;
  {foreach_child()
    if (cell.neighbors || (cell.pid < 0 && cell.pid != pid))
      return false;end_foreach_child()}



  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].restriction (point, s);
    if (_attribute[s.i].coarsen)
      _attribute[s.i].coarsen (point, s);
  }}}


  cell.flags |= leaf;


  decrement_neighbors (point);

#if 1
  if (!is_local(cell)) {
    cell.flags &= ~(active|border);
    {foreach_neighbor(1)
      if (cell.neighbors)
 {foreach_child()
   if (allocated(0,0,0) && is_local(cell) && !is_border(cell))
     cell.flags |= border;end_foreach_child()}end_foreach_neighbor()}
  }
#endif

  return true;
}

void coarsen_cell_recursive (Point point, scalar * list)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;


  {foreach_child()
    if (cell.neighbors)
      {foreach_neighbor(1)
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
   coarsen_cell_recursive (point, list);end_foreach_neighbor()}end_foreach_child()}

  if (!(coarsen_cell (point, list))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 148, "coarsen_cell (point, list)");
}

void mpi_boundary_refine (scalar *);
void mpi_boundary_coarsen (int, int);
void mpi_boundary_update (scalar *);

typedef struct {
  int nc, nf;
} astats;

struct Adapt {
  scalar * slist;
  double * max;
  int maxlevel;
  int minlevel;
  scalar * list;
};

     
astats adapt_wavelet (struct Adapt p)
{tracing("adapt_wavelet","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",168);
  scalar * list = p.list;

  if (is_constant(cm)) {
    if (list == NULL || list == all)
      list = list_copy (all);
    boundary_internal ((scalar *)list, "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 175);
    restriction (p.slist);
  }
  else {
    if (list == NULL || list == all) {
      list = list_copy (((scalar[]){cm, fm.x,fm.y,{-1}}));
      {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 list = list_add (list, s);}}
    }
    boundary_internal ((scalar *)list, "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 184);
    scalar * listr = list_concat (p.slist, ((scalar[]){cm,{-1}}));
    restriction (listr);
    pfree (listr,__func__,__FILE__,__LINE__);
  }

  astats st = {0, 0};
  scalar * listc = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].restriction != no_restriction)
      listc = list_add (listc, s);}}


  if (p.minlevel < 1)
    p.minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
  {foreach_cell() {
    if (is_active(cell)) {
      static const int too_coarse = 1 << (user + 2);
      if (is_leaf (cell)) {
 if (cell.flags & too_coarse) {
   cell.flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if (cell.flags & refined) {

   cell.flags &= ~too_coarse;
   continue;
 }

 bool local = is_local(cell);
 if (!local)
   {foreach_child()
     if (is_local(cell)) {
       local = true; foreach_child_break();
     }end_foreach_child()}
 if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   {scalar*_i=(scalar*)( p.slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
     double max = p.max[i++], sc[1 << 2];
     int c = 0;
     {foreach_child()
       sc[c++] = val(s,0,0,0);end_foreach_child()}
     _attribute[s.i].prolongation (point, s);
     c = 0;
     {foreach_child() {
       double e = fabs(sc[c] - val(s,0,0,0));
       if (e > max && level < p.maxlevel) {
  cell.flags &= ~too_fine;
  cell.flags |= too_coarse;
       }
       else if ((e <= max/1.5 || level > p.maxlevel) &&
         !(cell.flags & (too_coarse|just_fine))) {
  if (level >= p.minlevel)
    cell.flags |= too_fine;
       }
       else if (!(cell.flags & too_coarse)) {
  cell.flags &= ~too_fine;
  cell.flags |= just_fine;
       }
       val(s,0,0,0) = sc[c++];
     }end_foreach_child()}
   }}}
   {foreach_child() {
     cell.flags &= ~just_fine;
     if (!is_leaf(cell)) {
       cell.flags &= ~too_coarse;
       if (level >= p.maxlevel)
  cell.flags |= too_fine;
     }
     else if (!is_active(cell))
       cell.flags &= ~too_coarse;
   }end_foreach_child()}
 }
      }
    }
    else
      continue;
  }end_foreach_cell();}
  mpi_boundary_refine (listc);



  for (int l = depth(); l >= 0; l--) {
    {foreach_cell()
      if (!(cell.pid < 0)) {
 if (level == l) {
   if (!is_leaf(cell)) {
     if (cell.flags & refined)

       cell.flags &= ~(refined|too_fine);
     else if (cell.flags & too_fine) {
       if (is_local(cell) && coarsen_cell (point, listc))
  st.nc++;
       cell.flags &= ~too_fine;
     }
   }
   if (cell.flags & too_fine)
     cell.flags &= ~too_fine;
   else if (level > 0 && (aparent(0,0,0).flags & too_fine))
     aparent(0,0,0).flags &= ~too_fine;
   continue;
 }
 else if (is_leaf(cell))
   continue;
      }end_foreach_cell();}
    mpi_boundary_coarsen (l, too_fine);
  }
  pfree (listc,__func__,__FILE__,__LINE__);

  mpi_all_reduce (st.nf, MPI_INT, MPI_SUM);
  mpi_all_reduce (st.nc, MPI_INT, MPI_SUM);
  if (st.nc || st.nf)
    mpi_boundary_update (list);

  if (list != p.list)
    pfree (list,__func__,__FILE__,__LINE__);

  {end_tracing("adapt_wavelet","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",308);return st;}
end_tracing("adapt_wavelet","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",309);}
#line 331 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
static void refine_level (int depth)
{
  int refined;
  do {
    refined = 0;
    ((Tree *)grid)->refined.n = 0;
    {foreach_leaf()
      if (level < depth) {
 refine_cell (point, NULL, 0, &((Tree *)grid)->refined);
 refined++;
 continue;
      }end_foreach_leaf();}
    mpi_all_reduce (refined, MPI_INT, MPI_SUM);
    if (refined) {
      mpi_boundary_refine (NULL);
      mpi_boundary_update (NULL);
    }
  } while (refined);
}
#line 376 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
     
static void halo_face (vectorl vl)
{tracing("halo_face","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",377);
  
    {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
    
#line 380
{scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}

  for (int l = depth() - 1; l >= 0; l--)
    {foreach_halo (prolongation, l)
      {
        if (vl.x) {
#line 395 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
   if ((!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = (fine(s,0,0,0) + fine(s,0,1,0))/2.;}}
   if ((!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,1,0,0) = (fine(s,2,0,0) + fine(s,2,1,0))/2.;}}
#line 411 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
 }
        
#line 386
if (vl.y) {
#line 395 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
   if ((!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = (fine(s,0,0,0) + fine(s,1,0,0))/2.;}}
   if ((!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,1,0) = (fine(s,0,2,0) + fine(s,1,2,0))/2.;}}
#line 411 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
 }}end_foreach_halo();}
end_tracing("halo_face","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",412);}



static scalar tree_init_scalar (scalar s, const char * name)
{
  s = multigrid_init_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation;
  return s;
}

static void prolongation_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  fine(s,1,1,0) = (val(s,0,0,0) + val(s,1,0,0) + val(s,0,1,0) + val(s,1,1,0))/4.;





  for (int i = 0; i <= 1; i++) {
    for (int j = 0; j <= 1; j++)





      if (allocated_child(2*i,2*j,0))
 fine(s,2*i,2*j,0) = val(s,i,j,0);


    
      if (neighbor(i,0,0).neighbors) {

 fine(s,2*i,1,0) = (val(s,i,0,0) + val(s,i,1,0))/2.;
#line 456 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
      }
      
#line 444
if (neighbor(0,i,0).neighbors) {

 fine(s,1,2*i,0) = (val(s,0,i,0) + val(s,1,i,0))/2.;
#line 456 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
      }
  }
}

static scalar tree_init_vertex_scalar (scalar s, const char * name)
{
  s = multigrid_init_vertex_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation = prolongation_vertex;
  return s;
}


static void refine_face_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector v = _attribute[s.i].v;

  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) &&
      (is_local(cell) || is_local(neighbor(-1,0,0)))) {
    double g1 = (val(v.x,0,+1,0) - val(v.x,0,-1,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.x,0,j,0) = val(v.x,0,0,0) + (2*j - 1)*g1;
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors &&
      (is_local(cell) || is_local(neighbor(1,0,0)))) {
    double g1 = (val(v.x,1,+1,0) - val(v.x,1,-1,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.x,2,j,0) = val(v.x,1,0,0) + (2*j - 1)*g1;
  }
  if (is_local(cell)) {
    double g1 = (val(v.x,0,+1,0) - val(v.x,0,-1,0) + val(v.x,1,+1,0) - val(v.x,1,-1,0))/16.;
    for (int j = 0; j <= 1; j++)
      fine(v.x,1,j,0) = (val(v.x,0,0,0) + val(v.x,1,0,0))/2. + (2*j - 1)*g1;
  }
#line 514 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
}

#line 468
static void refine_face_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector v = _attribute[s.i].v;

  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) &&
      (is_local(cell) || is_local(neighbor(0,-1,0)))) {
    double g1 = (val(v.y,+1,0,0) - val(v.y,-1,0,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.y,j,0,0) = val(v.y,0,0,0) + (2*j - 1)*g1;
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors &&
      (is_local(cell) || is_local(neighbor(0,1,0)))) {
    double g1 = (val(v.y,+1,1,0) - val(v.y,-1,1,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.y,j,2,0) = val(v.y,0,1,0) + (2*j - 1)*g1;
  }
  if (is_local(cell)) {
    double g1 = (val(v.y,+1,0,0) - val(v.y,-1,0,0) + val(v.y,+1,1,0) - val(v.y,-1,1,0))/16.;
    for (int j = 0; j <= 1; j++)
      fine(v.y,j,1,0) = (val(v.y,0,0,0) + val(v.y,0,1,0))/2. + (2*j - 1)*g1;
  }
#line 514 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
}

void refine_face (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector v = _attribute[s.i].v;
  
    _attribute[v.x.i].prolongation (point, v.x);
    
#line 520
_attribute[v.y.i].prolongation (point, v.y);
}

void refine_face_solenoidal (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  refine_face (point, s);

  if (is_local(cell)) {

    vector v = _attribute[s.i].v;
    double d[1 << 2], p[1 << 2];
    int i = 0;
    {foreach_child() {
      d[i] = 0.;
      
 d[i] += val(v.x,1,0,0) - val(v.x,0,0,0);
 
#line 535
d[i] += val(v.y,0,1,0) - val(v.y,0,0,0);
      i++;
    }end_foreach_child()}

    p[0] = 0.;
    p[1] = (3.*d[3] + d[0])/4. + d[2]/2.;
    p[2] = (d[3] + 3.*d[0])/4. + d[2]/2.;
    p[3] = (d[3] + d[0])/2. + d[2];
    fine(v.x,1,1,0) += p[1] - p[0];
    fine(v.x,1,0,0) += p[3] - p[2];
    fine(v.y,0,1,0) += p[0] - p[2];
    fine(v.y,1,1,0) += p[1] - p[3];
#line 574 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
  }

}

vector tree_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  
    _attribute[v.x.i].restriction = _attribute[v.x.i].refine = no_restriction;
    
#line 582
_attribute[v.y.i].restriction = _attribute[v.y.i].refine = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  _attribute[v.x.i].refine = refine_face;
  
    _attribute[v.x.i].prolongation = refine_face_x;
    
#line 586
_attribute[v.y.i].prolongation = refine_face_y;
  return v;
}

     
static void tree_boundary_level (scalar * list, int l)
{tracing("tree_boundary_level","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",591);
  int depth = l < 0 ? depth() : l;

  if (tree_is_full()) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, depth); };
    {end_tracing("tree_boundary_level","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",597);return;}
  }

  scalar * listdef = NULL, * listc = NULL, * list2 = NULL, * vlist = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s)) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);
     
#line 611
list2 = list_add (list2, _attribute[s.i].v.y);}
 else {
   list2 = list_add (list2, s);
   if (_attribute[s.i].restriction == restriction_vertex)
     vlist = list_add (vlist, s);
 }
      }
    }}}

  if (vlist)






    {foreach_vertex () {
      if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) || (!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) ||
   (!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) || (!is_leaf (neighbor(-1,-1,0)) && neighbor(-1,-1,0).neighbors && neighbor(-1,-1,0).pid >= 0)) {

 {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   val(s,0,0,0) = is_vertex (child(0,0,0)) ? fine(s,0,0,0) : HUGE;}}
      }
      else
 {
   if (child.y == 1 &&
       ((!is_leaf(cell) && !cell.neighbors && cell.pid >= 0) || (!is_leaf(neighbor(-1,0,0)) && !neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))) {

     {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = is_vertex(neighbor(0,-1,0)) && is_vertex(neighbor(0,1,0)) ?
  (val(s,0,-1,0) + val(s,0,1,0))/2. : HUGE;}}
   }
   
#line 636
if (child.x == 1 &&
       ((!is_leaf(cell) && !cell.neighbors && cell.pid >= 0) || (!is_leaf(neighbor(0,-1,0)) && !neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))) {

     {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = is_vertex(neighbor(-1,0,0)) && is_vertex(neighbor(1,0,0)) ?
  (val(s,-1,0,0) + val(s,1,0,0))/2. : HUGE;}}
   }}
    }end_foreach_vertex();}
#line 676 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h"
  pfree (vlist,__func__,__FILE__,__LINE__);

  if (listdef || listc) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, depth); };
    for (int l = depth - 1; l >= 0; l--) {
      {foreach_coarse_level(l) {
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   _attribute[s.i].restriction (point, s);}}
      }end_foreach_coarse_level();}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, l); };
    }
    pfree (listdef,__func__,__FILE__,__LINE__);
    pfree (listc,__func__,__FILE__,__LINE__);
    pfree (list2,__func__,__FILE__,__LINE__);
  }

  scalar * listr = NULL;
  vector * listf = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else
 listr = list_add (listr, s);
    }}}

  if (listr || listf) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, 0); };
    for (int i = 0; i < depth; i++) {
      {foreach_halo (prolongation, i) {
 {scalar*_i=(scalar*)( listr);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
          _attribute[s.i].prolongation (point, s);}}
 {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
   {
     _attribute[v.x.i].prolongation (point, v.x);
     
#line 712
_attribute[v.y.i].prolongation (point, v.y);}}}
      }end_foreach_halo();}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, i + 1); };
    }
    pfree (listr,__func__,__FILE__,__LINE__);
    pfree (listf,__func__,__FILE__,__LINE__);
  }
end_tracing("tree_boundary_level","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",719);}

double treex (Point point) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (level == 0)
    return 0;

  double i = 2*child.x - child.y;
  if (i <= 1 && i >= -1) i = -i;




  return treex(parent) + i/(1 << 2*(level - 1));
}

double treey (Point point) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (level == 0)
    return 0;
  return treey(parent) + 4./(1 << 2*(level - 1));
}

void output_tree (FILE * fp)
{
  {foreach_cell()
    if (cell.neighbors)
      {foreach_child()
 if (is_local(cell))
   fprintf (fp, "%g %g\n%g %g\n\n",
     treex(parent), treey(parent), treex(point), treey(point));end_foreach_child()}end_foreach_cell();}
}

     
void tree_check()
{tracing("tree_check","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",751);


  long nleaves = 0, nactive = 0;
  {foreach_cell_all() {
    if (is_leaf(cell)) {
      if (!(cell.pid >= 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 758, "cell.pid >= 0");
      nleaves++;
    }
    if (is_local(cell))
      if (!(is_active(cell) || (!is_leaf(cell) && !cell.neighbors && cell.pid >= 0))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 762, "is_active(cell) || is_prolongation(cell)");
    if (is_active(cell))
      nactive++;

    int neighbors = 0;
    {foreach_neighbor(1)
      if (allocated(0,0,0) && (!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
 neighbors++;end_foreach_neighbor()}
    if (!(cell.neighbors == neighbors)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 770, "cell.neighbors == neighbors");


    if (!cell.neighbors)
      if (!(!allocated_child(0,0,0))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 774, "!allocated_child(0)");
  }end_foreach_cell_all();}


  long reachable = 0;
  {foreach_cell() {
    if (is_active(cell))
      reachable++;
    else
      continue;
  }end_foreach_cell();}
  if (!(nactive == reachable)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 785, "nactive == reachable");


  reachable = 0;
  {foreach_cell()
    if (is_leaf(cell)) {
      reachable++;
      continue;
    }end_foreach_cell();}
  if (!(nleaves == reachable)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 794, "nleaves == reachable");
end_tracing("tree_check","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",795);}

     
static void tree_restriction (scalar * list) {tracing("tree_restriction","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",798);
  boundary_internal ((scalar *)list, "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h", 799);
  if (tree_is_full())
    multigrid_restriction (list);
end_tracing("tree_restriction","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-common.h",802);}

void tree_methods()
{
  multigrid_methods();
  init_scalar = tree_init_scalar;
  init_vertex_scalar = tree_init_vertex_scalar;
  init_face_vector = tree_init_face_vector;
  boundary_level = tree_boundary_level;
  boundary_face = halo_face;
  restriction = tree_restriction;
}
#line 1672 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"


void tree_periodic (int dir)
{
  int depth = grid ? depth() : -1;
  if (grid)
    free_grid();
  periodic (dir);
  if (depth >= 0)
    init_grid (1 << depth);
}


#if 1
#line 1 "grid/tree-mpi.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"

int debug_iteration = -1;

void debug_mpi (FILE * fp1);

typedef struct {
  CacheLevel * halo;
  void * buf;
  MPI_Request r;
  int depth;
  int pid;
  int maxdepth;
} Rcv;

typedef struct {
  Rcv * rcv;
  char * name;
  int npid;
} RcvPid;

typedef struct {
  RcvPid * rcv, * snd;
} SndRcv;

typedef struct {
  Boundary parent;

  SndRcv mpi_level, mpi_level_root, restriction;
  Array * send, * receive;
} MpiBoundary;

static void cache_level_init (CacheLevel * c)
{
  c->p = NULL;
  c->n = c->nm = 0;
}

static void rcv_append (Point point, Rcv * rcv)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (level > rcv->depth) {
    rcv->halo = (CacheLevel *) prealloc (rcv->halo, (level + 1)*sizeof(CacheLevel),__func__,__FILE__,__LINE__);
    for (int j = rcv->depth + 1; j <= level; j++)
      cache_level_init (&rcv->halo[j]);
    rcv->depth = level;
  }
  cache_level_append (&rcv->halo[level], point);
  if (level > rcv->maxdepth)
    rcv->maxdepth = level;
}

void rcv_print (Rcv * rcv, FILE * fp, const char * prefix)
{
  for (int l = 0; l <= rcv->depth; l++)
    if (rcv->halo[l].n > 0)
      {foreach_cache_level(rcv->halo[l], l)
 fprintf (fp, "%s%g %g %g %d %d\n", prefix, x, y, z, rcv->pid, level);end_foreach_cache_level();}
}

static void rcv_free_buf (Rcv * rcv)
{
  if (rcv->buf) {
    prof_start ("rcv_pid_receive");
    MPI_Wait (&rcv->r, MPI_STATUS_IGNORE);
    pfree (rcv->buf,__func__,__FILE__,__LINE__);
    rcv->buf = NULL;
    prof_stop();
  }
}

static void rcv_destroy (Rcv * rcv)
{
  rcv_free_buf (rcv);
  for (int i = 0; i <= rcv->depth; i++)
    if (rcv->halo[i].n > 0)
      pfree (rcv->halo[i].p,__func__,__FILE__,__LINE__);
  pfree (rcv->halo,__func__,__FILE__,__LINE__);
}

static RcvPid * rcv_pid_new (const char * name)
{
  RcvPid * r = ((RcvPid *) pcalloc (1, sizeof(RcvPid),__func__,__FILE__,__LINE__));
  r->name = pstrdup (name,__func__,__FILE__,__LINE__);
  return r;
}

static Rcv * rcv_pid_pointer (RcvPid * p, int pid)
{
  if (!(pid >= 0 && pid < npe())) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 88, "pid >= 0 && pid < npe()");

  int i;
  for (i = 0; i < p->npid; i++)
    if (pid == p->rcv[i].pid)
      break;

  if (i == p->npid) {
    p->rcv = (Rcv *) prealloc (p->rcv, (++p->npid)*sizeof(Rcv),__func__,__FILE__,__LINE__);
    Rcv * rcv = &p->rcv[p->npid-1];
    rcv->pid = pid;
    rcv->depth = rcv->maxdepth = 0;
    rcv->halo = ((CacheLevel *) pmalloc ((1)*sizeof(CacheLevel),__func__,__FILE__,__LINE__));
    rcv->buf = NULL;
    cache_level_init (&rcv->halo[0]);
  }
  return &p->rcv[i];
}

static void rcv_pid_append (RcvPid * p, int pid, Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  rcv_append (point, rcv_pid_pointer (p, pid));
}

static void rcv_pid_append_pids (RcvPid * p, Array * pids)
{

  for (int i = 0; i < p->npid; i++) {
    int pid = p->rcv[i].pid, j, * a;
    for (j = 0, a = pids->p; j < pids->len/sizeof(int); j++,a++)
      if (*a == pid)
 break;
    if (j == pids->len/sizeof(int))
      array_append (pids, &pid, sizeof(int));
  }
}

void rcv_pid_write (RcvPid * p, const char * name)
{
  for (int i = 0; i < p->npid; i++) {
    Rcv * rcv = &p->rcv[i];
    char fname[80];
    sprintf (fname, "%s-%d-%d", name, pid(), rcv->pid);
    FILE * fp = fopen (fname, "w");
    rcv_print (rcv, fp, "");
    fclose (fp);
  }
}

static void rcv_pid_print (RcvPid * p, FILE * fp, const char * prefix)
{
  for (int i = 0; i < p->npid; i++)
    rcv_print (&p->rcv[i], fp, prefix);
}

static void rcv_pid_destroy (RcvPid * p)
{
  for (int i = 0; i < p->npid; i++)
    rcv_destroy (&p->rcv[i]);
  pfree (p->rcv,__func__,__FILE__,__LINE__);
  pfree (p->name,__func__,__FILE__,__LINE__);
  pfree (p,__func__,__FILE__,__LINE__);
}

static Boundary * mpi_boundary = NULL;






void debug_mpi (FILE * fp1);

static void apply_bc (Rcv * rcv, scalar * list, scalar * listv,
        vector * listf, int l, MPI_Status s)
{
  double * b = rcv->buf;
  {foreach_cache_level(rcv->halo[l], l) {
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      memcpy (&val(s,0,0,0), b, sizeof(double)*_attribute[s.i].block);
      b += _attribute[s.i].block;
    }}}
    {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      { {
 memcpy (&val(v.x,0,0,0), b, sizeof(double)*_attribute[v.x.i].block);
 b += _attribute[v.x.i].block;
 if (*b != HUGE && allocated(1,0,0))
   memcpy (&val(v.x,1,0,0), b, sizeof(double)*_attribute[v.x.i].block);
 b += _attribute[v.x.i].block;
      } 
#line 171
{
 memcpy (&val(v.y,0,0,0), b, sizeof(double)*_attribute[v.y.i].block);
 b += _attribute[v.y.i].block;
 if (*b != HUGE && allocated(0,1,0))
   memcpy (&val(v.y,0,1,0), b, sizeof(double)*_attribute[v.y.i].block);
 b += _attribute[v.y.i].block;
      }}}}
    {scalar*_i=(scalar*)( listv);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)







          {
     if (*b != HUGE && allocated(i,j,0))
       memcpy (&val(s,i,j,0), b, sizeof(double)*_attribute[s.i].block);
     b += _attribute[s.i].block;
          }

    }}}
  }end_foreach_cache_level();}
  size_t size = b - (double *) rcv->buf;
  pfree (rcv->buf,__func__,__FILE__,__LINE__);
  rcv->buf = NULL;

  int rlen;
  MPI_Get_count (&s, MPI_DOUBLE, &rlen);
  if (rlen != size) {
    fprintf (ferr,
      "rlen (%d) != size (%ld), %d receiving from %d at level %d\n"
      "Calling debug_mpi(NULL)...\n"
      "Aborting...\n",
      rlen, size, pid(), rcv->pid, l);
    fflush (ferr);
    debug_mpi (NULL);
    MPI_Abort (MPI_COMM_WORLD, -2);
  }
}
#line 234 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"
static void mpi_recv_check (void * buf, int count, MPI_Datatype datatype,
       int source, int tag,
       MPI_Comm comm, MPI_Status * status,
       const char * name)
{
#line 269 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"
  int errorcode = MPI_Recv (buf, count, datatype, source, tag, comm, status);
  if (errorcode != MPI_SUCCESS) {
    char string[MPI_MAX_ERROR_STRING];
    int resultlen;
    MPI_Error_string (errorcode, string, &resultlen);
    fprintf (ferr,
      "ERROR MPI_Recv \"%s\" (count = %d, source = %d, tag = %d):\n%s\n"
      "Calling debug_mpi(NULL)...\n"
      "Aborting...\n",
      name, count, source, tag, string);
    fflush (ferr);
    debug_mpi (NULL);
    MPI_Abort (MPI_COMM_WORLD, -1);
  }





}

     
static int mpi_waitany (int count, MPI_Request array_of_requests[], int *indx,
   MPI_Status *status)
{tracing("mpi_waitany","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",291);
  { int _ret= MPI_Waitany (count, array_of_requests, indx, status);end_tracing("mpi_waitany","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",294);return _ret;}
end_tracing("mpi_waitany","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",295);}

static int list_lenb (scalar * list) {
  int len = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    len += _attribute[s.i].block;}}
  return len;
}

static int vectors_lenb (vector * list) {
  int len = 0;
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
    len += _attribute[v.x.i].block;}}
  return len;
}

static void rcv_pid_receive (RcvPid * m, scalar * list, scalar * listv,
        vector * listf, int l)
{
  if (m->npid == 0)
    return;

  prof_start ("rcv_pid_receive");

  int len = list_lenb (list) + 2*2*vectors_lenb (listf) +
    (1 << 2)*list_lenb (listv);

  MPI_Request r[m->npid];
  Rcv * rrcv[m->npid];
  int nr = 0;
  for (int i = 0; i < m->npid; i++) {
    Rcv * rcv = &m->rcv[i];
    if (l <= rcv->depth && rcv->halo[l].n > 0) {
      if (!(!rcv->buf)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 328, "!rcv->buf");
      rcv->buf = pmalloc (sizeof (double)*rcv->halo[l].n*len,__func__,__FILE__,__LINE__);






      MPI_Irecv (rcv->buf, rcv->halo[l].n*len, MPI_DOUBLE, rcv->pid,
   (l), MPI_COMM_WORLD, &r[nr]);
      rrcv[nr++] = rcv;






    }
  }


  if (nr > 0) {
    int i;
    MPI_Status s;
    mpi_waitany (nr, r, &i, &s);
    while (i != MPI_UNDEFINED) {
      Rcv * rcv = rrcv[i];
      if (!(l <= rcv->depth && rcv->halo[l].n > 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 355, "l <= rcv->depth && rcv->halo[l].n > 0");
      if (!(rcv->buf)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 356, "rcv->buf");
      apply_bc (rcv, list, listv, listf, l, s);
      mpi_waitany (nr, r, &i, &s);
    }
  }

  prof_stop();
}

     
static void rcv_pid_wait (RcvPid * m)
{tracing("rcv_pid_wait","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",366);

  for (int i = 0; i < m->npid; i++)
    rcv_free_buf (&m->rcv[i]);
end_tracing("rcv_pid_wait","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",371);}

static void rcv_pid_send (RcvPid * m, scalar * list, scalar * listv,
     vector * listf, int l)
{
  if (m->npid == 0)
    return;

  prof_start ("rcv_pid_send");

  int len = list_lenb (list) + 2*2*vectors_lenb (listf) +
    (1 << 2)*list_lenb (listv);


  for (int i = 0; i < m->npid; i++) {
    Rcv * rcv = &m->rcv[i];
    if (l <= rcv->depth && rcv->halo[l].n > 0) {
      if (!(!rcv->buf)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 388, "!rcv->buf");
      rcv->buf = pmalloc (sizeof (double)*rcv->halo[l].n*len,__func__,__FILE__,__LINE__);
      double * b = rcv->buf;
      {foreach_cache_level(rcv->halo[l], l) {
 {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
   memcpy (b, &val(s,0,0,0), sizeof(double)*_attribute[s.i].block);
   b += _attribute[s.i].block;
 }}}
 {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
   { {
     memcpy (b, &val(v.x,0,0,0), sizeof(double)*_attribute[v.x.i].block);
     b += _attribute[v.x.i].block;
     if (allocated(1,0,0))
       memcpy (b, &val(v.x,1,0,0), sizeof(double)*_attribute[v.x.i].block);
     else
       *b = HUGE;
     b += _attribute[v.x.i].block;
   } 
#line 397
{
     memcpy (b, &val(v.y,0,0,0), sizeof(double)*_attribute[v.y.i].block);
     b += _attribute[v.y.i].block;
     if (allocated(0,1,0))
       memcpy (b, &val(v.y,0,1,0), sizeof(double)*_attribute[v.y.i].block);
     else
       *b = HUGE;
     b += _attribute[v.y.i].block;
   }}}}
 {scalar*_i=(scalar*)( listv);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
   for (int i = 0; i <= 1; i++)
     for (int j = 0; j <= 1; j++)
#line 418 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"
       {
  if (allocated(i,j,0))
    memcpy (b, &val(s,i,j,0), sizeof(double)*_attribute[s.i].block);
  else
    *b = HUGE;
  b += _attribute[s.i].block;
       }

 }}}
      }end_foreach_cache_level();}





      MPI_Isend (rcv->buf, (b - (double *) rcv->buf),
   MPI_DOUBLE, rcv->pid, (l), MPI_COMM_WORLD,
   &rcv->r);
    }
  }

  prof_stop();
}

static void rcv_pid_sync (SndRcv * m, scalar * list, int l)
{
  scalar * listr = NULL, * listv = NULL;
  vector * listf = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else if (_attribute[s.i].restriction == restriction_vertex)
 listv = list_add (listv, s);
      else
 listr = list_add (listr, s);
    }}}
  rcv_pid_send (m->snd, listr, listv, listf, l);
  rcv_pid_receive (m->rcv, listr, listv, listf, l);
  rcv_pid_wait (m->snd);
  pfree (listr,__func__,__FILE__,__LINE__);
  pfree (listf,__func__,__FILE__,__LINE__);
  pfree (listv,__func__,__FILE__,__LINE__);
}

static void snd_rcv_destroy (SndRcv * m)
{
  rcv_pid_destroy (m->rcv);
  rcv_pid_destroy (m->snd);
}

static void snd_rcv_init (SndRcv * m, const char * name)
{
  char s[strlen(name) + 5];
  strcpy (s, name);
  strcat (s, ".rcv");
  m->rcv = rcv_pid_new (s);
  strcpy (s, name);
  strcat (s, ".snd");
  m->snd = rcv_pid_new (s);
}

static void mpi_boundary_destroy (Boundary * b)
{
  MpiBoundary * m = (MpiBoundary *) b;
  snd_rcv_destroy (&m->mpi_level);
  snd_rcv_destroy (&m->mpi_level_root);
  snd_rcv_destroy (&m->restriction);
  array_free (m->send);
  array_free (m->receive);
  pfree (m,__func__,__FILE__,__LINE__);
}

     
static void mpi_boundary_level (const Boundary * b, scalar * list, int l)
{tracing("mpi_boundary_level","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",492);
  MpiBoundary * m = (MpiBoundary *) b;
  rcv_pid_sync (&m->mpi_level, list, l);
  rcv_pid_sync (&m->mpi_level_root, list, l);
end_tracing("mpi_boundary_level","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",497);}

     
static void mpi_boundary_restriction (const Boundary * b, scalar * list, int l)
{tracing("mpi_boundary_restriction","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",500);
  MpiBoundary * m = (MpiBoundary *) b;
  rcv_pid_sync (&m->restriction, list, l);
end_tracing("mpi_boundary_restriction","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",504);}

void mpi_boundary_new()
{
  mpi_boundary = (Boundary *) ((MpiBoundary *) pcalloc (1, sizeof(MpiBoundary),__func__,__FILE__,__LINE__));
  mpi_boundary->destroy = mpi_boundary_destroy;
  mpi_boundary->level = mpi_boundary_level;
  mpi_boundary->restriction = mpi_boundary_restriction;
  MpiBoundary * mpi = (MpiBoundary *) mpi_boundary;
  snd_rcv_init (&mpi->mpi_level, "mpi_level");
  snd_rcv_init (&mpi->mpi_level_root, "mpi_level_root");
  snd_rcv_init (&mpi->restriction, "restriction");
  mpi->send = array_new();
  mpi->receive = array_new();
  add_boundary (mpi_boundary);
}

static FILE * fopen_prefix (FILE * fp, const char * name, char * prefix)
{
  if (fp) {
    sprintf (prefix, "%s-%d ", name, pid());
    return fp;
  }
  else {
    strcpy (prefix, "");
    char fname[80];
    if (debug_iteration >= 0)
      sprintf (fname, "%s-%d-%d", name, debug_iteration, pid());
    else
      sprintf (fname, "%s-%d", name, pid());
    return fopen (fname, "w");
  }
}

void debug_mpi (FILE * fp1)
{
  void output_cells_internal (FILE * fp);

  char prefix[80];
  FILE * fp;


  if (fp1 == NULL) {
    char name[80];
    sprintf (name, "halo-%d", pid()); remove (name);
    sprintf (name, "cells-%d", pid()); remove (name);
    sprintf (name, "faces-%d", pid()); remove (name);
    sprintf (name, "vertices-%d", pid()); remove (name);
    sprintf (name, "neighbors-%d", pid()); remove (name);
    sprintf (name, "mpi-level-rcv-%d", pid()); remove (name);
    sprintf (name, "mpi-level-snd-%d", pid()); remove (name);
    sprintf (name, "mpi-level-root-rcv-%d", pid()); remove (name);
    sprintf (name, "mpi-level-root-snd-%d", pid()); remove (name);
    sprintf (name, "mpi-restriction-rcv-%d", pid()); remove (name);
    sprintf (name, "mpi-restriction-snd-%d", pid()); remove (name);
    sprintf (name, "mpi-border-%d", pid()); remove (name);
    sprintf (name, "exterior-%d", pid()); remove (name);
    sprintf (name, "depth-%d", pid()); remove (name);
    sprintf (name, "refined-%d", pid()); remove (name);
  }


  fp = fopen_prefix (fp1, "halo", prefix);
  for (int l = 0; l < depth(); l++)
    {foreach_halo (prolongation, l)
      {foreach_child()
        fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);end_foreach_child()}end_foreach_halo();}
  if (!fp1)
    fclose (fp);

  if (!fp1) {
    fp = fopen_prefix (fp1, "cells", prefix);
    output_cells_internal (fp);
    fclose (fp);
  }

  fp = fopen_prefix (fp1, "faces", prefix);
  {foreach_face_generic(){is_face_x(){
    fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);}end_is_face_x()
#line 581
is_face_y(){
    fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);}end_is_face_y()}end_foreach_face_generic();}
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "vertices", prefix);
  {foreach_vertex()
    fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);end_foreach_vertex();}
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "neighbors", prefix);
  {foreach() {
    int n = 0;
    {foreach_neighbor(1)
      if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
 n++;end_foreach_neighbor()}
    fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, cell.neighbors);
    if (!(cell.neighbors == n)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 599, "cell.neighbors == n");
  }end_foreach();}
  if (!fp1)
    fclose (fp);

  MpiBoundary * mpi = (MpiBoundary *) mpi_boundary;

  fp = fopen_prefix (fp1, "mpi-level-rcv", prefix);
  rcv_pid_print (mpi->mpi_level.rcv, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-level-root-rcv", prefix);
  rcv_pid_print (mpi->mpi_level_root.rcv, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-restriction-rcv", prefix);
  rcv_pid_print (mpi->restriction.rcv, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-level-snd", prefix);
  rcv_pid_print (mpi->mpi_level.snd, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-level-root-snd", prefix);
  rcv_pid_print (mpi->mpi_level_root.snd, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-restriction-snd", prefix);
  rcv_pid_print (mpi->restriction.snd, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-border", prefix);
  {foreach_cell() {
    if (is_border(cell))
      fprintf (fp, "%s%g %g %g %d %d %d\n",
        prefix, x, y, z, level, cell.neighbors, cell.pid);
    else
      continue;
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "exterior", prefix);
  {foreach_cell() {
    if (!is_local(cell))
      fprintf (fp, "%s%g %g %g %d %d %d %d\n",
        prefix, x, y, z, level, cell.neighbors,
        cell.pid, cell.flags & leaf);






  }end_foreach_cell();}
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "depth", prefix);
  fprintf (fp, "depth: %d %d\n", pid(), depth());
  fprintf (fp, "======= mpi_level.snd ======\n");
  RcvPid * snd = mpi->mpi_level.snd;
  for (int i = 0; i < snd->npid; i++)
    fprintf (fp, "%d %d %d\n", pid(), snd->rcv[i].pid, snd->rcv[i].maxdepth);
  fprintf (fp, "======= mpi_level.rcv ======\n");
  snd = mpi->mpi_level.rcv;
  for (int i = 0; i < snd->npid; i++)
    fprintf (fp, "%d %d %d\n", pid(), snd->rcv[i].pid, snd->rcv[i].maxdepth);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "refined", prefix);
  {foreach_cache (((Tree *)grid)->refined)
    fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);end_foreach_cache();}
  if (!fp1)
    fclose (fp);
}

static void snd_rcv_free (SndRcv * p)
{
  char name[strlen(p->rcv->name) + 1];
  strcpy (name, p->rcv->name);
  rcv_pid_destroy (p->rcv);
  p->rcv = rcv_pid_new (name);
  strcpy (name, p->snd->name);
  rcv_pid_destroy (p->snd);
  p->snd = rcv_pid_new (name);
}

static bool is_root (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
    {foreach_child()
      if (is_local(cell))
 return true;end_foreach_child()}
  return false;
}


static bool is_local_prolongation (Point point, Point p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  struct { int x, y; } dp = {p.i - point.i, p.j - point.j};



   {
    if (dp.x == 0 && ((!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) || (!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0)))
      return true;
    if ((!is_leaf (neighbor(dp.x,0,0)) && neighbor(dp.x,0,0).neighbors && neighbor(dp.x,0,0).pid >= 0))
      return true;
  } 
#line 713
{
    if (dp.y == 0 && ((!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) || (!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0)))
      return true;
    if ((!is_leaf (neighbor(0,dp.y,0)) && neighbor(0,dp.y,0).neighbors && neighbor(0,dp.y,0).pid >= 0))
      return true;
  }
  return false;
}



static void append_pid (Array * pids, int pid)
{
  for (int i = 0, * p = (int *) pids->p; i < pids->len/sizeof(int); i++, p++)
    if (*p == pid)
      return;
  array_append (pids, &pid, sizeof(int));
}

static int locals_pids (Point point, Array * pids)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (is_leaf(cell)) {
    if (is_local(cell)) {
      Point p = point;
      {foreach_neighbor(1) {
 if ((cell.pid >= 0 && cell.pid != pid()) &&
     ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) || is_local_prolongation (point, p)))
   append_pid (pids, cell.pid);
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
   {foreach_child()
     if ((cell.pid >= 0 && cell.pid != pid()))
       append_pid (pids, cell.pid);end_foreach_child()}
      }end_foreach_neighbor()}
    }
  }
  else
    {foreach_neighbor(1) {
      if ((cell.pid >= 0 && cell.pid != pid()))
 append_pid (pids, cell.pid);
      if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
 {foreach_child()
   if ((cell.pid >= 0 && cell.pid != pid()))
     append_pid (pids, cell.pid);end_foreach_child()}
    }end_foreach_neighbor()}
  return pids->len/sizeof(int);
}

static int root_pids (Point point, Array * pids)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    if ((cell.pid >= 0 && cell.pid != pid()))
      append_pid (pids, cell.pid);end_foreach_child()}
  return pids->len/sizeof(int);
}







static void rcv_pid_row (RcvPid * m, int l, int * row)
{
  for (int i = 0; i < npe(); i++)
    row[i] = 0;
  for (int i = 0; i < m->npid; i++) {
    Rcv * rcv = &m->rcv[i];
    if (l <= rcv->depth && rcv->halo[l].n > 0)
      row[rcv->pid] = rcv->halo[l].n;
  }
}

void check_snd_rcv_matrix (SndRcv * sndrcv, const char * name)
{
  int maxlevel = depth();
  mpi_all_reduce (maxlevel, MPI_INT, MPI_MAX);
  int * row = ((int *) pmalloc ((npe())*sizeof(int),__func__,__FILE__,__LINE__));
  for (int l = 0; l <= maxlevel; l++) {
    int status = 0;
    if (pid() == 0) {


      int ** send = matrix_new (npe(), npe(), sizeof(int));
      int ** receive = matrix_new (npe(), npe(), sizeof(int));
      rcv_pid_row (sndrcv->snd, l, row);
      MPI_Gather (row, npe(), MPI_INT, &send[0][0], npe(), MPI_INT, 0,
    MPI_COMM_WORLD);
      rcv_pid_row (sndrcv->rcv, l, row);
      MPI_Gather (row, npe(), MPI_INT, &receive[0][0], npe(), MPI_INT, 0,
    MPI_COMM_WORLD);

      int * astatus = ((int *) pmalloc ((npe())*sizeof(int),__func__,__FILE__,__LINE__));
      for (int i = 0; i < npe(); i++)
 astatus[i] = 0;
      for (int i = 0; i < npe(); i++)
 for (int j = 0; j < npe(); j++)
   if (send[i][j] != receive[j][i]) {
     fprintf (ferr, "%s: %d sends    %d to   %d at level %d\n",
       name, i, send[i][j], j, l);
     fprintf (ferr, "%s: %d receives %d from %d at level %d\n",
       name, j, receive[j][i], i, l);
     fflush (ferr);
     for (int k = i - 2; k <= i + 2; k++)
       if (k >= 0 && k < npe())
  astatus[k] = 1;
     for (int k = j - 2; k <= j + 2; k++)
       if (k >= 0 && k < npe())
  astatus[k] = 1;
   }
      MPI_Scatter (astatus, 1, MPI_INT, &status, 1, MPI_INT, 0, MPI_COMM_WORLD);
      pfree (astatus,__func__,__FILE__,__LINE__);

      matrix_free (send);
      matrix_free (receive);
    }
    else {
      rcv_pid_row (sndrcv->snd, l, row);
      MPI_Gather (row, npe(), MPI_INT, NULL, npe(), MPI_INT, 0, MPI_COMM_WORLD);
      rcv_pid_row (sndrcv->rcv, l, row);
      MPI_Gather (row, npe(), MPI_INT, NULL, npe(), MPI_INT, 0, MPI_COMM_WORLD);
      MPI_Scatter (NULL, 1, MPI_INT, &status, 1, MPI_INT, 0, MPI_COMM_WORLD);
    }
    if (status) {
      fprintf (ferr,
        "check_snd_rcv_matrix \"%s\" failed\n"
        "Calling debug_mpi(NULL)...\n"
        "Aborting...\n",
        name);
      fflush (ferr);
      debug_mpi (NULL);
      MPI_Abort (MPI_COMM_WORLD, -3);
    }
  }
  pfree (row,__func__,__FILE__,__LINE__);
}

static bool has_local_child (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child()
    if (is_local(cell))
      return true;end_foreach_child()}
  return false;
}

     
void mpi_boundary_update_buffers()
{tracing("mpi_boundary_update_buffers","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",858);
  if (npe() == 1)
    {end_tracing("mpi_boundary_update_buffers","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",861);return;}

  prof_start ("mpi_boundary_update_buffers");

  MpiBoundary * m = (MpiBoundary *) mpi_boundary;
  SndRcv * mpi_level = &m->mpi_level;
  SndRcv * mpi_level_root = &m->mpi_level_root;
  SndRcv * restriction = &m->restriction;

  snd_rcv_free (mpi_level);
  snd_rcv_free (mpi_level_root);
  snd_rcv_free (restriction);

  static const unsigned short used = 1 << user;
  {foreach_cell() {
    if (is_active(cell) && !is_border(cell))



      continue;

    if (cell.neighbors) {

      Array pids = {NULL, 0, 0};
      int n = locals_pids (point, &pids);
      if (n) {
 {foreach_child()
   if (is_local(cell))
     for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
       rcv_pid_append (mpi_level->snd, *p, point);end_foreach_child()}
 pfree (pids.p,__func__,__FILE__,__LINE__);
      }

      bool locals = false;
      if (is_leaf(cell)) {
 if ((cell.pid >= 0 && cell.pid != pid())) {
   Point p = point;
   {foreach_neighbor(1)
     if ((is_local(cell) &&
   ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) || is_local_prolongation (point, p))) ||
  is_root(point)) {
       locals = true; foreach_neighbor_break();
     }end_foreach_neighbor()}
 }
      }
      else
 {foreach_neighbor(1)
   if (is_local(cell) || is_root(point)) {
     locals = true; foreach_neighbor_break();
   }end_foreach_neighbor()}
      if (locals)
 {foreach_child()
   if ((cell.pid >= 0 && cell.pid != pid()))
            rcv_pid_append (mpi_level->rcv, cell.pid, point),
       cell.flags |= used;end_foreach_child()}


      if (!is_leaf(cell)) {

 if (is_local(cell)) {
   Array pids = {NULL, 0, 0};

   int n = root_pids (point, &pids);
   if (n) {
     {foreach_neighbor()
       for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
  if (cell.pid >= 0 && cell.pid != *p)
    rcv_pid_append (mpi_level_root->snd, *p, point);end_foreach_neighbor()}

     for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
       rcv_pid_append (restriction->snd, *p, point);
     pfree (pids.p,__func__,__FILE__,__LINE__);
   }
 }

 else if ((cell.pid >= 0 && cell.pid != pid())) {
   bool root = false;
   {foreach_child()
     if (is_local(cell)) {
       root = true; foreach_child_break();
     }end_foreach_child()}
   if (root) {
     int pid = cell.pid;
     {foreach_neighbor()
       if ((cell.pid >= 0 && cell.pid != pid()))
  rcv_pid_append (mpi_level_root->rcv, pid, point),
    cell.flags |= used;end_foreach_neighbor()}

     rcv_pid_append (restriction->rcv, pid, point);
   }
 }
      }
    }


    if (level > 0) {
      if (is_local(cell)) {

 Array pids = {NULL, 0, 0};
 if ((aparent(0,0,0).pid >= 0 && aparent(0,0,0).pid != pid()))
   append_pid (&pids, aparent(0,0,0).pid);
 int n = root_pids (parent, &pids);
 if (n) {
   for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
     rcv_pid_append (restriction->snd, *p, point);
   pfree (pids.p,__func__,__FILE__,__LINE__);
 }
      }
      else if ((cell.pid >= 0 && cell.pid != pid())) {

 if (is_local(aparent(0,0,0)) || has_local_child (parent))
   rcv_pid_append (restriction->rcv, cell.pid, point);
      }
    }
  }end_foreach_cell();}





  static const unsigned short keep = 1 << (user + 1);
  for (int l = depth(); l >= 0; l--)
    {foreach_cell()
      if (level == l) {
 if (level > 0 && (cell.pid < 0 || is_local(cell) || (cell.flags & used)))
   aparent(0,0,0).flags |= keep;
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) && !(cell.flags & keep))
   coarsen_cell (point, NULL);
 cell.flags &= ~(used|keep);
 continue;
      }end_foreach_cell();}


  m->send->len = m->receive->len = 0;
  rcv_pid_append_pids (mpi_level->snd, m->send);
  rcv_pid_append_pids (mpi_level_root->snd, m->send);
  rcv_pid_append_pids (mpi_level->rcv, m->receive);
  rcv_pid_append_pids (mpi_level_root->rcv, m->receive);

  prof_stop();
#line 1015 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"
end_tracing("mpi_boundary_update_buffers","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1015);}

     
void mpi_boundary_refine (scalar * list)
{tracing("mpi_boundary_refine","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1018);
  prof_start ("mpi_boundary_refine");

  MpiBoundary * mpi = (MpiBoundary *) mpi_boundary;


  Array * snd = mpi->send;
  MPI_Request r[2*snd->len/sizeof(int)];
  int nr = 0;
  for (int i = 0, * dest = snd->p; i < snd->len/sizeof(int); i++,dest++) {
    int len = ((Tree *)grid)->refined.n;
    MPI_Isend (&((Tree *)grid)->refined.n, 1, MPI_INT, *dest,
        (128), MPI_COMM_WORLD, &r[nr++]);
    if (len > 0)
      MPI_Isend (((Tree *)grid)->refined.p, sizeof(Index)/sizeof(int)*len,
   MPI_INT, *dest, (128), MPI_COMM_WORLD, &r[nr++]);
  }



  Array * rcv = mpi->receive;
  Cache rerefined = {NULL, 0, 0};
  for (int i = 0, * source = rcv->p; i < rcv->len/sizeof(int); i++,source++) {
    int len;
    mpi_recv_check (&len, 1, MPI_INT, *source, (128),
      MPI_COMM_WORLD, MPI_STATUS_IGNORE,
      "mpi_boundary_refine (len)");
    if (len > 0) {
      Index p[len];
      mpi_recv_check (p, sizeof(Index)/sizeof(int)*len,
        MPI_INT, *source, (128),
        MPI_COMM_WORLD, MPI_STATUS_IGNORE,
        "mpi_boundary_refine (p)");
      Cache refined = {p, len, len};
      {foreach_cache (refined)
 if (level <= depth() && allocated(0,0,0)) {
   if (is_leaf(cell)) {
     bool neighbors = false;
     {foreach_neighbor()
       if (allocated(0,0,0) && (is_active(cell) || is_local(aparent(0,0,0)))) {
  neighbors = true; foreach_neighbor_break();
       }end_foreach_neighbor()}

     if (neighbors)
       refine_cell (point, list, 0, &rerefined);
   }
 }end_foreach_cache();}
    }
  }


  if (nr)
    MPI_Waitall (nr, r, MPI_STATUSES_IGNORE);


  pfree (((Tree *)grid)->refined.p,__func__,__FILE__,__LINE__);
  ((Tree *)grid)->refined = rerefined;

  prof_stop();



  mpi_all_reduce (rerefined.n, MPI_INT, MPI_SUM);
  if (rerefined.n)
    mpi_boundary_refine (list);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}
end_tracing("mpi_boundary_refine","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1086);}

static void check_depth()
{
#line 1121 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"
}

typedef struct {
  int refined, leaf;
} Remote;



     
void mpi_boundary_coarsen (int l, int too_fine)
{tracing("mpi_boundary_coarsen","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1130);
  if (npe() == 1)
    {end_tracing("mpi_boundary_coarsen","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1133);return;}

  check_depth();

  if (!(sizeof(Remote) == sizeof(double))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h", 1137, "sizeof(Remote) == sizeof(double)");

  scalar  remote=new_scalar("remote");
  {foreach_cell() {
    if (level == l) {
      if (is_local(cell)) {
 ((Remote *)&val(remote,0,0,0))->refined = (!is_leaf (cell) && cell.neighbors && cell.pid >= 0);
 ((Remote *)&val(remote,0,0,0))->leaf = is_leaf(cell);
      }
      else {
 ((Remote *)&val(remote,0,0,0))->refined = true;
 ((Remote *)&val(remote,0,0,0))->leaf = false;
      }
      continue;
    }
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}
  mpi_boundary_level (mpi_boundary, ((scalar[]){remote,{-1}}), l);

  {foreach_cell() {
    if (level == l) {
      if (!is_local(cell)) {
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) && !((Remote *)&val(remote,0,0,0))->refined)
   coarsen_cell_recursive (point, NULL);
 else if (is_leaf(cell) && cell.neighbors && ((Remote *)&val(remote,0,0,0))->leaf) {
   int pid = cell.pid;
   {foreach_child()
     cell.pid = pid;end_foreach_child()}
 }
      }
      continue;
    }
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}

  check_depth();

  if (l > 0) {
    {foreach_cell() {
      if (level == l) {
 val(remote,0,0,0) = is_local(cell) ? cell.neighbors : 0;
 continue;
      }
      if (is_leaf(cell))
 continue;
    }end_foreach_cell();}
    mpi_boundary_level (mpi_boundary, ((scalar[]){remote,{-1}}), l);
    {foreach_cell() {
      if (level == l)
 if (!is_local(cell) && is_local(aparent(0,0,0)) && val(remote,0,0,0)) {
   aparent(0,0,0).flags &= ~too_fine;
   continue;
 }
      if (is_leaf(cell))
 continue;
    }end_foreach_cell();}
  }delete((scalar*)((scalar[]){remote,{-1}}));
end_tracing("mpi_boundary_coarsen","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1196);}

static void flag_border_cells()
{
  {foreach_cell() {
    if (is_active(cell)) {
      short flags = cell.flags & ~border;
      {foreach_neighbor() {
 if (!is_local(cell) || (level > 0 && !is_local(aparent(0,0,0)))) {
   flags |= border; foreach_neighbor_break();
 }

 if (is_refined_check())
   {foreach_child()
     if (!is_local(cell)) {
       flags |= border; foreach_child_break();
     }end_foreach_child()}
 if (flags & border)
   foreach_neighbor_break();
      }end_foreach_neighbor()}
      cell.flags = flags;
    }
    else {
      cell.flags &= ~border;

    }
    if (is_leaf(cell)) {
      if (cell.neighbors) {
 {foreach_child()
   cell.flags &= ~border;end_foreach_child()}
 if (is_border(cell)) {
   bool remote = false;
   {foreach_neighbor (2/2)
     if (!is_local(cell)) {
       remote = true; foreach_neighbor_break();
     }end_foreach_neighbor()}
   if (remote)
     {foreach_child()
       cell.flags |= border;end_foreach_child()}
 }
      }
      continue;
    }
  }end_foreach_cell();}
}

static int balanced_pid (long index, long nt, int nproc)
{
  long ne = max(1, nt/nproc), nr = nt % nproc;
  int pid = index < nr*(ne + 1) ?
    index/(ne + 1) :
    nr + (index - nr*(ne + 1))/ne;
  return min(nproc - 1, pid);
}


     
void mpi_partitioning()
{tracing("mpi_partitioning","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1253);
  prof_start ("mpi_partitioning");

  long nt = 0;
  
#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 1258
foreach ()
    nt++;end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif



  
#line 1262
long i = 0;
  ((Tree *)grid)->dirty = true;
  {foreach_cell_post (is_active (cell))
    if (is_active (cell)) {
      if (is_leaf (cell)) {
 cell.pid = balanced_pid (i++, nt, npe());
 if (cell.neighbors > 0) {
   int pid = cell.pid;
   {foreach_child()
     cell.pid = pid;end_foreach_child()}
 }
 if (!is_local(cell))
   cell.flags &= ~active;
      }
      else {
 cell.pid = child(0,0,0).pid;
 bool inactive = true;
 {foreach_child()
   if (is_active(cell)) {
     inactive = false; foreach_child_break();
   }end_foreach_child()}
 if (inactive)
   cell.flags &= ~active;
      }
    }end_foreach_cell_post();}

  flag_border_cells();

  prof_stop();

  mpi_boundary_update_buffers();
end_tracing("mpi_partitioning","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1293);}

void restore_mpi (FILE * fp, scalar * list1)
{
  long index = 0, nt = 0, start = ftell (fp);
  scalar  size=new_scalar("size"), * list = list_concat (((scalar[]){size,{-1}}), list1);;
  long offset = sizeof(double)*list_len(list);


  static const unsigned short set = 1 << user;
  scalar * listm = is_constant(cm) ? NULL : (scalar *)((vector[]){fm,{{-1},{-1}}});
  {foreach_cell()
    if (balanced_pid (index, nt, npe()) <= pid()) {
      unsigned flags;
      if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
 fprintf (ferr, "restore(): error: expecting 'flags'\n");
 exit (1);
      }
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 double val;
 if (fread (&val, sizeof(double), 1, fp) != 1) {
   fprintf (ferr, "restore(): error: expecting scalar\n");
   exit (1);
 }
 if (s.i != INT_MAX)
   val(s,0,0,0) = val;
      }}}
      if (level == 0)
 nt = val(size,0,0,0);
      cell.pid = balanced_pid (index, nt, npe());
      cell.flags |= set;
      if (!(flags & leaf) && is_leaf(cell)) {
 if (balanced_pid (index + val(size,0,0,0) - 1, nt, npe()) < pid()) {
   fseek (fp, (sizeof(unsigned) + offset)*(val(size,0,0,0) - 1), SEEK_CUR);
   index += val(size,0,0,0);
   continue;
 }
 refine_cell (point, listm, 0, NULL);
      }
      index++;
      if (is_leaf(cell))
 continue;
    }end_foreach_cell();}


  fseek (fp, start, SEEK_SET);
  index = 0;
  {foreach_cell() {
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (ferr, "restore(): error: expecting 'flags'\n");
      exit (1);
    }
    if (cell.flags & set)
      fseek (fp, offset, SEEK_CUR);
    else {
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 double val;
 if (fread (&val, sizeof(double), 1, fp) != 1) {
   fprintf (ferr, "restore(): error: expecting a scalar\n");
   exit (1);
 }
 if (s.i != INT_MAX)
   val(s,0,0,0) = val;
      }}}
      cell.pid = balanced_pid (index, nt, npe());
      if (is_leaf(cell) && cell.neighbors) {
 int pid = cell.pid;
 {foreach_child()
   cell.pid = pid;end_foreach_child()}
      }
    }
    if (!(flags & leaf) && is_leaf(cell)) {
      bool locals = false;
      {foreach_neighbor(1)
 if ((cell.flags & set) && (is_local(cell) || is_root(point))) {
   locals = true; foreach_neighbor_break();
 }end_foreach_neighbor()}
      if (locals)
 refine_cell (point, listm, 0, NULL);
      else {
 fseek (fp, (sizeof(unsigned) + offset)*(val(size,0,0,0) - 1), SEEK_CUR);
 index += val(size,0,0,0);
 continue;
      }
    }
    index++;
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}


  {foreach_cell_post (is_active (cell)) {
    cell.flags &= ~set;
    if (is_active (cell)) {
      if (is_leaf (cell)) {
 if (cell.neighbors > 0) {
   int pid = cell.pid;
   {foreach_child()
     cell.pid = pid;end_foreach_child()}
 }
 if (!is_local(cell))
   cell.flags &= ~active;
      }
      else if (!is_local(cell)) {
 bool inactive = true;
 {foreach_child()
   if (is_active(cell)) {
     inactive = false; foreach_child_break();
   }end_foreach_child()}
 if (inactive)
   cell.flags &= ~active;
      }
    }
  }end_foreach_cell_post();}

  flag_border_cells();

  mpi_boundary_update (list);
  pfree (list,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){size,{-1}}));
}
#line 1435 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h"
     
double z_indexing (scalar index, bool leaves)
{tracing("z_indexing","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1436);



  scalar  size=new_scalar("size");
  subtree_size (size, leaves);






  double maxi = -1.;
  if (pid() == 0)
    {foreach_level(0)
      maxi = val(size,0,0,0) - 1.;end_foreach_level();}




  {foreach_level(0)
    val(index,0,0,0) = 0;end_foreach_level();}
  for (int l = 0; l < depth(); l++) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar[]){index,{-1}}), l); };
    {foreach_cell() {
      if (level == l) {
 if (is_leaf(cell)) {
   if (is_local(cell) && cell.neighbors) {
     int i = val(index,0,0,0);
     {foreach_child()
       val(index,0,0,0) = i;end_foreach_child()}
   }
 }
 else {
   bool loc = is_local(cell);
   if (!loc)
     {foreach_child()
       if (is_local(cell)) {
  loc = true; foreach_child_break();
       }end_foreach_child()}
   if (loc) {
     int i = val(index,0,0,0) + !leaves;
     {foreach_child() {
       val(index,0,0,0) = i;
       i += val(size,0,0,0);
     }end_foreach_child()}
   }
 }
 continue;
      }
      if (is_leaf(cell))
 continue;
    }end_foreach_cell();}
  }
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar[]){index,{-1}}), depth()); };

  {delete((scalar*)((scalar[]){size,{-1}}));{end_tracing("z_indexing","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1493);return maxi;}}delete((scalar*)((scalar[]){size,{-1}}));
end_tracing("z_indexing","/home/xiangbin2/basilisk_new/basilisk/src/grid/tree-mpi.h",1494);}
#line 1687 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#line 1 "grid/balance.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h"


typedef struct {
  short leaf, prolongation;
  int pid;
} NewPid;



#if TRASH
# define is_newpid() (!isnan(val(newpid,0,0,0)) && ((NewPid *)&val(newpid,0,0,0))->pid > 0)
#else
# define is_newpid() (((NewPid *)&val(newpid,0,0,0))->pid > 0)
#endif

Array * linear_tree (size_t size, scalar newpid)
{
  const unsigned short sent = 1 << user, next = 1 << (user + 1);
  Array * a = array_new();

  {foreach_cell_post_all (true)
    if (level > 0 && (cell.flags & (sent|next)))
      aparent(0,0,0).flags |= next;end_foreach_cell_post_all();}

  bool empty = true;
  {foreach_cell_all() {
    if (cell.flags & sent) {
      array_append (a, &cell, size);
      cell.flags &= ~sent;
      empty = false;
    }
    else {
      if (cell.pid >= 0 && ((NewPid *)&val(newpid,0,0,0))->leaf)
 if (!(is_leaf(cell))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h", 34, "is_leaf(cell)");
      if (is_refined_check()) {


 bool prolo = false;
 {foreach_child()
   if (((NewPid *)&val(newpid,0,0,0))->prolongation)
     prolo = true;end_foreach_child()}
 if (prolo) {

   cell.flags |= leaf;
   array_append (a, &cell, sizeof(Cell));
   cell.flags &= ~leaf;
 }
 else
   array_append (a, &cell, sizeof(Cell));
      }
      else
 array_append (a, &cell, sizeof(Cell));
    }
    if (cell.flags & next)
      cell.flags &= ~next;
    else
      continue;
  }end_foreach_cell_all();}

  if (empty)
    a->len = 0;
  return a;
}

#define foreach_tree(t, size, list)\
{\
  const unsigned short _sent = 1 << user, _next = 1 << (user + 1);\
  scalar * _list = list;\
  char * _i = (char *) (t)->p;\
  foreach_cell_all() {\
    Cell * c = (Cell *) _i;\
    if (c->flags & _sent) {\
      _i += size;\

#line 74


#define end_foreach_tree()\
    }\
    else\
      _i += sizeof(Cell);\
    if (c->flags & _next) {\
      if (!(c->neighbors)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h", 81, "c->neighbors");\
      if (!(c->flags & leaf) && is_leaf(cell) &&\
   (!is_newpid() || !((NewPid *)&val(newpid,0,0,0))->leaf))\
\
 refine_cell (point, _list, 0, NULL);\
      else if (!cell.neighbors)\
\
 alloc_children (point);\
    }\
    else\
      continue;\
  } end_foreach_cell_all();\
}\

#line 94


Array * neighborhood (scalar newpid, int nextpid, FILE * fp)
{
  const unsigned short sent = 1 << user;
  {foreach_cell() {

    bool root = false;
    if ((!is_local(cell) || ((NewPid *)&val(newpid,0,0,0))->pid - 1 != nextpid) && (!is_leaf (cell) && cell.neighbors && cell.pid >= 0)) {
      {foreach_child()
 if (is_local(cell) && ((NewPid *)&val(newpid,0,0,0))->pid - 1 == nextpid) {
   root = true; foreach_child_break();
 }end_foreach_child()}
      if (root && cell.pid != nextpid) {
 {foreach_neighbor()
   if (cell.pid != nextpid && is_newpid()) {
     if (fp)
       fprintf (fp, "%g %g %g %d %d root\n",
         x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
     cell.flags |= sent;
   }end_foreach_neighbor()}
      }
    }

    if ((is_local(cell) && ((NewPid *)&val(newpid,0,0,0))->pid - 1 == nextpid) || root) {
      {foreach_neighbor(1)
 if (cell.neighbors && cell.pid != nextpid)
   {foreach_child()
     if (cell.pid != nextpid && is_newpid()) {
       if (fp)
  fprintf (fp, "%g %g %g %d %d nextpid\n",
    x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
       cell.flags |= sent;
     }end_foreach_child()}end_foreach_neighbor()}
    }
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}

  return linear_tree (sizeof(Cell) + datasize, newpid);
}

static void send_tree (Array * a, int to, MPI_Request * r)
{
  MPI_Isend (&a->len, 1, MPI_LONG, to, (256), MPI_COMM_WORLD, &r[0]);
  if (a->len > 0) {
    MPI_Isend (a->p, a->len, MPI_BYTE, to, (256), MPI_COMM_WORLD, &r[1]);
    ((Tree *)grid)->dirty = true;
  }
}

static void receive_tree (int from, scalar newpid, FILE * fp)
{
  Array a;
  mpi_recv_check (&a.len, 1, MPI_LONG, from, (256),
    MPI_COMM_WORLD, MPI_STATUS_IGNORE, "receive_tree (len)");
  if (a.len > 0) {
    a.p = pmalloc (a.len,__func__,__FILE__,__LINE__);
    if (fp)
      fprintf (fp, "receiving %ld from %d\n", a.len, from);
    mpi_recv_check (a.p, a.len, MPI_BYTE, from, (256),
      MPI_COMM_WORLD, MPI_STATUS_IGNORE, "receive_tree (p)");

    {foreach_tree (&a, sizeof(Cell) + datasize, NULL) {
      memcpy (((char *)&cell) + sizeof(Cell), ((char *)c) + sizeof(Cell),
       datasize);
      if (!(((NewPid *)&val(newpid,0,0,0))->pid > 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h", 160, "NEWPID()->pid > 0");
      if (fp)
 fprintf (fp, "%g %g %g %d %d %d %d %d %d recv\n",
   x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid,
   c->flags & leaf,
   cell.flags & leaf, from, ((NewPid *)&val(newpid,0,0,0))->leaf);
    }end_foreach_tree();}
    pfree (a.p,__func__,__FILE__,__LINE__);
    ((Tree *)grid)->dirty = true;
  }
}

static void wait_tree (Array * a, MPI_Request * r)
{
  MPI_Wait (&r[0], MPI_STATUS_IGNORE);
  if (a->len > 0)
    MPI_Wait (&r[1], MPI_STATUS_IGNORE);
}

static void check_flags()
{







}

struct {
  int min;
  bool leaves;

  int npe;
} mpi = {
  1,
  true
};

     
bool balance()
{tracing("balance","/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h",201);
  if (npe() == 1)
    {end_tracing("balance","/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h",204);return false;}

  if (!(sizeof(NewPid) == sizeof(double))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h", 206, "sizeof(NewPid) == sizeof(double)");

  check_flags();

  long nl = 0, nt = 0;
  {foreach_cell() {
    if (is_local(cell)) {
      nt++;
      if (is_leaf(cell))
 nl++;
    }
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}

  grid->n = grid->tn = nl;
  grid->maxdepth = depth();
  long nmin = nl, nmax = nl;

  mpi_all_reduce (nmax, MPI_LONG, MPI_MAX);
  mpi_all_reduce (nmin, MPI_LONG, MPI_MIN);
  mpi_all_reduce (grid->tn, MPI_LONG, MPI_SUM);
  mpi_all_reduce (grid->maxdepth, MPI_INT, MPI_MAX);
  if (mpi.leaves)
    nt = grid->tn;
  else
    mpi_all_reduce (nt, MPI_LONG, MPI_SUM);

  long ne = max(1, nt/npe());

  if (ne < mpi.min) {
    mpi.npe = max(1, nt/mpi.min);
    ne = max(1, nt/mpi.npe);
  }
  else
    mpi.npe = npe();

  if (nmax - nmin <= 1)
    {end_tracing("balance","/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h",244);return false;}

  scalar  newpid=new_scalar("newpid");
  double zn = z_indexing (newpid, mpi.leaves);
  if (pid() == 0)
    if (!(zn + 1 == nt)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h", 249, "zn + 1 == nt");

  FILE * fp = NULL;
#line 261 "/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h"
  bool next = false, prev = false;
  {foreach_cell_all() {
    if (is_local(cell)) {
      int pid = balanced_pid (val(newpid,0,0,0), nt, mpi.npe);
      pid = clamp (pid, cell.pid - 1, cell.pid + 1);
      if (pid == pid() + 1)
 next = true;
      else if (pid == pid() - 1)
 prev = true;
      ((NewPid *)&val(newpid,0,0,0))->pid = pid + 1;
      ((NewPid *)&val(newpid,0,0,0))->leaf = is_leaf(cell);
      ((NewPid *)&val(newpid,0,0,0))->prolongation = (!is_leaf(cell) && !cell.neighbors && cell.pid >= 0);
      if (fp)
 fprintf (fp, "%g %g %d %d newpid\n", x, y, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
    }
    else
      val(newpid,0,0,0) = 0;
  }end_foreach_cell_all();}
  for (int l = 0; l <= depth(); l++)
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, ((scalar[]){newpid,{-1}}), l); };
#line 305 "/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h"
  Array * anext = next ? neighborhood (newpid, pid() + 1, fp) : array_new();
  Array * aprev = prev ? neighborhood (newpid, pid() - 1, fp) : array_new();

  if (fp)
    fflush (fp);

  check_flags();


  MPI_Request rprev[2], rnext[2];
  if (pid() > 0)
    send_tree (aprev, pid() - 1, rprev);
  if (pid() < npe() - 1)
    send_tree (anext, pid() + 1, rnext);


  if (pid() < npe() - 1)
    receive_tree (pid() + 1, newpid, fp);
  if (pid() > 0)
    receive_tree (pid() - 1, newpid, fp);


  if (pid() > 0)
    wait_tree (aprev, rprev);
  array_free (aprev);
  if (pid() < npe() - 1)
    wait_tree (anext, rnext);
  array_free (anext);

  if (fp)
    fflush (fp);


  int pid_changed = false;
  {foreach_cell_all() {
    if (cell.pid >= 0) {
      if (is_newpid()) {
 if (fp)
   fprintf (fp, "%g %g %g %d %d %d %d %d new\n",
     x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid,
     is_leaf(cell), cell.neighbors, ((NewPid *)&val(newpid,0,0,0))->leaf);
 if (cell.pid != ((NewPid *)&val(newpid,0,0,0))->pid - 1) {
   cell.pid = ((NewPid *)&val(newpid,0,0,0))->pid - 1;
   cell.flags &= ~(active|border);
   if (is_local(cell))
     cell.flags |= active;
   pid_changed = true;
 }
 if (((NewPid *)&val(newpid,0,0,0))->leaf && !is_leaf(cell) && cell.neighbors)
   coarsen_cell_recursive (point, NULL);
      }
      else if (level > 0 && ((NewPid *)&coarse(newpid,0,0,0))->leaf)
 cell.pid = aparent(0,0,0).pid;
    }

    if (!cell.neighbors && allocated_child(0,0,0)) {
      if (fp)
 fprintf (fp, "%g %g %g %d %d freechildren\n",
   x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
      free_children (point);
    }
  }end_foreach_cell_all();}

  if (((Tree *)grid)->dirty || pid_changed) {


    {foreach_cell_post (!is_leaf (cell))
      if (!is_leaf(cell) && !is_local(cell)) {
 unsigned short flags = cell.flags & ~active;
 {foreach_child()
   if (is_active(cell)) {
     flags |= active; foreach_child_break();
   }end_foreach_child()}
 cell.flags = flags;
      }end_foreach_cell_post();}

    flag_border_cells();
    pid_changed = true;
  }

  if (fp)
    fclose (fp);

  mpi_all_reduce (pid_changed, MPI_INT, MPI_MAX);
  if (pid_changed)
    mpi_boundary_update_buffers();

  {delete((scalar*)((scalar[]){newpid,{-1}}));{end_tracing("balance","/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h",392);return pid_changed;}}delete((scalar*)((scalar[]){newpid,{-1}}));
end_tracing("balance","/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h",393);}

void mpi_boundary_update (scalar * list)
{
  mpi_boundary_update_buffers();
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}
  grid->tn = 0;
  boundary_internal ((scalar *)list, "/home/xiangbin2/basilisk_new/basilisk/src/grid/balance.h", 401);
  while (balance());
}
#line 1688 "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h"
#else
void mpi_boundary_refine (scalar * list){}
void mpi_boundary_coarsen (int a, int b){}
void mpi_boundary_update (scalar * list) {
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}
  boundary_internal ((scalar *)list, "/home/xiangbin2/basilisk_new/basilisk/src/grid/tree.h", 1694);
}
#endif
#line 4 "/home/xiangbin2/basilisk_new/basilisk/src/grid/quadtree.h"

void quadtree_methods() {
  tree_methods();
}
#line 15 "template01-cpp.c"
#line 1 "template01.c"


#line 1 "./embed-update-2.h"
#line 1 "././embed-update-2.h"
#line 12 "././embed-update-2.h"
#line 1 "./fractions.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
#line 12 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
#line 1 "./geometry.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
#line 28 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
double line_alpha (double c, coord n)
{
  double alpha, n1, n2;

  n1 = fabs (n.x); n2 = fabs (n.y);
  if (n1 > n2)
    do { double __tmp = n1; n1 = n2; n2 = __tmp; } while(0);

  c = clamp (c, 0., 1.);
  double v1 = n1/2.;
  if (c <= v1/n2)
    alpha = sqrt (2.*c*n1*n2);
  else if (c <= 1. - v1/n2)
    alpha = c*n2 + v1;
  else
    alpha = n1 + n2 - sqrt (2.*n1*n2*(1. - c));

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;

  return alpha - (n.x + n.y)/2.;
}
#line 133 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
double line_area (double nx, double ny, double alpha)
{
  double a, v, area;

  alpha += (nx + ny)/2.;
  if (nx < 0.) {
    alpha -= nx;
    nx = - nx;
  }
  if (ny < 0.) {
    alpha -= ny;
    ny = - ny;
  }

  if (alpha <= 0.)
    return 0.;

  if (alpha >= nx + ny)
    return 1.;

  if (nx < 1e-10)
    area = alpha/ny;
  else if (ny < 1e-10)
    area = alpha/nx;
  else {
    v = sq(alpha);

    a = alpha - nx;
    if (a > 0.)
      v -= a*a;

    a = alpha - ny;
    if (a > 0.)
      v -= a*a;

    area = v/(2.*nx*ny);
  }

  return clamp (area, 0., 1.);
}
#line 237 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
double rectangle_fraction (coord n, double alpha, coord a, coord b)
{
  coord n1;
   {
    alpha -= n.x*(b.x + a.x)/2.;
    n1.x = n.x*(b.x - a.x);
  } 
#line 240
{
    alpha -= n.y*(b.y + a.y)/2.;
    n1.y = n.y*(b.y - a.y);
  }
  return line_area(n1.x, n1.y, alpha);
}
#line 262 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
int facets (coord n, double alpha, coord p[2])
{
  int i = 0;
  for (double s = -0.5; s <= 0.5; s += 1.)
    {
      if (fabs (n.y) > 1e-4 && i < 2) {
 double a = (alpha - s*n.x)/n.y;
 if (a >= -0.5 && a <= 0.5) {
   p[i].x = s;
   p[i++].y = a;
 }
      }
      
#line 267
if (fabs (n.x) > 1e-4 && i < 2) {
 double a = (alpha - s*n.y)/n.x;
 if (a >= -0.5 && a <= 0.5) {
   p[i].y = s;
   p[i++].x = a;
 }
      }}
  return i;
}
#line 352 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
double line_length_center (coord m, double alpha, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
    
#line 358
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->x = p->y = p->z = 0.;

  if (alpha <= 0. || alpha >= n.x + n.y)
    return 0.;

  
    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = (m.y < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }
    
#line 369
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = (m.x < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }

  if (alpha >= n.x) {
    p->x += 1.;
    p->y += (alpha - n.x)/n.y;
  }
  else
    p->x += alpha/n.x;

  double ax = p->x, ay = p->y;
  if (alpha >= n.y) {
    p->y += 1.;
    ay -= 1.;
    p->x += (alpha - n.y)/n.x;
    ax -= (alpha - n.y)/n.x;
  }
  else {
    p->y += alpha/n.y;
    ay -= alpha/n.y;
  }

   {
    p->x /= 2.;
    p->x = clamp (p->x, 0., 1.);
    if (m.x < 0.)
      p->x = 1. - p->x;
    p->x -= 0.5;
  } 
#line 394
{
    p->y /= 2.;
    p->y = clamp (p->y, 0., 1.);
    if (m.y < 0.)
      p->y = 1. - p->y;
    p->y -= 0.5;
  }

  return sqrt (ax*ax + ay*ay);
}
#line 482 "/home/xiangbin2/basilisk_new/basilisk/src/geometry.h"
void line_center (coord m, double alpha, double a, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
    
#line 488
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->z = 0.;
  if (alpha <= 0.) {
    p->x = p->y = -0.5;
    return;
  }

  if (alpha >= n.x + n.y) {
    p->x = p->y = 0.;
    return;
  }

  
    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = sign(m.y)*(a/2. - 0.5);
      return;
    }
    
#line 505
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = sign(m.x)*(a/2. - 0.5);
      return;
    }

  p->x = p->y = cube(alpha);

   {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= sq(b)*(alpha + 2.*n.x);
      p->y -= cube(b);
    }
  } 
#line 513
{
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= sq(b)*(alpha + 2.*n.y);
      p->x -= cube(b);
    }
  }

   {
    p->x /= 6.*sq(n.x)*n.y*a;
    p->x = sign(m.x)*(p->x - 0.5);
  } 
#line 521
{
    p->y /= 6.*sq(n.y)*n.x*a;
    p->y = sign(m.y)*(p->y - 0.5);
  }
}
#line 13 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"






#line 1 "./myc2d.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/myc2d.h"





coord mycs (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int ix;
  double c_t,c_b,c_r,c_l;
  double mx0,my0,mx1,my1,mm1,mm2;


  c_t = val(c,-1,1,0) + val(c,0,1,0) + val(c,1,1,0);
  c_b = val(c,-1,-1,0) + val(c,0,-1,0) + val(c,1,-1,0);
  c_r = val(c,1,-1,0) + val(c,1,0,0) + val(c,1,1,0);
  c_l = val(c,-1,-1,0) + val(c,-1,0,0) + val(c,-1,1,0);



  mx0 = 0.5*(c_l-c_r);
  my0 = 0.5*(c_b-c_t);


  if (fabs(mx0) <= fabs(my0)) {
    my0 = my0 > 0. ? 1. : -1.;
    ix = 1;
  }
  else {
    mx0 = mx0 > 0. ? 1. : -1.;
    ix = 0;
  }


  mm1 = val(c,-1,-1,0) + 2.0*val(c,-1,0,0) + val(c,-1,1,0);
  mm2 = val(c,1,-1,0) + 2.0*val(c,1,0,0) + val(c,1,1,0);
  mx1 = mm1 - mm2 + 1.e-30;
  mm1 = val(c,-1,-1,0) + 2.0*val(c,0,-1,0) + val(c,1,-1,0);
  mm2 = val(c,-1,1,0) + 2.0*val(c,0,1,0) + val(c,1,1,0);
  my1 = mm1 - mm2 + 1.e-30;


  if (ix) {
    mm1 = fabs(my1);
    mm1 = fabs(mx1)/mm1;
    if (mm1 > fabs(mx0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }
  else {
    mm1 = fabs(mx1);
    mm1 = fabs(my1)/mm1;
    if (mm1 > fabs(my0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }



  mm1 = fabs(mx0) + fabs(my0);
  coord n = {mx0/mm1, my0/mm1};

  return n;
}
#line 13 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"






#line 1 "./myc2d.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/myc2d.h"





static void _stencil_mycs (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;   
  
  
   


_stencil_val(c,-1,1,0); _stencil_val(c,0,1,0); _stencil_val(c,1,1,0); 


     
#line 14
_stencil_val(c,-1,-1,0); _stencil_val(c,0,-1,0); _stencil_val(c,1,-1,0); 
     _stencil_val(c,1,-1,0); _stencil_val(c,1,0,0); _stencil_val(c,1,1,0); 
     _stencil_val(c,-1,-1,0); _stencil_val(c,-1,0,0); _stencil_val(c,-1,1,0);
            
      
   
            
     
       
    



   
    





_stencil_val(c,-1,-1,0);_stencil_val(c,-1,0,0); _stencil_val(c,-1,1,0); 


     
  


      
#line 35
_stencil_val(c,1,-1,0);_stencil_val(c,1,0,0); _stencil_val(c,1,1,0);  
     
        _stencil_val(c,-1,-1,0);_stencil_val(c,0,-1,0); _stencil_val(c,1,-1,0);
       _stencil_val(c,-1,1,0);_stencil_val(c,0,1,0); _stencil_val(c,1,1,0);    
        
        
    
      
       
       
   
    
      
       


  
        
        
    
      
       
       
   



      
  

  
#line 64
return ;
}
#line 20 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
#line 41 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
void fraction_refine (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;





  double cc = val(c,0,0,0);
  if (cc <= 0. || cc >= 1.)
    {foreach_child()
      val(c,0,0,0) = cc;end_foreach_child()}
  else {




    coord n = mycs (point, c);
    double alpha = line_alpha (cc, n);






    {foreach_child() {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x;
 
#line 69
nc.y = child.y*n.y;
      val(c,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }end_foreach_child()}
  }
}











static void alpha_refine (Point point, scalar alpha)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector n = _attribute[alpha.i].n;
  double alphac = 2.*val(alpha,0,0,0);
  coord m;
  
    m.x = val(n.x,0,0,0);
    
#line 91
m.y = val(n.y,0,0,0);
  {foreach_child() {
    val(alpha,0,0,0) = alphac;
    
      val(alpha,0,0,0) -= child.x*m.x/2.;
      
#line 95
val(alpha,0,0,0) -= child.y*m.y/2.;
  }end_foreach_child()}
}
#line 121 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
struct Fractions {
  scalar Phi;
  scalar c;
  vector s;
  double val;
};

     
void fractions (struct Fractions a)
{tracing("fractions","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",129);
  scalar Phi = a.Phi;
  scalar c = a.c;
  vector   s=(a.s).x.i?(a.s):new_face_vector("s");
  double val = a.val;
#line 145 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
  vector p;
  p.x = s.y; p.y = s.x;
#line 155 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
  foreach_face_stencil(){_stencil_is_face_y(){ {





_stencil_val(Phi,0,0,0);_stencil_val(Phi,1,0,0);{ {






      _stencil_val_a(p.x,0,0,0);_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,1,0,0);
_stencil_val(Phi,0,0,0);
 {_stencil_val_a(p.x,0,0,0); _stencil_val(p.x,0,0,0);   }     
         
    
#line 171
}
      








{_stencil_val_a(p.x,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,1,0,0);       }}





           
#line 180 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    
  
}}end__stencil_is_face_y()
#line 155
_stencil_is_face_x(){ {





_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,1,0);{ {






      _stencil_val_a(p.y,0,0,0);_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,1,0);
_stencil_val(Phi,0,0,0);
 {_stencil_val_a(p.y,0,0,0); _stencil_val(p.y,0,0,0);   }     
         
    
#line 171
}
      








{_stencil_val_a(p.y,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,1,0);       }}





           
#line 180 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    
  
}}end__stencil_is_face_x()}end_foreach_face_stencil();
#line 155 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
  {foreach_face_generic(){is_face_y(){ {





    if ((val(Phi,0,0,0) - val)*(val(Phi,1,0,0) - val) < 0.) {






      val(p.x,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,1,0,0));
      if (val(Phi,0,0,0) < val)
 val(p.x,0,0,0) = 1. - val(p.x,0,0,0);
    }
#line 180 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    else
      val(p.x,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,1,0,0) > val);
  }}end_is_face_y()
#line 155
is_face_x(){ {





    if ((val(Phi,0,0,0) - val)*(val(Phi,0,1,0) - val) < 0.) {






      val(p.y,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,0,1,0));
      if (val(Phi,0,0,0) < val)
 val(p.y,0,0,0) = 1. - val(p.y,0,0,0);
    }
#line 180 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    else
      val(p.y,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,0,1,0) > val);
  }}end_is_face_x()}end_foreach_face_generic();}
#line 205 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
  scalar s_z = c;
  foreach_stencil()

  {    
#line 240 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    
    
     { 
_stencil_val(p.y,0,0,0); _stencil_val(p.y,1,0,0);  
       
       
    
#line 245
} 
#line 242
{ 
_stencil_val(p.x,0,0,0); _stencil_val(p.x,0,1,0);  
       
       
    
#line 245
}





{
      {_stencil_val_a(s_z,0,0,0); _stencil_val(p.x,0,0,0); } 
{      





      
   






      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(p.x,0,i,0); _stencil_val(p.x,0,i,0); {       
     _stencil_val(p.x,0,i,0);_stencil_val(Phi,0,i,0); 
          
     
   }      }
   
#line 270
{_stencil_val(p.y,i,0,0); _stencil_val(p.y,i,0,0); {       
     _stencil_val(p.y,i,0,0);_stencil_val(Phi,i,0,0); 
          
     
   }      }}








{
 {_stencil_val_a(s_z,0,0,0);_stencil_val(p.x,0,0,0); _stencil_val(p.y,0,0,0);   }
{
 {_stencil_val_a(s_z,0,0,0);     } 
{



 _stencil_val_a(s_z,0,0,0);  

      }}}
#line 283 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
         
          
      
    







}}





       
    
  
#line 295
}end_foreach_stencil();
  {
#line 206
foreach()

  {
#line 240 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
     {
      n.x = val(p.y,0,0,0) - val(p.y,1,0,0);
      nn += fabs(n.x);
    } 
#line 242
{
      n.y = val(p.x,0,0,0) - val(p.x,0,1,0);
      nn += fabs(n.y);
    }





    if (nn == 0.)
      val(s_z,0,0,0) = val(p.x,0,0,0);
    else {





      
 n.x /= nn;
 
#line 260
n.y /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (val(p.x,0,i,0) > 0. && val(p.x,0,i,0) < 1.) {
     double a = sign(val(Phi,0,i,0) - val)*(val(p.x,0,i,0) - 0.5);
     alpha += n.x*a + n.y*(i - 0.5);
     ni++;
   }
   
#line 270
if (val(p.y,i,0,0) > 0. && val(p.y,i,0,0) < 1.) {
     double a = sign(val(Phi,i,0,0) - val)*(val(p.y,i,0,0) - 0.5);
     alpha += n.y*a + n.x*(i - 0.5);
     ni++;
   }}
#line 283 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
      if (ni == 0)
 val(s_z,0,0,0) = max (val(p.x,0,0,0), val(p.y,0,0,0));
      else if (ni != 4)
 val(s_z,0,0,0) = line_area (n.x, n.y, alpha/ni);
      else {



 val(s_z,0,0,0) = 0.;

      }
    }
  }end_foreach();}{if(!(a.s).x.i)delete((scalar*)((vector[]){s,{{-1},{-1}}}));}
#line 347 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
end_tracing("fractions","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",347);}
#line 391 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
coord youngs_normal (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n;
  double nn = 0.;
  if (!(2 == 2)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/fractions.h", 395, "dimension == 2");
   {
    n.x = (val(c,-1,1,0) + 2.*val(c,-1,0,0) + val(c,-1,-1,0) -
    val(c,+1,1,0) - 2.*val(c,+1,0,0) - val(c,+1,-1,0));
    nn += fabs(n.x);
  } 
#line 396
{
    n.y = (val(c,1,-1,0) + 2.*val(c,0,-1,0) + val(c,-1,-1,0) -
    val(c,1,+1,0) - 2.*val(c,0,+1,0) - val(c,-1,+1,0));
    nn += fabs(n.y);
  }

  if (nn > 0.)
    {
      n.x /= nn;
      
#line 404
n.y /= nn;}
  else
    n.x = 1.;
  return n;
}





coord facet_normal (Point point, scalar c, vector s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (s.x.i >= 0) {
    coord n;
    double nn = 0.;
     {
      n.x = val(s.x,0,0,0) - val(s.x,1,0,0);
      nn += fabs(n.x);
    } 
#line 419
{
      n.y = val(s.y,0,0,0) - val(s.y,0,1,0);
      nn += fabs(n.y);
    }
    if (nn > 0.)
      {
 n.x /= nn;
 
#line 425
n.y /= nn;}
    else
      {
 n.x = 1./2;
 
#line 428
n.y = 1./2;}
    return n;
  }
  return mycs (point, c);
}






#line 414
static void _stencil_facet_normal (Point point, scalar c, vector s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (s.x.i >= 0) {    
    
    
     { 
_stencil_val(s.x,0,0,0); _stencil_val(s.x,1,0,0);  
       
       
    
#line 422
} 
#line 419
{ 
_stencil_val(s.y,0,0,0); _stencil_val(s.y,0,1,0);  
       
       
    
#line 422
}
      
   
       
    
       
  
    return ;
  } 
_stencil_mycs (point, c);
  
#line 431
return;
}
#line 441 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
     
void reconstruction (const scalar c, vector n, scalar alpha)
{tracing("reconstruction","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",442);
  foreach_stencil() {





_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
      _stencil_val_a(alpha,0,0,0);  
      
 {_stencil_val_a(n.x,0,0,0);  }
 
#line 453
{_stencil_val_a(n.y,0,0,0);  }
    } 
{  






       _stencil_mycs (point, c);
      
 {_stencil_val_a(n.x,0,0,0);  }
 
#line 464
{_stencil_val_a(n.y,0,0,0);  }
      _stencil_val_a(alpha,0,0,0);_stencil_val(c,0,0,0);    
    }}





          
    
  
#line 467
}end_foreach_stencil();
  {
#line 444
foreach() {





    if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
      val(alpha,0,0,0) = 0.;
      
 val(n.x,0,0,0) = 0.;
 
#line 453
val(n.y,0,0,0) = 0.;
    }
    else {






      coord m = mycs (point, c);
      
 val(n.x,0,0,0) = m.x;
 
#line 464
val(n.y,0,0,0) = m.y;
      val(alpha,0,0,0) = line_alpha (val(c,0,0,0), m);
    }
  }end_foreach();}
#line 476 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
  
    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;
    
#line 477
_attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;

end_tracing("reconstruction","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",485);}
#line 505 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
struct OutputFacets {
  scalar c;
  FILE * fp;
  vector s;
};

     
void output_facets (struct OutputFacets p)
{tracing("output_facets","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",512);
  scalar c = p.c;
  vector s = p.s;
  if (!p.fp) p.fp = fout;
  if (!s.x.i) s.x.i = -1;

  foreach_stencil()
    {_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {  
       _stencil_facet_normal (point, c, s);     
      _stencil_val(c,0,0,0); 

            
           
        
     
 
#line 538 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    }        }end_foreach_stencil();

  {
#line 519
foreach()
    if (val(c,0,0,0) > 1e-6 && val(c,0,0,0) < 1. - 1e-6) {
      coord n = facet_normal (point, c, s);
      double alpha = line_alpha (val(c,0,0,0), n);

      coord segment[2];
      if (facets (n, alpha, segment) == 2)
 fprintf (p.fp, "%g %g\n%g %g\n\n",
   x + segment[0].x*Delta, y + segment[0].y*Delta,
   x + segment[1].x*Delta, y + segment[1].y*Delta);
#line 538 "/home/xiangbin2/basilisk_new/basilisk/src/fractions.h"
    }end_foreach();}

  fflush (p.fp);
end_tracing("output_facets","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",541);}







     
double interface_area (scalar c)
{tracing("interface_area","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",550);
  double area = 0.;
  foreach_stencil ()
    {_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
       _stencil_mycs (point, c);     
      _stencil_val(c,0,0,0); 
          
    }        }end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:area)){
#line 553
foreach ()
    if (val(c,0,0,0) > 1e-6 && val(c,0,0,0) < 1. - 1e-6) {
      coord n = mycs (point, c), p;
      double alpha = line_alpha (val(c,0,0,0), n);
      area += pow(Delta, 2 - 1)*line_length_center(n,alpha,&p);
    }end_foreach();mpi_all_reduce_array(&area,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
  
#line 559
{end_tracing("interface_area","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",559);return area;}
end_tracing("interface_area","/home/xiangbin2/basilisk_new/basilisk/src/fractions.h",560);}
#line 13 "././embed-update-2.h"






scalar  cs={0};
vector  fs={{1},{2}};

double (* metric_embed_factor) (Point, coord) = NULL;







#line 1 "././my-embed-tree.h"
#line 1 "./././my-embed-tree.h"
#line 14 "./././my-embed-tree.h"
static void embed_fraction_refine (Point point, scalar cs)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(cs,0,0,0);





  if (cc <= 0. || cc >= 1.) {
    {foreach_child()
      val(cs,0,0,0) = cc;end_foreach_child()}
  }
  else {






    coord n = facet_normal (point, cs, fs);
    double alpha = line_alpha (cc, n);

    {foreach_child() {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x;
 
#line 40
nc.y = child.y*n.y;
      val(cs,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }end_foreach_child()}
  }
}








static void embed_face_fraction_refine_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fs = _attribute[s.i].v;





  if (val(cs,0,0,0) <= 0. || val(cs,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fs.x,1,j,k) = val(cs,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0) && neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fs.x,2*i,j,k) = val(fs.x,i,0,0);
  }
  else {





    coord n = facet_normal (point, cs, fs);
    double alpha = line_alpha (val(cs,0,0,0), n);
#line 99 "./././my-embed-tree.h"
    if (2.*fabs(alpha) < fabs(n.y)) {
      double yc = alpha/n.y;
      int i = yc > 0.;
      fine(fs.x,1,1 - i,0) = n.y < 0. ? 1. - i : i;
      fine(fs.x,1,i,0) = n.y < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fs.x,1,0,0) = fine(fs.x,1,1,0) = alpha > 0.;
#line 133 "./././my-embed-tree.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0)))) {
 if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0)) {
   if (val(fs.x,i,0,0) <= 0. || val(fs.x,i,0,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fs.x,2*i,j,k) = val(fs.x,i,0,0);
   else {






     double a = val(fs.y,0,1,0) <= 0. || val(fs.y,2*i-1,1,0) <= 0. ||
       val(fs.y,0,0,0) >= 1. || val(fs.y,2*i-1,0,0) >= 1.;
     if ((2.*a - 1)*(val(fs.x,i,0,0) - 0.5) > 0.) {
       fine(fs.x,2*i,0,0) = a;
       fine(fs.x,2*i,1,0) = 2.*val(fs.x,i,0,0) - a;
     }
     else {
       fine(fs.x,2*i,0,0) = 2.*val(fs.x,i,0,0) + a - 1.;
       fine(fs.x,2*i,1,0) = 1. - a;
     }
#line 175 "./././my-embed-tree.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fs.x,2*i,j,k) && !fine(cs,i,j,k))
       fine(fs.x,2*i,j,k) = 0.;
      }
  }


}

#line 53
static void embed_face_fraction_refine_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fs = _attribute[s.i].v;





  if (val(cs,0,0,0) <= 0. || val(cs,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fs.y,j,1,k) = val(cs,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0) && neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fs.y,j,2*i,k) = val(fs.y,0,i,0);
  }
  else {





    coord n = facet_normal (point, cs, fs);
    double alpha = line_alpha (val(cs,0,0,0), n);
#line 99 "./././my-embed-tree.h"
    if (2.*fabs(alpha) < fabs(n.x)) {
      double yc = alpha/n.x;
      int i = yc > 0.;
      fine(fs.y,1 - i,1,0) = n.x < 0. ? 1. - i : i;
      fine(fs.y,i,1,0) = n.x < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fs.y,0,1,0) = fine(fs.y,1,1,0) = alpha > 0.;
#line 133 "./././my-embed-tree.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0)))) {
 if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0)) {
   if (val(fs.y,0,i,0) <= 0. || val(fs.y,0,i,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fs.y,j,2*i,k) = val(fs.y,0,i,0);
   else {






     double a = val(fs.x,1,0,0) <= 0. || val(fs.x,1,2*i-1,0) <= 0. ||
       val(fs.x,0,0,0) >= 1. || val(fs.x,0,2*i-1,0) >= 1.;
     if ((2.*a - 1)*(val(fs.y,0,i,0) - 0.5) > 0.) {
       fine(fs.y,0,2*i,0) = a;
       fine(fs.y,1,2*i,0) = 2.*val(fs.y,0,i,0) - a;
     }
     else {
       fine(fs.y,0,2*i,0) = 2.*val(fs.y,0,i,0) + a - 1.;
       fine(fs.y,1,2*i,0) = 1. - a;
     }
#line 175 "./././my-embed-tree.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fs.y,j,2*i,k) && !fine(cs,j,i,k))
       fine(fs.y,j,2*i,k) = 0.;
      }
  }


}
#line 209 "./././my-embed-tree.h"




static inline void restriction_embed_linear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  if (!val(cs,0,0,0)) {
    val(s,0,0,0) = 0.;
    return;
  }






  double val = 0., nv = 0.;
  for (int i = 0; i <= 1; i++)



      if (fine(cs,0,i,j) && fine(cs,1,!i,!j))
 val += (fine(s,0,i,j) + fine(s,1,!i,!j))/2., nv++;
  if (nv > 0.) {
    val(s,0,0,0) = val/nv;
    return;
  }





  coord p = {0.,0.,0.};
  {foreach_child()
    if (val(cs,0,0,0))
      p.x += x, p.y += y, p.z += z, val += val(s,0,0,0), nv++;end_foreach_child()}
  if (!(nv > 0.)) qassert ("./././my-embed-tree.h", 246, "nv > 0.");
  val(s,0,0,0) = val/nv;






  if (_attribute[s.i].embed_gradient && _attribute[s.i].boundary[0] != _attribute[s.i].boundary_homogeneous[0]) {
    coord o = {x,y,z}, g;
    _attribute[s.i].embed_gradient (point, s, &g);
    
      val(s,0,0,0) += (o.x - p.x/nv)*g.x;
      
#line 258
val(s,0,0,0) += (o.y - p.y/nv)*g.y;
  }
}
#line 271 "./././my-embed-tree.h"
static inline void refine_embed_linear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child() {
    if (!val(cs,0,0,0))
      val(s,0,0,0) = 0.;
    else {
      if (!(coarse(cs,0,0,0))) qassert ("./././my-embed-tree.h", 277, "coarse(cs)");
      int i = (child.x + 1)/2, j = (child.y + 1)/2;

      if (coarse(fs.x,i,0,0) && coarse(fs.y,0,j,0) &&
   (coarse(cs,0,0,0) == 1. || coarse(cs,child.x,0,0) == 1. ||
    coarse(cs,0,child.y,0) == 1. || coarse(cs,child.x,child.y,0) == 1.)) {
 if (!(coarse(cs,child.x,0,0) && coarse(cs,0,child.y,0))) qassert ("./././my-embed-tree.h", 283, "coarse(cs,child.x) && coarse(cs,0,child.y)");
 if (coarse(fs.x,i,child.y,0) && coarse(fs.y,child.x,j,0)) {

   if (!(coarse(cs,child.x,child.y,0))) qassert ("./././my-embed-tree.h", 286, "coarse(cs,child.x,child.y)");
   val(s,0,0,0) = (9.*coarse(s,0,0,0) +
   3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
   coarse(s,child.x,child.y,0))/16.;
 }
 else

   val(s,0,0,0) = (2.*coarse(s,0,0,0) + coarse(s,child.x,0,0) + coarse(s,0,child.y,0))/4.;
      }
      else if (coarse(cs,child.x,child.y,0) &&
        ((coarse(fs.x,i,0,0) && coarse(fs.y,child.x,j,0)) ||
  (coarse(fs.y,0,j,0) && coarse(fs.x,i,child.y,0)))) {

 val(s,0,0,0) = (3.*coarse(s,0,0,0) + coarse(s,child.x,child.y,0))/4.;
      }
#line 349 "./././my-embed-tree.h"
      else {

 val(s,0,0,0) = coarse(s,0,0,0);
  {
   if (coarse(fs.x,(child.x + 1)/2,0,0) && coarse(cs,child.x,0,0))
     val(s,0,0,0) += (coarse(s,child.x,0,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fs.x,(- child.x + 1)/2,0,0) && coarse(cs,- child.x,0,0))
     val(s,0,0,0) -= (coarse(s,- child.x,0,0) - coarse(s,0,0,0))/4.;
 } 
#line 352
{
   if (coarse(fs.y,0,(child.y + 1)/2,0) && coarse(cs,0,child.y,0))
     val(s,0,0,0) += (coarse(s,0,child.y,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fs.y,0,(- child.y + 1)/2,0) && coarse(cs,0,- child.y,0))
     val(s,0,0,0) -= (coarse(s,0,- child.y,0) - coarse(s,0,0,0))/4.;
 }
      }
    }
  }end_foreach_child()}
}
#line 372 "./././my-embed-tree.h"

void refine_embed_face_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector v = _attribute[s.i].v;
  for (int i = 0; i <= 1; i++)
    if (neighbor(2*i - 1,0,0).neighbors &&
 (is_local(cell) || is_local(neighbor(2*i - 1,0,0)))) {
      double g1 = val(fs.x,i,0,0) >= 1. && val(fs.x,i,+1,0) && val(fs.x,i,-1,0) ?
 (val(v.x,i,+1,0)/val(fs.x,i,+1,0) - val(v.x,i,-1,0)/val(fs.x,i,-1,0))/8. : 0.;
      double g2 = val(fs.x,i,0,0) >= 1. && val(fs.x,i,0,+1) && val(fs.x,i,0,-1) ?
 (val(v.x,i,0,+1)/val(fs.x,i,0,+1) - val(v.x,i,0,-1)/val(fs.x,i,0,-1))/8. : 0.;
      for (int j = 0; j <= 1; j++)
 for (int k = 0; k <= 1; k++)
   fine(v.x,2*i,j,k) = val(fs.x,i,0,0) ?
     fine(fs.x,2*i,j,k)*(val(v.x,i,0,0)/val(fs.x,i,0,0) +
    (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
    }
  if (is_local(cell)) {
    double g1 = (val(fs.x,0,+1,0) + val(fs.x,1,+1,0)) && (val(fs.x,0,-1,0) + val(fs.x,1,-1,0)) ?
      ((val(v.x,0,+1,0) + val(v.x,1,+1,0))/(val(fs.x,0,+1,0) + val(fs.x,1,+1,0)) -
       (val(v.x,0,-1,0) + val(v.x,1,-1,0))/(val(fs.x,0,-1,0) + val(fs.x,1,-1,0)))/8. : 0.;
    double g2 = (val(fs.x,1,0,+1) + val(fs.x,0,0,+1)) && (val(fs.x,1,0,-1) + val(fs.x,0,0,-1)) ?
      ((val(v.x,0,0,+1) + val(v.x,1,0,+1))/(val(fs.x,1,0,+1) + val(fs.x,0,0,+1)) -
       (val(v.x,0,0,-1) + val(v.x,1,0,-1))/(val(fs.x,1,0,-1) + val(fs.x,0,0,-1)))/8. : 0.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(v.x,1,j,k) = val(fs.x,0,0,0) + val(fs.x,1,0,0) ?
   fine(fs.x,1,j,k)*((val(v.x,0,0,0) + val(v.x,1,0,0))/(val(fs.x,0,0,0) + val(fs.x,1,0,0)) +
       (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
  }
}

#line 373
void refine_embed_face_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector v = _attribute[s.i].v;
  for (int i = 0; i <= 1; i++)
    if (neighbor(0,2*i - 1,0).neighbors &&
 (is_local(cell) || is_local(neighbor(0,2*i - 1,0)))) {
      double g1 = val(fs.y,0,i,0) >= 1. && val(fs.y,+1,i,0) && val(fs.y,-1,i,0) ?
 (val(v.y,+1,i,0)/val(fs.y,+1,i,0) - val(v.y,-1,i,0)/val(fs.y,-1,i,0))/8. : 0.;
      double g2 = val(fs.y,0,i,0) >= 1. && val(fs.y,0,i,+1) && val(fs.y,0,i,-1) ?
 (val(v.y,0,i,+1)/val(fs.y,0,i,+1) - val(v.y,0,i,-1)/val(fs.y,0,i,-1))/8. : 0.;
      for (int j = 0; j <= 1; j++)
 for (int k = 0; k <= 1; k++)
   fine(v.y,j,2*i,k) = val(fs.y,0,i,0) ?
     fine(fs.y,j,2*i,k)*(val(v.y,0,i,0)/val(fs.y,0,i,0) +
    (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
    }
  if (is_local(cell)) {
    double g1 = (val(fs.y,+1,0,0) + val(fs.y,+1,1,0)) && (val(fs.y,-1,0,0) + val(fs.y,-1,1,0)) ?
      ((val(v.y,+1,0,0) + val(v.y,+1,1,0))/(val(fs.y,+1,0,0) + val(fs.y,+1,1,0)) -
       (val(v.y,-1,0,0) + val(v.y,-1,1,0))/(val(fs.y,-1,0,0) + val(fs.y,-1,1,0)))/8. : 0.;
    double g2 = (val(fs.y,0,1,+1) + val(fs.y,0,0,+1)) && (val(fs.y,0,1,-1) + val(fs.y,0,0,-1)) ?
      ((val(v.y,0,0,+1) + val(v.y,0,1,+1))/(val(fs.y,0,1,+1) + val(fs.y,0,0,+1)) -
       (val(v.y,0,0,-1) + val(v.y,0,1,-1))/(val(fs.y,0,1,-1) + val(fs.y,0,0,-1)))/8. : 0.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(v.y,j,1,k) = val(fs.y,0,0,0) + val(fs.y,0,1,0) ?
   fine(fs.y,j,1,k)*((val(v.y,0,0,0) + val(v.y,0,1,0))/(val(fs.y,0,0,0) + val(fs.y,0,1,0)) +
       (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
  }
}
#line 31 "././embed-update-2.h"
#line 71 "././embed-update-2.h"

static inline double embed_face_gradient_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int j = sign(val(fs.x,i,1,0) - val(fs.x,i,-1,0));
  if (!(val(cs,i,0,0) && val(cs,i-1,0,0))) qassert ("././embed-update-2.h", 75, "cs[i] && cs[i-1]");
  if ((val(fs.x,i,j,0) > 0.5 && val(fs.y,i,j + (j < 0),0) && val(fs.y,i-1,j + (j < 0),0) && val(cs,i,j,0) && val(cs,i-1,j,0)))
    return ((1. + val(fs.x,i,0,0))*(val(a,i,0,0) - val(a,i-1,0,0)) +
     (1. - val(fs.x,i,0,0))*(val(a,i,j,0) - val(a,i-1,j,0)))/(2.*Delta);
  return (val(a,i,0,0) - val(a,i-1,0,0))/Delta;
}

#line 72
static inline double embed_face_gradient_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int j = sign(val(fs.y,1,i,0) - val(fs.y,-1,i,0));
  if (!(val(cs,0,i,0) && val(cs,0,i-1,0))) qassert ("././embed-update-2.h", 75, "cs[i] && cs[i-1]");
  if ((val(fs.y,j,i,0) > 0.5 && val(fs.x,j + (j < 0),i,0) && val(fs.x,j + (j < 0),i-1,0) && val(cs,j,i,0) && val(cs,j,i-1,0)))
    return ((1. + val(fs.y,0,i,0))*(val(a,0,i,0) - val(a,0,i-1,0)) +
     (1. - val(fs.y,0,i,0))*(val(a,j,i,0) - val(a,j,i-1,0)))/(2.*Delta);
  return (val(a,0,i,0) - val(a,0,i-1,0))/Delta;
}
#line 31 "././embed-update-2.h"
#line 71 "././embed-update-2.h"

static void _stencil_embed_face_gradient_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;    
   _stencil_val(fs.x,i,-1,0);_stencil_val(fs.x,i,1,0);
_stencil_val(cs,i,0,0); _stencil_val(cs,i-1,0,0);
_stencil_val(fs.x,i,o_stencil,0); _stencil_val(fs.y,i,o_stencil,0    ); _stencil_val(fs.y,i-1,o_stencil,0    ); _stencil_val(cs,i,o_stencil,0); _stencil_val(cs,i-1,o_stencil,0);
    { _stencil_val(fs.x,i,0,0);_stencil_val(a,i,0,0); _stencil_val(a,i-1,0,0); 
_stencil_val(fs.x,i,0,0);_stencil_val(a,i,o_stencil,0); _stencil_val(a,i-1,o_stencil,0);    
       
#line 78
}
_stencil_val(a,i,0,0); _stencil_val(a,i-1,0,0);  
      
         
  
#line 79
return  ;
}

#line 72
static void _stencil_embed_face_gradient_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;    
   _stencil_val(fs.y,-1,i,0);_stencil_val(fs.y,1,i,0);
_stencil_val(cs,0,i,0); _stencil_val(cs,0,i-1,0);
_stencil_val(fs.y,o_stencil,i,0); _stencil_val(fs.x,o_stencil,i,0    ); _stencil_val(fs.x,o_stencil,i-1,0    ); _stencil_val(cs,o_stencil,i,0); _stencil_val(cs,o_stencil,i-1,0);
    { _stencil_val(fs.y,0,i,0);_stencil_val(a,0,i,0); _stencil_val(a,0,i-1,0); 
_stencil_val(fs.y,0,i,0);_stencil_val(a,o_stencil,i,0); _stencil_val(a,o_stencil,i-1,0);    
       
#line 78
}
_stencil_val(a,0,i,0); _stencil_val(a,0,i-1,0);  
      
         
  
#line 79
return  ;
}


static inline double embed_face_value_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int j = sign(val(fs.x,i,1,0) - val(fs.x,i,-1,0));
  return (val(fs.x,i,j,0) > 0.5 && val(fs.y,i,j + (j < 0),0) && val(fs.y,i-1,j + (j < 0),0) && val(cs,i,j,0) && val(cs,i-1,j,0)) ?
    ((1. + val(fs.x,i,0,0))*((val(a,i,0,0)*(1.5 + val(cs,i,0,0)) + val(a,i-1,0,0)*(1.5 + val(cs,i-1,0,0)))/ (val(cs,i,0,0) + val(cs,i-1,0,0) + 3.)) + (1. - val(fs.x,i,0,0))*((val(a,i,j,0)*(1.5 + val(cs,i,j,0)) + val(a,i-1,j,0)*(1.5 + val(cs,i-1,j,0)))/ (val(cs,i,j,0) + val(cs,i-1,j,0) + 3.)))/2. :
    ((val(a,i,0,0)*(1.5 + val(cs,i,0,0)) + val(a,i-1,0,0)*(1.5 + val(cs,i-1,0,0)))/ (val(cs,i,0,0) + val(cs,i-1,0,0) + 3.));
}

#line 83
static inline double embed_face_value_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int j = sign(val(fs.y,1,i,0) - val(fs.y,-1,i,0));
  return (val(fs.y,j,i,0) > 0.5 && val(fs.x,j + (j < 0),i,0) && val(fs.x,j + (j < 0),i-1,0) && val(cs,j,i,0) && val(cs,j,i-1,0)) ?
    ((1. + val(fs.y,0,i,0))*((val(a,0,i,0)*(1.5 + val(cs,0,i,0)) + val(a,0,i-1,0)*(1.5 + val(cs,0,i-1,0)))/ (val(cs,0,i,0) + val(cs,0,i-1,0) + 3.)) + (1. - val(fs.y,0,i,0))*((val(a,j,i,0)*(1.5 + val(cs,j,i,0)) + val(a,j,i-1,0)*(1.5 + val(cs,j,i-1,0)))/ (val(cs,j,i,0) + val(cs,j,i-1,0) + 3.)))/2. :
    ((val(a,0,i,0)*(1.5 + val(cs,0,i,0)) + val(a,0,i-1,0)*(1.5 + val(cs,0,i-1,0)))/ (val(cs,0,i,0) + val(cs,0,i-1,0) + 3.));
}



#line 83
static void _stencil_embed_face_value_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;    
   _stencil_val(fs.x,i,-1,0);_stencil_val(fs.x,i,1,0);
_stencil_val(fs.x,i,o_stencil,0); _stencil_val(fs.y,i,o_stencil,0    ); _stencil_val(fs.y,i-1,o_stencil,0    ); _stencil_val(cs,i,o_stencil,0); _stencil_val(cs,i-1,o_stencil,0); 
_stencil_val(fs.x,i,0,0);_stencil_val(a,i,0,0); _stencil_val(cs,i,0,0); _stencil_val(a,i-1,0,0); _stencil_val(cs,i-1,0,0);_stencil_val(cs,i,0,0); _stencil_val(cs,i-1,0,0); _stencil_val(fs.x,i,0,0);_stencil_val(a,i,o_stencil,0); _stencil_val(cs,i,o_stencil,0); _stencil_val(a,i-1,o_stencil,0); _stencil_val(cs,i-1,o_stencil,0);_stencil_val(cs,i,o_stencil,0); _stencil_val(cs,i-1,o_stencil,0);
_stencil_val(a,i,0,0); _stencil_val(cs,i,0,0); _stencil_val(a,i-1,0,0); _stencil_val(cs,i-1,0,0);_stencil_val(cs,i,0,0); _stencil_val(cs,i-1,0,0);
  
#line 86
return                  
                    
    ;
}

#line 83
static void _stencil_embed_face_value_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;    
   _stencil_val(fs.y,-1,i,0);_stencil_val(fs.y,1,i,0);
_stencil_val(fs.y,o_stencil,i,0); _stencil_val(fs.x,o_stencil,i,0    ); _stencil_val(fs.x,o_stencil,i-1,0    ); _stencil_val(cs,o_stencil,i,0); _stencil_val(cs,o_stencil,i-1,0); 
_stencil_val(fs.y,0,i,0);_stencil_val(a,0,i,0); _stencil_val(cs,0,i,0); _stencil_val(a,0,i-1,0); _stencil_val(cs,0,i-1,0);_stencil_val(cs,0,i,0); _stencil_val(cs,0,i-1,0); _stencil_val(fs.y,0,i,0);_stencil_val(a,o_stencil,i,0); _stencil_val(cs,o_stencil,i,0); _stencil_val(a,o_stencil,i-1,0); _stencil_val(cs,o_stencil,i-1,0);_stencil_val(cs,o_stencil,i,0); _stencil_val(cs,o_stencil,i-1,0);
_stencil_val(a,0,i,0); _stencil_val(cs,0,i,0); _stencil_val(a,0,i-1,0); _stencil_val(cs,0,i-1,0);_stencil_val(cs,0,i,0); _stencil_val(cs,0,i-1,0);
  
#line 86
return                  
                    
    ;
}
#line 178 "././embed-update-2.h"

#line 223 "././embed-update-2.h"
static inline
double embed_geometry (Point point, coord * p, coord * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  *n = facet_normal (point, cs, fs);
  double alpha = line_alpha (val(cs,0,0,0), *n);
  double area = line_length_center(*n,alpha,p);
  normalize (n);
  return area;
}
#line 223 "././embed-update-2.h"
static void 
_stencil_embed_geometry (Point point,_stencil_undefined  * p,_stencil_undefined  * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 
_stencil_facet_normal (point, cs, fs);     
   
  
#line 227
_stencil_val(cs,0,0,0);   
   
  
  return ;
}





static inline
double embed_area_center (Point point, double * x1, double * y1, double * z1)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double area = 0.;
  if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
    coord n, p;
    area = embed_geometry (point, &p, &n);
    *x1 += p.x*Delta, *y1 += p.y*Delta, *z1 += p.z*Delta;
  }
  return area;
}
#line 256 "././embed-update-2.h"
double embed_interpolate (Point point, scalar s, coord p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (!(2 == 2)) qassert ("././embed-update-2.h", 258, "dimension == 2");
  int i = sign(p.x), j = sign(p.y);
  if (val(cs,i,0,0) && val(cs,0,j,0) && val(cs,i,j,0))

    return ((val(s,0,0,0)*(1. - fabs(p.x)) + val(s,i,0,0)*fabs(p.x))*(1. - fabs(p.y)) +
     (val(s,0,j,0)*(1. - fabs(p.x)) + val(s,i,j,0)*fabs(p.x))*fabs(p.y));
  else {


    double val = val(s,0,0,0);
     {
      int i = sign(p.x);
      if (val(cs,i,0,0))
 val += fabs(p.x)*(val(s,i,0,0) - val(s,0,0,0));
      else if (val(cs,-i,0,0))
 val += fabs(p.x)*(val(s,0,0,0) - val(s,-i,0,0));
    } 
#line 268
{
      int i = sign(p.y);
      if (val(cs,0,i,0))
 val += fabs(p.y)*(val(s,0,i,0) - val(s,0,0,0));
      else if (val(cs,0,-i,0))
 val += fabs(p.y)*(val(s,0,0,0) - val(s,0,-i,0));
    }
    return val;
  }
}
#line 256 "././embed-update-2.h"
static void _stencil_embed_interpolate (Point point, scalar s,_stencil_undefined * p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;         
      
  
_stencil_val(cs,o_stencil,0,0); _stencil_val(cs,0,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0);{

    {_stencil_val(s,0,0,0);_stencil_val(s, o_stencil,0,0);
_stencil_val(s,0,o_stencil,0); _stencil_val(s,o_stencil,o_stencil,0);         
      
#line 263
} 
{  


     _stencil_val(s,0,0,0);
     {   
      
_stencil_val(cs,o_stencil,0,0);{
 {_stencil_val(s,o_stencil,0,0); _stencil_val(s,0,0,0);   } 
{_stencil_val(cs,o_stencil,0,0);
 {_stencil_val(s,0,0,0);_stencil_val(s, o_stencil,0,0);   } }}
       
      
    
#line 274
} 
#line 268
{   
      
_stencil_val(cs,0,o_stencil,0);{
 {_stencil_val(s,0,o_stencil,0); _stencil_val(s,0,0,0);   } 
{_stencil_val(cs,0,o_stencil,0);
 {_stencil_val(s,0,0,0);_stencil_val(s,0, o_stencil,0);   } }}
       
      
    
#line 274
} 
    
  }}
     
  

#line 277
}
#line 286 "././embed-update-2.h"
struct Cleanup {
  scalar c;
  vector s;
  double smin;
  bool opposite;
};

     
int fractions_cleanup (struct Cleanup p)
{tracing("fractions_cleanup","././embed-update-2.h",294);
  scalar c = p.c;
  vector s = p.s;







  int changed = 1, schanged = 0, i;
  for (i = 0; i < 100 && changed; i++) {




    foreach_face_stencil(){_stencil_is_face_x(){
      {_stencil_val(s.x,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,-1,0,0); _stencil_val(s.x,0,0,0);
 {_stencil_val_a(s.x,0,0,0);  }        }}end__stencil_is_face_x()
#line 311
_stencil_is_face_y(){
      {_stencil_val(s.y,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,-1,0); _stencil_val(s.y,0,0,0);
 {_stencil_val_a(s.y,0,0,0);  }        }}end__stencil_is_face_y()}end_foreach_face_stencil();




    {
#line 311
foreach_face_generic(){is_face_x(){
      if (val(s.x,0,0,0) && ((!val(c,0,0,0) || !val(c,-1,0,0)) || val(s.x,0,0,0) < p.smin))
 val(s.x,0,0,0) = 0.;}end_is_face_x()
#line 311
is_face_y(){
      if (val(s.y,0,0,0) && ((!val(c,0,0,0) || !val(c,0,-1,0)) || val(s.y,0,0,0) < p.smin))
 val(s.y,0,0,0) = 0.;}end_is_face_y()}end_foreach_face_generic();}

    changed = 0;
    foreach_stencil()
      {_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
 
  {
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.x,i,0,0);
          } 









_stencil_val(s.x,0,0,0); _stencil_val(s.x,1,0,0);
     {_stencil_val_a(c,0,0,0);   }
#line 332 "././embed-update-2.h"
          
 
} 
#line 319
{
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.y,0,i,0);
          } 









_stencil_val(s.y,0,0,0); _stencil_val(s.y,0,1,0);
     {_stencil_val_a(c,0,0,0);   }
#line 332 "././embed-update-2.h"
          
 
}
   







{_stencil_val_a(c,0,0,0);   }







    
      
#line 344
}      }end_foreach_stencil();
    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:changed)){
#line 316
foreach()
      if (val(c,0,0,0) > 0. && val(c,0,0,0) < 1.) {
 int n = 0;
  {
   for (int i = 0; i <= 1; i++)
     if (val(s.x,i,0,0) > 0.)
       n++;
#line 332 "././embed-update-2.h"
   if (p.opposite && val(s.x,0,0,0) == 0. && val(s.x,1,0,0) == 0.)
     val(c,0,0,0) = 0., changed++;
 } 
#line 319
{
   for (int i = 0; i <= 1; i++)
     if (val(s.y,0,i,0) > 0.)
       n++;
#line 332 "././embed-update-2.h"
   if (p.opposite && val(s.y,0,0,0) == 0. && val(s.y,0,1,0) == 0.)
     val(c,0,0,0) = 0., changed++;
 }







 if (n < 2)
   val(c,0,0,0) = 0., changed++;
      }end_foreach();mpi_all_reduce_array(&changed,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}

    
#line 346
schanged += changed;
  }
  if (changed)
    fprintf (ferr, "WARNING: fractions_cleanup() did not converge after "
      "%d iterations\n", i);
  {end_tracing("fractions_cleanup","././embed-update-2.h",351);return schanged;}
end_tracing("fractions_cleanup","././embed-update-2.h",352);}
#line 376 "././embed-update-2.h"

static inline double dirichlet_gradient_x (Point point, scalar s, scalar cs,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  
    n.x = - n.x;
    
#line 382
n.y = - n.y;
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  
    if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;
    
#line 386
if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(n.x);
      d[l] = (i - p.x)/n.x;
      double y1 = p.y + d[l]*n.y;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(fs.x,i + (i < 0),j,0) && val(fs.y,i,j,0) && val(fs.y,i,j+1,0) &&
   val(cs,i,j-1,0) && val(cs,i,j,0) && val(cs,i,j+1,0))
 v[l] = ((((val(s,i,j-1,0)))*((y1) - 1.) + ((val(s,i,j+1,0)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,0)))*((y1) - 1.)*((y1) + 1.));
#line 420 "././embed-update-2.h"
      else
 break;
    }
  if (v[0] == HUGE) {





    d[0] = max(1e-3, fabs(p.x/n.x));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != HUGE)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}

#line 377
static inline double dirichlet_gradient_y (Point point, scalar s, scalar cs,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  
    n.y = - n.y;
    
#line 382
n.x = - n.x;
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  
    if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;
    
#line 386
if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(n.y);
      d[l] = (i - p.y)/n.y;
      double y1 = p.x + d[l]*n.x;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(fs.y,j,i + (i < 0),0) && val(fs.x,j,i,0) && val(fs.x,j+1,i,0) &&
   val(cs,j-1,i,0) && val(cs,j,i,0) && val(cs,j+1,i,0))
 v[l] = ((((val(s,j-1,i,0)))*((y1) - 1.) + ((val(s,j+1,i,0)))*((y1) + 1.))*(y1)/2. - ((val(s,j,i,0)))*((y1) - 1.)*((y1) + 1.));
#line 420 "././embed-update-2.h"
      else
 break;
    }
  if (v[0] == HUGE) {





    d[0] = max(1e-3, fabs(p.y/n.y));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != HUGE)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}
#line 376 "././embed-update-2.h"

static void _stencil_dirichlet_gradient_x (Point point, scalar s, scalar cs,
_stencil_undefined *
        
#line 378
n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined 
        
#line 379
* coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;       
  
       
  
  
  
    {_stencil_val(fs.x,o_stencil,0,0  ); 
          }
    
#line 386
{_stencil_val(fs.y,0,o_stencil,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
      
      
        

_stencil_val(fs.x,    o_stencil,o_stencil,0); _stencil_val(fs.y,o_stencil,o_stencil,0); _stencil_val(fs.y,o_stencil,o_stencil,0);
   _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0);
#line 396
{
 
{_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);              }
 
#line 421
}

            
#line 420 "././embed-update-2.h"
      
    
}         
     
   
     





   
     
  







return   ;
}

#line 377
static void _stencil_dirichlet_gradient_y (Point point, scalar s, scalar cs,
_stencil_undefined *
        
#line 378
n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined 
        
#line 379
* coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;       
  
       
  
  
  
    {_stencil_val(fs.y,0,o_stencil,0  ); 
          }
    
#line 386
{_stencil_val(fs.x,o_stencil,0,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
      
      
        

_stencil_val(fs.y,o_stencil,    o_stencil,0); _stencil_val(fs.x,o_stencil,o_stencil,0); _stencil_val(fs.x,o_stencil,o_stencil,0);
   _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0);
#line 396
{
 
{_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);              }
 
#line 421
}

            
#line 420 "././embed-update-2.h"
      
    
}         
     
   
     





   
     
  







return   ;
}


static inline double dirichlet_gradient_direction_x (Point point, scalar s, scalar cs,
        coord n, coord direction, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {
    direction.x = - direction.x;
    n.x = -n.x ;
  }
#line 449
{
    direction.y = - direction.y;
    n.y = -n.y ;
  }
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  

    if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;

    
#line 457
if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(direction.x);
      d[l] = (i - p.x)/direction.x;
      double y1 = p.y + d[l]*direction.y;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(fs.x,i + (i < 0),j,0) && val(fs.y,i,j,0) && val(fs.y,i,j+1,0) &&
   val(cs,i,j-1,0) && val(cs,i,j,0) && val(cs,i,j+1,0))
 v[l] = ((((val(s,i,j-1,0)))*((y1) - 1.) + ((val(s,i,j+1,0)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,0)))*((y1) - 1.)*((y1) + 1.));
#line 491 "././embed-update-2.h"
      else
 break;
    }
  if (v[0] == HUGE) {





    d[0] = max(1e-3, fabs(p.x/direction.x));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != HUGE)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}

#line 445
static inline double dirichlet_gradient_direction_y (Point point, scalar s, scalar cs,
        coord n, coord direction, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {
    direction.y = - direction.y;
    n.y = -n.y ;
  }
#line 449
{
    direction.x = - direction.x;
    n.x = -n.x ;
  }
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  

    if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;

    
#line 457
if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(direction.y);
      d[l] = (i - p.y)/direction.y;
      double y1 = p.x + d[l]*direction.x;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(fs.y,j,i + (i < 0),0) && val(fs.x,j,i,0) && val(fs.x,j+1,i,0) &&
   val(cs,j-1,i,0) && val(cs,j,i,0) && val(cs,j+1,i,0))
 v[l] = ((((val(s,j-1,i,0)))*((y1) - 1.) + ((val(s,j+1,i,0)))*((y1) + 1.))*(y1)/2. - ((val(s,j,i,0)))*((y1) - 1.)*((y1) + 1.));
#line 491 "././embed-update-2.h"
      else
 break;
    }
  if (v[0] == HUGE) {





    d[0] = max(1e-3, fabs(p.y/direction.y));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != HUGE)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}



#line 445
static void _stencil_dirichlet_gradient_direction_x (Point point, scalar s, scalar cs,
_stencil_undefined *
        
#line 446
n,_stencil_undefined * direction,_stencil_undefined * p, double bc,
_stencil_undefined 
        
#line 447
* coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;       
  
       
       
  
  
  
  

    {_stencil_val(fs.x,o_stencil,0,0  ); 
          }

    
#line 457
{_stencil_val(fs.y,0,o_stencil,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
      
      
        

_stencil_val(fs.x,    o_stencil,o_stencil,0); _stencil_val(fs.y,o_stencil,o_stencil,0); _stencil_val(fs.y,o_stencil,o_stencil,0);
   _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0);
#line 467
{
 
{_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);              }
 
#line 492
}

            
#line 491 "././embed-update-2.h"
      
    
}         
     
   
     





   
     
  







return   ;
}

#line 445
static void _stencil_dirichlet_gradient_direction_y (Point point, scalar s, scalar cs,
_stencil_undefined *
        
#line 446
n,_stencil_undefined * direction,_stencil_undefined * p, double bc,
_stencil_undefined 
        
#line 447
* coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;       
  
       
       
  
  
  
  

    {_stencil_val(fs.y,0,o_stencil,0  ); 
          }

    
#line 457
{_stencil_val(fs.x,o_stencil,0,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
      
      
        

_stencil_val(fs.y,o_stencil,    o_stencil,0); _stencil_val(fs.x,o_stencil,o_stencil,0); _stencil_val(fs.x,o_stencil,o_stencil,0);
   _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0);
#line 467
{
 
{_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);              }
 
#line 492
}

            
#line 491 "././embed-update-2.h"
      
    
}         
     
   
     





   
     
  







return   ;
}


double dirichlet_gradient (Point point, scalar s, scalar cs,
      coord n, coord p, double bc, double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  
    if (fabs(n.x) >= fabs(n.y))
      return dirichlet_gradient_x (point, s, cs, n, p, bc, coef);
    
#line 521
if (fabs(n.y) >= fabs(n.x))
      return dirichlet_gradient_y (point, s, cs, n, p, bc, coef);
#line 532 "././embed-update-2.h"
  return HUGE;
}



#line 516
static void _stencil_dirichlet_gradient (Point point, scalar s, scalar cs,
_stencil_undefined *
      
#line 517
n,_stencil_undefined * p,_stencil_undefined * bc,_stencil_undefined  * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  
      
{ _stencil_dirichlet_gradient_x (point, s, cs,NULL ,NULL ,NULL ,NULL );}
      
#line 522
{ _stencil_dirichlet_gradient_y (point, s, cs,NULL ,NULL ,NULL ,NULL );}
       
#line 532 "././embed-update-2.h"
  return ;
}

double dirichlet_gradient_direction (Point point, scalar s, scalar cs,
      coord n, coord* direction, coord* p, double bc, double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord direction1,p1;
  {
    direction1.x = direction->x;
    p1.x = p->x;
  }
#line 539
{
    direction1.y = direction->y;
    p1.y = p->y;
  }

  
    if (fabs(direction1.x) >= fabs(direction1.y))
      return dirichlet_gradient_direction_x (point, s, cs, n, direction1, p1, bc, coef);
    
#line 545
if (fabs(direction1.y) >= fabs(direction1.x))
      return dirichlet_gradient_direction_y (point, s, cs, n, direction1, p1, bc, coef);
#line 556 "././embed-update-2.h"
  return HUGE;
}


#line 535
static void _stencil_dirichlet_gradient_direction (Point point, scalar s, scalar cs,
_stencil_undefined *
      
#line 536
n,_stencil_undefined * direction,_stencil_undefined * p, double bc,_stencil_undefined  * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 
  
    
     
     
  

  
      
{ _stencil_dirichlet_gradient_direction_x (point, s, cs,NULL ,NULL ,NULL , bc,NULL );}
      
#line 546
{ _stencil_dirichlet_gradient_direction_y (point, s, cs,NULL ,NULL ,NULL , bc,NULL );}
       
#line 556 "././embed-update-2.h"
  return ;
}

bid embed;
#line 568 "././embed-update-2.h"
static inline
coord embed_gradient (Point point, vector u, coord p, coord n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord dudn;
   {
    bool dirichlet;
    double vb = _attribute[u.x.i].boundary[embed] (point, point, u.x, &dirichlet);
    if (dirichlet) {
      double val;
      dudn.x = dirichlet_gradient (point, u.x, cs, n, p, vb, &val);
    }
    else
      dudn.x = vb;
    if (dudn.x == HUGE)
      dudn.x = 0.;
  } 
#line 572
{
    bool dirichlet;
    double vb = _attribute[u.y.i].boundary[embed] (point, point, u.y, &dirichlet);
    if (dirichlet) {
      double val;
      dudn.y = dirichlet_gradient (point, u.y, cs, n, p, vb, &val);
    }
    else
      dudn.y = vb;
    if (dudn.y == HUGE)
      dudn.y = 0.;
  }
  return dudn;
}
#line 568 "././embed-update-2.h"
static void 
_stencil_embed_gradient (Point point, vector u,_stencil_undefined * p,_stencil_undefined * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 
  
   {   
    
    default_stencil ( point,((scalar[]){ u.x,{-1}}) ); 
{ 
       
_stencil_dirichlet_gradient (point, u.x, cs,NULL ,NULL ,NULL ,NULL ); 
      
    
#line 578
}   
     
    
        
     
       
  
#line 583
} 
#line 572
{   
    
    default_stencil ( point,((scalar[]){ u.y,{-1}}) ); 
{ 
       
_stencil_dirichlet_gradient (point, u.y, cs,NULL ,NULL ,NULL ,NULL ); 
      
    
#line 578
}   
     
    
        
     
       
  
#line 583
}
  return ;
}
#line 606 "././embed-update-2.h"
     
void embed_force (scalar p, vector u, vector mu, coord * Fp, coord * Fmu)
{tracing("embed_force","././embed-update-2.h",607);
  coord Fps = {0}, Fmus = {0};

  foreach_stencil ()
    {_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); {    






      
       _stencil_embed_geometry (point,NULL ,NULL );   
            
      _stencil_embed_interpolate (point, p,NULL );
       
  
#line 633 "././embed-update-2.h"
      if (constant(mu.x) != 0.) {      
 
  { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
     _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); 
    
 
#line 638
} 
#line 635
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
     _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); 
    
 
#line 638
}  
      
#line 698 "././embed-update-2.h"
     
  _stencil_embed_gradient (point, u,NULL ,NULL );
  
        
      }
    }      }end_foreach_stencil();

  
#line 611
if(!is_constant(fm.x)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:Fmus)reduction(+:Fps)){
#line 611
foreach ()
    if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {






      coord n, b;
      double area = embed_geometry (point, &b, &n);
      area *= pow (Delta, 2 - 1);
      double Fn = area*embed_interpolate (point, p, b);
      
 Fps.x += Fn*n.x;
 
#line 624
Fps.y += Fn*n.y;
#line 633 "././embed-update-2.h"
      if (constant(mu.x) != 0.) {
 double mua = 0., fa = 0.;
  {
   mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
   fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
 } 
#line 635
{
   mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
   fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
 }
 mua /= fa;
#line 698 "././embed-update-2.h"
 if (!(2 == 2)) qassert ("././embed-update-2.h", 698, "dimension == 2");
 coord dudn = embed_gradient (point, u, b, n);
 
   Fmus.x -= area*mua*(dudn.x*(sq(n.x) + 1.) + dudn.y*n.x*n.y);
   
#line 701
Fmus.y -= area*mua*(dudn.y*(sq(n.y) + 1.) + dudn.x*n.y*n.x);
      }
    }end_foreach();mpi_all_reduce_array(&Fmus.x,double,MPI_SUM,2);mpi_all_reduce_array(&Fps.x,double,MPI_SUM,2);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 703
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);

  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:Fmus)reduction(+:Fps)){
#line 611
foreach ()
    if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {






      coord n, b;
      double area = embed_geometry (point, &b, &n);
      area *= pow (Delta, 2 - 1);
      double Fn = area*embed_interpolate (point, p, b);
      
 Fps.x += Fn*n.x;
 
#line 624
Fps.y += Fn*n.y;
#line 633 "././embed-update-2.h"
      if (constant(mu.x) != 0.) {
 double mua = 0., fa = 0.;
  {
   mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
   fa += _const_fm.x + _const_fm.x;
 } 
#line 635
{
   mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
   fa += _const_fm.y + _const_fm.y;
 }
 mua /= fa;
#line 698 "././embed-update-2.h"
 if (!(2 == 2)) qassert ("././embed-update-2.h", 698, "dimension == 2");
 coord dudn = embed_gradient (point, u, b, n);
 
   Fmus.x -= area*mua*(dudn.x*(sq(n.x) + 1.) + dudn.y*n.x*n.y);
   
#line 701
Fmus.y -= area*mua*(dudn.y*(sq(n.y) + 1.) + dudn.x*n.y*n.x);
      }
    }end_foreach();mpi_all_reduce_array(&Fmus.x,double,MPI_SUM,2);mpi_all_reduce_array(&Fps.x,double,MPI_SUM,2);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 703
}

  *Fp = Fps; *Fmu = Fmus;
end_tracing("embed_force","././embed-update-2.h",706);}
#line 715 "././embed-update-2.h"
double embed_vorticity (Point point, vector u, coord p, coord n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  coord dudn = embed_gradient (point, u, p, n);
#line 732 "././embed-update-2.h"
  return dudn.y*n.x - dudn.x*n.y;
}
#line 754 "././embed-update-2.h"
double embed_flux (Point point, scalar s, vector mu, double * val)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

#line 755
if(!is_constant(fm.x)){{





  *val = 0.;
  if (val(cs,0,0,0) >= 1. || val(cs,0,0,0) <= 0.)
    return 0.;





  bool dirichlet;
  double grad = _attribute[s.i].boundary[embed] (point, point, s, &dirichlet);
  if (!grad && !dirichlet)
    return 0.;





  coord n = facet_normal (point, cs, fs), p;
  double alpha = line_alpha (val(cs,0,0,0), n);
  double area = line_length_center(n,alpha,&p);
  if (metric_embed_factor)
    area *= metric_embed_factor (point, p);





  double coef = 0.;
  if (dirichlet) {
    normalize (&n);
    grad = dirichlet_gradient (point, s, cs, n, p, grad, &coef);
  }




  double mua = 0., fa = 0.;
   {
    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
    fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
  } 
#line 798
{
    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
    fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
  }
  *val = - mua/(fa + 1e-30)*grad*area/Delta;
  return - mua/(fa + 1e-30)*coef*area/Delta;
}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);

#line 755
{





  *val = 0.;
  if (val(cs,0,0,0) >= 1. || val(cs,0,0,0) <= 0.)
    return 0.;





  bool dirichlet;
  double grad = _attribute[s.i].boundary[embed] (point, point, s, &dirichlet);
  if (!grad && !dirichlet)
    return 0.;





  coord n = facet_normal (point, cs, fs), p;
  double alpha = line_alpha (val(cs,0,0,0), n);
  double area = line_length_center(n,alpha,&p);
  if (metric_embed_factor)
    area *= metric_embed_factor (point, p);





  double coef = 0.;
  if (dirichlet) {
    normalize (&n);
    grad = dirichlet_gradient (point, s, cs, n, p, grad, &coef);
  }




  double mua = 0., fa = 0.;
   {
    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
    fa += _const_fm.x + _const_fm.x;
  } 
#line 798
{
    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
    fa += _const_fm.y + _const_fm.y;
  }
  *val = - mua/(fa + 1e-30)*grad*area/Delta;
  return - mua/(fa + 1e-30)*coef*area/Delta;
}}

#line 804
}
#line 754 "././embed-update-2.h"
static void _stencil_embed_flux (Point point, scalar s, vector mu,_stencil_undefined  * val)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 





   
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);    
    
        





  
  
#line 770
default_stencil ( point,((scalar[]){ s,{-1}}) );    
    
     





   _stencil_facet_normal (point, cs, fs);     
  _stencil_val(cs,0,0,0);      
   
   
    





   
{ 

_stencil_dirichlet_gradient (point, s, cs,NULL , NULL,NULL ,NULL ); 
    
     
  
#line 792
}      
   




  
   
#line 798
{ 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
      _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); 
     
  
#line 801
} 
#line 798
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
      _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); 
     
  
#line 801
}
       
  return    ;
}

double embed_flux_direction (Point point, scalar s, vector mu, coord direction, double bc, double * val)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

#line 807
if(!is_constant(fm.x)){{





  *val = 0.;
  if (val(cs,0,0,0) >= 1. || val(cs,0,0,0) <= 0.)
    return 0.;





  bool dirichlet;

  double grad = 0.0;







  coord n = facet_normal (point, cs, fs), p;
  double alpha = line_alpha (val(cs,0,0,0), n);
  double area = line_length_center(n,alpha,&p);
  if (metric_embed_factor)
    area *= metric_embed_factor (point, p);





  double coef = 0.;

    normalize (&n);
    normalize (&direction);

    grad = dirichlet_gradient_direction (point, s, cs, n, &direction, &p, bc, &coef);





  double mua = 0., fa = 0.;
   {
    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
    fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
  } 
#line 853
{
    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
    fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
  }
  *val = - mua/(fa + 1e-30)*grad*area/Delta;
  return - mua/(fa + 1e-30)*coef*area/Delta;
}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);

#line 807
{





  *val = 0.;
  if (val(cs,0,0,0) >= 1. || val(cs,0,0,0) <= 0.)
    return 0.;





  bool dirichlet;

  double grad = 0.0;







  coord n = facet_normal (point, cs, fs), p;
  double alpha = line_alpha (val(cs,0,0,0), n);
  double area = line_length_center(n,alpha,&p);
  if (metric_embed_factor)
    area *= metric_embed_factor (point, p);





  double coef = 0.;

    normalize (&n);
    normalize (&direction);

    grad = dirichlet_gradient_direction (point, s, cs, n, &direction, &p, bc, &coef);





  double mua = 0., fa = 0.;
   {
    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
    fa += _const_fm.x + _const_fm.x;
  } 
#line 853
{
    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
    fa += _const_fm.y + _const_fm.y;
  }
  *val = - mua/(fa + 1e-30)*grad*area/Delta;
  return - mua/(fa + 1e-30)*coef*area/Delta;
}}

#line 859
}


#line 806
static void _stencil_embed_flux_direction (Point point, scalar s, vector mu,_stencil_undefined * direction, double bc,_stencil_undefined  * val)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 





   
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);        
    
        





  

  







   
#line 831
_stencil_facet_normal (point, cs, fs);     
  _stencil_val(cs,0,0,0);      
   
   
    





   




_stencil_dirichlet_gradient_direction (point, s, cs,NULL ,NULL ,NULL , bc,NULL );         

    
    

    





  
   
#line 853
{ 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
      _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); 
     
  
#line 856
} 
#line 853
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
      _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); 
     
  
#line 856
}
       
  return    ;
}
#line 868 "././embed-update-2.h"
#undef neumann
#define neumann(expr) (data ? embed_area_center (point, &x, &y, &z),\
        *((bool *)data) = false, (expr) :\
        Delta*(expr) + val(_s,0,0,0))\

#line 872

#undef neumann_homogeneous
#define neumann_homogeneous() (data ? *((bool *)data) = false, (0) :\
       val(_s,0,0,0))\

#line 876

#undef dirichlet
#define dirichlet(expr) (data ? embed_area_center (point, &x, &y, &z),\
        *((bool *)data) = true, (expr) :\
        2.*(expr) - val(_s,0,0,0))\

#line 881

#undef dirichlet_homogeneous
#define dirichlet_homogeneous() (data ? *((bool *)data) = true, (0) :\
         - val(_s,0,0,0))\

#line 885

#line 896 "././embed-update-2.h"
static inline double bilinear_embed (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (!coarse(cs,0,0,0) || !coarse(cs,child.x,0,0))
    return coarse(s,0,0,0);

  if (!coarse(cs,0,child.y,0) || !coarse(cs,child.x,child.y,0))
    return coarse(s,0,0,0);







  return bilinear (point, s);
}
#line 943 "././embed-update-2.h"
     
void update_tracer (scalar f, vector uf, vector flux, double dt)
{tracing("update_tracer","././embed-update-2.h",944);
#line 955 "././embed-update-2.h"
  scalar  e=new_scalar("e");
  foreach_stencil() {




_stencil_val(cs,0,0,0);{
      {_stencil_val_a(e,0,0,0);  } 






{_stencil_val(cs,0,0,0);{ {
      {

          _stencil_val_r(f,0,0,0);_stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);_stencil_val(cm,0,0,0);   

      }
#line 970
{

          _stencil_val_r(f,0,0,0);_stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);_stencil_val(cm,0,0,0);   

      }
      _stencil_val_a(e,0,0,0);  
    } 
#line 987
{   
      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(uf.x,i,0,0);
     {_stencil_val(uf.x,i,0,0);  }   }
   
#line 991
{_stencil_val(uf.y,0,i,0);
     {_stencil_val(uf.y,0,i,0);  }   }}     
      _stencil_val(cm,0,0,0);   




      
      
 { _stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);  }
 
#line 1000
{ _stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);  }
_stencil_val(cm,0,0,0);






{ {
 _stencil_val_r(f,0,0,0);  
 _stencil_val_a(e,0,0,0);  
      } 







{
 _stencil_val_r(f,0,0,0);     
 
 {foreach_neighbor(1)
   {_stencil_val(cm,0,0,0);  }end_foreach_neighbor()}
 _stencil_val_a(e,0,0,0);_stencil_val(cm,0,0,0);    
      }}
        






         







      
    
#line 1026
}}   
#line 987 "././embed-update-2.h"
    
#line 1026
}}




       






    
  
#line 1027
}end_foreach_stencil();
  
#line 956
if(!is_constant(cm)){{foreach() {




    if (val(cs,0,0,0) <= 0.)
      val(e,0,0,0) = 0.;






    else if (val(cs,0,0,0) >= 1.) {
      {

          val(f,0,0,0) += dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/(val(cm,0,0,0)*Delta);

      }
#line 970
{

          val(f,0,0,0) += dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/(val(cm,0,0,0)*Delta);

      }
      val(e,0,0,0) = 0.;
    }
#line 987 "././embed-update-2.h"
    else {
      double umax = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (fabs(val(uf.x,i,0,0)) > umax)
     umax = fabs(val(uf.x,i,0,0));
   
#line 991
if (fabs(val(uf.y,0,i,0)) > umax)
     umax = fabs(val(uf.y,0,i,0));}
      double dtmax = Delta*val(cm,0,0,0)/(umax + 1e-30);




      double F = 0.;
      
 F += val(flux.x,0,0,0) - val(flux.x,1,0,0);
 
#line 1000
F += val(flux.y,0,0,0) - val(flux.y,0,1,0);
      F /= Delta*val(cm,0,0,0);






      if (dt <= dtmax) {
 val(f,0,0,0) += dt*F;
 val(e,0,0,0) = 0.;
      }







      else {
 val(f,0,0,0) += dtmax*F;
 double scs = 0.;
 {foreach_neighbor(1)
   scs += sq(val(cm,0,0,0));end_foreach_neighbor()}
 val(e,0,0,0) = (dt - dtmax)*F*val(cm,0,0,0)/scs;
      }
    }
  }end_foreach();}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  {
#line 956
foreach() {




    if (val(cs,0,0,0) <= 0.)
      val(e,0,0,0) = 0.;






    else if (val(cs,0,0,0) >= 1.) {
      {

          val(f,0,0,0) += dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/(_const_cm*Delta);

      }
#line 970
{

          val(f,0,0,0) += dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/(_const_cm*Delta);

      }
      val(e,0,0,0) = 0.;
    }
#line 987 "././embed-update-2.h"
    else {
      double umax = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (fabs(val(uf.x,i,0,0)) > umax)
     umax = fabs(val(uf.x,i,0,0));
   
#line 991
if (fabs(val(uf.y,0,i,0)) > umax)
     umax = fabs(val(uf.y,0,i,0));}
      double dtmax = Delta*_const_cm/(umax + 1e-30);




      double F = 0.;
      
 F += val(flux.x,0,0,0) - val(flux.x,1,0,0);
 
#line 1000
F += val(flux.y,0,0,0) - val(flux.y,0,1,0);
      F /= Delta*_const_cm;






      if (dt <= dtmax) {
 val(f,0,0,0) += dt*F;
 val(e,0,0,0) = 0.;
      }







      else {
 val(f,0,0,0) += dtmax*F;
 double scs = 0.;
 {foreach_neighbor(1)
   scs += sq(_const_cm);end_foreach_neighbor()}
 val(e,0,0,0) = (dt - dtmax)*F*_const_cm/scs;
      }
    }
  }end_foreach();}}





  foreach_stencil() {   
    
    {foreach_neighbor(1)
      { _stencil_val(e,0,0,0); }end_foreach_neighbor()}
    _stencil_val_r(f,0,0,0); _stencil_val(cs,0,0,0); 
  }end_foreach_stencil();





  {
#line 1033
foreach() {
    double se = 0.;
    {foreach_neighbor(1)
      se += val(e,0,0,0);end_foreach_neighbor()}
    val(f,0,0,0) += val(cs,0,0,0)*se;
  }end_foreach();}delete((scalar*)((scalar[]){e,{-1}}));
end_tracing("update_tracer","././embed-update-2.h",1039);}
#line 1052 "././embed-update-2.h"
static int metric_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int metric(const int i,const double t,Event *_ev){tracing("metric","././embed-update-2.h",1052);
{
  if (is_constant (fm.x)) {
    
      if (!(constant (fm.x) == 1.)) qassert ("././embed-update-2.h", 1056, "constant (fm.x) == 1.");
      
#line 1056
if (!(constant (fm.y) == 1.)) qassert ("././embed-update-2.h", 1056, "constant (fm.x) == 1.");
    fm = fs;
  }
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(fs.x,0,0,0);  }}end__stencil_is_face_x()
#line 1059
_stencil_is_face_y(){
    {_stencil_val_a(fs.y,0,0,0);  }}end__stencil_is_face_y()}end_foreach_face_stencil();
  {
#line 1059
foreach_face_generic(){is_face_x(){
    val(fs.x,0,0,0) = 1.;}end_is_face_x()
#line 1059
is_face_y(){
    val(fs.y,0,0,0) = 1.;}end_is_face_y()}end_foreach_face_generic();}
  if (is_constant (cm)) {
    if (!(constant (cm) == 1.)) qassert ("././embed-update-2.h", 1062, "constant (cm) == 1.");
    cm = cs;
  }
  foreach_stencil()
    {_stencil_val_a(cs,0,0,0);  }end_foreach_stencil();
  {
#line 1065
foreach()
    val(cs,0,0,0) = 1.;end_foreach();}


  _attribute[cs.i].refine = embed_fraction_refine;
#line 1079 "././embed-update-2.h"
  _attribute[cs.i].prolongation = fraction_refine;
  
    _attribute[fs.x.i].prolongation = embed_face_fraction_refine_x;
    
#line 1081
_attribute[fs.y.i].prolongation = embed_face_fraction_refine_y;







  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
}{end_tracing("metric","././embed-update-2.h",1090);return 0;}end_tracing("metric","././embed-update-2.h",1090);}




static int defaults_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int defaults(const int i,const double t,Event *_ev){tracing("defaults","././embed-update-2.h",1095); {
  display ((struct _display){"draw_vof (c = 'cs', s = 'fs', filled = -1, "
    "fc = {0.5,0.5,0.5}, order = 2);"});
}{end_tracing("defaults","././embed-update-2.h",1098);return 0;}end_tracing("defaults","././embed-update-2.h",1098);}
#line 4 "template01.c"


#line 1 "./axi-official-update.h"
#line 1 "././axi-official-update.h"
#line 20 "././axi-official-update.h"
static void refine_cm_axi (Point point, scalar cm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
    coord n = mycs (point, cs);


    {foreach_child() {
      if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
 coord p;
     double alpha = line_alpha (val(cs,0,0,0), n);
 line_center(n,alpha,val(cs,0,0,0),&p);
 val(cm,0,0,0) = (y + Delta*p.y)*val(cs,0,0,0);
      }
      else
 val(cm,0,0,0) = y*val(cs,0,0,0);
    }end_foreach_child()}
  }
  else
    {foreach_child()
      val(cm,0,0,0) = y*val(cs,0,0,0);end_foreach_child()}

}

static void refine_face_x_axi (Point point, scalar fm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
#line 61 "././axi-official-update.h"
  double sig = 0., fff = 0.;
  if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
    coord n = facet_normal (point, cs, fs);
    sig = sign(n.y)*Delta/4.;

  }
  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0)) {
    fff = fine(fs.x,0,0,0);


    fine(fm,0,0,0) = (y - Delta/4. - sig*(1. - fff))*fff;
    fff = fine(fs.x,0,1,0);


    fine(fm,0,1,0) = (y + Delta/4. - sig*(1. - fff))*fff;
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors) {
    fff = fine(fs.x,2,0,0);


    fine(fm,2,0,0) = (y - Delta/4. - sig*(1. - fff))*fff;
    fff = fine(fs.x,2,1,0);


    fine(fm,2,1,0) = (y + Delta/4. - sig*(1. - fff))*fff;
  }
  fff = fine(fs.x,1,0,0);


  fine(fm,1,0,0) = (y - Delta/4. - sig*(1. - fff))*fff;
  fff = fine(fs.x,1,1,0);


  fine(fm,1,1,0) = (y + Delta/4. - sig*(1. - fff))*fff;

}

static void refine_face_y_axi (Point point, scalar fm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;







  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0)) {
    fine(fm,0,0,0) = (max(y - Delta/2., 1e-20))*fine(fs.y,0,0,0) ;
    fine(fm,1,0,0) = (max(y - Delta/2., 1e-20))*fine(fs.y,1,0,0);
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors) {
    fine(fm,0,2,0) = (y + Delta/2.)*fine(fs.y,0,2,0);
    fine(fm,1,2,0) = (y + Delta/2.)*fine(fs.y,1,2,0);
  }
  fine(fm,0,1,0) = y*fine(fs.y,0,1,0);
  fine(fm,1,1,0) = y*fine(fs.y,1,1,0);



}
#line 129 "././axi-official-update.h"
double axi_factor (Point point, coord p) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  return (y + p.y*Delta);
}static double _boundary0(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 145
dirichlet(y*val(cs,0,0,0)));}}static double _boundary0_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary1(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(cs,0,0,0)));}}static double _boundary1_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}


#line 133
void cm_update (scalar cm, scalar cs, vector fs)
{
  foreach_stencil() {
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);{ {   
       _stencil_facet_normal (point, cs, fs);     
      _stencil_val(cs,0,0,0);
_stencil_val(cs,0,0,0);
      
      
#line 140
_stencil_val_a(cm,0,0,0);_stencil_val(cs,0,0,0);    
    }
      
{_stencil_val_a(cm,0,0,0);_stencil_val(cs,0,0,0);  }}
          
    
  
#line 144
}end_foreach_stencil();
  {
#line 135
foreach() {
    if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
      coord p, n = facet_normal (point, cs, fs);
      double alpha = line_alpha (val(cs,0,0,0), n);
      line_center(n,alpha,val(cs,0,0,0),&p);
      val(cm,0,0,0) = (y + Delta*p.y)*val(cs,0,0,0);
    }
    else
      val(cm,0,0,0) = y*val(cs,0,0,0);
  }end_foreach();}
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[top]=_boundary0,_attribute[cm.i].boundary_homogeneous[top]=_boundary0_homogeneous;
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[bottom]=_boundary1,_attribute[cm.i].boundary_homogeneous[bottom]=_boundary1_homogeneous;
}static double _boundary2(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 161
dirichlet(y*val(fs.x,0,0,0)));}}static double _boundary2_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary3(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(fs.x,0,0,0)));}}static double _boundary3_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}


#line 149
void fm_update (vector fm, scalar cs, vector fs)
{
  foreach_face_stencil()_stencil_is_face_x(){ {   
    
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); {  
       _stencil_facet_normal (point, cs, fs); 
       
    }
          
    
#line 157
_stencil_val_a(fm.x,0,0,0); _stencil_val(fs.x,0,0,0);_stencil_val(fs.x,0,0,0);     
  }}end__stencil_is_face_x()end_foreach_face_stencil();
  {
#line 151
foreach_face_generic()is_face_x(){ {
    double sig = 0.;
    if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
      coord n = facet_normal (point, cs, fs);
      sig = sign(n.y)*Delta/2.;
    }
    val(fm.x,0,0,0) = (y - sig*(1. - val(fs.x,0,0,0)))*val(fs.x,0,0,0);
  }}end_is_face_x()end_foreach_face_generic();}
  foreach_face_stencil()_stencil_is_face_y(){
    {_stencil_val_a(fm.y,0,0,0);_stencil_val(fs.y,0,0,0);   }}end__stencil_is_face_y()end_foreach_face_stencil();
  {
#line 159
foreach_face_generic()is_face_y(){
    val(fm.y,0,0,0) = max(y, 1e-20)*val(fs.y,0,0,0);}end_is_face_y()end_foreach_face_generic();}
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[top]=_boundary2,_attribute[fm.y.i].boundary_homogeneous[top]=_boundary2_homogeneous;
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[bottom]=_boundary3,_attribute[fm.y.i].boundary_homogeneous[bottom]=_boundary3_homogeneous;
}static double _boundary4(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 199
dirichlet(y));}}static double _boundary4_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary5(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary5_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary6(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 218
dirichlet(y));}}static double _boundary6_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary7(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary7_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}


static int metric_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}
#line 166
      static int metric_0(const int i,const double t,Event *_ev){tracing("metric_0","././axi-official-update.h",166); {







  if (is_constant(cm)) {
    scalar * l = list_copy (all);
    cm = new_scalar("cm");
    pfree (all,__func__,__FILE__,__LINE__);
    all = list_concat (((scalar[]){cm,{-1}}), l);
    pfree (l,__func__,__FILE__,__LINE__);
  }






  metric_embed_factor = axi_factor;
#line 196 "././axi-official-update.h"
  scalar cmv = cm;
  foreach_stencil()
    {_stencil_val_a(cmv,0,0,0);  }end_foreach_stencil();
  {
#line 197
foreach()
    val(cmv,0,0,0) = y;end_foreach();}
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[top]=_boundary4,_attribute[cm.i].boundary_homogeneous[top]=_boundary4_homogeneous;
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[bottom]=_boundary5,_attribute[cm.i].boundary_homogeneous[bottom]=_boundary5_homogeneous;







  if (is_constant(fm.x)) {
    scalar * l = list_copy (all);
    fm = new_face_vector("fm");
    pfree (all,__func__,__FILE__,__LINE__);
    all = list_concat ((scalar *)((vector[]){fm,{{-1},{-1}}}), l);
    pfree (l,__func__,__FILE__,__LINE__);
  }
  vector fmv = fm;
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(fmv.x,0,0,0);   }}end__stencil_is_face_x()
#line 216
_stencil_is_face_y(){
    {_stencil_val_a(fmv.y,0,0,0);   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  {
#line 216
foreach_face_generic(){is_face_x(){
    val(fmv.x,0,0,0) = max(y, 1e-20);}end_is_face_x()
#line 216
is_face_y(){
    val(fmv.y,0,0,0) = max(y, 1e-20);}end_is_face_y()}end_foreach_face_generic();}
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[top]=_boundary6,_attribute[fm.y.i].boundary_homogeneous[top]=_boundary6_homogeneous;
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[bottom]=_boundary7,_attribute[fm.y.i].boundary_homogeneous[bottom]=_boundary7_homogeneous;





  _attribute[cm.i].refine = _attribute[cm.i].prolongation = refine_cm_axi;
  _attribute[fm.x.i].prolongation = refine_face_x_axi;
  _attribute[fm.y.i].prolongation = refine_face_y_axi;

}{end_tracing("metric_0","././axi-official-update.h",229);return 0;}end_tracing("metric_0","././axi-official-update.h",229);}
#line 7 "template01.c"





#line 1 "./axi-centered.h"
#line 1 "././axi-centered.h"
#line 27 "././axi-centered.h"
#line 1 "./run.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/run.h"
#line 9 "/home/xiangbin2/basilisk_new/basilisk/src/run.h"
double dt = 1.;

#line 1 "./utils.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"







double DT = 1e10, CFL = 0.5;




struct {

  long nc;

  long tnc;

  double t;

  double speed;

  timer gt;
} perf;





void update_perf() {
  perf.nc += grid->n;
  perf.tnc += grid->tn;
  perf.t = timer_elapsed (perf.gt);
  perf.speed = perf.tnc/perf.t;
}






typedef struct {
  double cpu;
  double real;
  double speed;
  double min;
  double avg;
  double max;
  size_t tnc;
  long mem;
} timing;






timing timer_timing (timer t, int i, size_t tnc, double * mpi)
{
  timing s;
#if 1
  s.avg = mpi_time - t.tm;
#endif
  clock_t end = clock();
  s.cpu = ((double) (end - t.c))/CLOCKS_PER_SEC;
  s.real = timer_elapsed (t);
  if (tnc == 0) {
    double n = 0;
    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:n)){
#line 69
foreach() n++;end_foreach();mpi_all_reduce_array(&n,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
    
#line 70
s.tnc = n;
    tnc = n*i;
  }
  else
    s.tnc = tnc;
#if _GNU_SOURCE
  struct rusage usage;
  getrusage (RUSAGE_SELF, &usage);
  s.mem = usage.ru_maxrss;
#else
  s.mem = 0;
#endif
#if 1
  if (mpi)
    MPI_Allgather (&s.avg, 1, MPI_DOUBLE, mpi, 1, MPI_DOUBLE, MPI_COMM_WORLD);
  s.max = s.min = s.avg;
  mpi_all_reduce (s.max, MPI_DOUBLE, MPI_MAX);
  mpi_all_reduce (s.min, MPI_DOUBLE, MPI_MIN);
  mpi_all_reduce (s.avg, MPI_DOUBLE, MPI_SUM);
  mpi_all_reduce (s.real, MPI_DOUBLE, MPI_SUM);
  mpi_all_reduce (s.mem, MPI_LONG, MPI_SUM);
  s.real /= npe();
  s.avg /= npe();
  s.mem /= npe();
#else
  s.min = s.max = s.avg = 0.;
#endif
  s.speed = s.real > 0. ? tnc/s.real : -1.;
  return s;
}




void timer_print (timer t, int i, size_t tnc)
{
  timing s = timer_timing (t, i, tnc, NULL);
  fprintf (fout,
    "\n# " "Quadtree"
    ", %d steps, %g CPU, %.4g real, %.3g points.step/s, %d var\n",
    i, s.cpu, s.real, s.speed, (int) (datasize/sizeof(double)));
#if 1
  fprintf (fout,
    "# %d procs, MPI: min %.2g (%.2g%%) "
    "avg %.2g (%.2g%%) max %.2g (%.2g%%)\n",
    npe(),
    s.min, 100.*s.min/s.real,
    s.avg, 100.*s.avg/s.real,
    s.max, 100.*s.max/s.real);
#endif
}







typedef struct {
  double avg, rms, max, volume;
} norm;

norm normf (scalar f)
{
  double avg = 0., rms = 0., max = 0., volume = 0.;
  foreach_stencil(
)
    {_stencil_val(f,0,0,0);_stencil_val(cm,0,0,0); {   
      _stencil_val(f,0,0,0);   
         
_stencil_val(cm,0,0,0); 
       _stencil_val(cm,0,0,0); 
       _stencil_val(cm,0,0,0); 
       
    
#line 143
}       }end_foreach_stencil();
  
#line 135
if(!is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:volume)
   reduction(+:rms) reduction(+:avg)reduction(max:max)){
#line 135
foreach(
)
    if (val(f,0,0,0) != HUGE && (sq(Delta)*val(cm,0,0,0)) > 0.) {
      double v = fabs(val(f,0,0,0));
      if (v > max) max = v;
      volume += (sq(Delta)*val(cm,0,0,0));
      avg += (sq(Delta)*val(cm,0,0,0))*v;
      rms += (sq(Delta)*val(cm,0,0,0))*sq(v);
    }end_foreach();mpi_all_reduce_array(&volume,double,MPI_SUM,1);mpi_all_reduce_array(&rms,double,MPI_SUM,1);mpi_all_reduce_array(&avg,double,MPI_SUM,1);mpi_all_reduce_array(&max,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 143
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:volume)
   reduction(+:rms) reduction(+:avg)reduction(max:max)){
#line 135
foreach(
)
    if (val(f,0,0,0) != HUGE && (sq(Delta)*_const_cm) > 0.) {
      double v = fabs(val(f,0,0,0));
      if (v > max) max = v;
      volume += (sq(Delta)*_const_cm);
      avg += (sq(Delta)*_const_cm)*v;
      rms += (sq(Delta)*_const_cm)*sq(v);
    }end_foreach();mpi_all_reduce_array(&volume,double,MPI_SUM,1);mpi_all_reduce_array(&rms,double,MPI_SUM,1);mpi_all_reduce_array(&avg,double,MPI_SUM,1);mpi_all_reduce_array(&max,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 143
}
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}





typedef struct {
  double min, max, sum, stddev, volume;
} stats;

stats statsf (scalar f)
{
  double min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
  foreach_stencil(
)
    {_stencil_val(cm,0,0,0); _stencil_val(f,0,0,0); {
_stencil_val(cm,0,0,0); 
       _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0); 
       _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0); 
       _stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }
_stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }
         
         
    
#line 171
}      }end_foreach_stencil();
  
#line 163
if(!is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(min:min)
   reduction(max:max) reduction(+:volume) reduction(+:sum2)reduction(+:sum)){
#line 163
foreach(
)
    if ((sq(Delta)*val(cm,0,0,0)) > 0. && val(f,0,0,0) != HUGE) {
      volume += (sq(Delta)*val(cm,0,0,0));
      sum += (sq(Delta)*val(cm,0,0,0))*val(f,0,0,0);
      sum2 += (sq(Delta)*val(cm,0,0,0))*sq(val(f,0,0,0));
      if (val(f,0,0,0) > max) max = val(f,0,0,0);
      if (val(f,0,0,0) < min) min = val(f,0,0,0);
    }end_foreach();mpi_all_reduce_array(&min,double,MPI_MIN,1);mpi_all_reduce_array(&max,double,MPI_MAX,1);mpi_all_reduce_array(&volume,double,MPI_SUM,1);mpi_all_reduce_array(&sum2,double,MPI_SUM,1);mpi_all_reduce_array(&sum,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 171
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(min:min)
   reduction(max:max) reduction(+:volume) reduction(+:sum2)reduction(+:sum)){
#line 163
foreach(
)
    if ((sq(Delta)*_const_cm) > 0. && val(f,0,0,0) != HUGE) {
      volume += (sq(Delta)*_const_cm);
      sum += (sq(Delta)*_const_cm)*val(f,0,0,0);
      sum2 += (sq(Delta)*_const_cm)*sq(val(f,0,0,0));
      if (val(f,0,0,0) > max) max = val(f,0,0,0);
      if (val(f,0,0,0) < min) min = val(f,0,0,0);
    }end_foreach();mpi_all_reduce_array(&min,double,MPI_MIN,1);mpi_all_reduce_array(&max,double,MPI_MAX,1);mpi_all_reduce_array(&volume,double,MPI_SUM,1);mpi_all_reduce_array(&sum2,double,MPI_SUM,1);mpi_all_reduce_array(&sum,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 171
}
  stats s;
  s.min = min, s.max = max, s.sum = sum, s.volume = volume;
  if (volume > 0.)
    sum2 -= sum*sum/volume;
  s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
  return s;
}
#line 187 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
static double generic_limiter (double r, double beta)
{
  double v1 = min (r, beta), v2 = min (beta*r, 1.);
  v1 = max (0., v1);
  return max (v1, v2);
}

double minmod (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.)*(s1 - s0);
}

double superbee (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 2.)*(s1 - s0);
}

double sweby (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.5)*(s1 - s0);
}
#line 213 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
double theta = 1.3;

double minmod2 (double s0, double s1, double s2)
{
  if (s0 < s1 && s1 < s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 < d1) d1 = d2;
    return min(d1, d3);
  }
  if (s0 > s1 && s1 > s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 > d1) d1 = d2;
    return max(d1, d3);
  }
  return 0.;
}
#line 237 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
void gradients (scalar * f, vector * g)
{
  if (!(list_len(f) == vectors_len(g))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/utils.h", 239, "list_len(f) == vectors_len(g)");
  foreach_stencil() {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
     {_stencil_val_a(v.x,0,0,0);  }

     
{_stencil_val_a(v.x,0,0,0);_stencil_val(s,-1,0,0); _stencil_val(s,0,0,0); _stencil_val(s,1,0,0);   }}

      
   
 
#line 251
} 
#line 244
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
     {_stencil_val_a(v.y,0,0,0);  }

     
{_stencil_val_a(v.y,0,0,0);_stencil_val(s,0,-1,0); _stencil_val(s,0,0,0); _stencil_val(s,0,1,0);   }}

      
   
 
#line 251
}}
      else
 { {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
     {_stencil_val_a(v.x,0,0,0);  }

     
{_stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0);   }}

      
   
 
#line 260
} 
#line 253
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
     {_stencil_val_a(v.y,0,0,0);  }

     
{_stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0);   }}

      
   
 
#line 260
}}
    }}}
  }end_foreach_stencil();
  {
#line 240
foreach() {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {

   if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
     val(v.x,0,0,0) = 0.;
   else

     val(v.x,0,0,0) = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0))/Delta;
 } 
#line 244
{

   if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
     val(v.y,0,0,0) = 0.;
   else

     val(v.y,0,0,0) = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0))/Delta;
 }}
      else
 { {

   if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
     val(v.x,0,0,0) = 0.;
   else

     val(v.x,0,0,0) = (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta);
 } 
#line 253
{

   if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
     val(v.y,0,0,0) = 0.;
   else

     val(v.y,0,0,0) = (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta);
 }}
    }}}
  }end_foreach();}
}
#line 280 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
void vorticity (const vector u, scalar omega)
{
  foreach_stencil()
    {_stencil_val_a(omega,0,0,0);_stencil_val(fm.x,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,0,0,0);
        _stencil_val(fm.x,1,0,0);_stencil_val(u.y,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,-1,0,0);
_stencil_val(fm.y,0,1,0); _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,0,0);
        _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,-1,0); _stencil_val(fm.y,0,1,0);_stencil_val(u.x,0,1,0);_stencil_val(cm,0,0,0);      
             
#line 286
}end_foreach_stencil();
  
#line 282
if(!is_constant(fm.x) && !is_constant(cm)){{foreach()
    val(omega,0,0,0) = ((val(fm.x,1,0,0) - val(fm.x,0,0,0))*val(u.y,0,0,0) +
        val(fm.x,1,0,0)*val(u.y,1,0,0) - val(fm.x,0,0,0)*val(u.y,-1,0,0) -
        (val(fm.y,0,1,0) - val(fm.y,0,0,0))*val(u.x,0,0,0) +
        val(fm.y,0,0,0)*val(u.x,0,-1,0) - val(fm.y,0,1,0)*val(u.x,0,1,0))/(2.*val(cm,0,0,0)*Delta + 1e-30);end_foreach();}}else if(is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 282
foreach()
    val(omega,0,0,0) = ((_const_fm.x - _const_fm.x)*val(u.y,0,0,0) +
        _const_fm.x*val(u.y,1,0,0) - _const_fm.x*val(u.y,-1,0,0) -
        (_const_fm.y - _const_fm.y)*val(u.x,0,0,0) +
        _const_fm.y*val(u.x,0,-1,0) - _const_fm.y*val(u.x,0,1,0))/(2.*val(cm,0,0,0)*Delta + 1e-30);end_foreach();}}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  {
#line 282
foreach()
    val(omega,0,0,0) = ((val(fm.x,1,0,0) - val(fm.x,0,0,0))*val(u.y,0,0,0) +
        val(fm.x,1,0,0)*val(u.y,1,0,0) - val(fm.x,0,0,0)*val(u.y,-1,0,0) -
        (val(fm.y,0,1,0) - val(fm.y,0,0,0))*val(u.x,0,0,0) +
        val(fm.y,0,0,0)*val(u.x,0,-1,0) - val(fm.y,0,1,0)*val(u.x,0,1,0))/(2.*_const_cm*Delta + 1e-30);end_foreach();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  {
#line 282
foreach()
    val(omega,0,0,0) = ((_const_fm.x - _const_fm.x)*val(u.y,0,0,0) +
        _const_fm.x*val(u.y,1,0,0) - _const_fm.x*val(u.y,-1,0,0) -
        (_const_fm.y - _const_fm.y)*val(u.x,0,0,0) +
        _const_fm.y*val(u.x,0,-1,0) - _const_fm.y*val(u.x,0,1,0))/(2.*_const_cm*Delta + 1e-30);end_foreach();}}
}





double change (scalar s, scalar sn)
{
  double max = 0.;
  foreach_stencil() {
_stencil_val(cm,0,0,0); {     
       _stencil_val(sn,0,0,0);_stencil_val(s,0,0,0);   
       
  
    }
       
    
#line 302
_stencil_val_a(sn,0,0,0); _stencil_val(s,0,0,0); 
  }end_foreach_stencil();
  
#line 296
if(!is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:max)){
#line 296
foreach() {
    if ((sq(Delta)*val(cm,0,0,0)) > 0.) {
      double ds = fabs (val(s,0,0,0) - val(sn,0,0,0));
      if (ds > max)
 max = ds;
    }
    val(sn,0,0,0) = val(s,0,0,0);
  }end_foreach();mpi_all_reduce_array(&max,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 303
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:max)){
#line 296
foreach() {
    if ((sq(Delta)*_const_cm) > 0.) {
      double ds = fabs (val(s,0,0,0) - val(sn,0,0,0));
      if (ds > max)
 max = ds;
    }
    val(sn,0,0,0) = val(s,0,0,0);
  }end_foreach();mpi_all_reduce_array(&max,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 303
}
  return max;
}





scalar lookup_field (const char * name)
{
  if (name)
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, name))
 return s;}}
  return (scalar){-1};
}

vector lookup_vector (const char * name)
{
  if (name) {
    char component[strlen(name) + 3];
    strcpy (component, name);
    strcat (component, ".x");
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, component))
 return _attribute[s.i].v;}}
  }
  return (vector){{-1}};
}
#line 340 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
#define foreach_segment(_S,_p) {\
  coord t = {(_S)[1].x - (_S)[0].x, (_S)[1].y - (_S)[0].y};\
  double norm = sqrt(sq(t.x) + sq(t.y));\
  if (!(norm > 0.)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/utils.h", 343, "norm > 0.");\
  t.x = t.x/norm + 1e-6, t.y = t.y/norm - 1.5e-6;\
  double alpha = ((_S)[0].x*((_S)[1].y - (_S)[0].y) -\
    (_S)[0].y*((_S)[1].x - (_S)[0].x))/norm;\
  foreach()\
    if (fabs(t.y*x - t.x*y - alpha) < 0.708*Delta) {\
      coord _o = {x,y}, _p[2];\
      int _n = 0;\
 if (t.x)\
   for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {\
     _p[_n].x = _o.x + _i*Delta/2.;\
     double a = (_p[_n].x - (_S)[0].x)/t.x;\
     _p[_n].y = (_S)[0].y + a*t.y;\
     if (fabs(_p[_n].y - _o.y) <= Delta/2.) {\
       a = clamp (a, 0., norm);\
       _p[_n].x = (_S)[0].x + a*t.x, _p[_n].y = (_S)[0].y + a*t.y;\
       if (fabs(_p[_n].x - _o.x) <= Delta/2. &&\
    fabs(_p[_n].y - _o.y) <= Delta/2.)\
  _n++;\
     }\
   }\
\
 if (t.y)\
   for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {\
     _p[_n].y = _o.y + _i*Delta/2.;\
     double a = (_p[_n].y - (_S)[0].y)/t.y;\
     _p[_n].x = (_S)[0].x + a*t.x;\
     if (fabs(_p[_n].x - _o.x) <= Delta/2.) {\
       a = clamp (a, 0., norm);\
       _p[_n].y = (_S)[0].y + a*t.y, _p[_n].x = (_S)[0].x + a*t.x;\
       if (fabs(_p[_n].y - _o.y) <= Delta/2. &&\
    fabs(_p[_n].x - _o.x) <= Delta/2.)\
  _n++;\
     }\
   }\
\
      if (_n == 2) {\

#line 380

#line 410 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
#define end_foreach_segment() } } end_foreach(); }




void fields_stats()
{
  fprintf (ferr, "# t = %g, fields = {", t);
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (ferr, " %s", _attribute[s.i].name);}}
  fputs (" }\n", ferr);
  fprintf (ferr, "# %12s: %12s %12s %12s %12s\n",
    "name", "min", "avg", "stddev", "max");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    stats ss = statsf (s);
    fprintf (ferr, "# %12s: %12g %12g %12g %12g\n",
      _attribute[s.i].name, ss.min, ss.sum/ss.volume, ss.stddev, ss.max);
  }}}
}

#line 1 "./output.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
#line 37 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
struct OutputField {
  scalar * list;
  FILE * fp;
  int n;
  bool linear;
  double box[2][2];
};

     
void output_field (struct OutputField p)
{tracing("output_field","/home/xiangbin2/basilisk_new/basilisk/src/output.h",46);
  if (!p.list) p.list = all;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = fout;
  p.n++;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }

  boundary_internal ((scalar *)p.list, "/home/xiangbin2/basilisk_new/basilisk/src/output.h", 58);
  int len = list_len(p.list);
  double Delta = 0.999999*(p.box[1][0] - p.box[0][0])/(p.n - 1);
  int ny = (p.box[1][1] - p.box[0][1])/Delta + 1;
  double ** field = (double **) matrix_new (p.n, ny, len*sizeof(double));
  for (int i = 0; i < p.n; i++) {
    double x = Delta*i + p.box[0][0];
    for (int j = 0; j < ny; j++) {
      double y = Delta*j + p.box[0][1];
      if (p.linear) {
 int k = 0;
 {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   field[i][len*j + k++] = interpolate ((struct _interpolate){s, x, y});}}
      }
      else {
 Point point = locate ((struct _locate){x, y});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
 int k = 0;
 {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   field[i][len*j + k++] = point.level >= 0 ? val(s,0,0,0) : HUGE;}}
      }
    }
  }

  if (pid() == 0) {
#if 1
    MPI_Reduce (MPI_IN_PLACE, field[0], len*p.n*ny, MPI_DOUBLE, MPI_MIN, 0,
  MPI_COMM_WORLD);
#endif
    fprintf (p.fp, "# 1:x 2:y");
    int i = 3;
    {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      fprintf (p.fp, " %d:%s", i++, _attribute[s.i].name);}}
    fputc('\n', p.fp);
    for (int i = 0; i < p.n; i++) {
      double x = Delta*i + p.box[0][0];
      for (int j = 0; j < ny; j++) {
 double y = Delta*j + p.box[0][1];

 fprintf (p.fp, "%g %g", x, y);
 int k = 0;
 {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   fprintf (p.fp, " %g", field[i][len*j + k++]);}}
 fputc ('\n', p.fp);
      }
      fputc ('\n', p.fp);
    }
    fflush (p.fp);
  }
#if 1
  else
    MPI_Reduce (field[0], NULL, len*p.n*ny, MPI_DOUBLE, MPI_MIN, 0,
  MPI_COMM_WORLD);
#endif

  matrix_free (field);
end_tracing("output_field","/home/xiangbin2/basilisk_new/basilisk/src/output.h",113);}
#line 141 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
struct OutputMatrix {
  scalar f;
  FILE * fp;
  int n;
  bool linear;
};

     
void output_matrix (struct OutputMatrix p)
{tracing("output_matrix","/home/xiangbin2/basilisk_new/basilisk/src/output.h",149);
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = fout;
  if (p.linear) {
    scalar f = p.f;
    boundary_internal ((scalar *)((scalar[]){f,{-1}}), "/home/xiangbin2/basilisk_new/basilisk/src/output.h", 155);
  }
  float fn = p.n;
  float Delta = (float) L0/fn;
  fwrite (&fn, sizeof(float), 1, p.fp);
  for (int j = 0; j < p.n; j++) {
    float yp = (float) (Delta*j + X0 + Delta/2.);
    fwrite (&yp, sizeof(float), 1, p.fp);
  }
  for (int i = 0; i < p.n; i++) {
    float xp = (float) (Delta*i + X0 + Delta/2.);
    fwrite (&xp, sizeof(float), 1, p.fp);
    for (int j = 0; j < p.n; j++) {
      float yp = (float)(Delta*j + Y0 + Delta/2.), v;
      if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
 if (!(point.level >= 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/output.h", 173, "point.level >= 0");
 v = val(p.f,0,0,0);
      }
      fwrite (&v, sizeof(float), 1, p.fp);
    }
  }
  fflush (p.fp);
end_tracing("output_matrix","/home/xiangbin2/basilisk_new/basilisk/src/output.h",180);}
#line 189 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
typedef void (* colormap) (double cmap[127][3]);

void jet (double cmap[127][3])
{
  for (int i = 0; i < 127; i++) {
    cmap[i][0] =
      i <= 46 ? 0. :
      i >= 111 ? -0.03125*(i - 111) + 1. :
      i >= 78 ? 1. :
      0.03125*(i - 46);
    cmap[i][1] =
      i <= 14 || i >= 111 ? 0. :
      i >= 79 ? -0.03125*(i - 111) :
      i <= 46 ? 0.03125*(i - 14) :
      1.;
    cmap[i][2] =
      i >= 79 ? 0. :
      i >= 47 ? -0.03125*(i - 79) :
      i <= 14 ? 0.03125*(i - 14) + 1.:
      1.;
  }
}

void cool_warm (double cmap[127][3])
{






  static double basemap[33][3] = {
    {0.2298057, 0.298717966, 0.753683153},
    {0.26623388, 0.353094838, 0.801466763},
    {0.30386891, 0.406535296, 0.84495867},
    {0.342804478, 0.458757618, 0.883725899},
    {0.38301334, 0.50941904, 0.917387822},
    {0.424369608, 0.558148092, 0.945619588},
    {0.46666708, 0.604562568, 0.968154911},
    {0.509635204, 0.648280772, 0.98478814},
    {0.552953156, 0.688929332, 0.995375608},
    {0.596262162, 0.726149107, 0.999836203},
    {0.639176211, 0.759599947, 0.998151185},
    {0.681291281, 0.788964712, 0.990363227},
    {0.722193294, 0.813952739, 0.976574709},
    {0.761464949, 0.834302879, 0.956945269},
    {0.798691636, 0.849786142, 0.931688648},
    {0.833466556, 0.860207984, 0.901068838},
    {0.865395197, 0.86541021, 0.865395561},
    {0.897787179, 0.848937047, 0.820880546},
    {0.924127593, 0.827384882, 0.774508472},
    {0.944468518, 0.800927443, 0.726736146},
    {0.958852946, 0.769767752, 0.678007945},
    {0.96732803, 0.734132809, 0.628751763},
    {0.969954137, 0.694266682, 0.579375448},
    {0.966811177, 0.650421156, 0.530263762},
    {0.958003065, 0.602842431, 0.481775914},
    {0.943660866, 0.551750968, 0.434243684},
    {0.923944917, 0.49730856, 0.387970225},
    {0.89904617, 0.439559467, 0.343229596},
    {0.869186849, 0.378313092, 0.300267182},
    {0.834620542, 0.312874446, 0.259301199},
    {0.795631745, 0.24128379, 0.220525627},
    {0.752534934, 0.157246067, 0.184115123},
    {0.705673158, 0.01555616, 0.150232812}
  };

  for (int i = 0; i < 127; i++) {
    double x = i*(32 - 1e-10)/(127 - 1);
    int j = x; x -= j;
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (1. - x)*basemap[j][k] + x*basemap[j+1][k];
  }
}

void gray (double cmap[127][3])
{
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = i/(127 - 1.);
}

void randomap (double cmap[127][3])
{
  srand(0);
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (noise() + 1.)/2.;
}

void blue_white_red (double cmap[127][3])
{
  for (int i = 0; i < (127 + 1)/2; i++) {
    cmap[i][0] = i/((127 - 1)/2.);
    cmap[i][1] = i/((127 - 1)/2.);
    cmap[i][2] = 1.;
  }
  for (int i = 0; i < (127 - 1)/2; i++) {
    cmap[i + (127 + 1)/2][0] = 1.;
    cmap[i + (127 + 1)/2][1] = cmap[(127 - 3)/2 - i][1];
    cmap[i + (127 + 1)/2][2] = cmap[(127 - 3)/2 - i][1];
  }
}





typedef struct {
  unsigned char r, g, b;
} color;

color colormap_color (double cmap[127][3],
        double val, double min, double max)
{
  color c;
  if (val == HUGE) {
    c.r = c.g = c.b = 0;
    return c;
  }
  int i;
  double coef;
  if (max != min)
    val = (val - min)/(max - min);
  else
    val = 0.;
  if (val <= 0.) i = 0, coef = 0.;
  else if (val >= 1.) i = 127 - 2, coef = 1.;
  else {
    i = val*(127 - 1);
    coef = val*(127 - 1) - i;
  }
  if (!(i < 127 - 1)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/output.h", 321, "i < NCMAP - 1");
  unsigned char * c1 = (unsigned char *) &c;
  for (int j = 0; j < 3; j++)
    c1[j] = 255*(cmap[i][j]*(1. - coef) + cmap[i + 1][j]*coef);
  return c;
}
#line 340 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
static const char * extension (const char * file, const char * ext) {
  int len = strlen(file);
  return len > 4 && !strcmp (file + len - 4, ext) ? file + len - 4 : NULL;
}

static const char * is_animation (const char * file) {
  const char * ext;
  if ((ext = extension (file, ".mp4")) ||
      (ext = extension (file, ".ogv")) ||
      (ext = extension (file, ".gif")))
    return ext;
  return NULL;
}

static struct {
  FILE ** fp;
  char ** names;
  int n;
} open_image_data = {NULL, NULL, 0};

static void open_image_cleanup()
{
  for (int i = 0; i < open_image_data.n; i++) {
    qpclose (open_image_data.fp[i]);
    pfree (open_image_data.names[i],__func__,__FILE__,__LINE__);
  }
  pfree (open_image_data.fp,__func__,__FILE__,__LINE__);
  pfree (open_image_data.names,__func__,__FILE__,__LINE__);
  open_image_data.fp = NULL;
  open_image_data.names = NULL;
  open_image_data.n = 0;
}

static FILE * open_image_lookup (const char * file)
{
  for (int i = 0; i < open_image_data.n; i++)
    if (!strcmp (file, open_image_data.names[i]))
      return open_image_data.fp[i];
  return NULL;
}

static bool which (const char * command)
{
  char * s = getenv ("PATH");
  if (!s)
    return false;
  char path[strlen(s) + 1];
  strcpy (path, s);
  s = strtok (path, ":");
  while (s) {
    char f[strlen(s) + strlen(command) + 2];
    strcpy (f, s);
    strcat (f, "/");
    strcat (f, command);
    FILE * fp = fopen (f, "r");
    if (fp) {
      fclose (fp);
      return true;
    }
    s = strtok (NULL, ":");
  }
  return false;
}

static FILE * ppm_fallback (const char * file, const char * mode)
{
  char filename[strlen(file) + 5];
  strcpy (filename, file);
  strcat (filename, ".ppm");
  FILE * fp = fopen (filename, mode);
  if (!fp) {
    perror (file);

    MPI_Abort (MPI_COMM_WORLD, 1);

    exit (1);
  }
  return fp;
}

FILE * open_image (const char * file, const char * options)
{
  if (!(pid() == 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/output.h", 422, "pid() == 0");
  const char * ext;
  if ((ext = is_animation (file))) {
    FILE * fp = open_image_lookup (file);
    if (fp)
      return fp;

    int len = strlen ("ppm2???    ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "ppm2"); strcat (command, ext + 1);

    static int has_ffmpeg = -1;
    if (has_ffmpeg < 0) {
      if (which (command) && (which ("ffmpeg") || which ("avconv")))
 has_ffmpeg = true;
      else {
 fprintf (ferr,
   "open_image(): cannot find '%s' or 'ffmpeg'/'avconv'\n"
   "  falling back to raw PPM outputs\n", command);
 has_ffmpeg = false;
      }
    }
    if (!has_ffmpeg)
      return ppm_fallback (file, "a");

    static bool added = false;
    if (!added) {
      free_solver_func_add (open_image_cleanup);
      added = true;
    }
    open_image_data.n++;
    open_image_data.names = (char * *) prealloc (open_image_data.names, (open_image_data.n)*sizeof(char *),__func__,__FILE__,__LINE__);
    open_image_data.names[open_image_data.n - 1] = pstrdup (file,__func__,__FILE__,__LINE__);

    if (options) {
      strcat (command, " ");
      strcat (command, options);
    }
    strcat (command, !strcmp (ext, ".mp4") ? " " : " > ");
    strcat (command, file);
    open_image_data.fp = (FILE * *) prealloc (open_image_data.fp, (open_image_data.n)*sizeof(FILE *),__func__,__FILE__,__LINE__);
    return open_image_data.fp[open_image_data.n - 1] = qpopen (command, "w");
  }
  else {
    static int has_convert = -1;
    if (has_convert < 0) {
      if (which ("convert"))
 has_convert = true;
      else {
 fprintf (ferr,
   "open_image(): cannot find 'convert'\n"
   "  falling back to raw PPM outputs\n");
 has_convert = false;
      }
    }
    if (!has_convert)
      return ppm_fallback (file, "w");

    int len = strlen ("convert ppm:-   ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "convert ppm:- ");
    if (options) {
      strcat (command, options);
      strcat (command, " ");
    }
    strcat (command, file);
    return qpopen (command, "w");
  }
}

void close_image (const char * file, FILE * fp)
{
  if (!(pid() == 0)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/output.h", 496, "pid() == 0");
  if (is_animation (file)) {
    if (!open_image_lookup (file))
      fclose (fp);
  }
  else if (which ("convert"))
    qpclose (fp);
  else
    fclose (fp);
}
#line 571 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
struct OutputPPM {
  scalar f;
  FILE * fp;
  int n;
  char * file;
  double min, max, spread, z;
  bool linear;
  double box[2][2];
  scalar mask;
  colormap map;
  char * opt;
};

     
void output_ppm (struct OutputPPM p)
{tracing("output_ppm","/home/xiangbin2/basilisk_new/basilisk/src/output.h",585);

  if (p.n == 0) p.n = N;
  if (p.min == 0 && p.max == 0) {
    stats s = statsf (p.f);
    if (p.spread < 0.)
      p.min = s.min, p.max = s.max;
    else {
      double avg = s.sum/s.volume, spread = (p.spread ? p.spread : 5.)*s.stddev;
      p.min = avg - spread; p.max = avg + spread;
    }
  }
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }
  if (!p.map)
    p.map = jet;
  if (p.linear) {
    scalar f = p.f, mask = p.mask;
    if (mask.i)
      boundary_internal ((scalar *)((scalar[]){f, mask,{-1}}), "/home/xiangbin2/basilisk_new/basilisk/src/output.h", 608);
    else
      boundary_internal ((scalar *)((scalar[]){f,{-1}}), "/home/xiangbin2/basilisk_new/basilisk/src/output.h", 610);
  }

  double fn = p.n;
  double Delta = (p.box[1][0] - p.box[0][0])/fn;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;
  if (ny % 2) ny++;

  color ** ppm = (color **) matrix_new (ny, p.n, sizeof(color));
  double cmap[127][3];
  p.map (cmap);
  OMP_PARALLEL() {
    OMP(omp for schedule(static))
      for (int j = 0; j < ny; j++) {
 double yp = Delta*j + p.box[0][1] + Delta/2.;
 for (int i = 0; i < p.n; i++) {
   double xp = Delta*i + p.box[0][0] + Delta/2., v;
   if (p.mask.i) {
     if (p.linear) {
       double m = interpolate ((struct _interpolate){p.mask, xp, yp, p.z});
       if (m < 0.)
  v = HUGE;
       else
  v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
     }
     else {
       Point point = locate ((struct _locate){xp, yp, p.z});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
       if (point.level < 0 || val(p.mask,0,0,0) < 0.)
  v = HUGE;
       else
  v = val(p.f,0,0,0);
     }
   }
   else if (p.linear)
     v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
   else {
     Point point = locate ((struct _locate){xp, yp, p.z});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
     v = point.level >= 0 ? val(p.f,0,0,0) : HUGE;
   }
   ppm[ny - 1 - j][i] = colormap_color (cmap, v, p.min, p.max);
 }
      }
  }

  if (pid() == 0) {
#if 1
    MPI_Reduce (MPI_IN_PLACE, ppm[0], 3*ny*p.n, MPI_UNSIGNED_CHAR, MPI_MAX, 0,
  MPI_COMM_WORLD);
#endif
    if (!p.fp) p.fp = fout;
    if (p.file)
      p.fp = open_image (p.file, p.opt);

    fprintf (p.fp, "P6\n%u %u 255\n", p.n, ny);
    fwrite (((void **) ppm)[0], sizeof(color), ny*p.n, p.fp);

    if (p.file)
      close_image (p.file, p.fp);
    else
      fflush (p.fp);
  }
#if 1
  else
    MPI_Reduce (ppm[0], NULL, 3*ny*p.n, MPI_UNSIGNED_CHAR, MPI_MAX, 0,
  MPI_COMM_WORLD);
#endif

  matrix_free (ppm);
end_tracing("output_ppm","/home/xiangbin2/basilisk_new/basilisk/src/output.h",678);}
#line 710 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
struct OutputGRD {
  scalar f;
  FILE * fp;
  double Delta;
  bool linear;
  double box[2][2];
  scalar mask;
};

     
void output_grd (struct OutputGRD p)
{tracing("output_grd","/home/xiangbin2/basilisk_new/basilisk/src/output.h",720);

  if (!p.fp) p.fp = fout;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
    if (p.Delta == 0) p.Delta = L0/N;
  }
  if (p.linear) {
    scalar f = p.f, mask = p.mask;
    if (mask.i)
      boundary_internal ((scalar *)((scalar[]){f, mask,{-1}}), "/home/xiangbin2/basilisk_new/basilisk/src/output.h", 733);
    else
      boundary_internal ((scalar *)((scalar[]){f,{-1}}), "/home/xiangbin2/basilisk_new/basilisk/src/output.h", 735);
  }

  double Delta = p.Delta;
  int nx = (p.box[1][0] - p.box[0][0])/Delta;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;


  fprintf (p.fp, "ncols          %d\n", nx);
  fprintf (p.fp, "nrows          %d\n", ny);
  fprintf (p.fp, "xllcorner      %g\n", p.box[0][0]);
  fprintf (p.fp, "yllcorner      %g\n", p.box[0][1]);
  fprintf (p.fp, "cellsize       %g\n", Delta);
  fprintf (p.fp, "nodata_value   -9999\n");


  for (int j = ny-1; j >= 0; j--) {
    double yp = Delta*j + p.box[0][1] + Delta/2.;
    for (int i = 0; i < nx; i++) {
      double xp = Delta*i + p.box[0][0] + Delta/2., v;
      if (p.mask.i) {
 if (p.linear) {
   double m = interpolate ((struct _interpolate){p.mask, xp, yp});
   if (m < 0.)
     v = HUGE;
   else
     v = interpolate ((struct _interpolate){p.f, xp, yp});
 }
 else {
   Point point = locate ((struct _locate){xp, yp});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
   if (point.level < 0 || val(p.mask,0,0,0) < 0.)
     v = HUGE;
   else
     v = val(p.f,0,0,0);
 }
      }
      else if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp});int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
 v = point.level >= 0 ? val(p.f,0,0,0) : HUGE;
      }
      if (v == HUGE)
 fprintf (p.fp, "-9999 ");
      else
 fprintf (p.fp, "%f ", v);
    }
    fprintf (p.fp, "\n");
  }

  fflush (p.fp);
end_tracing("output_grd","/home/xiangbin2/basilisk_new/basilisk/src/output.h",786);}
#line 813 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
struct OutputGfs {
  FILE * fp;
  scalar * list;
  double t;
  char * file;
  bool translate;
};

static char * replace (const char * input, int target, int with,
         bool translate)
{
  if (translate) {
    if (!strcmp (input, "u.x"))
      return pstrdup ("U",__func__,__FILE__,__LINE__);
    if (!strcmp (input, "u.y"))
      return pstrdup ("V",__func__,__FILE__,__LINE__);
    if (!strcmp (input, "u.z"))
      return pstrdup ("W",__func__,__FILE__,__LINE__);
  }
  char * name = pstrdup (input,__func__,__FILE__,__LINE__), * i = name;
  while (*i != '\0') {
    if (*i == target)
      *i = with;
    i++;
  }
  return name;
}

     
void output_gfs (struct OutputGfs p)
{tracing("output_gfs","/home/xiangbin2/basilisk_new/basilisk/src/output.h",842);
  char * fname = p.file;

#if 1



  FILE * fp = p.fp;
  if (p.file == NULL) {
    long pid = getpid();
    MPI_Bcast (&pid, 1, MPI_LONG, 0, MPI_COMM_WORLD);
    fname = ((char *) pmalloc ((80)*sizeof(char),__func__,__FILE__,__LINE__));
    snprintf (fname, 80, ".output-%ld", pid);
    p.fp = NULL;
  }
#endif

  bool opened = false;
  if (p.fp == NULL) {
    if (fname == NULL)
      p.fp = fout;
    else if (!(p.fp = fopen (fname, "w"))) {
      perror (fname);
      exit (1);
    }
    else
      opened = true;
  }

  scalar * list = p.list ? p.list : list_copy (all);

  restriction (list);
  fprintf (p.fp,
    "1 0 GfsSimulation GfsBox GfsGEdge { binary = 1"
    " x = %g y = %g ",
    0.5 + X0/L0, 0.5 + Y0/L0);




  if (list != NULL && list[0].i != -1) {
    scalar s = list[0];
    char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
    fprintf (p.fp, "variables = %s", name);
    pfree (name,__func__,__FILE__,__LINE__);
    for (int i = 1; i < list_len(list); i++) {
      scalar s = list[i];
      if (_attribute[s.i].name) {
 char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
 fprintf (p.fp, ",%s", name);
 pfree (name,__func__,__FILE__,__LINE__);
      }
    }
    fprintf (p.fp, " ");
  }
  fprintf (p.fp, "} {\n");
  fprintf (p.fp, "  Time { t = %g }\n", t);
  if (L0 != 1.)
    fprintf (p.fp, "  PhysicalParams { L = %g }\n", L0);
  fprintf (p.fp, "  VariableTracerVOF f\n");
  fprintf (p.fp, "}\nGfsBox { x = 0 y = 0 z = 0 } {\n");

#if 1
  long header;
  if ((header = ftell (p.fp)) < 0) {
    perror ("output_gfs(): error in header");
    exit (1);
  }
  int cell_size = sizeof(unsigned) + sizeof(double);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (_attribute[s.i].name)
      cell_size += sizeof(double);}}
  scalar index = new_scalar("index");
  size_t total_size = header + (z_indexing (index, false) + 1)*cell_size;
#endif



  {foreach_cell() {
#if 1
    if (is_local(cell))
#endif
    {
#if 1
      if (fseek (p.fp, header + val(index,0,0,0)*cell_size, SEEK_SET) < 0) {
 perror ("output_gfs(): error while seeking");
 exit (1);
      }
#endif
      unsigned flags =
 level == 0 ? 0 :



      child.x == -1 && child.y == -1 ? 0 :
 child.x == -1 && child.y == 1 ? 1 :
 child.x == 1 && child.y == -1 ? 2 :
 3;
#line 951 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
      if (is_leaf(cell))
 flags |= (1 << 4);
      fwrite (&flags, sizeof (unsigned), 1, p.fp);
      double a = -1;
      fwrite (&a, sizeof (double), 1, p.fp);
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 if (_attribute[s.i].name) {
   if (_attribute[s.i].v.x.i >= 0) {




     if (_attribute[s.i].v.x.i == s.i) {
       s = _attribute[s.i].v.y;
       a = is_local(cell) && val(s,0,0,0) != HUGE ? val(s,0,0,0) : (double) DBL_MAX;
     }
     else if (_attribute[s.i].v.y.i == s.i) {
       s = _attribute[s.i].v.x;
       a = is_local(cell) && val(s,0,0,0) != HUGE ? - val(s,0,0,0) : (double) DBL_MAX;
     }





   }
   else
     a = is_local(cell) && val(s,0,0,0) != HUGE ? val(s,0,0,0) : (double) DBL_MAX;
   fwrite (&a, sizeof (double), 1, p.fp);
 }}}
    }
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}

#if 1
  delete (((scalar[]){index,{-1}}));
  if (!pid() && fseek (p.fp, total_size, SEEK_SET) < 0) {
    perror ("output_gfs(): error while finishing");
    exit (1);
  }
  if (!pid())
#endif
    fputs ("}\n", p.fp);
  fflush (p.fp);

  if (!p.list)
    pfree (list,__func__,__FILE__,__LINE__);
  if (opened)
    fclose (p.fp);

#if 1
  if (p.file == NULL) {
    MPI_Barrier (MPI_COMM_WORLD);
    if (pid() == 0) {
      if (fp == NULL)
 fp = fout;
      p.fp = fopen (fname, "r");
      size_t l;
      unsigned char buffer[8192];
      while ((l = fread (buffer, 1, 8192, p.fp)) > 0)
 fwrite (buffer, 1, l, fp);
      fflush (fp);
      remove (fname);
    }
    pfree (fname,__func__,__FILE__,__LINE__);
  }
#endif
end_tracing("output_gfs","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1019);}
#line 1043 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
struct Dump {
  char * file;
  scalar * list;
  FILE * fp;
  bool unbuffered;
};

struct DumpHeader {
  double t;
  long len;
  int i, depth, npe, version;
  coord n;
};

static const int dump_version =

  170901;

static scalar * dump_list (scalar * lista)
{
  scalar * list = is_constant(cm) ? NULL : list_concat (((scalar[]){cm,{-1}}), NULL);
  {scalar*_i=(scalar*)( lista);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!_attribute[s.i].face && !_attribute[s.i].nodump && s.i != cm.i)
      list = list_add (list, s);}}
  return list;
}

static void dump_header (FILE * fp, struct DumpHeader * header, scalar * list)
{
  if (fwrite (header, sizeof(struct DumpHeader), 1, fp) < 1) {
    perror ("dump(): error while writing header");
    exit (1);
  }
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    unsigned len = strlen(_attribute[s.i].name);
    if (fwrite (&len, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing len");
      exit (1);
    }
    if (fwrite (_attribute[s.i].name, sizeof(char), len, fp) < len) {
      perror ("dump(): error while writing s.name");
      exit (1);
    }
  }}}
  double o[4] = {X0,Y0,Z0,L0};
  if (fwrite (o, sizeof(double), 4, fp) < 4) {
    perror ("dump(): error while writing coordinates");
    exit (1);
  }
}

#if !1
     
void dump (struct Dump p)
{tracing("dump","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1096);
  FILE * fp = p.fp;
  char def[] = "dump", * file = p.file ? p.file : p.fp ? NULL : def;

  char * name = NULL;
  if (file) {
    name = (char *) pmalloc (strlen(file) + 2,__func__,__FILE__,__LINE__);
    strcpy (name, file);
    if (!p.unbuffered)
      strcat (name, "~");
    if ((fp = fopen (name, "w")) == NULL) {
      perror (name);
      exit (1);
    }
  }
  if (!(fp)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/output.h", 1112, "fp");

  scalar * dlist = dump_list (p.list ? p.list : all);
  scalar  size=new_scalar("size");
  scalar * list = list_concat (((scalar[]){size,{-1}}), dlist); pfree (dlist,__func__,__FILE__,__LINE__);
  struct DumpHeader header = { t, list_len(list), iter, depth(), npe(),
          dump_version };
  dump_header (fp, &header, list);

  subtree_size (size, false);

  {foreach_cell() {
    unsigned flags = is_leaf(cell) ? leaf : 0;
    if (fwrite (&flags, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing flags");
      exit (1);
    }
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (fwrite (&val(s,0,0,0), sizeof(double), 1, fp) < 1) {
 perror ("dump(): error while writing scalars");
 exit (1);
      }}}
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}

  pfree (list,__func__,__FILE__,__LINE__);
  if (file) {
    fclose (fp);
    if (!p.unbuffered)
      rename (name, file);
    pfree (name,__func__,__FILE__,__LINE__);
  }delete((scalar*)((scalar[]){size,{-1}}));
end_tracing("dump","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1145);}
#else
     
void dump (struct Dump p)
{tracing("dump","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1148);
  FILE * fp = p.fp;
  char def[] = "dump", * file = p.file ? p.file : p.fp ? NULL : def;

  if (fp != NULL || file == NULL) {
    fprintf (ferr, "dump(): must specify a file name when using MPI\n");
    exit(1);
  }

  char name[strlen(file) + 2];
  strcpy (name, file);
  if (!p.unbuffered)
    strcat (name, "~");
  FILE * fh = fopen (name, "w");
  if (fh == NULL) {
    perror (name);
    exit (1);
  }

  scalar * dlist = dump_list (p.list ? p.list : all);
  scalar  size=new_scalar("size");
  scalar * list = list_concat (((scalar[]){size,{-1}}), dlist); pfree (dlist,__func__,__FILE__,__LINE__);
  struct DumpHeader header = { t, list_len(list), iter, depth(), npe(),
          dump_version };







  if (pid() == 0)
    dump_header (fh, &header, list);

  scalar index = {-1};

  index = new_scalar("index");
  z_indexing (index, false);
  int cell_size = sizeof(unsigned) + header.len*sizeof(double);
  int sizeofheader = sizeof(header) + 4*sizeof(double);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    sizeofheader += sizeof(unsigned) + sizeof(char)*strlen(_attribute[s.i].name);}}
  long pos = pid() ? 0 : sizeofheader;

  subtree_size (size, false);

  {foreach_cell() {

    if (is_local(cell)) {
      long offset = sizeofheader + val(index,0,0,0)*cell_size;
      if (pos != offset) {
 fseek (fh, offset, SEEK_SET);
 pos = offset;
      }
      unsigned flags = is_leaf(cell) ? leaf : 0;
      fwrite (&flags, 1, sizeof(unsigned), fh);
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 fwrite (&val(s,0,0,0), 1, sizeof(double), fh);}}
      pos += cell_size;
    }
    if (is_leaf(cell))
      continue;
  }end_foreach_cell();}

  delete (((scalar[]){index,{-1}}));

  pfree (list,__func__,__FILE__,__LINE__);
  fclose (fh);
  if (!p.unbuffered && pid() == 0)
    rename (name, file);delete((scalar*)((scalar[]){size,{-1}}));
end_tracing("dump","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1219);}
#endif

     
bool restore (struct Dump p)
{tracing("restore","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1223);
  FILE * fp = p.fp;
  char * file = p.file;
  if (file && (fp = fopen (file, "r")) == NULL)
    {end_tracing("restore","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1228);return false;}
  if (!(fp)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/output.h", 1229, "fp");

  struct DumpHeader header;
  if (fread (&header, sizeof(header), 1, fp) < 1) {
    fprintf (ferr, "restore(): error: expecting header\n");
    exit (1);
  }


  init_grid (1);
  {foreach_cell() {
    cell.pid = pid();
    cell.flags |= active;
  }end_foreach_cell();}
  ((Tree *)grid)->dirty = true;
#line 1264 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
  bool restore_all = (p.list == all);
  scalar * list = dump_list (p.list ? p.list : all);
  if (header.version == 161020) {
    if (header.len - 1 != list_len (list)) {
      fprintf (ferr,
        "restore(): error: the list lengths don't match: "
        "%ld (file) != %d (code)\n",
        header.len - 1, list_len (list));
      exit (1);
    }
  }
  else {
    if (header.version != dump_version) {
      fprintf (ferr,
        "restore(): error: file version mismatch: "
        "%d (file) != %d (code)\n",
        header.version, dump_version);
      exit (1);
    }

    scalar * input = NULL;
    for (int i = 0; i < header.len; i++) {
      unsigned len;
      if (fread (&len, sizeof(unsigned), 1, fp) < 1) {
 fprintf (ferr, "restore(): error: expecting len\n");
 exit (1);
      }
      char name[len + 1];
      if (fread (name, sizeof(char), len, fp) < 1) {
 fprintf (ferr, "restore(): error: expecting s.name\n");
 exit (1);
      }
      name[len] = '\0';

      if (i > 0) {
 bool found = false;
 {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   if (!strcmp (_attribute[s.i].name, name)) {
     input = list_append (input, s);
     found = true; break;
   }}}
 if (!found) {
   if (restore_all) {
     scalar s = new_scalar("s");
     pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
     _attribute[s.i].name = pstrdup (name,__func__,__FILE__,__LINE__);
     input = list_append (input, s);
   }
   else
     input = list_append (input, (scalar){INT_MAX});
 }
      }
    }
    pfree (list,__func__,__FILE__,__LINE__);
    list = input;

    double o[4];
    if (fread (o, sizeof(double), 4, fp) < 4) {
      fprintf (ferr, "restore(): error: expecting coordinates\n");
      exit (1);
    }
    origin ((struct _origin){o[0], o[1], o[2]});
    size (o[3]);
  }
#line 1339 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
  scalar * listm = is_constant(cm) ? NULL : (scalar *)((vector[]){fm,{{-1},{-1}}});

  restore_mpi (fp, list);
#line 1369 "/home/xiangbin2/basilisk_new/basilisk/src/output.h"
  scalar * other = NULL;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!list_lookup (list, s) && !list_lookup (listm, s))
      other = list_append (other, s);}}
  reset (other, 0.);
  pfree (other,__func__,__FILE__,__LINE__);

  pfree (list,__func__,__FILE__,__LINE__);
  if (file)
    fclose (fp);


  while (iter < header.i && events (false))
    iter = inext;
  events (false);
  while (t < header.t && events (false))
    t = tnext;
  t = header.t;
  events (false);

  {end_tracing("restore","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1389);return true;}
end_tracing("restore","/home/xiangbin2/basilisk_new/basilisk/src/output.h",1390);}
#line 431 "/home/xiangbin2/basilisk_new/basilisk/src/utils.h"
#line 12 "/home/xiangbin2/basilisk_new/basilisk/src/run.h"

     
void run (void)
{tracing("run","/home/xiangbin2/basilisk_new/basilisk/src/run.h",14);
  iter = 0, t = 0., dt = 1.;
  init_grid (N);

  perf.nc = perf.tnc = 0;
  perf.gt = timer_start();
  while (events (true)) {





    update_perf();
    iter = inext, t = tnext;
  }




  timer_print (perf.gt, iter, perf.tnc);

  free_grid();
end_tracing("run","/home/xiangbin2/basilisk_new/basilisk/src/run.h",37);}




static int defaults_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int defaults_0(const int i,const double t,Event *_ev){tracing("defaults_0","/home/xiangbin2/basilisk_new/basilisk/src/run.h",42); {
  display ((struct _display){"box();"});
}{end_tracing("defaults_0","/home/xiangbin2/basilisk_new/basilisk/src/run.h",44);return 0;}end_tracing("defaults_0","/home/xiangbin2/basilisk_new/basilisk/src/run.h",44);}





static int cleanup_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 1234567890);*ip=i;*tp=t;return ret;}      static int cleanup(const int i,const double t,Event *_ev){tracing("cleanup","/home/xiangbin2/basilisk_new/basilisk/src/run.h",50); {
  display ((struct _display){"", true});
}{end_tracing("cleanup","/home/xiangbin2/basilisk_new/basilisk/src/run.h",52);return 0;}end_tracing("cleanup","/home/xiangbin2/basilisk_new/basilisk/src/run.h",52);}
#line 28 "././axi-centered.h"

#line 1 "././my-timestep.h"
#line 1 "./././my-timestep.h"

double timestep (const vector u, double dtmax)
{
  static double previous = 0.;
  dtmax /= CFL;
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val(u.x,0,0,0); _stencil_val(fs.x,0,0,0); { 
      
_stencil_val(u.x,0,0,0); 
        _stencil_val(fm.x,0,0,0);   
       
         
    
#line 12
}    }}end__stencil_is_face_x()
#line 6
_stencil_is_face_y(){
    {_stencil_val(u.y,0,0,0); _stencil_val(fs.y,0,0,0); { 
      
_stencil_val(u.y,0,0,0); 
        _stencil_val(fm.y,0,0,0);   
       
         
    
#line 12
}    }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 6
if(!is_constant(fm.x)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(min:dtmax)){
#line 6
foreach_face_generic(){is_face_x(){
    if (val(u.x,0,0,0) != 0. && val(fs.x,0,0,0)>=1) {
      double dt;
      dt = Delta/fabs(val(u.x,0,0,0));
      dt *= val(fm.x,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}end_is_face_x()
#line 6
is_face_y(){
    if (val(u.y,0,0,0) != 0. && val(fs.y,0,0,0)>=1) {
      double dt;
      dt = Delta/fabs(val(u.y,0,0,0));
      dt *= val(fm.y,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dtmax,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 12
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(min:dtmax)){
#line 6
foreach_face_generic(){is_face_x(){
    if (val(u.x,0,0,0) != 0. && val(fs.x,0,0,0)>=1) {
      double dt;
      dt = Delta/fabs(val(u.x,0,0,0));
      dt *= _const_fm.x;
      if (dt < dtmax) dtmax = dt;
    }}end_is_face_x()
#line 6
is_face_y(){
    if (val(u.y,0,0,0) != 0. && val(fs.y,0,0,0)>=1) {
      double dt;
      dt = Delta/fabs(val(u.y,0,0,0));
      dt *= _const_fm.y;
      if (dt < dtmax) dtmax = dt;
    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dtmax,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 12
}
  dtmax *= CFL;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  previous = dtmax;
  return dtmax;
}
#line 30 "././axi-centered.h"
#line 1 "./bcg.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
#line 11 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
void tracer_fluxes (scalar f,
      vector uf,
      vector flux,
      double dt,
              scalar src)
{





  vector  g=new_vector("g");
  gradients (((scalar[]){f,{-1}}), ((vector[]){g,{{-1},{-1}}}));




  foreach_face_stencil(){_stencil_is_face_x(){ {        







    _stencil_val(fm.x,0,0,0);_stencil_val(uf.x,0,0,0);              
    
    _stencil_val(g.x,o_stencil,0,0); _stencil_val(src,-1,0,0);_stencil_val(src,0,0,0);_stencil_val(f, o_stencil,0,0);





_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {     
       _stencil_val(fm.y,o_stencil,1,0);_stencil_val(fm.y,o_stencil,0,0); _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }





      
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    _stencil_val_a(flux.x,0,0,0);_stencil_val(uf.x,0,0,0);  
  }}end__stencil_is_face_x()
#line 28
_stencil_is_face_y(){ {        







    _stencil_val(fm.y,0,0,0);_stencil_val(uf.y,0,0,0);              
    
    _stencil_val(g.y,0,o_stencil,0); _stencil_val(src,0,-1,0);_stencil_val(src,0,0,0);_stencil_val(f,0, o_stencil,0);





_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {     
       _stencil_val(fm.x,1,o_stencil,0);_stencil_val(fm.x,0,o_stencil,0); _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }





      
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    _stencil_val_a(flux.y,0,0,0);_stencil_val(uf.y,0,0,0);  
  }}end__stencil_is_face_y()}end_foreach_face_stencil();




  
#line 28
if(!is_constant(fm.x) && !is_constant(src)){{foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && !is_constant(src)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);




  {
#line 28
foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && is_constant(src)){double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);




  {
#line 28
foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);




  {
#line 28
foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "/home/xiangbin2/basilisk_new/basilisk/src/bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}






struct Advection {
  scalar * tracers;
  vector u;
  double dt;
  scalar * src;
};

void advection (struct Advection p)
{




  scalar * lsrc = p.src;
  if (!lsrc)
    {scalar*_i=(scalar*)( p.tracers);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      lsrc = list_append (lsrc, zeroc);}}
  if (!(list_len(p.tracers) == list_len(lsrc))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/bcg.h", 84, "list_len(p.tracers) == list_len(lsrc)");

  scalar f, src;
  {scalar*_i0=lsrc;scalar*_i1= p.tracers;if(_i0)for(src=*_i0,f=*_i1;_i0->i>= 0;src=*++_i0,f=*++_i1){ {
    vector  flux=new_face_vector("flux");
    tracer_fluxes (f, p.u, flux, p.dt, src);





    update_tracer (f, p.u, flux, p.dt);delete((scalar*)((vector[]){flux,{{-1},{-1}}}));

  }}}

  if (!p.src)
    pfree (lsrc,__func__,__FILE__,__LINE__);
}
#line 31 "././axi-centered.h"



#line 1 "././newest-viscosity.h"
#line 1 "./././newest-viscosity.h"
#line 50 "./././newest-viscosity.h"
#line 1 "./././my-poisson.h"
#line 1 "././././my-poisson.h"
#line 31 "././././my-poisson.h"
extern int maxl;
extern scalar cs;
extern vector u;
extern scalar topo_mask_s;
extern bool flag_get_u_ghost;

void get_u_ghost(vector u);

void mg_cycle (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = min (minlevel, maxlevel);
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {foreach_level_or_leaf (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = 0.;}}end_foreach_level_or_leaf();}





    else
      {foreach_level (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = bilinear_embed(point, s);}}end_foreach_level();}





    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax (da, res, l, data);
      boundary_level (da, l);
    }
  }




  foreach_stencil() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 {_stencil_val_r(s,0,0,0); _stencil_val(ds,0,0,0); }}}
  }end_foreach_stencil();




  {
#line 91
foreach() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 val(s,0,0,0) += val(ds,0,0,0);}}
  }end_foreach();}
}


void mg_cycle_viscous (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = min (minlevel, maxlevel);
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {foreach_level_or_leaf (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = 0.;}}end_foreach_level_or_leaf();}





    else
      {foreach_level (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = bilinear_embed(point, s);}}end_foreach_level();}





    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax (da, res, l, data);
      boundary_level (da, l);
    }
  }




  foreach_stencil() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 {_stencil_val_r(s,0,0,0); _stencil_val(ds,0,0,0); }}}
  }end_foreach_stencil();




  {
#line 152
foreach() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 val(s,0,0,0) += val(ds,0,0,0);}}
  }end_foreach();}

  if(flag_get_u_ghost){
        get_u_ghost(u);
  }else{
    foreach_stencil() {
_stencil_val(cs,0,0,0);{

          _stencil_val_a(u.x,0,0,0);
          _stencil_val_a(u.y,0,0,0);

      }
      
    
#line 169
}end_foreach_stencil();
    {
#line 162
foreach() {
      if(val(cs,0,0,0)<=0.0){

          val(u.x,0,0,0)=0.0;
          val(u.y,0,0,0)=0.0;

      }
    }end_foreach();}

  }


}
#line 186 "././././my-poisson.h"
int NITERMAX = 200, NITERMIN = 1;
double TOLERANCE = 1e-3;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats;
#line 209 "././././my-poisson.h"
struct MGSolve {
  scalar * a, * b;
  double (* residual) (scalar * a, scalar * b, scalar * res,
         void * data);
  void (* relax) (scalar * da, scalar * res, int depth,
    void * data);
  void * data;

  int nrelax;
  scalar * res;
  int minlevel;
  double tolerance;
};

mgstats mg_solve (struct MGSolve p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    res = list_clone (p.b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats s = {0};
  double sum = 0.;
  foreach_stencil ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { _stencil_val(s,0,0,0); }}}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:sum)){
#line 248
foreach ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      sum += val(s,0,0,0);}}end_foreach();mpi_all_reduce_array(&sum,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
  
#line 251
s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual (p.a, p.b, res, p.data);






  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE;
  for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > p.tolerance);
       s.i++) {
    mg_cycle (p.a, res, da, p.relax, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual (p.a, p.b, res, p.data);
#line 283 "././././my-poisson.h"
    if (s.resa > p.tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = p.minlevel;




  if (s.resa > p.tolerance) {
    scalar v = p.a[0];
    fprintf (ferr,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d pid:%d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax, pid()), fflush (ferr);
  }




  if (!p.res)
    delete (res), pfree (res,__func__,__FILE__,__LINE__);
  delete (da), pfree (da,__func__,__FILE__,__LINE__);

  return s;
}


mgstats mg_solve_viscous (struct MGSolve p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    res = list_clone (p.b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats s = {0};
  double sum = 0.;
  foreach_stencil ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { _stencil_val(s,0,0,0); }}}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:sum)){
#line 347
foreach ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      sum += val(s,0,0,0);}}end_foreach();mpi_all_reduce_array(&sum,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
  
#line 350
s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual (p.a, p.b, res, p.data);






  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE;
  for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > p.tolerance);
       s.i++) {
    mg_cycle_viscous (p.a, res, da, p.relax, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual (p.a, p.b, res, p.data);
#line 382 "././././my-poisson.h"
    if (s.resa > p.tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = p.minlevel;




  if (s.resa > p.tolerance) {
    scalar v = p.a[0];
    fprintf (ferr,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d pid:%d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax, pid()), fflush (ferr);
  }




  if (!p.res)
    delete (res), pfree (res,__func__,__FILE__,__LINE__);
  delete (da), pfree (da,__func__,__FILE__,__LINE__);

  return s;
}
#line 440 "././././my-poisson.h"
struct Poisson {
  scalar a, b;
          vector alpha;
          scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;
};





static void relax (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;

  bool embedded = (_attribute[a.i].boundary[embed] != symmetry);
#line 478 "././././my-poisson.h"
  scalar c = a;






  if(!is_constant(lambda) && !is_constant(alpha.x)){{foreach_level_or_leaf (l) {
    double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
     {
      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
    } 
#line 487
{
      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
    }

    if (embedded) {
      double c, e = embed_flux (point, a, alpha, &c);
      n -= c*sq(Delta);
      d += e*sq(Delta);
    }
    if (!d)
      val(c,0,0,0) = val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }end_foreach_level_or_leaf();}}else if(is_constant(lambda) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);






  {
#line 485
foreach_level_or_leaf (l) {
    double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
     {
      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
    } 
#line 487
{
      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
    }

    if (embedded) {
      double c, e = embed_flux (point, a, alpha, &c);
      n -= c*sq(Delta);
      d += e*sq(Delta);
    }
    if (!d)
      val(c,0,0,0) = val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }end_foreach_level_or_leaf();}}else if(!is_constant(lambda) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);






  {
#line 485
foreach_level_or_leaf (l) {
    double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
     {
      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
      d += _const_alpha.x + _const_alpha.x;
    } 
#line 487
{
      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
      d += _const_alpha.y + _const_alpha.y;
    }

    if (embedded) {
      double c, e = embed_flux (point, a, alpha, &c);
      n -= c*sq(Delta);
      d += e*sq(Delta);
    }
    if (!d)
      val(c,0,0,0) = val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }end_foreach_level_or_leaf();}}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);






  {
#line 485
foreach_level_or_leaf (l) {
    double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
     {
      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
      d += _const_alpha.x + _const_alpha.x;
    } 
#line 487
{
      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
      d += _const_alpha.y + _const_alpha.y;
    }

    if (embedded) {
      double c, e = embed_flux (point, a, alpha, &c);
      n -= c*sq(Delta);
      d += e*sq(Delta);
    }
    if (!d)
      val(c,0,0,0) = val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }end_foreach_level_or_leaf();}}
#line 520 "././././my-poisson.h"
}






static double residual (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;

  bool embedded = (_attribute[a.i].boundary[embed] != symmetry);

  double maxres = 0.;


  vector  g=new_face_vector("g");
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(g.x,0,0,0); _stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);           }}end__stencil_is_face_x()
#line 540
_stencil_is_face_y(){
    {_stencil_val_a(g.y,0,0,0); _stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);           }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 540
if(!is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(g.x,0,0,0) = val(alpha.x,0,0,0)*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta);}end_is_face_x()
#line 540
is_face_y(){
    val(g.y,0,0,0) = val(alpha.y,0,0,0)*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 540
foreach_face_generic(){is_face_x(){
    val(g.x,0,0,0) = _const_alpha.x*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta);}end_is_face_x()
#line 540
is_face_y(){
    val(g.y,0,0,0) = _const_alpha.y*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}
  foreach_stencil () {
    _stencil_val_a(res,0,0,0); _stencil_val(b,0,0,0); _stencil_val(lambda,0,0,0);_stencil_val(a,0,0,0);  
    
      {_stencil_val_r(res,0,0,0);_stencil_val(g.x,1,0,0); _stencil_val(g.x,0,0,0);   }
      
#line 545
{_stencil_val_r(res,0,0,0);_stencil_val(g.y,0,1,0); _stencil_val(g.y,0,0,0);   }

    if (embedded) {   
       _stencil_embed_flux (point, a, alpha,NULL );
      _stencil_val_r(res,0,0,0);_stencil_val(a,0,0,0);    
    }

_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }

        
  
#line 554
}end_foreach_stencil();
  
#line 542
if(!is_constant(lambda)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 542
foreach () {
    val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
    
      val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
      
#line 545
val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;

    if (embedded) {
      double c, e = embed_flux (point, a, alpha, &c);
      val(res,0,0,0) += c - e*val(a,0,0,0);
    }

    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 554
}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 542
foreach () {
    val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
    
      val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
      
#line 545
val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;

    if (embedded) {
      double c, e = embed_flux (point, a, alpha, &c);
      val(res,0,0,0) += c - e*val(a,0,0,0);
    }

    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 554
}
#line 572 "././././my-poisson.h"
  {delete((scalar*)((vector[]){g,{{-1},{-1}}}));return maxres;}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}
#line 584 "././././my-poisson.h"
mgstats poisson (struct Poisson p)
{






  if (!p.alpha.x.i)
    p.alpha = unityf;
  if (!p.lambda.i)
    p.lambda = zeroc;




  vector alpha = p.alpha;
  scalar lambda = p.lambda;
  restriction (((scalar[]){alpha.x,alpha.y,lambda,{-1}}));





  double defaultol = TOLERANCE;
  if (p.tolerance)
    TOLERANCE = p.tolerance;

  scalar a = p.a, b = p.b;
  mgstats s = mg_solve ((struct MGSolve){((scalar[]){a,{-1}}), ((scalar[]){b,{-1}}), residual, relax,
   &p, p.nrelax, p.res, .minlevel = max(1, p.minlevel)});




  if (p.tolerance)
    TOLERANCE = defaultol;

  return s;
}
#line 642 "././././my-poisson.h"
struct Project {
  vector uf;
  scalar p;
  vector alpha;
  double dt;
  int nrelax;
};

     
mgstats project (struct Project q)
{tracing("project","././././my-poisson.h",651);
  vector uf = q.uf;
  scalar p = q.p;
          vector alpha = q.alpha.x.i ? q.alpha : unityf;
  double dt = q.dt ? q.dt : 1.;
  int nrelax = q.nrelax ? q.nrelax : 4;






  scalar  div=new_scalar("div");
  foreach_stencil() {
    _stencil_val_a(div,0,0,0);  
    
      {_stencil_val_r(div,0,0,0); _stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);  }
      
#line 668
{_stencil_val_r(div,0,0,0); _stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);  }
    _stencil_val_r(div,0,0,0);  
  }end_foreach_stencil();
  {
#line 665
foreach() {
    val(div,0,0,0) = 0.;
    
      val(div,0,0,0) += val(uf.x,1,0,0) - val(uf.x,0,0,0);
      
#line 668
val(div,0,0,0) += val(uf.y,0,1,0) - val(uf.y,0,0,0);
    val(div,0,0,0) /= dt*Delta;
  }end_foreach();}
#line 681 "././././my-poisson.h"
  mgstats mgp = poisson ((struct Poisson){p, div, alpha,
    .tolerance = TOLERANCE/sq(dt), .nrelax = nrelax});




  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_r(uf.x,0,0,0);_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);            }}end__stencil_is_face_x()
#line 687
_stencil_is_face_y(){
    {_stencil_val_r(uf.y,0,0,0);_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);            }}end__stencil_is_face_y()}end_foreach_face_stencil();




  
#line 687
if(!is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*val(alpha.x,0,0,0)*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 687
is_face_y(){
    val(uf.y,0,0,0) -= dt*val(alpha.y,0,0,0)*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);




  {
#line 687
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*_const_alpha.x*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 687
is_face_y(){
    val(uf.y,0,0,0) -= dt*_const_alpha.y*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}

  {delete((scalar*)((scalar[]){div,{-1}}));{end_tracing("project","././././my-poisson.h",690);return mgp;}}delete((scalar*)((scalar[]){div,{-1}}));
end_tracing("project","././././my-poisson.h",691);}

struct Project_s {
  vector uf;
  scalar p;
  vector alpha;
  scalar sv;
  double dt;
  int nrelax;
};

     
mgstats project_source (struct Project_s q)
{tracing("project_source","././././my-poisson.h",703);
  vector uf = q.uf;
  scalar p = q.p;
          vector alpha = q.alpha.x.i ? q.alpha : unityf;
  scalar sv =q.sv;
  double dt = q.dt ? q.dt : 1.;
  int nrelax = q.nrelax ? q.nrelax : 4;






  scalar  div=new_scalar("div");
  foreach_stencil() {
    _stencil_val_a(div,0,0,0);  
    
      {_stencil_val_r(div,0,0,0); _stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);  }
      
#line 721
{_stencil_val_r(div,0,0,0); _stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);  }
    _stencil_val_r(div,0,0,0);  


    _stencil_val_a(div,0,0,0); _stencil_val(div,0,0,0); _stencil_val(sv,0,0,0);  

  }end_foreach_stencil();
  {
#line 718
foreach() {
    val(div,0,0,0) = 0.;
    
      val(div,0,0,0) += val(uf.x,1,0,0) - val(uf.x,0,0,0);
      
#line 721
val(div,0,0,0) += val(uf.y,0,1,0) - val(uf.y,0,0,0);
    val(div,0,0,0) /= dt*Delta;


    val(div,0,0,0) = val(div,0,0,0) - val(sv,0,0,0)/dt;

  }end_foreach();}
#line 760 "././././my-poisson.h"
TOLERANCE = 1e-3/dt;
if(maxl==11){
TOLERANCE = 1e-2/dt;
}
mgstats mgp = poisson ((struct Poisson){p, div, alpha,
    .tolerance = TOLERANCE, .nrelax = nrelax});
#line 776 "././././my-poisson.h"
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_r(uf.x,0,0,0);_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);            }}end__stencil_is_face_x()
#line 776
_stencil_is_face_y(){
    {_stencil_val_r(uf.y,0,0,0);_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);            }}end__stencil_is_face_y()}end_foreach_face_stencil();
#line 776 "././././my-poisson.h"
  if(!is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*val(alpha.x,0,0,0)*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 776
is_face_y(){
    val(uf.y,0,0,0) -= dt*val(alpha.y,0,0,0)*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
#line 776 "././././my-poisson.h"
  {foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*_const_alpha.x*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 776
is_face_y(){
    val(uf.y,0,0,0) -= dt*_const_alpha.y*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}

  {delete((scalar*)((scalar[]){div,{-1}}));{end_tracing("project_source","././././my-poisson.h",779);return mgp;}}delete((scalar*)((scalar[]){div,{-1}}));
end_tracing("project_source","././././my-poisson.h",780);}
#line 51 "./././newest-viscosity.h"

bool flag_embed=false;
struct Viscosity {
  vector u;
  vector mu;
  scalar rho;
  double dt;
  int nrelax;
  scalar * res;
};
#line 145 "./././newest-viscosity.h"
bool arePerpendicular(coord n1, coord n2) {
    double dotProduct = 0.0;

     {
        dotProduct += n1.x * n2.x;
    } 
#line 148
{
        dotProduct += n1.y * n2.y;
    }

    return fabs(dotProduct)<1e-2;
}
static void relax_viscosity (scalar * a, scalar * b, int l, void * data)
{
  struct Viscosity * p = (struct Viscosity *) data;
          vector mu = p->mu;
          scalar rho = p->rho;
  double dt = p->dt;
  vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0])));




  vector w = u;


  if(!is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){{foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*val(mu.x,1,0,0)*val(u.x,1,0,0) + 2.*val(mu.x,0,0,0)*val(u.x,-1,0,0)

      + val(mu.y,0,1,0)*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - val(mu.y,0,0,0)*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.x,1,0,0) + 2.*val(mu.x,0,0,0)

          + val(mu.y,0,1,0) + val(mu.y,0,0,0)




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*val(mu.y,0,1,0)*val(u.y,0,1,0) + 2.*val(mu.y,0,0,0)*val(u.y,0,-1,0)

      + val(mu.x,1,0,0)*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - val(mu.x,0,0,0)*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*val(mu.y,0,1,0) + 2.*val(mu.y,0,0,0)

          + val(mu.x,1,0,0) + val(mu.x,0,0,0)




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else if(!is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/val(rho,0,0,0)*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0))*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/val(rho,0,0,0) + dt/val(rho,0,0,0)*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);


  {
#line 168
foreach_level_or_leaf (l) {
    if(val(cs,0,0,0)>0.0){
    {

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.x);
            }
#line 180
{
                norm_direction += sq(direction.y);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.x*embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                          c2 = c2*direction.x;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.y*embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                          c3 = c3*direction.y;

                        }
            }
            }



      val(w.x,0,0,0) = (dt/_const_rho*(2.*_const_mu.x*val(u.x,1,0,0) + 2.*_const_mu.x*val(u.x,-1,0,0)

      + _const_mu.y*(val(u.x,0,1,0) +
     (val(u.y,1,0,0) + val(u.y,1,1,0))/4. -
     (val(u.y,-1,0,0) + val(u.y,-1,1,0))/4.)
      - _const_mu.y*(- val(u.x,0,-1,0) +
         (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
         (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.x,0,0,0)-dt*(c+c2+c3 + d3*val(u.y,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
        }
#line 170
{

    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
         double norm_direction=0.0;
            {
                norm_direction += sq(direction.y);
            }
#line 180
{
                norm_direction += sq(direction.x);
            }
            if(fabs(norm_direction)>1e-20){

                        double bc=0.0;

                        dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);



                        normalize(&direction);

                        coord direction2 = (coord){1,0};
                        if(!arePerpendicular(direction,direction2)){
                          double bc2 = 0.0;
                          d2 = direction.y*embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                          c2 = c2*direction.y;

                        }

                        coord direction3 = (coord){1,0};
                        if(!arePerpendicular(direction,direction3)){

                          double bc3 = 0.0;
                          d3 = direction.x*embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                          c3 = c3*direction.x;

                        }
            }
            }



      val(w.y,0,0,0) = (dt/_const_rho*(2.*_const_mu.y*val(u.y,0,1,0) + 2.*_const_mu.y*val(u.y,0,-1,0)

      + _const_mu.x*(val(u.y,1,0,0) +
     (val(u.x,0,1,0) + val(u.x,1,1,0))/4. -
     (val(u.x,0,-1,0) + val(u.x,1,-1,0))/4.)
      - _const_mu.x*(- val(u.y,-1,0,0) +
         (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
         (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)
#line 231 "./././newest-viscosity.h"
      ) + (val(r.y,0,0,0)-dt*(c+c2+c3 + d3*val(u.x,0,0,0))/_const_rho)*sq(Delta))/
    (sq(Delta)*((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y +dt*sq(Delta)*(dd+d2)/_const_rho + dt/_const_rho*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
        }
     }else{
            val(w.x,0,0,0) = 0.0;
     }
  }end_foreach_level_or_leaf();}}
#line 262 "./././newest-viscosity.h"
}
#line 271 "./././newest-viscosity.h"
static double residual_viscosity (scalar * a, scalar * b, scalar * resl,
      void * data)
{
  struct Viscosity * p = (struct Viscosity *) data;
          vector mu = p->mu;
          scalar rho = p->rho;
  double dt = p->dt;
  vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0]))), res = (*((vector *)&(resl[0])));
  double maxres = 0.;
#line 288 "./././newest-viscosity.h"
  boundary_internal ((scalar *)((vector[]){u,{{-1},{-1}}}), "./././newest-viscosity.h", 288);

   {
    scalar ss = u.x;
    vector  g=new_face_vector("g");
    foreach_face_stencil(){_stencil_is_face_x(){
      {_stencil_val_a(g.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, ss, 0);_stencil_val(ss,0,0,0); _stencil_val(ss,0 -1,0,0);            }}end__stencil_is_face_x()
#line 293
_stencil_is_face_y(){
      {_stencil_val_a(g.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, ss, 0);_stencil_val(ss,0,0,0); _stencil_val(ss,0,0 -1,0);            }}end__stencil_is_face_y()}end_foreach_face_stencil();
    {
#line 293
foreach_face_generic(){is_face_x(){
      val(g.x,0,0,0) = (_attribute[ss.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, ss, 0) : (val(ss,0,0,0) - val(ss,0 -1,0,0))/Delta);}end_is_face_x()
#line 293
is_face_y(){
      val(g.y,0,0,0) = (_attribute[ss.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, ss, 0) : (val(ss,0,0,0) - val(ss,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}
    vector  taux=new_face_vector("taux");


    foreach_face_stencil()_stencil_is_face_x(){
      {_stencil_val_a(taux.x,0,0,0);_stencil_val(mu.x,0,0,0);_stencil_val(g.x,0,0,0);  }}end__stencil_is_face_x()end_foreach_face_stencil();


    
#line 298
if(!is_constant(mu.x)){{foreach_face_generic()is_face_x(){
      val(taux.x,0,0,0) = 2.*val(mu.x,0,0,0)*val(g.x,0,0,0);}end_is_face_x()end_foreach_face_generic();}}else {struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);


    {
#line 298
foreach_face_generic()is_face_x(){
      val(taux.x,0,0,0) = 2.*_const_mu.x*val(g.x,0,0,0);}end_is_face_x()end_foreach_face_generic();}}

      foreach_face_stencil()_stencil_is_face_y(){{
 _stencil_val_a(taux.y,0,0,0); _stencil_val(mu.y,0,0,0);_stencil_val(u.x,0,0,0); _stencil_val(u.x,0,-1,0);
_stencil_val(u.y,1,-1,0); _stencil_val(u.y,1,0,0);
_stencil_val(u.y,-1,-1,0); _stencil_val(u.y,-1,0,0);    
        
      
      
#line 305
}}end__stencil_is_face_y()end_foreach_face_stencil();

      
#line 301
if(!is_constant(mu.x)){{foreach_face_generic()is_face_y(){{
 val(taux.y,0,0,0) = val(mu.y,0,0,0)*(val(u.x,0,0,0) - val(u.x,0,-1,0) +
      (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
      (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)/Delta;
      }}end_is_face_y()end_foreach_face_generic();}}else {struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);

      {
#line 301
foreach_face_generic()is_face_y(){{
 val(taux.y,0,0,0) = _const_mu.y*(val(u.x,0,0,0) - val(u.x,0,-1,0) +
      (val(u.y,1,-1,0) + val(u.y,1,0,0))/4. -
      (val(u.y,-1,-1,0) + val(u.y,-1,0,0))/4.)/Delta;
      }}end_is_face_y()end_foreach_face_generic();}}







    foreach_stencil () {
_stencil_val(cs,0,0,0);{{   
      
      
 { _stencil_val(taux.x,1,0,0); _stencil_val(taux.x,0,0,0);  }
 
#line 317
{ _stencil_val(taux.y,0,1,0); _stencil_val(taux.y,0,0,0);  }
      _stencil_val_a(res.x,0,0,0); _stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(cs,0,0,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);_stencil_val(rho,0,0,0);                         


    
    
    
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); {    

      
       _stencil_embed_geometry (point,NULL ,NULL ); 
       
                 
                     
                
{


                  double bc=0.0; 

_stencil_embed_flux_direction (point, u.x, mu,NULL , bc,NULL ); 

                  
                  
#line 338
_stencil_val_r(res.x,0,0,0);_stencil_val(u.x,0,0,0);_stencil_val(rho,0,0,0);       


                  

                  
{
                              double bc2 = 0.0; 
_stencil_embed_flux_direction (point, u.x, mu, NULL, bc2,NULL ); 
                              
                              
#line 347
_stencil_val_r(res.x,0,0,0);_stencil_val(u.x,0,0,0);_stencil_val(rho,0,0,0);    
                            }   
                  

                 {

                              double bc3 = 0.0; 
_stencil_embed_flux_direction (point, u.y, mu, NULL, bc3,NULL ); 
                              
                              
#line 355
_stencil_val_r(res.x,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val(rho,0,0,0);    
                            }
                            
          
#line 357
}
          
    
#line 358
}


_stencil_val(res.x,0,0,0);
                        {_stencil_val(res.x,0,0,0);   }
        


                      
        
#line 363
}{
            _stencil_val_a(res.x,0,0,0);
        }}
      
    
#line 366
}end_foreach_stencil();







    
#line 313
if(!is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0))*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
 
#line 317
d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
      val(res.x,0,0,0) = val(r.x,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y)*sq(val(cs,0,0,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)*2./(_const_cm + 1e-30)}).x*val(u.x,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.x);
                }
#line 329
{
                    norm_direction += sq(direction.y);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.x, mu, direction, bc, &c);
                  val(res.x,0,0,0) -= dt*(c + dd*val(u.x,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.x, mu, direction2, bc2, &c2);
                              val(res.x,0,0,0) -= dt*(c2 + d2*val(u.x,0,0,0))/_const_rho*direction.x;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.y, mu, direction3, bc3, &c3);
                              val(res.x,0,0,0) -= dt*(c3 + d3*val(u.y,0,0,0))/_const_rho*direction.y;
                            }
          }
    }


                  if (fabs (val(res.x,0,0,0)) > maxres)
                        maxres = fabs (val(res.x,0,0,0));
        }else{
            val(res.x,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}delete((scalar*)((vector[]){taux,g,{{-1},{-1}}}));
  } 
#line 290
{
    scalar ss = u.y;
    vector  g=new_face_vector("g");
    foreach_face_stencil(){_stencil_is_face_y(){
      {_stencil_val_a(g.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, ss, 0);_stencil_val(ss,0,0,0); _stencil_val(ss,0,0 -1,0);            }}end__stencil_is_face_y()
#line 293
_stencil_is_face_x(){
      {_stencil_val_a(g.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, ss, 0);_stencil_val(ss,0,0,0); _stencil_val(ss,0 -1,0,0);            }}end__stencil_is_face_x()}end_foreach_face_stencil();
    {
#line 293
foreach_face_generic(){is_face_y(){
      val(g.y,0,0,0) = (_attribute[ss.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, ss, 0) : (val(ss,0,0,0) - val(ss,0,0 -1,0))/Delta);}end_is_face_y()
#line 293
is_face_x(){
      val(g.x,0,0,0) = (_attribute[ss.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, ss, 0) : (val(ss,0,0,0) - val(ss,0 -1,0,0))/Delta);}end_is_face_x()}end_foreach_face_generic();}
    vector  taux=new_face_vector("taux");


    foreach_face_stencil()_stencil_is_face_y(){
      {_stencil_val_a(taux.y,0,0,0);_stencil_val(mu.y,0,0,0);_stencil_val(g.y,0,0,0);  }}end__stencil_is_face_y()end_foreach_face_stencil();


    
#line 298
if(!is_constant(mu.y)){{foreach_face_generic()is_face_y(){
      val(taux.y,0,0,0) = 2.*val(mu.y,0,0,0)*val(g.y,0,0,0);}end_is_face_y()end_foreach_face_generic();}}else {struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);


    {
#line 298
foreach_face_generic()is_face_y(){
      val(taux.y,0,0,0) = 2.*_const_mu.y*val(g.y,0,0,0);}end_is_face_y()end_foreach_face_generic();}}

      foreach_face_stencil()_stencil_is_face_x(){{
 _stencil_val_a(taux.x,0,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(u.y,0,0,0); _stencil_val(u.y,-1,0,0);
_stencil_val(u.x,-1,1,0); _stencil_val(u.x,0,1,0);
_stencil_val(u.x,-1,-1,0); _stencil_val(u.x,0,-1,0);    
        
      
      
#line 305
}}end__stencil_is_face_x()end_foreach_face_stencil();

      
#line 301
if(!is_constant(mu.y)){{foreach_face_generic()is_face_x(){{
 val(taux.x,0,0,0) = val(mu.x,0,0,0)*(val(u.y,0,0,0) - val(u.y,-1,0,0) +
      (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
      (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)/Delta;
      }}end_is_face_x()end_foreach_face_generic();}}else {struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);

      {
#line 301
foreach_face_generic()is_face_x(){{
 val(taux.x,0,0,0) = _const_mu.x*(val(u.y,0,0,0) - val(u.y,-1,0,0) +
      (val(u.x,-1,1,0) + val(u.x,0,1,0))/4. -
      (val(u.x,-1,-1,0) + val(u.x,0,-1,0))/4.)/Delta;
      }}end_is_face_x()end_foreach_face_generic();}}







    foreach_stencil () {
_stencil_val(cs,0,0,0);{{   
      
      
 { _stencil_val(taux.y,0,1,0); _stencil_val(taux.y,0,0,0);  }
 
#line 317
{ _stencil_val(taux.x,1,0,0); _stencil_val(taux.x,0,0,0);  }
      _stencil_val_a(res.y,0,0,0); _stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(cs,0,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val(rho,0,0,0);                         


    
    
    
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); {    

      
       _stencil_embed_geometry (point,NULL ,NULL ); 
       
                 
                     
                
{


                  double bc=0.0; 

_stencil_embed_flux_direction (point, u.y, mu,NULL , bc,NULL ); 

                  
                  
#line 338
_stencil_val_r(res.y,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val(rho,0,0,0);       


                  

                  
{
                              double bc2 = 0.0; 
_stencil_embed_flux_direction (point, u.y, mu, NULL, bc2,NULL ); 
                              
                              
#line 347
_stencil_val_r(res.y,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val(rho,0,0,0);    
                            }   
                  

                 {

                              double bc3 = 0.0; 
_stencil_embed_flux_direction (point, u.x, mu, NULL, bc3,NULL ); 
                              
                              
#line 355
_stencil_val_r(res.y,0,0,0);_stencil_val(u.x,0,0,0);_stencil_val(rho,0,0,0);    
                            }
                            
          
#line 357
}
          
    
#line 358
}


_stencil_val(res.y,0,0,0);
                        {_stencil_val(res.y,0,0,0);   }
        


                      
        
#line 363
}{
            _stencil_val_a(res.y,0,0,0);
        }}
      
    
#line 366
}end_foreach_stencil();







    
#line 313
if(!is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(val(cm,0,0,0) + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0))*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else if(!is_constant(rho) && is_constant(mu.y) && is_constant(fm.y) && is_constant(cm)){struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/val(rho,0,0,0)*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/val(rho,0,0,0)*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/val(rho,0,0,0);


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/val(rho,0,0,0)*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/val(rho,0,0,0)*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);







    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 313
foreach () {
      if(val(cs,0,0,0)>0.0){
      double d = 0.;
      
 d += val(taux.y,0,1,0) - val(taux.y,0,0,0);
 
#line 317
d += val(taux.x,1,0,0) - val(taux.x,0,0,0);
      val(res.y,0,0,0) = val(r.y,0,0,0) - ((coord){1., 1. + dt/_const_rho*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x)*sq(val(cs,0,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)*2./(_const_cm + 1e-30)}).y*val(u.y,0,0,0) + dt/_const_rho*d/Delta;


    double c=0, dd=0;
    double c2=0, d2=0;
    double c3=0, d3=0;
    if (val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && flag_embed) {

      coord direction, b;
      double area2 = embed_geometry (point, &b, &direction);
       double norm_direction=0.0;
                {
                    norm_direction += sq(direction.y);
                }
#line 329
{
                    norm_direction += sq(direction.x);
                }
          if(fabs(norm_direction)>1e-20){


                  double bc=0.0;

                  dd = embed_flux_direction (point, u.y, mu, direction, bc, &c);
                  val(res.y,0,0,0) -= dt*(c + dd*val(u.y,0,0,0))/_const_rho;


                  normalize(&direction);

                  coord direction2 = (coord){1,0};
                  if(!arePerpendicular(direction,direction2)){
                              double bc2 = 0.0;
                              d2 = embed_flux_direction (point, u.y, mu, direction2, bc2, &c2);
                              val(res.y,0,0,0) -= dt*(c2 + d2*val(u.y,0,0,0))/_const_rho*direction.y;
                            }

                 coord direction3 = (coord){1,0};
                            if(!arePerpendicular(direction,direction3)){

                              double bc3 = 0.0;
                              d3 = embed_flux_direction (point, u.x, mu, direction3, bc3, &c3);
                              val(res.y,0,0,0) -= dt*(c3 + d3*val(u.x,0,0,0))/_const_rho*direction.x;
                            }
          }
    }


                  if (fabs (val(res.y,0,0,0)) > maxres)
                        maxres = fabs (val(res.y,0,0,0));
        }else{
            val(res.y,0,0,0)=0.0;
        }
    }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 366
}delete((scalar*)((vector[]){taux,g,{{-1},{-1}}}));
  }
#line 441 "./././newest-viscosity.h"
  return maxres;
}
#line 453 "./././newest-viscosity.h"
     


mgstats viscosity (struct Viscosity p)
{tracing("viscosity","./././newest-viscosity.h",456);






  vector u = p.u,  r=new_vector("r");
  foreach_stencil()
    {
      {_stencil_val_a(r.x,0,0,0); _stencil_val(u.x,0,0,0); }
      
#line 467
{_stencil_val_a(r.y,0,0,0); _stencil_val(u.y,0,0,0); }}end_foreach_stencil();
  {
#line 465
foreach()
    {
      val(r.x,0,0,0) = val(u.x,0,0,0);
      
#line 467
val(r.y,0,0,0) = val(u.y,0,0,0);}end_foreach();}



  vector mu = p.mu;
  scalar rho = p.rho;
  restriction (((scalar[]){mu.x,mu.y,rho,{-1}}));





  { mgstats _ret= mg_solve_viscous ((struct MGSolve){(scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){r,{{-1},{-1}}}),
     residual_viscosity, relax_viscosity, &p, p.nrelax, p.res});delete((scalar*)((vector[]){r,{{-1},{-1}}}));{end_tracing("viscosity","./././newest-viscosity.h",480);return _ret;}}delete((scalar*)((vector[]){r,{{-1},{-1}}}));
end_tracing("viscosity","./././newest-viscosity.h",481);}
#line 490 "./././newest-viscosity.h"
     

mgstats viscosity_explicit (struct Viscosity p)
{tracing("viscosity_explicit","./././newest-viscosity.h",492);

  vector u = p.u,  r=new_vector("r");
  mgstats mg = {0};

  mg.resb = residual_viscosity ((scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){r,{{-1},{-1}}}), &p);
  foreach_stencil()
    {
      {_stencil_val_r(u.x,0,0,0); _stencil_val(r.x,0,0,0); }
      
#line 501
{_stencil_val_r(u.y,0,0,0); _stencil_val(r.y,0,0,0); }}end_foreach_stencil();
  {
#line 499
foreach()
    {
      val(u.x,0,0,0) += val(r.x,0,0,0);
      
#line 501
val(u.y,0,0,0) += val(r.y,0,0,0);}end_foreach();}
  {delete((scalar*)((vector[]){r,{{-1},{-1}}}));{end_tracing("viscosity_explicit","./././newest-viscosity.h",502);return mg;}}delete((scalar*)((vector[]){r,{{-1},{-1}}}));
end_tracing("viscosity_explicit","./././newest-viscosity.h",503);}
#line 35 "././axi-centered.h"
#line 51 "././axi-centered.h"
scalar  p={3};
vector  u={{4},{5}},  g={{6},{7}};
scalar  pf={8};
vector  uf={{9},{10}};
extern scalar ff;
extern scalar ps;

extern vector ulf, ugf, usf, usfg;
extern scalar T,Tlff,Tgff;
extern scalar source_pc,source_pc2;
extern double Tsat00;
#line 84 "././axi-centered.h"
        vector mu = {{_NVARMAX+0},{_NVARMAX+1}}, a = {{_NVARMAX+0},{_NVARMAX+1}}, alpha = {{_NVARMAX+2},{_NVARMAX+3}};
        scalar rho = {_NVARMAX+4};
mgstats mgp, mgpf, mgu;
bool stokes = false;
#line 113
static double _boundary8(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}}static double _boundary8_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann_homogeneous ());}}
static double _boundary9(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (val(fm.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (- (_const_fm.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))));}}}}static double _boundary9_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann_homogeneous ());}}


static double _boundary10(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 0.);}}
static double _boundary11(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet(0));}}static double _boundary11_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}

static double _boundary12(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && !is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))));}}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x) && is_constant(rho) && is_constant(cm)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((val(fm.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))));}}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann ((_const_fm.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))));}}}}static double _boundary12_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann_homogeneous ());}}
#line 138 "././axi-centered.h"
void pressure_embed_gradient (Point point, scalar p, coord * g)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

#line 139
if(!is_constant(rho) && !is_constant(cm) && !is_constant(a.x)){{
  
    g->x = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;
    
#line 141
g->y = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(is_constant(rho) && !is_constant(cm) && !is_constant(a.x)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);

#line 139
{
  
    g->x = _const_rho/(val(cm,0,0,0) + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;
    
#line 141
g->y = _const_rho/(val(cm,0,0,0) + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(!is_constant(rho) && is_constant(cm) && !is_constant(a.x)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);

#line 139
{
  
    g->x = val(rho,0,0,0)/(_const_cm + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;
    
#line 141
g->y = val(rho,0,0,0)/(_const_cm + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(is_constant(rho) && is_constant(cm) && !is_constant(a.x)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);

#line 139
{
  
    g->x = _const_rho/(_const_cm + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;
    
#line 141
g->y = _const_rho/(_const_cm + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(!is_constant(rho) && !is_constant(cm) && is_constant(a.x)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);

#line 139
{
  
    g->x = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(_const_a.x + _const_a.x)/2.;
    
#line 141
g->y = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}else if(is_constant(rho) && !is_constant(cm) && is_constant(a.x)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);

#line 139
{
  
    g->x = _const_rho/(val(cm,0,0,0) + 1e-30)*(_const_a.x + _const_a.x)/2.;
    
#line 141
g->y = _const_rho/(val(cm,0,0,0) + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}else if(!is_constant(rho) && is_constant(cm) && is_constant(a.x)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);

#line 139
{
  
    g->x = val(rho,0,0,0)/(_const_cm + 1e-30)*(_const_a.x + _const_a.x)/2.;
    
#line 141
g->y = val(rho,0,0,0)/(_const_cm + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);

#line 139
{
  
    g->x = _const_rho/(_const_cm + 1e-30)*(_const_a.x + _const_a.x)/2.;
    
#line 141
g->y = _const_rho/(_const_cm + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}

#line 142
}





static int defaults_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int defaults_1(const int i,const double t,Event *_ev){tracing("defaults_1","././axi-centered.h",148);
{

  CFL = 0.8;




  _attribute[p.i].nodump = _attribute[pf.i].nodump = false;




  if (alpha.x.i == unityf.x.i) {
    alpha = fm;
    rho = cm;
  }
  else if (!is_constant(alpha.x)) {
    vector alphav = alpha;
    foreach_face_stencil(){_stencil_is_face_x(){
      {_stencil_val_a(alphav.x,0,0,0); _stencil_val(fm.x,0,0,0); }}end__stencil_is_face_x()
#line 167
_stencil_is_face_y(){
      {_stencil_val_a(alphav.y,0,0,0); _stencil_val(fm.y,0,0,0); }}end__stencil_is_face_y()}end_foreach_face_stencil();
    
#line 167
if(!is_constant(fm.x)){{foreach_face_generic(){is_face_x(){
      val(alphav.x,0,0,0) = val(fm.x,0,0,0);}end_is_face_x()
#line 167
is_face_y(){
      val(alphav.y,0,0,0) = val(fm.y,0,0,0);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
    {
#line 167
foreach_face_generic(){is_face_x(){
      val(alphav.x,0,0,0) = _const_fm.x;}end_is_face_x()
#line 167
is_face_y(){
      val(alphav.y,0,0,0) = _const_fm.y;}end_is_face_y()}end_foreach_face_generic();}}
  }






  _attribute[uf.x.i].refine = refine_face_solenoidal;






  _attribute[uf.x.i].refine = refine_face;
  _attribute[ulf.x.i].refine = refine_face;

  {
    _attribute[uf.x.i].prolongation = refine_embed_face_x;
    _attribute[ulf.x.i].prolongation = refine_embed_face_x;
  }
#line 186
{
    _attribute[uf.y.i].prolongation = refine_embed_face_y;
    _attribute[ulf.y.i].prolongation = refine_embed_face_y;
  }
  {scalar*_i=(scalar*) ((scalar[]){p, pf, u.x,u.y, g.x,g.y,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].restriction = restriction_embed_linear;
    _attribute[s.i].refine = _attribute[s.i].prolongation = refine_embed_linear;
    _attribute[s.i].depends = list_add (_attribute[s.i].depends, cs);
  }}}
  {scalar*_i=(scalar*) ((scalar[]){p, pf,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].embed_gradient = pressure_embed_gradient;}}




}{end_tracing("defaults_1","././axi-centered.h",201);return 0;}end_tracing("defaults_1","././axi-centered.h",201);}





static int default_display_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int default_display(const int i,const double t,Event *_ev){tracing("default_display","././axi-centered.h",207);
  display ((struct _display){"squares (color = 'u.x', spread = -1);"});{end_tracing("default_display","././axi-centered.h",208);return 0;}end_tracing("default_display","././axi-centered.h",208);}





double dtmax;
void delete_small_fraction(){

    double small_fraction_limit_T = 1e-12;
    foreach_stencil(){
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{{
           _stencil_val_a(Tlff,0,0,0);
           _stencil_val_a(Tgff,0,0,0);_stencil_val(Tgff,0,0,0);

           _stencil_val_a(ff,0,0,0);
        } {_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
           _stencil_val_a(Tlff,0,0,0);_stencil_val(Tlff,0,0,0);

           _stencil_val_a(Tgff,0,0,0);
           _stencil_val_a(ff,0,0,0);
        } }}
         
    
#line 230
}end_foreach_stencil();
    {
#line 218
foreach(){
        if(val(ff,0,0,0)<small_fraction_limit_T && val(ff,0,0,0)>0.0){
           val(Tlff,0,0,0)=Tsat00;
           val(Tgff,0,0,0)=val(Tgff,0,0,0);

           val(ff,0,0,0)=0.0;
        }else if(val(ff,0,0,0)>1-small_fraction_limit_T && val(ff,0,0,0)<1.0){
           val(Tlff,0,0,0)=val(Tlff,0,0,0);

           val(Tgff,0,0,0)=Tsat00;
           val(ff,0,0,0)=1.0;
        }
    }end_foreach();}


}

static int init_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int init(const int i,const double t,Event *_ev){tracing("init","././axi-centered.h",235);
{
  trash (((vector[]){uf,{{-1},{-1}}}));
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(uf.x,0,0,0); _stencil_val(fm.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);                 }}end__stencil_is_face_x()
#line 238
_stencil_is_face_y(){
    {_stencil_val_a(uf.y,0,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);                 }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 238
if(!is_constant(fm.x)){{foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) = val(fm.x,0,0,0)*(_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.)));}end_is_face_x()
#line 238
is_face_y(){
    val(uf.y,0,0,0) = val(fm.y,0,0,0)*(_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.)));}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 238
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) = _const_fm.x*(_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.)));}end_is_face_x()
#line 238
is_face_y(){
    val(uf.y,0,0,0) = _const_fm.y*(_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.)));}end_is_face_y()}end_foreach_face_generic();}}




  event ("properties");





  dtmax = DT;
  event ("stability");
}{end_tracing("init","././axi-centered.h",252);return 0;}end_tracing("init","././axi-centered.h",252);}







extern double CFL_evap;
double timestep_evap (const vector u, double dtmax)
{
  static double previous = 0.;
  dtmax /= CFL_evap;
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val(u.x,0,0,0); {   
      _stencil_val(u.x,0,0,0);

_stencil_val(fm.x,0,0,0); 
_stencil_val(fm.x,0,0,0);    

          
       



         
    
#line 275
}   }}end__stencil_is_face_x()
#line 265
_stencil_is_face_y(){
    {_stencil_val(u.y,0,0,0); {   
      _stencil_val(u.y,0,0,0);

_stencil_val(fm.y,0,0,0); 
_stencil_val(fm.y,0,0,0);    

          
       



         
    
#line 275
}   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 265
if(!is_constant(fm.x)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(min:dtmax)){
#line 265
foreach_face_generic(){is_face_x(){
    if (val(u.x,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.x,0,0,0));

      if (!(val(fm.x,0,0,0))) qassert ("././axi-centered.h", 269, "fm.x[]");
      dt *= val(fm.x,0,0,0);



      if (dt < dtmax) dtmax = dt;
    }}end_is_face_x()
#line 265
is_face_y(){
    if (val(u.y,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.y,0,0,0));

      if (!(val(fm.y,0,0,0))) qassert ("././axi-centered.h", 269, "fm.x[]");
      dt *= val(fm.y,0,0,0);



      if (dt < dtmax) dtmax = dt;
    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dtmax,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 275
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(min:dtmax)){
#line 265
foreach_face_generic(){is_face_x(){
    if (val(u.x,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.x,0,0,0));

      if (!(_const_fm.x)) qassert ("././axi-centered.h", 269, "fm.x[]");
      dt *= _const_fm.x;



      if (dt < dtmax) dtmax = dt;
    }}end_is_face_x()
#line 265
is_face_y(){
    if (val(u.y,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.y,0,0,0));

      if (!(_const_fm.y)) qassert ("././axi-centered.h", 269, "fm.x[]");
      dt *= _const_fm.y;



      if (dt < dtmax) dtmax = dt;
    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dtmax,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 275
}
  dtmax *= CFL_evap;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  previous = dtmax;
  return dtmax;
}

extern int case_number;
extern bool restart_Tsat,surface_heat;


extern double Tks,Tkl,Tkg;
extern double Trhos,Trhol,Trhog;
extern double Tcps,Tcpl,Tcpg,delta_min;
double Tkslg_stability(double ks,double kl, double kg, double delta_min){
    double result;
    double maxk;
    maxk = max(ks,kl);
    maxk = max(maxk,kg);
    result = 4.0*sq(delta_min)/(4.0*maxk);
    return result;
}

static int set_dtmax_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int set_dtmax(const int i,const double t,Event *_ev){tracing("set_dtmax","././axi-centered.h",299); dtmax = DT;{end_tracing("set_dtmax","././axi-centered.h",299);return 0;}end_tracing("set_dtmax","././axi-centered.h",299);}





extern int globali,outstep;
extern bool out_flag;
static int stability_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int stability(const int i,const double t,Event *_ev){tracing("stability","././axi-centered.h",307); {







  globali=i;
  out_flag =((globali%outstep)==0);


  if(1==1){







            double dtmax1,dtmax2;






            dtmax1 = timestep (uf, dtmax);
            dtmax2 = timestep (ulf, dtmax);
            dt = dtmax1 < dtmax2 ? (dtmax1 < DT ? dtmax1 : DT) : (dtmax2 < DT ? dtmax2 : DT);
            double dt_T_stability = Tkslg_stability(Tks/(Trhos*Tcps),Tkl/(Trhol*Tcpl),Tkg/(Trhog*Tcpg),delta_min);
            if(dt>1e-20){
              dt = min(dt,dt_T_stability);
            }else{
              fprintf(ferr,"not normal\n");
              dt = dt_T_stability;
            }

            dt = dtnext(dt);

            fprintf(ferr,"after: itime=%d t=%g dtmax=%g dtmax1=%g dtmax2=%g DT=%g dt_T_stability=%g dt=%g\n",i,t,dtmax,dtmax1,dtmax2,DT,dt_T_stability,dt);

  }else{
       dtmax = DT;
       dt = dtnext (stokes ? dtmax : timestep (uf, dtmax));
       fprintf(ferr,"after: itime=%d t=%g dtmax=%g dt=%g\n",i,t,dtmax,dt);
  }
#line 362 "././axi-centered.h"
}{end_tracing("stability","././axi-centered.h",362);return 0;}end_tracing("stability","././axi-centered.h",362);}






static int before_vof_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int before_vof(const int i,const double t,Event *_ev){tracing("before_vof","././axi-centered.h",369);{


    event("contact");
}{end_tracing("before_vof","././axi-centered.h",373);return 0;}end_tracing("before_vof","././axi-centered.h",373);};

static int vof_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int vof(const int i,const double t,Event *_ev){{

}return 0;};


static int after_vof_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int after_vof(const int i,const double t,Event *_ev){tracing("after_vof","././axi-centered.h",380);{

     event("contact");
}{end_tracing("after_vof","././axi-centered.h",383);return 0;}end_tracing("after_vof","././axi-centered.h",383);};






static int properties_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int properties(const int i,const double t,Event *_ev){;return 0;}
static int diffusionT_one_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int diffusionT_one(const int i,const double t,Event *_ev){tracing("diffusionT_one","././axi-centered.h",391);{
  MPI_Barrier(MPI_COMM_WORLD);

}{end_tracing("diffusionT_one","././axi-centered.h",394);return 0;}end_tracing("diffusionT_one","././axi-centered.h",394);};
#line 412 "././axi-centered.h"
void prediction()
{
  vector du;
   {
    scalar s = new_scalar("s");
    du.x = s;
  } 
#line 415
{
    scalar s = new_scalar("s");
    du.y = s;
  }

   if (_attribute[u.x.i].gradient){


    foreach_stencil(){
       {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
          {_stencil_val_a(du.x,0,0,0);  }
{
             _stencil_val_a(du.x,0,0,0);_stencil_val(u.x,-1,0,0); _stencil_val(u.x,0,0,0); _stencil_val(u.x,1,0,0);   
#line 443 "././axi-centered.h"
        }}

           
        



      
#line 447
} 
#line 424
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
          {_stencil_val_a(du.y,0,0,0);  }
{
             _stencil_val_a(du.y,0,0,0);_stencil_val(u.y,0,-1,0); _stencil_val(u.y,0,0,0); _stencil_val(u.y,0,1,0);   
#line 443 "././axi-centered.h"
        }}

           
        



      
#line 447
}
    }end_foreach_stencil();


    {
#line 423
foreach(){
       {

        if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
          val(du.x,0,0,0) = 0.;
        else{
             val(du.x,0,0,0) = _attribute[u.x.i].gradient (val(u.x,-1,0,0), val(u.x,0,0,0), val(u.x,1,0,0))/Delta;
#line 443 "././axi-centered.h"
        }



      } 
#line 424
{

        if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
          val(du.y,0,0,0) = 0.;
        else{
             val(du.y,0,0,0) = _attribute[u.y.i].gradient (val(u.y,0,-1,0), val(u.y,0,0,0), val(u.y,0,1,0))/Delta;
#line 443 "././axi-centered.h"
        }



      }
    }end_foreach();}
  }else{
    foreach_stencil(){
         {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
              {_stencil_val_a(du.x,0,0,0);  }
{
              _stencil_val_a(du.x,0,0,0);_stencil_val(u.x,1,0,0); _stencil_val(u.x,-1,0,0);   

          }}

             
          



      
#line 462
} 
#line 451
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
              {_stencil_val_a(du.y,0,0,0);  }
{
              _stencil_val_a(du.y,0,0,0);_stencil_val(u.y,0,1,0); _stencil_val(u.y,0,-1,0);   

          }}

             
          



      
#line 462
}
    }end_foreach_stencil();
    {
#line 450
foreach(){
         {

          if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
              val(du.x,0,0,0) = 0.;
          else{
              val(du.x,0,0,0) = (val(u.x,1,0,0) - val(u.x,-1,0,0))/(2.*Delta);

          }



      } 
#line 451
{

          if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
              val(du.y,0,0,0) = 0.;
          else{
              val(du.y,0,0,0) = (val(u.y,0,1,0) - val(u.y,0,-1,0))/(2.*Delta);

          }



      }
    }end_foreach();}
  }
  trash (((vector[]){uf,{{-1},{-1}}}));
  foreach_face_stencil(){_stencil_is_face_x(){ {       
     _stencil_val(u.x,-1,0,0);_stencil_val(u.x,0,0,0);     
    
    _stencil_val_a(uf.x,0,0,0);_stencil_val(u.x, o_stencil,0,0);_stencil_val(g.x,0,0,0); _stencil_val(g.x,-1,0,0);_stencil_val(du.x,o_stencil,0,0);

_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {        

       _stencil_val(u.x,o_stencil,-1,0);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,1,0);_stencil_val(u.y, o_stencil,0,0);

      _stencil_val_r(uf.x,0,0,0);_stencil_val(u.y,o_stencil,0,0);  

    }        

      







    
#line 485
_stencil_val_r(uf.x,0,0,0); _stencil_val(fm.x,0,0,0); 
  }}end__stencil_is_face_x()
#line 466
_stencil_is_face_y(){ {       
     _stencil_val(u.y,0,-1,0);_stencil_val(u.y,0,0,0);     
    
    _stencil_val_a(uf.y,0,0,0);_stencil_val(u.y,0, o_stencil,0);_stencil_val(g.y,0,0,0); _stencil_val(g.y,0,-1,0);_stencil_val(du.y,0,o_stencil,0);

_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {        

       _stencil_val(u.y,-1,o_stencil,0);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,1,o_stencil,0);_stencil_val(u.x,0, o_stencil,0);

      _stencil_val_r(uf.y,0,0,0);_stencil_val(u.x,0,o_stencil,0);  

    }        

      







    
#line 485
_stencil_val_r(uf.y,0,0,0); _stencil_val(fm.y,0,0,0); 
  }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 466
if(!is_constant(fm.x)){{foreach_face_generic(){is_face_x(){ {
    double un = dt*(val(u.x,0,0,0) + val(u.x,-1,0,0))/(2.*Delta), s = sign(un);
    int i = -(s + 1.)/2.;
    val(uf.x,0,0,0) = val(u.x,i,0,0) + (val(g.x,0,0,0) + val(g.x,-1,0,0))*dt/4. + s*(1. - s*un)*val(du.x,i,0,0)*Delta/2.;

    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {

      double fyy = val(u.y,i,0,0) < 0. ? val(u.x,i,1,0) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,-1,0);

      val(uf.x,0,0,0) -= dt*val(u.y,i,0,0)*fyy/(2.*Delta);

    }







    val(uf.x,0,0,0) *= val(fm.x,0,0,0);
  }}end_is_face_x()
#line 466
is_face_y(){ {
    double un = dt*(val(u.y,0,0,0) + val(u.y,0,-1,0))/(2.*Delta), s = sign(un);
    int i = -(s + 1.)/2.;
    val(uf.y,0,0,0) = val(u.y,0,i,0) + (val(g.y,0,0,0) + val(g.y,0,-1,0))*dt/4. + s*(1. - s*un)*val(du.y,0,i,0)*Delta/2.;

    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {

      double fyy = val(u.x,0,i,0) < 0. ? val(u.y,1,i,0) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,-1,i,0);

      val(uf.y,0,0,0) -= dt*val(u.x,0,i,0)*fyy/(2.*Delta);

    }







    val(uf.y,0,0,0) *= val(fm.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 466
foreach_face_generic(){is_face_x(){ {
    double un = dt*(val(u.x,0,0,0) + val(u.x,-1,0,0))/(2.*Delta), s = sign(un);
    int i = -(s + 1.)/2.;
    val(uf.x,0,0,0) = val(u.x,i,0,0) + (val(g.x,0,0,0) + val(g.x,-1,0,0))*dt/4. + s*(1. - s*un)*val(du.x,i,0,0)*Delta/2.;

    if (_const_fm.y && _const_fm.y) {

      double fyy = val(u.y,i,0,0) < 0. ? val(u.x,i,1,0) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,-1,0);

      val(uf.x,0,0,0) -= dt*val(u.y,i,0,0)*fyy/(2.*Delta);

    }







    val(uf.x,0,0,0) *= _const_fm.x;
  }}end_is_face_x()
#line 466
is_face_y(){ {
    double un = dt*(val(u.y,0,0,0) + val(u.y,0,-1,0))/(2.*Delta), s = sign(un);
    int i = -(s + 1.)/2.;
    val(uf.y,0,0,0) = val(u.y,0,i,0) + (val(g.y,0,0,0) + val(g.y,0,-1,0))*dt/4. + s*(1. - s*un)*val(du.y,0,i,0)*Delta/2.;

    if (_const_fm.x && _const_fm.x) {

      double fyy = val(u.x,0,i,0) < 0. ? val(u.y,1,i,0) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,-1,i,0);

      val(uf.y,0,0,0) -= dt*val(u.x,0,i,0)*fyy/(2.*Delta);

    }







    val(uf.y,0,0,0) *= _const_fm.y;
  }}end_is_face_y()}end_foreach_face_generic();}}

  delete ((scalar *)((vector[]){du,{{-1},{-1}}}));
}
#line 500 "././axi-centered.h"
#line 1 "././my-bcg2.h"
#line 1 "./././my-bcg2.h"
#line 11 "./././my-bcg2.h"
void tracer_fluxes2 (scalar f,
      vector uf,
      vector flux,
      double dt,
              scalar src)
{





  vector  g=new_vector("g");
  gradients (((scalar[]){f,{-1}}), ((vector[]){g,{{-1},{-1}}}));




  foreach_face_stencil(){_stencil_is_face_x(){ {        







    _stencil_val(fm.x,0,0,0);_stencil_val(uf.x,0,0,0);              
    
    _stencil_val(g.x,o_stencil,0,0); _stencil_val(src,-1,0,0);_stencil_val(src,0,0,0);_stencil_val(f, o_stencil,0,0);





_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {     
       _stencil_val(fm.y,o_stencil,1,0);_stencil_val(fm.y,o_stencil,0,0); _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }





      
#line 58 "./././my-bcg2.h"
    _stencil_val_a(flux.x,0,0,0);_stencil_val(uf.x,0,0,0);  
  }}end__stencil_is_face_x()
#line 28
_stencil_is_face_y(){ {        







    _stencil_val(fm.y,0,0,0);_stencil_val(uf.y,0,0,0);              
    
    _stencil_val(g.y,0,o_stencil,0); _stencil_val(src,0,-1,0);_stencil_val(src,0,0,0);_stencil_val(f,0, o_stencil,0);





_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {     
       _stencil_val(fm.x,1,o_stencil,0);_stencil_val(fm.x,0,o_stencil,0); _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }





      
#line 58 "./././my-bcg2.h"
    _stencil_val_a(flux.y,0,0,0);_stencil_val(uf.y,0,0,0);  
  }}end__stencil_is_face_y()}end_foreach_face_stencil();




  
#line 28
if(!is_constant(fm.x) && !is_constant(src)){{foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && !is_constant(src)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);




  {
#line 28
foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && is_constant(src)){double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);




  {
#line 28
foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);




  {
#line 28
foreach_face_generic(){is_face_x(){ {







    double un = dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}end_is_face_x()
#line 28
is_face_y(){ {







    double un = dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 58 "./././my-bcg2.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}end_is_face_y()}end_foreach_face_generic();}}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}






struct Advection2 {
  scalar * tracers;
  vector u;
  double dt;
  scalar * src;
};

void advection2 (struct Advection2 p)
{




  scalar * lsrc = p.src;
  if (!lsrc)
    {scalar*_i=(scalar*)( p.tracers);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      lsrc = list_append (lsrc, zeroc);}}
  if (!(list_len(p.tracers) == list_len(lsrc))) qassert ("./././my-bcg2.h", 84, "list_len(p.tracers) == list_len(lsrc)");

  scalar f, src;
  {scalar*_i0=lsrc;scalar*_i1= p.tracers;if(_i0)for(src=*_i0,f=*_i1;_i0->i>= 0;src=*++_i0,f=*++_i1){ {
    vector  flux=new_face_vector("flux");
    tracer_fluxes2 (f, p.u, flux, p.dt, src);






    foreach_stencil()
      {{
_stencil_val(cs,0,0,0);
          {_stencil_val_r(f,0,0,0);_stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);_stencil_val(cm,0,0,0);   }
        
      
#line 100
}
#line 97
{
_stencil_val(cs,0,0,0);
          {_stencil_val_r(f,0,0,0);_stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);_stencil_val(cm,0,0,0);   }
        
      
#line 100
}}end_foreach_stencil();






    
#line 96
if(!is_constant(cm)){{foreach()
      {{
        if(val(cs,0,0,0)>0.0)
          val(f,0,0,0) += p.dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/(Delta*val(cm,0,0,0));
      }
#line 97
{
        if(val(cs,0,0,0)>0.0)
          val(f,0,0,0) += p.dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/(Delta*val(cm,0,0,0));
      }}end_foreach();}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);






    {
#line 96
foreach()
      {{
        if(val(cs,0,0,0)>0.0)
          val(f,0,0,0) += p.dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/(Delta*_const_cm);
      }
#line 97
{
        if(val(cs,0,0,0)>0.0)
          val(f,0,0,0) += p.dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/(Delta*_const_cm);
      }}end_foreach();}}delete((scalar*)((vector[]){flux,{{-1},{-1}}}));

  }}}

  if (!p.src)
    pfree (lsrc,__func__,__FILE__,__LINE__);
}
#line 501 "././axi-centered.h"
static int advection_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int advection_term(const int i,const double t,Event *_ev){tracing("advection_term","././axi-centered.h",501);
{







  if (!stokes) {
fprintf(ferr,"mypoisson1 begin\n");
    prediction();


     mgpf = project_source ((struct Project_s){uf, pf, alpha, source_pc2, dt/2.0, mgpf.nrelax});
      advection ((struct Advection){(scalar *)((vector[]){u,{{-1},{-1}}}), uf, dt, (scalar *)((vector[]){g,{{-1},{-1}}})});

fprintf(ferr,"mypoisson1 end\n");
  }



}{end_tracing("advection_term","././axi-centered.h",523);return 0;}end_tracing("advection_term","././axi-centered.h",523);}







static void correction (double dt)
{
  foreach_stencil()
    {
      {_stencil_val_r(u.x,0,0,0);_stencil_val(g.x,0,0,0);  }
      
#line 535
{_stencil_val_r(u.y,0,0,0);_stencil_val(g.y,0,0,0);  }}end_foreach_stencil();
  {
#line 533
foreach()
    {
      val(u.x,0,0,0) += dt*val(g.x,0,0,0);
      
#line 535
val(u.y,0,0,0) += dt*val(g.y,0,0,0);}end_foreach();}
}
#line 545 "././axi-centered.h"
static int viscous_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int viscous_term(const int i,const double t,Event *_ev){tracing("viscous_term","././axi-centered.h",545);
{
  if (constant(mu.x) != 0.) {
    correction (dt);
    mgu = viscosity ((struct Viscosity){u, mu, rho, dt, mgu.nrelax});
    correction (-dt);
  }




  if (!is_constant(a.x)) {
    vector af = a;
    trash (((vector[]){af,{{-1},{-1}}}));
    foreach_face_stencil(){_stencil_is_face_x(){
      {_stencil_val_a(af.x,0,0,0);  }}end__stencil_is_face_x()
#line 559
_stencil_is_face_y(){
      {_stencil_val_a(af.y,0,0,0);  }}end__stencil_is_face_y()}end_foreach_face_stencil();
    {
#line 559
foreach_face_generic(){is_face_x(){
      val(af.x,0,0,0) = 0.;}end_is_face_x()
#line 559
is_face_y(){
      val(af.y,0,0,0) = 0.;}end_is_face_y()}end_foreach_face_generic();}
  }
}{end_tracing("viscous_term","././axi-centered.h",562);return 0;}end_tracing("viscous_term","././axi-centered.h",562);}
#line 581 "././axi-centered.h"
static int acceleration_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int acceleration(const int i,const double t,Event *_ev){tracing("acceleration","././axi-centered.h",581);
{
  trash (((vector[]){uf,{{-1},{-1}}}));
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(uf.x,0,0,0); _stencil_val(fm.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(a.x,0,0,0);                   }}end__stencil_is_face_x()
#line 584
_stencil_is_face_y(){
    {_stencil_val_a(uf.y,0,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);_stencil_val(a.y,0,0,0);                   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 584
if(!is_constant(fm.x) && !is_constant(a.x)){{foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) = val(fm.x,0,0,0)*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*val(a.x,0,0,0));}end_is_face_x()
#line 584
is_face_y(){
    val(uf.y,0,0,0) = val(fm.y,0,0,0)*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*val(a.y,0,0,0));}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && !is_constant(a.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 584
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) = _const_fm.x*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*val(a.x,0,0,0));}end_is_face_x()
#line 584
is_face_y(){
    val(uf.y,0,0,0) = _const_fm.y*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*val(a.y,0,0,0));}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && is_constant(a.x)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
  {
#line 584
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) = val(fm.x,0,0,0)*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*_const_a.x);}end_is_face_x()
#line 584
is_face_y(){
    val(uf.y,0,0,0) = val(fm.y,0,0,0)*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*_const_a.y);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
  {
#line 584
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) = _const_fm.x*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*_const_a.x);}end_is_face_x()
#line 584
is_face_y(){
    val(uf.y,0,0,0) = _const_fm.y*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*_const_a.y);}end_is_face_y()}end_foreach_face_generic();}}
}{end_tracing("acceleration","././axi-centered.h",586);return 0;}end_tracing("acceleration","././axi-centered.h",586);}
#line 595 "././axi-centered.h"
void centered_gradient (scalar p, vector g)
{





  vector  gf=new_face_vector("gf");
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(gf.x,0,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(a.x,0,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);   }}end__stencil_is_face_x()
#line 603
_stencil_is_face_y(){
    {_stencil_val_a(gf.y,0,0,0); _stencil_val(fm.y,0,0,0);_stencil_val(a.y,0,0,0); _stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 603
if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(a.x,0,0,0) - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(a.y,0,0,0) - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = _const_fm.x*val(a.x,0,0,0) - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = _const_fm.y*val(a.y,0,0,0) - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = val(fm.x,0,0,0)*_const_a.x - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = val(fm.y,0,0,0)*_const_a.y - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = _const_fm.x*_const_a.x - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = _const_fm.y*_const_a.y - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(a.x,0,0,0) - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(a.y,0,0,0) - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = _const_fm.x*val(a.x,0,0,0) - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = _const_fm.y*val(a.y,0,0,0) - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x)){struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = val(fm.x,0,0,0)*_const_a.x - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = val(fm.y,0,0,0)*_const_a.y - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 603
foreach_face_generic(){is_face_x(){
    val(gf.x,0,0,0) = _const_fm.x*_const_a.x - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}end_is_face_x()
#line 603
is_face_y(){
    val(gf.y,0,0,0) = _const_fm.y*_const_a.y - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}end_is_face_y()}end_foreach_face_generic();}}





  trash (((vector[]){g,{{-1},{-1}}}));
  foreach_stencil()
    {
      {_stencil_val_a(g.x,0,0,0);_stencil_val(gf.x,0,0,0); _stencil_val(gf.x,1,0,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);      }
      
#line 613
{_stencil_val_a(g.y,0,0,0);_stencil_val(gf.y,0,0,0); _stencil_val(gf.y,0,1,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);      }}end_foreach_stencil();
  
#line 611
if(!is_constant(fm.x)){{foreach()
    {
      val(g.x,0,0,0) = (val(gf.x,0,0,0) + val(gf.x,1,0,0))/(val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30);
      
#line 613
val(g.y,0,0,0) = (val(gf.y,0,0,0) + val(gf.y,0,1,0))/(val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30);}end_foreach();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 611
foreach()
    {
      val(g.x,0,0,0) = (val(gf.x,0,0,0) + val(gf.x,1,0,0))/(_const_fm.x + _const_fm.x + 1e-30);
      
#line 613
val(g.y,0,0,0) = (val(gf.y,0,0,0) + val(gf.y,0,1,0))/(_const_fm.y + _const_fm.y + 1e-30);}end_foreach();}}delete((scalar*)((vector[]){gf,{{-1},{-1}}}));
}






static int projection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int projection(const int i,const double t,Event *_ev){tracing("projection","././axi-centered.h",621);
{
#line 658 "././axi-centered.h"
fprintf(ferr,"mypoisson2 begin\n");
  mgp = project_source ((struct Project_s){uf, p, alpha, source_pc2, dt, mgp.nrelax});


  centered_gradient (p, g);




  correction (dt);
fprintf(ferr,"mypoisson2 finish\n");
}{end_tracing("projection","././axi-centered.h",669);return 0;}end_tracing("projection","././axi-centered.h",669);}

static int poisson_ps_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int poisson_ps(const int i,const double t,Event *_ev){{


}return 0;}


static int get_ulf_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int get_ulf(const int i,const double t,Event *_ev){{
#line 717 "././axi-centered.h"
}return 0;}





static int end_timestep_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int end_timestep(const int i,const double t,Event *_ev){;return 0;}
#line 734 "././axi-centered.h"
static int update_Tl_Tg_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int update_Tl_Tg(const int i,const double t,Event *_ev){{


}return 0;}
static int adapt_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int adapt(const int i,const double t,Event *_ev){tracing("adapt","././axi-centered.h",738); {

  fractions_cleanup ((struct Cleanup){cs, fs});


   boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "././axi-centered.h", 743);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));


  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val(uf.x,0,0,0); _stencil_val(ulf.x,0,0,0); _stencil_val(usf.x,0,0,0);_stencil_val(fs.x,0,0,0);{
      _stencil_val_a(uf.x,0,0,0);  
      _stencil_val_a(ulf.x,0,0,0);
      _stencil_val_a(usf.x,0,0,0);  
      _stencil_val_a(ugf.x,0,0,0);  
      _stencil_val_a(usfg.x,0,0,0);  
    }     }}end__stencil_is_face_x()
#line 751
_stencil_is_face_y(){
    {_stencil_val(uf.y,0,0,0); _stencil_val(ulf.y,0,0,0); _stencil_val(usf.y,0,0,0);_stencil_val(fs.y,0,0,0);{
      _stencil_val_a(uf.y,0,0,0);  
      _stencil_val_a(ulf.y,0,0,0);
      _stencil_val_a(usf.y,0,0,0);  
      _stencil_val_a(ugf.y,0,0,0);  
      _stencil_val_a(usfg.y,0,0,0);  
    }     }}end__stencil_is_face_y()}end_foreach_face_stencil();


  {
#line 751
foreach_face_generic(){is_face_x(){
    if ((val(uf.x,0,0,0) || val(ulf.x,0,0,0) || val(usf.x,0,0,0)) && !val(fs.x,0,0,0)){
      val(uf.x,0,0,0) = 0.;
      val(ulf.x,0,0,0)=0.0;
      val(usf.x,0,0,0) = 0.0;
      val(ugf.x,0,0,0) = 0.0;
      val(usfg.x,0,0,0) = 0.0;
    }}end_is_face_x()
#line 751
is_face_y(){
    if ((val(uf.y,0,0,0) || val(ulf.y,0,0,0) || val(usf.y,0,0,0)) && !val(fs.y,0,0,0)){
      val(uf.y,0,0,0) = 0.;
      val(ulf.y,0,0,0)=0.0;
      val(usf.y,0,0,0) = 0.0;
      val(ugf.y,0,0,0) = 0.0;
      val(usfg.y,0,0,0) = 0.0;
    }}end_is_face_y()}end_foreach_face_generic();}

  boundary_internal ((scalar *)((vector[]){uf,ulf,usf,{{-1},{-1}}}), "././axi-centered.h", 760);

  event ("properties");
}{end_tracing("adapt","././axi-centered.h",763);return 0;}end_tracing("adapt","././axi-centered.h",763);}
#line 13 "template01.c"

#line 1 "axi-two-phase.h"
#line 1 "./axi-two-phase.h"
#line 14 "./axi-two-phase.h"
#line 1 "./my-vof-css-test.h"
#line 1 "././my-vof-css-test.h"
#line 27 "././my-vof-css-test.h"






#line 1 "././myc2d2.h"
#line 1 "./././myc2d2.h"





coord mycs2 (double c[3][3])
{
  int ix;
  double c_t,c_b,c_r,c_l;
  double mx0,my0,mx1,my1,mm1,mm2;


  c_t = c[0][2] + c[1][2] + c[2][2];
  c_b = c[0][0] + c[1][0] + c[2][0];
  c_r = c[2][0] + c[2][1] + c[2][2];
  c_l = c[0][0] + c[0][1] + c[0][2];



  mx0 = 0.5*(c_l-c_r);
  my0 = 0.5*(c_b-c_t);


  if (fabs(mx0) <= fabs(my0)) {
    my0 = my0 > 0. ? 1. : -1.;
    ix = 1;
  }
  else {
    mx0 = mx0 > 0. ? 1. : -1.;
    ix = 0;
  }


  mm1 = c[0][0] + 2.0*c[0][1] + c[0][2];
  mm2 = c[2][0] + 2.0*c[2][1] + c[2][2];
  mx1 = mm1 - mm2 + 1.e-30;
  mm1 = c[0][0] + 2.0*c[1][0] + c[2][0];
  mm2 = c[0][2] + 2.0*c[1][2] + c[2][2];
  my1 = mm1 - mm2 + 1.e-30;


  if (ix) {
    mm1 = fabs(my1);
    mm1 = fabs(mx1)/mm1;
    if (mm1 > fabs(mx0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }
  else {
    mm1 = fabs(mx1);
    mm1 = fabs(my1)/mm1;
    if (mm1 > fabs(my0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }



  mm1 = fabs(mx0) + fabs(my0);
  coord n = {mx0/mm1, my0/mm1};

  return n;
}
#line 38 "././my-vof-css-test.h"
extern scalar css_test;
extern scalar modify_near_region;
extern bool energy_advecting_flag;
#line 49 "././my-vof-css-test.h"
extern scalar * interfaces;
extern vector ulf,ugf;
extern double dt;

extern double Tsat0;
extern scalar Tlff,Tgff;
extern scalar ff;

extern vector flux_show;


int vof_flag;
int globalii;





extern vector uf;
extern double tracex,tracey;
extern double delta_min;
extern scalar topo_mask_s;






scalar  cc_css_test={11};
#line 86 "././my-vof-css-test.h"

static double vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  static const double cmin = 0.5;
  double cl = val(c,-1,0,0), cc = val(c,0,0,0), cr = val(c,1,0,0);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin)
 return _attribute[t.i].gradient (val(t,-1,0,0)/cl, val(t,0,0,0)/cc, val(t,1,0,0)/cr)/Delta;
      else
 return (val(t,1,0,0)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,-1,0,0)/cl)/Delta;
  }
  return 0.;
}

#line 87
static double vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  static const double cmin = 0.5;
  double cl = val(c,0,-1,0), cc = val(c,0,0,0), cr = val(c,0,1,0);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin)
 return _attribute[t.i].gradient (val(t,0,-1,0)/cl, val(t,0,0,0)/cc, val(t,0,1,0)/cr)/Delta;
      else
 return (val(t,0,1,0)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,0,-1,0)/cl)/Delta;
  }
  return 0.;
}
#line 86 "././my-vof-css-test.h"

static void _stencil_vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;           

  
   _stencil_val(c,1,0,0); _stencil_val(c,0,0,0); _stencil_val(c,-1,0,0); 


{
{ {
{
 {_stencil_val(t,-1,0,0); _stencil_val(t,0,0,0); _stencil_val(t,1,0,0);  }
 
{_stencil_val(t,1,0,0); _stencil_val(t,0,0,0);  }}
         
      
    
#line 100
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,-1,0,0);  }}
       
        
  
#line 103
} 
  
                  
         
  
#line 104
return ;
}

#line 87
static void _stencil_vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;           

  
   _stencil_val(c,0,1,0); _stencil_val(c,0,0,0); _stencil_val(c,0,-1,0); 


{
{ {
{
 {_stencil_val(t,0,-1,0); _stencil_val(t,0,0,0); _stencil_val(t,0,1,0);  }
 
{_stencil_val(t,0,1,0); _stencil_val(t,0,0,0);  }}
         
      
    
#line 100
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,0,-1,0);  }}
       
        
  
#line 103
} 
  
                  
         
  
#line 104
return ;
}


static double vof_concentration_gradient_f_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  static const double cmin = 0.5;
  double cl = val(c,-1,0,0), cc = val(c,0,0,0), cr = val(c,1,0,0);
  double result=0.0;
  int flag=0;
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin) {


          if (cr >= cmin) {
            if (cl >= cmin){


              result = (val(t,1,0,0)/cr-val(t,-1,0,0)/cl)/(2.0*Delta);
              flag = 1;
            }else{

               result = (val(t,1,0,0)/cr - val(t,0,0,0)/cc)/Delta;
               flag = 2;
            }
          }
          else if (cl >= cmin){

             result = (val(t,0,0,0)/cc - val(t,-1,0,0)/cl)/Delta;
             flag = 3;
          }



  }
  if(fabs(result)>1e+29){
    printf("result very big: result=%g flag=%d t[]=%g cc=%g t[-1]=%g cl=%g t[1]=%g cr=%g\n",result,flag,val(t,0,0,0),cc,val(t,-1,0,0),cl,val(t,1,0,0),cr);
  }
  return result;
}

#line 108
static double vof_concentration_gradient_f_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  static const double cmin = 0.5;
  double cl = val(c,0,-1,0), cc = val(c,0,0,0), cr = val(c,0,1,0);
  double result=0.0;
  int flag=0;
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin) {


          if (cr >= cmin) {
            if (cl >= cmin){


              result = (val(t,0,1,0)/cr-val(t,0,-1,0)/cl)/(2.0*Delta);
              flag = 1;
            }else{

               result = (val(t,0,1,0)/cr - val(t,0,0,0)/cc)/Delta;
               flag = 2;
            }
          }
          else if (cl >= cmin){

             result = (val(t,0,0,0)/cc - val(t,0,-1,0)/cl)/Delta;
             flag = 3;
          }



  }
  if(fabs(result)>1e+29){
    printf("result very big: result=%g flag=%d t[]=%g cc=%g t[-1]=%g cl=%g t[1]=%g cr=%g\n",result,flag,val(t,0,0,0),cc,val(t,0,-1,0),cl,val(t,0,1,0),cr);
  }
  return result;
}



#line 108
static void _stencil_vof_concentration_gradient_f_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;           

  
   _stencil_val(c,1,0,0); _stencil_val(c,0,0,0); _stencil_val(c,-1,0,0);  
  
   


{


{ {
{{


_stencil_val(t,1,0,0);_stencil_val(t,-1,0,0);  


               
               
            
#line 126
}{

_stencil_val(t,1,0,0); _stencil_val(t,0,0,0);

                  
                 
            
#line 130
}}
               
          
#line 131
}
{

_stencil_val(t,0,0,0); _stencil_val(t,-1,0,0);

                
               
          
#line 136
}}


             
              



  
#line 140
} 
  
                  
     
#line 141
{
_stencil_val(t,0,0,0);_stencil_val(t,-1,0,0);_stencil_val(t,1,0,0);
    
  
#line 143
}
  
  
#line 144
return ;
}

#line 108
static void _stencil_vof_concentration_gradient_f_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;           

  
   _stencil_val(c,0,1,0); _stencil_val(c,0,0,0); _stencil_val(c,0,-1,0);  
  
   


{


{ {
{{


_stencil_val(t,0,1,0);_stencil_val(t,0,-1,0);  


               
               
            
#line 126
}{

_stencil_val(t,0,1,0); _stencil_val(t,0,0,0);

                  
                 
            
#line 130
}}
               
          
#line 131
}
{

_stencil_val(t,0,0,0); _stencil_val(t,0,-1,0);

                
               
          
#line 136
}}


             
              



  
#line 140
} 
  
                  
     
#line 141
{
_stencil_val(t,0,0,0);_stencil_val(t,0,-1,0);_stencil_val(t,0,1,0);
    
  
#line 143
}
  
  
#line 144
return ;
}






static void vof_concentration_refine (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

#line 153
if(!is_constant(cm)){{
  scalar f = _attribute[s.i].c;
  if (val(cm,0,0,0) == 0. || (!_attribute[s.i].inverse && val(f,0,0,0) <= 0.) || (_attribute[s.i].inverse && val(f,0,0,0) >= 1.))
    {foreach_child()
      val(s,0,0,0) = 0.;end_foreach_child()}
  else {
    coord g;
    
      g.x = Delta*vof_concentration_gradient_x (point, f, s);
      
#line 161
g.y = Delta*vof_concentration_gradient_y (point, f, s);
    double sc = _attribute[s.i].inverse ? val(s,0,0,0)/(1. - val(f,0,0,0)) : val(s,0,0,0)/val(f,0,0,0), cmc = 4.*val(cm,0,0,0);
    {foreach_child() {
      val(s,0,0,0) = sc;
      
 val(s,0,0,0) += child.x*g.x*val(cm,-child.x,0,0)/cmc;
 
#line 166
val(s,0,0,0) += child.y*g.y*val(cm,0,-child.y,0)/cmc;
      val(s,0,0,0) *= _attribute[s.i].inverse ? 1. - val(f,0,0,0) : val(f,0,0,0);
    }end_foreach_child()}
  }
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);

#line 153
{
  scalar f = _attribute[s.i].c;
  if (_const_cm == 0. || (!_attribute[s.i].inverse && val(f,0,0,0) <= 0.) || (_attribute[s.i].inverse && val(f,0,0,0) >= 1.))
    {foreach_child()
      val(s,0,0,0) = 0.;end_foreach_child()}
  else {
    coord g;
    
      g.x = Delta*vof_concentration_gradient_x (point, f, s);
      
#line 161
g.y = Delta*vof_concentration_gradient_y (point, f, s);
    double sc = _attribute[s.i].inverse ? val(s,0,0,0)/(1. - val(f,0,0,0)) : val(s,0,0,0)/val(f,0,0,0), cmc = 4.*_const_cm;
    {foreach_child() {
      val(s,0,0,0) = sc;
      
 val(s,0,0,0) += child.x*g.x*_const_cm/cmc;
 
#line 166
val(s,0,0,0) += child.y*g.y*_const_cm/cmc;
      val(s,0,0,0) *= _attribute[s.i].inverse ? 1. - val(f,0,0,0) : val(f,0,0,0);
    }end_foreach_child()}
  }
}}

#line 170
}





static int defaults_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int defaults_2(const int i,const double t,Event *_ev){tracing("defaults_2","././my-vof-css-test.h",176);
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
    _attribute[c.i].dirty = true;
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      _attribute[t.i].restriction = restriction_volume_average;
      _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
      _attribute[t.i].dirty = true;
      _attribute[t.i].c = c;
    }}}
  }}}
}{end_tracing("defaults_2","././my-vof-css-test.h",189);return 0;}end_tracing("defaults_2","././my-vof-css-test.h",189);}






static int defaults_3_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int defaults_3(const int i,const double t,Event *_ev){tracing("defaults_3","././my-vof-css-test.h",196);
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
      _attribute[t.i].depends = list_add (_attribute[t.i].depends, c);}}
  }}}
}{end_tracing("defaults_3","././my-vof-css-test.h",203);return 0;}end_tracing("defaults_3","././my-vof-css-test.h",203);}





static int stability_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int stability_0(const int i,const double t,Event *_ev){tracing("stability_0","././my-vof-css-test.h",209); {
  if (CFL > 0.5)
    CFL = 0.5;
}{end_tracing("stability_0","././my-vof-css-test.h",212);return 0;}end_tracing("stability_0","././my-vof-css-test.h",212);}
#line 230 "././my-vof-css-test.h"

static void sweep_x (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux");
  double cfl = 0.;
#line 254 "././my-vof-css-test.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}




    foreach_stencil() {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 {_stencil_val_a(gf,0,0,0); _stencil_vof_concentration_gradient_x (point, c, t); }}}
    }end_foreach_stencil();




    {
#line 265
foreach() {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_x (point, c, t);}}
    }end_foreach();}
  }






  reconstruction (c, n, alpha);
  foreach_face_stencil()_stencil_is_face_x(){ {       






    _stencil_val(fm.x,0,0,0); _stencil_val(ulf.x,0,0,0);     
    








_stencil_val(cs,0,0,0);

    {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);    }     } 
#line 295 "././my-vof-css-test.h"
       
#line 311 "././my-vof-css-test.h"
    
_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);{
      {_stencil_val(c, o_stencil,0,0); }
      
{_stencil_val(n.x,o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val_higher_dimension;_stencil_val(alpha, o_stencil,0,0);     
            
            }}
          
    





    
#line 323
_stencil_val_a(flux,0,0,0);_stencil_val(ulf.x,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {       
 _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
 _stencil_val_a(tflux,0,0,0);_stencil_val(ulf.x,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }} 
      
          
         
      
    
#line 341
}}}
  }}end__stencil_is_face_x()end_foreach_face_stencil();
  
#line 278
if(!is_constant(fm.x) && !is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_x(){ {






    double un = val(ulf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)
      cf = val(c,i,0,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}else if(is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_x(){ {






    double un = val(ulf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)
      cf = val(c,i,0,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_x(){ {






    double un = val(ulf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)
      cf = val(c,i,0,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_x(){ {






    double un = val(ulf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.x*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.x*s/(_const_cm + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)
      cf = val(c,i,0,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (ferr);
#line 400 "././my-vof-css-test.h"
  foreach_stencil()
    {_stencil_val(cs,0,0,0); {


      _stencil_val_r(c,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);     
      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val_r(t,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);     }}}
    }   }end_foreach_stencil();
#line 400 "././my-vof-css-test.h"
  {foreach()
    if (val(cs,0,0,0) > 0.) {


      val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/Delta;
      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/Delta;}}
    }end_foreach();}


  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,{-1}}));
}

#line 231
static void sweep_y (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux");
  double cfl = 0.;
#line 254 "././my-vof-css-test.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}




    foreach_stencil() {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 {_stencil_val_a(gf,0,0,0); _stencil_vof_concentration_gradient_y (point, c, t); }}}
    }end_foreach_stencil();




    {
#line 265
foreach() {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_y (point, c, t);}}
    }end_foreach();}
  }






  reconstruction (c, n, alpha);
  foreach_face_stencil()_stencil_is_face_y(){ {       






    _stencil_val(fm.y,0,0,0); _stencil_val(ulf.y,0,0,0);     
    








_stencil_val(cs,0,0,0);

    {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);    }     } 
#line 295 "././my-vof-css-test.h"
       
#line 311 "././my-vof-css-test.h"
    
_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);{
      {_stencil_val(c,0, o_stencil,0); }
      
{_stencil_val(n.y,0,o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val_higher_dimension;_stencil_val(alpha,0, o_stencil,0);     
            
            }}
          
    





    
#line 323
_stencil_val_a(flux,0,0,0);_stencil_val(ulf.y,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {       
 _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
 _stencil_val_a(tflux,0,0,0);_stencil_val(ulf.y,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }} 
      
          
         
      
    
#line 341
}}}
  }}end__stencil_is_face_y()end_foreach_face_stencil();
  
#line 278
if(!is_constant(fm.y) && !is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_y(){ {






    double un = val(ulf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)
      cf = val(c,0,i,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}else if(is_constant(fm.y) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_y(){ {






    double un = val(ulf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)
      cf = val(c,0,i,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}else if(!is_constant(fm.y) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_y(){ {






    double un = val(ulf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)
      cf = val(c,0,i,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}else {struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 278
foreach_face_generic()is_face_y(){ {






    double un = val(ulf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;
#line 295 "././my-vof-css-test.h"
    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.y*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.y*s/(_const_cm + 1e-30);
#line 311 "././my-vof-css-test.h"
    double cf;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)
      cf = val(c,0,i,0);
    else
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 342
}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (ferr);
#line 400 "././my-vof-css-test.h"
  foreach_stencil()
    {_stencil_val(cs,0,0,0); {


      _stencil_val_r(c,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);     
      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val_r(t,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);     }}}
    }   }end_foreach_stencil();
#line 400 "././my-vof-css-test.h"
  {foreach()
    if (val(cs,0,0,0) > 0.) {


      val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/Delta;
      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/Delta;}}
    }end_foreach();}


  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,{-1}}));
}

extern int level_interface;
void get_topomask2(scalar topo_mask_vof){


     foreach_stencil(){       
        _stencil_val(ff,0,0,0);
 _stencil_val_a(topo_mask_vof,0,0,0);
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
   _stencil_val_a(topo_mask_vof,0,0,0);  
        }  
         
     
#line 424
}end_foreach_stencil();


     {
#line 418
foreach(){
        int phase_sign = (val(ff,0,0,0)>=0.5-0.0000000001) ? 1 : -1;
 val(topo_mask_vof,0,0,0) = 3*phase_sign;
        if(val(ff,0,0,0)<1.0-0.0000000001 && val(ff,0,0,0)>0.0000000001){
   val(topo_mask_vof,0,0,0) = 0;
        }
     }end_foreach();}
     foreach_stencil(){
{  
          
          { 
                  _stencil_val(topo_mask_vof,1,0,0); 
                  _stencil_val(topo_mask_vof,-1,0,0); 
                       
                  
                    
          }
#line 428
{ 
                  _stencil_val(topo_mask_vof,0,1,0); 
                  _stencil_val(topo_mask_vof,0,-1,0); 
                       
                  
                    
          } 
          _stencil_val(topo_mask_vof,0,0,0);
{
             _stencil_val_a(topo_mask_vof,0,0,0);_stencil_val(ff,0,0,0);       
          }
             
        
#line 439
}
        
     
#line 440
}end_foreach_stencil();
     {
#line 425
foreach(){
        if(level==level_interface){
          bool is1= false;
          {
                  int temp1=val(topo_mask_vof,1,0,0);
                  int temp2=val(topo_mask_vof,-1,0,0);
                  if(temp1==0 || temp2==0){
                      is1 = true;
                  }
          }
#line 428
{
                  int temp1=val(topo_mask_vof,0,1,0);
                  int temp2=val(topo_mask_vof,0,-1,0);
                  if(temp1==0 || temp2==0){
                      is1 = true;
                  }
          }
          int temp3=val(topo_mask_vof,0,0,0);
          if (is1 && temp3!=0){
             val(topo_mask_vof,0,0,0) = (val(ff,0,0,0)>=0.5-0.0000000001) ? 1 : -1 ;
          }
        }
     }end_foreach();}
  for(int phase=0;phase<=1;phase++){
     foreach_stencil(){
{      
             _stencil_val(ff,0,0,0);  
            
            { 
              _stencil_val(topo_mask_vof,1,0,0); 
              _stencil_val(topo_mask_vof,-1,0,0); 
                 
              
                 
            }
#line 446
{ 
              _stencil_val(topo_mask_vof,0,1,0); 
              _stencil_val(topo_mask_vof,0,-1,0); 
                 
              
                 
            }  
             _stencil_val(topo_mask_vof,0,0,0);
{
              _stencil_val_a(topo_mask_vof,0,0,0);   
            }
               
        
#line 457
}
        
     
#line 458
}end_foreach_stencil();
     {
#line 442
foreach(){
        if(level==level_interface){
            int phase_sign = val(ff,0,0,0)>=0.5-0.0000000001 ? 1 : -1;
            bool is1= false;
            {
              int temp1=val(topo_mask_vof,1,0,0);
              int temp2=val(topo_mask_vof,-1,0,0);
              if( temp1==(2*phase-1) || temp2==(2*phase-1)){
                is1 = true;
              }
            }
#line 446
{
              int temp1=val(topo_mask_vof,0,1,0);
              int temp2=val(topo_mask_vof,0,-1,0);
              if( temp1==(2*phase-1) || temp2==(2*phase-1)){
                is1 = true;
              }
            }
            int temp3 = val(topo_mask_vof,0,0,0);
            if (is1 && temp3==3*phase_sign){
              val(topo_mask_vof,0,0,0) = 2*(2*phase-1) ;
            }
        }
     }end_foreach();}
  }



}
#line 473 "././my-vof-css-test.h"
#line 1 "././reconstruction4.h"
#line 1 "./././reconstruction4.h"
#line 1 "././fractions.h"
#line 2 "./././reconstruction4.h"

#line 1 "././curvature.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
#line 12 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
static void curvature_restriction (Point point, scalar kappa)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double k = 0., s = 0.;
  {foreach_child()
    if (val(kappa,0,0,0) != HUGE)
      k += val(kappa,0,0,0), s++;end_foreach_child()}
  val(kappa,0,0,0) = s ? k/s : HUGE;
}







static void curvature_prolongation (Point point, scalar kappa)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child() {
    double sk = 0., s = 0.;
    for (int i = 0; i <= 1; i++)

      for (int j = 0; j <= 1; j++)




   if (coarse(kappa,child.x*i,child.y*j,child.z*k) != HUGE)
     sk += coarse(kappa,child.x*i,child.y*j,child.z*k), s++;
    val(kappa,0,0,0) = s ? sk/s : HUGE;
  }end_foreach_child()}
}
#line 66 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
#line 1 "././heights.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
#line 29 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
static inline double height (double H) {
  return H > 20./2. ? H - 20. : H < -20./2. ? H + 20. : H;
}

static inline int orientation (double H) {
  return fabs(H) > 20./2.;
}
#line 49 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
static void half_column (Point point, scalar c, vector h, vector cs, int j)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;






  const int complete = -1;

   {







    double S = val(c,0,0,0), H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.x,0,0,0) == 300.)
 state.s = complete, state.h = HUGE;




      else {
 int s = (val(h.x,0,0,0) + 20./2.)/100.;
 state.h = val(h.x,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,i*j,0,0) : val(cs.x,(i - 2)*j,0,0);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.x,0,0,0) = 300.;
      else if (S == complete)
 val(h.x,0,0,0) = H;
      else





 val(h.x,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.x,0,0,0) = HUGE;
      else
 val(h.x,0,0,0) = (state.h > 1e10 ? HUGE : state.h);
    }
  } 
#line 59
{







    double S = val(c,0,0,0), H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.y,0,0,0) == 300.)
 state.s = complete, state.h = HUGE;




      else {
 int s = (val(h.y,0,0,0) + 20./2.)/100.;
 state.h = val(h.y,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,0,i*j,0) : val(cs.y,0,(i - 2)*j,0);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.y,0,0,0) = 300.;
      else if (S == complete)
 val(h.y,0,0,0) = H;
      else





 val(h.y,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.y,0,0,0) = HUGE;
      else
 val(h.y,0,0,0) = (state.h > 1e10 ? HUGE : state.h);
    }
  }
}
#line 222 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
static void column_propagation (vector h)
{
  foreach_stencil ()
    for (int i = -2; i <= 2; i++)
      {
 {_stencil_val(h.x,i,0,0);
_stencil_val(h.x,i,0,0);_stencil_val(h.x,0,0,0);
   {_stencil_val_a(h.x,0,0,0); _stencil_val(h.x,i,0,0);   }      
       
#line 229
}
 
#line 227
{_stencil_val(h.y,0,i,0);
_stencil_val(h.y,0,i,0);_stencil_val(h.y,0,0,0);
   {_stencil_val_a(h.y,0,0,0); _stencil_val(h.y,0,i,0);   }      
       
#line 229
}}end_foreach_stencil();
  
#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 224
foreach ()
    for (int i = -2; i <= 2; i++)
      {
 if (fabs(height(val(h.x,i,0,0))) <= 3.5 &&
     fabs(height(val(h.x,i,0,0)) + i) < fabs(height(val(h.x,0,0,0))))
   val(h.x,0,0,0) = val(h.x,i,0,0) + i;
 
#line 227
if (fabs(height(val(h.y,0,i,0))) <= 3.5 &&
     fabs(height(val(h.y,0,i,0)) + i) < fabs(height(val(h.y,0,0,0))))
   val(h.y,0,0,0) = val(h.y,0,i,0) + i;}end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif


#line 230
}
#line 289 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"

static void refine_h_x (Point point, scalar h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  bool complete = true;
  {foreach_child() {
    for (int i = -2; i <= 2; i++)
      if (allocated(i,0,0) &&
   !(!is_leaf(neighbor(i,0,0)) && !neighbor(i,0,0).neighbors && neighbor(i,0,0).pid >= 0) && !(neighbor(i,0,0).pid < 0) &&
   fabs(height(val(h,i,0,0))) <= 3.5 &&
   fabs(height(val(h,i,0,0)) + i) < fabs(height(val(h,0,0,0))))
 val(h,0,0,0) = val(h,i,0,0) + i;
    if (val(h,0,0,0) == HUGE)
      complete = false;
  }end_foreach_child()}
  if (complete)
    return;
#line 317 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
  int ori = orientation(val(h,0,0,0));

  for (int i = -1; i <= 1; i++)
    if (val(h,0,i,0) == HUGE || orientation(val(h,0,i,0)) != ori)
      return;

  double h0 = (30.*height(val(h,0,0,0)) + height(val(h,0,1,0)) + height(val(h,0,-1,0)))/16.
    + 20.*ori;
  double dh = (height(val(h,0,1,0)) - height(val(h,0,-1,0)))/4.;
  {foreach_child()
    if (val(h,0,0,0) == HUGE)
      val(h,0,0,0) = h0 + dh*child.y - child.x/2.;end_foreach_child()}
#line 352 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
}

#line 290
static void refine_h_y (Point point, scalar h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  bool complete = true;
  {foreach_child() {
    for (int i = -2; i <= 2; i++)
      if (allocated(0,i,0) &&
   !(!is_leaf(neighbor(0,i,0)) && !neighbor(0,i,0).neighbors && neighbor(0,i,0).pid >= 0) && !(neighbor(0,i,0).pid < 0) &&
   fabs(height(val(h,0,i,0))) <= 3.5 &&
   fabs(height(val(h,0,i,0)) + i) < fabs(height(val(h,0,0,0))))
 val(h,0,0,0) = val(h,0,i,0) + i;
    if (val(h,0,0,0) == HUGE)
      complete = false;
  }end_foreach_child()}
  if (complete)
    return;
#line 317 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
  int ori = orientation(val(h,0,0,0));

  for (int i = -1; i <= 1; i++)
    if (val(h,i,0,0) == HUGE || orientation(val(h,i,0,0)) != ori)
      return;

  double h0 = (30.*height(val(h,0,0,0)) + height(val(h,1,0,0)) + height(val(h,-1,0,0)))/16.
    + 20.*ori;
  double dh = (height(val(h,1,0,0)) - height(val(h,-1,0,0)))/4.;
  {foreach_child()
    if (val(h,0,0,0) == HUGE)
      val(h,0,0,0) = h0 + dh*child.x - child.y/2.;end_foreach_child()}
#line 352 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
}






     
void heights (scalar c, vector h)
{tracing("heights","/home/xiangbin2/basilisk_new/basilisk/src/heights.h",360);
  vector  s=new_vector("s");
  
    for (int i = 0; i < nboundary; i++)
      _attribute[s.x.i].boundary[i] = _attribute[c.i].boundary[i];
    
#line 364
for (int i = 0; i < nboundary; i++)
      _attribute[s.y.i].boundary[i] = _attribute[c.i].boundary[i];





  restriction (((scalar[]){c,{-1}}));
  for (int j = -1; j <= 1; j += 2) {





    {foreach_level(0)
      {
        val(h.x,0,0,0) = HUGE;
        
#line 380
val(h.y,0,0,0) = HUGE;}end_foreach_level();}

    for (int l = 1; l <= depth(); l++) {




      {foreach_level (l)
 {
   val(s.x,0,0,0) = val(c,2*j,0,0);
   
#line 389
val(s.y,0,0,0) = val(c,0,2*j,0);}end_foreach_level();}
#line 399 "/home/xiangbin2/basilisk_new/basilisk/src/heights.h"
      {foreach_level (l - 1)
 { {
   val(s.x,0,0,0) = val(c,j,0,0);
   val(s.x,j,0,0) = val(c,2*j,0,0);
        } 
#line 400
{
   val(s.y,0,0,0) = val(c,0,j,0);
   val(s.y,0,j,0) = val(c,0,2*j,0);
        }}end_foreach_level();}






      {foreach_halo (prolongation, l - 1)
 {
   _attribute[c.i].prolongation (point, s.x);
   
#line 412
_attribute[c.i].prolongation (point, s.y);}end_foreach_halo();}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, (scalar *)((vector[]){s,{{-1},{-1}}}), l); };





      {foreach_level (l)
        half_column (point, c, h, s, j);end_foreach_level();}
    }
  }






   {
    _attribute[h.x.i].prolongation = no_data;
    _attribute[h.x.i].restriction = no_restriction;
    _attribute[h.x.i].dirty = true;
  } 
#line 429
{
    _attribute[h.y.i].prolongation = no_data;
    _attribute[h.y.i].restriction = no_restriction;
    _attribute[h.y.i].dirty = true;
  }




  column_propagation (h);






  
    _attribute[h.x.i].prolongation = refine_h_x;
    
#line 446
_attribute[h.y.i].prolongation = refine_h_y;delete((scalar*)((vector[]){s,{{-1},{-1}}}));
end_tracing("heights","/home/xiangbin2/basilisk_new/basilisk/src/heights.h",447);}








#line 67 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"



static double kappa_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int ori = orientation(val(h.y,0,0,0));
  for (int i = -1; i <= 1; i++)
    if (val(h.y,i,0,0) == HUGE || orientation(val(h.y,i,0,0)) != ori)
      return HUGE;
  double hx = (val(h.y,1,0,0) - val(h.y,-1,0,0))/2.;
  double hxx = (val(h.y,1,0,0) + val(h.y,-1,0,0) - 2.*val(h.y,0,0,0))/Delta;
  return hxx/pow(1. + sq(hx), 3/2.);
}

#line 70
static double kappa_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  int ori = orientation(val(h.x,0,0,0));
  for (int i = -1; i <= 1; i++)
    if (val(h.x,0,i,0) == HUGE || orientation(val(h.x,0,i,0)) != ori)
      return HUGE;
  double hx = (val(h.x,0,1,0) - val(h.x,0,-1,0))/2.;
  double hxx = (val(h.x,0,1,0) + val(h.x,0,-1,0) - 2.*val(h.x,0,0,0))/Delta;
  return hxx/pow(1. + sq(hx), 3/2.);
}


static coord normal_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n = {HUGE, HUGE, HUGE};
  if (val(h.y,0,0,0) == HUGE)
    return n;
  int ori = orientation(val(h.y,0,0,0));
  if (val(h.y,-1,0,0) != HUGE && orientation(val(h.y,-1,0,0)) == ori) {
    if (val(h.y,1,0,0) != HUGE && orientation(val(h.y,1,0,0)) == ori)
      n.x = (val(h.y,-1,0,0) - val(h.y,1,0,0))/2.;
    else
      n.x = val(h.y,-1,0,0) - val(h.y,0,0,0);
  }
  else if (val(h.y,1,0,0) != HUGE && orientation(val(h.y,1,0,0)) == ori)
    n.x = val(h.y,0,0,0) - val(h.y,1,0,0);
  else
    return n;
  double nn = (ori ? -1. : 1.)*sqrt(1. + sq(n.x));
  n.x /= nn;
  n.y = 1./nn;
  return n;
}

#line 82
static coord normal_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n = {HUGE, HUGE, HUGE};
  if (val(h.x,0,0,0) == HUGE)
    return n;
  int ori = orientation(val(h.x,0,0,0));
  if (val(h.x,0,-1,0) != HUGE && orientation(val(h.x,0,-1,0)) == ori) {
    if (val(h.x,0,1,0) != HUGE && orientation(val(h.x,0,1,0)) == ori)
      n.y = (val(h.x,0,-1,0) - val(h.x,0,1,0))/2.;
    else
      n.y = val(h.x,0,-1,0) - val(h.x,0,0,0);
  }
  else if (val(h.x,0,1,0) != HUGE && orientation(val(h.x,0,1,0)) == ori)
    n.y = val(h.x,0,0,0) - val(h.x,0,1,0);
  else
    return n;
  double nn = (ori ? -1. : 1.)*sqrt(1. + sq(n.y));
  n.y /= nn;
  n.x = 1./nn;
  return n;
}
#line 179 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
static double height_curvature (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;






  typedef struct {
    double n;
    double (* kappa) (Point, vector);
  } NormKappa;
  struct { NormKappa x, y, z; } n;
  
    n.x.n = val(c,1,0,0) - val(c,-1,0,0), n.x.kappa = kappa_x;
    
#line 193
n.y.n = val(c,0,1,0) - val(c,0,-1,0), n.y.kappa = kappa_y;
  double (* kappaf) (Point, vector) = NULL; NOT_UNUSED (kappaf);




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormKappa __tmp = n.x; n.x = n.y; n.y = __tmp; } while(0);
#line 211 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
  double kappa = HUGE;
  
    if (kappa == HUGE) {
      kappa = n.x.kappa (point, h);
      if (kappa != HUGE) {
 kappaf = n.x.kappa;
 if (n.x.n < 0.)
   kappa = - kappa;
      }
    }
    
#line 213
if (kappa == HUGE) {
      kappa = n.y.kappa (point, h);
      if (kappa != HUGE) {
 kappaf = n.y.kappa;
 if (n.y.n < 0.)
   kappa = - kappa;
      }
    }

  if (kappa != HUGE) {




    if (fabs(kappa) > 1./Delta)
      kappa = sign(kappa)/Delta;





    double nr, r = y, hx;
    if (kappaf == kappa_x) {
      hx = (height(val(h.x,0,1,0)) - height(val(h.x,0,-1,0)))/2.;
      nr = hx*(orientation(val(h.x,0,0,0)) ? 1 : -1);
    }
    else {
      r += height(val(h.y,0,0,0))*Delta;
      hx = (height(val(h.y,1,0,0)) - height(val(h.y,-1,0,0)))/2.;
      nr = orientation(val(h.y,0,0,0)) ? -1 : 1;
    }

    kappa += nr/max (sqrt(1. + sq(hx))*r, Delta/2.);

  }

  return kappa;
}
#line 179 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
static void _stencil_height_curvature (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;        
      
     
      






  
  
  
    { _stencil_val(c,1,0,0); _stencil_val(c,-1,0,0);     }
    
#line 193
{ _stencil_val(c,0,1,0); _stencil_val(c,0,-1,0);     }                      
  
      




     
#line 211 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
   
#line 222
{     
        




       





    
{ {
_stencil_val(h.x,0,1,0);_stencil_val(h.x,0,-1,0); 
         _stencil_val(h.x,0,0,0); 
           
    
#line 238
} 
{
_stencil_val(h.y,0,0,0);
        _stencil_val(h.y,1,0,0);_stencil_val(h.y,-1,0,0);
          _stencil_val(h.y,0,0,0);
            
    
#line 243
}}
       
    

          

  
#line 247
}
     
           
      
         
   
 
      
       
     

     

  
#line 249
return ;
}






coord height_normal (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;






  typedef struct {
    double n;
    coord (* normal) (Point, vector);
  } NormNormal;
  struct { NormNormal x, y, z; } n;
  
    n.x.n = val(c,1,0,0) - val(c,-1,0,0), n.x.normal = normal_x;
    
#line 271
n.y.n = val(c,0,1,0) - val(c,0,-1,0), n.y.normal = normal_y;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormNormal __tmp = n.x; n.x = n.y; n.y = __tmp; } while(0);
#line 288 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
  coord normal = {HUGE, HUGE, HUGE};
  
    if (normal.x == HUGE)
      normal = n.x.normal (point, h);
    
#line 290
if (normal.y == HUGE)
      normal = n.y.normal (point, h);

  return normal;
}







#line 257
static void _stencil_height_normal (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;        
      
     
      






  
  
  
    { _stencil_val(c,1,0,0); _stencil_val(c,-1,0,0);     }
    
#line 271
{ _stencil_val(c,0,1,0); _stencil_val(c,0,-1,0);     }                  
    




     
#line 288 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
  
     
        
      

  return ;
}
#line 330 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
#line 1 "././parabola.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"
#line 1 "././utils.h"
#line 2 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"






typedef struct {
  coord o;

  coord m;
  double ** M, rhs[3], a[3];
#line 21 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"
} ParabolaFit;

static void parabola_fit_init (ParabolaFit * p, coord o, coord m)
{
  
    p->o.x = o.x;
    
#line 26
p->o.y = o.y;

  
    p->m.x = m.x;
    
#line 29
p->m.y = m.y;
  normalize (&p->m);
  int n = 3;
#line 65 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"
  p->M = (double **) matrix_new (n, n, sizeof(double));
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++)
      p->M[i][j] = 0.;
    p->rhs[i] = 0.;
  }
}

static void parabola_fit_add (ParabolaFit * p, coord m, double w)
{

  double x1 = m.x - p->o.x, y1 = m.y - p->o.y;
  double x = p->m.y*x1 - p->m.x*y1;
  double y = p->m.x*x1 + p->m.y*y1;
  double x2 = w*x*x, x3 = x2*x, x4 = x3*x;
  p->M[0][0] += x4;
  p->M[1][0] += x3; p->M[1][1] += x2;
  p->M[2][1] += w*x; p->M[2][2] += w;
  p->rhs[0] += x2*y; p->rhs[1] += w*x*y; p->rhs[2] += w*y;
#line 111 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"
}

static double parabola_fit_solve (ParabolaFit * p)
{

  p->M[0][1] = p->M[1][0];
  p->M[0][2] = p->M[2][0] = p->M[1][1];
  p->M[1][2] = p->M[2][1];
  double pivmin = matrix_inverse (p->M, 3, 1e-10);
  if (pivmin) {
    p->a[0] = p->M[0][0]*p->rhs[0] + p->M[0][1]*p->rhs[1] + p->M[0][2]*p->rhs[2];
    p->a[1] = p->M[1][0]*p->rhs[0] + p->M[1][1]*p->rhs[1] + p->M[1][2]*p->rhs[2];
  }
  else
    p->a[0] = p->a[1] = 0.;
#line 158 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"
  matrix_free (p->M);
  return pivmin;
}

static double parabola_fit_curvature (ParabolaFit * p,
          double kappamax, double * kmax)
{
  double kappa;

  double dnm = 1. + sq(p->a[1]);
  kappa = - 2.*p->a[0]/pow(dnm, 3/2.);
  if (kmax)
    *kmax = fabs (kappa);
#line 190 "/home/xiangbin2/basilisk_new/basilisk/src/parabola.h"
  if (fabs (kappa) > kappamax) {
    if (kmax)
      *kmax = kappamax;
    return kappa > 0. ? kappamax : - kappamax;
  }
  return kappa;
}


static void parabola_fit_axi_curvature (const ParabolaFit * p,
     double r, double h,
     double * kappa, double * kmax)
{
  double nr = (p->m.x*p->a[1] + p->m.y)/sqrt (1. + sq(p->a[1]));

  double kaxi = nr/max(r, h/2.);
  *kappa += kaxi;
  if (kmax)
    *kmax = max (*kmax, fabs (kaxi));
}
#line 331 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"






static int independents (coord * p, int n)
{
  if (n < 2)
    return n;
  int ni = 1;
  for (int j = 1; j < n; j++) {
    bool depends = false;
    for (int i = 0; i < j && !depends; i++) {
      double d2 = 0.;
      
 d2 += sq(p[i].x - p[j].x);
 
#line 347
d2 += sq(p[i].y - p[j].y);
      depends = (d2 < sq(0.5));
    }
    ni += !depends;
  }
  return ni;
}






static double height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;





  coord ip[2 == 2 ? 6 : 27];
  int n = 0;




   {





    int n1 = 0, n2 = 0;

    for (int i = -1; i <= 1; i++)
      if (val(h.y,i,0,0) != HUGE) {
 if (orientation(val(h.y,i,0,0))) n1++; else n2++;
      }







    int ori = (n1 > n2);







    for (int i = -1; i <= 1; i++)
      if (val(h.y,i,0,0) != HUGE && orientation(val(h.y,i,0,0)) == ori)
 ip[n].x = i, ip[n++].y = height(val(h.y,i,0,0));






  } 
#line 373
{





    int n1 = 0, n2 = 0;

    for (int i = -1; i <= 1; i++)
      if (val(h.x,0,i,0) != HUGE) {
 if (orientation(val(h.x,0,i,0))) n1++; else n2++;
      }







    int ori = (n1 > n2);







    for (int i = -1; i <= 1; i++)
      if (val(h.x,0,i,0) != HUGE && orientation(val(h.x,0,i,0)) == ori)
 ip[n].y = i, ip[n++].x = height(val(h.x,0,i,0));






  }





  if (independents (ip, n) < (2 == 2 ? 3 : 9))
    return HUGE;





  coord m = mycs (point, c), fc;
  double alpha = line_alpha (val(c,0,0,0), m);
  double area = line_length_center(m,alpha,&fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);

  NOT_UNUSED(area);
  parabola_fit_add (&fit, fc, .1);
#line 438 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
  for (int i = 0; i < n; i++)
    parabola_fit_add (&fit, ip[i], 1.);
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., NULL)/Delta;

  parabola_fit_axi_curvature (&fit, y + fc.y*Delta, Delta, &kappa, NULL);

  return kappa;
}







#line 360
static void _stencil_height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;          





  
  




   {      





    

    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.y,i,0,0); {
_stencil_val(h.y,i,0,0);  
   
      
#line 384
}   }     







    







    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.y,i,0,0);_stencil_val(h.y,i,0,0);
 {_stencil_val(h.y,i,0,0);     }       }






  } 
#line 373
{      





    

    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.x,0,i,0); {
_stencil_val(h.x,0,i,0);  
   
      
#line 384
}   }     







    







    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.x,0,i,0);_stencil_val(h.x,0,i,0);
 {_stencil_val(h.x,0,i,0);     }       }






  }    
    





             





   _stencil_mycs (point, c);     
  _stencil_val(c,0,0,0);          
  
                 
  

  
  
#line 438 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
     
    
  
         

  

  return ;
}






static double centroids_curvature_fit (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;





  coord m = mycs (point, c), fc;
  double alpha = line_alpha (val(c,0,0,0), m);
  line_length_center(m,alpha,&fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);





  coord r = {x,y,z};
  {foreach_neighbor(1)
    if (val(c,0,0,0) > 0. && val(c,0,0,0) < 1.) {
      coord m = mycs (point, c), fc;
      double alpha = line_alpha (val(c,0,0,0), m);
      double area = line_length_center(m,alpha,&fc);
      coord rn = {x,y,z};
      
 fc.x += (rn.x - r.x)/Delta;
 
#line 478
fc.y += (rn.y - r.y)/Delta;
      parabola_fit_add (&fit, fc, area);
    }end_foreach_neighbor()}
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., NULL)/Delta;

  parabola_fit_axi_curvature (&fit, y + fc.y*Delta, Delta, &kappa, NULL);

  return kappa;
}







#line 453
static void _stencil_centroids_curvature_fit (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;   





   _stencil_mycs (point, c);     
  _stencil_val(c,0,0,0);    
  
     
  





  
  {foreach_neighbor(1)
    {_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
       _stencil_mycs (point, c);     
      _stencil_val(c,0,0,0);      
      
      
       
       
      
    }      }end_foreach_neighbor()}       
  
         

  

  return ;
}
#line 500 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
static inline bool interfacial (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (val(c,0,0,0) >= 1.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (val(c,i,0,0) <= 0.)
   return true;
 
#line 505
if (val(c,0,i,0) <= 0.)
   return true;}
  }
  else if (val(c,0,0,0) <= 0.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (val(c,i,0,0) >= 1.)
   return true;
 
#line 511
if (val(c,0,i,0) >= 1.)
   return true;}
  }
  else
    return true;
  return false;
}
#line 500 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
static void _stencil_interfacial (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
_stencil_val(c,0,0,0);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {_stencil_val(c,i,0,0); 
      }
 
#line 505
{_stencil_val(c,0,i,0); 
      }}
  } 
{_stencil_val(c,0,0,0);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {_stencil_val(c,i,0,0); 
      }
 
#line 511
{_stencil_val(c,0,i,0); 
      }}
  } 
    
}   
  
#line 515
}}
     
  
  
#line 516
return ;
}
#line 530 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
typedef struct {
  int h;
  int f;
  int a;
  int c;
} cstats;

struct Curvature {
  scalar c, kappa;
  double sigma;
  bool add;
};

     
cstats curvature (struct Curvature p)
{tracing("curvature","/home/xiangbin2/basilisk_new/basilisk/src/curvature.h",544);
  scalar c = p.c, kappa = p.kappa;
  double sigma = p.sigma ? p.sigma : 1.;
  int sh = 0, sf = 0, sa = 0, sc = 0;
  vector ch = _attribute[c.i].height,   h=(ch).x.i?(ch):new_vector("h");
  if (!ch.x.i)
    heights (c, h);






  _attribute[kappa.i].refine = _attribute[kappa.i].prolongation = curvature_prolongation;
  _attribute[kappa.i].restriction = curvature_restriction;






  scalar  k=new_scalar("k");
  scalar_clone (k, kappa);

  foreach_stencil() {




_stencil_interfacial (point, c);{
      {_stencil_val_a(k,0,0,0);  } 





{_stencil_val_a(k,0,0,0); _stencil_height_curvature (point, c, h);{
       
{_stencil_val_a(k,0,0,0); _stencil_height_curvature_fit (point, c, h);
          }}    
    
#line 584
}}




     





    
  
#line 585
}end_foreach_stencil();

  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:sf)reduction(+:sh)){
#line 569
foreach() {




    if (!interfacial (point, c))
      val(k,0,0,0) = HUGE;





    else if ((val(k,0,0,0) = height_curvature (point, c, h)) != HUGE)
      sh++;
    else if ((val(k,0,0,0) = height_curvature_fit (point, c, h)) != HUGE)
      sf++;
  }end_foreach();mpi_all_reduce_array(&sf,int,MPI_SUM,1);mpi_all_reduce_array(&sh,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}

  
#line 587
foreach_stencil () { 





    
_stencil_val(k,0,0,0);{
      { _stencil_val(k,0,0,0); } 
{_stencil_interfacial (point, c);{ {      





      
      {foreach_neighbor(1)
 {_stencil_val(k,0,0,0);
   { _stencil_val(k,0,0,0);  }   }end_foreach_neighbor()}




 


{ _stencil_centroids_curvature_fit (point, c);  }
         
    
      
    
#line 614
}
        
} 
    
#line 616
}}




{
      {_stencil_val_a(kappa,0,0,0);  } 
if (p.add)
      {_stencil_val_r(kappa,0,0,0);  }
    else
      {_stencil_val_a(kappa,0,0,0);  }}
       
    




       
    
  
#line 627
}end_foreach_stencil();

  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:sc)reduction(+:sa)){
#line 587
foreach () {





    double kf;
    if (val(k,0,0,0) < HUGE)
      kf = val(k,0,0,0);
    else if (interfacial (point, c)) {





      double sk = 0., a = 0.;
      {foreach_neighbor(1)
 if (val(k,0,0,0) < HUGE)
   sk += val(k,0,0,0), a++;end_foreach_neighbor()}
      if (a > 0.)
 kf = sk/a, sa++;
      else




 kf = centroids_curvature_fit (point, c), sc++;
    }
    else
      kf = HUGE;




    if (kf == HUGE)
      val(kappa,0,0,0) = HUGE;
    else if (p.add)
      val(kappa,0,0,0) += sigma*kf;
    else
      val(kappa,0,0,0) = sigma*kf;
  }end_foreach();mpi_all_reduce_array(&sc,int,MPI_SUM,1);mpi_all_reduce_array(&sa,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}

  
#line 629
{ cstats _ret= (cstats){sh, sf, sa, sc};{delete((scalar*)((scalar[]){k,{-1}}));if(!(ch).x.i)delete((scalar*)((vector[]){h,{{-1},{-1}}}));}{end_tracing("curvature","/home/xiangbin2/basilisk_new/basilisk/src/curvature.h",629);return _ret;}}{delete((scalar*)((scalar[]){k,{-1}}));if(!(ch).x.i)delete((scalar*)((vector[]){h,{{-1},{-1}}}));}
end_tracing("curvature","/home/xiangbin2/basilisk_new/basilisk/src/curvature.h",630);}
#line 649 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"

static double pos_x (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (fabs(height(val(h.x,0,0,0))) > 1.)
    return HUGE;
  coord o = {x, y, z};
  o.x += height(val(h.x,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.x - Z->x)*G->x;
    
#line 658
pos += (o.y - Z->y)*G->y;
  return pos;
}

#line 650
static double pos_y (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (fabs(height(val(h.y,0,0,0))) > 1.)
    return HUGE;
  coord o = {x, y, z};
  o.y += height(val(h.y,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.y - Z->y)*G->y;
    
#line 658
pos += (o.x - Z->x)*G->x;
  return pos;
}







static double height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;






  typedef struct {
    double n;
    double (* pos) (Point, vector, coord *, coord *);
  } NormPos;
  struct { NormPos x, y, z; } n;
  
    n.x.n = val(f,1,0,0) - val(f,-1,0,0), n.x.pos = pos_x;
    
#line 683
n.y.n = val(f,0,1,0) - val(f,0,-1,0), n.y.pos = pos_y;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormPos __tmp = n.x; n.x = n.y; n.y = __tmp; } while(0);
#line 700 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
  double pos = HUGE;
  
    if (pos == HUGE)
      pos = n.x.pos (point, h, G, Z);
    
#line 702
if (pos == HUGE)
      pos = n.y.pos (point, h, G, Z);

  return pos;
}








#line 668
static void _stencil_height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;        
          
     
      






  
  
  
    { _stencil_val(f,1,0,0); _stencil_val(f,-1,0,0);     }
    
#line 683
{ _stencil_val(f,0,1,0); _stencil_val(f,0,-1,0);     }                
    




     
#line 700 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
  
     
          
      

  return ;
}
#line 717 "/home/xiangbin2/basilisk_new/basilisk/src/curvature.h"
struct Position {
  scalar f, pos;
  coord G, Z;
  bool add;
};

void position (struct Position p)
{
  scalar f = p.f, pos = p.pos;
  coord * G = &p.G, * Z = &p.Z;






  _attribute[pos.i].refine = _attribute[pos.i].prolongation = curvature_prolongation;
  _attribute[pos.i].restriction = curvature_restriction;


  vector fh = _attribute[f.i].height,   h=(fh).x.i?(fh):new_vector("h");
  if (!fh.x.i)
    heights (f, h);
  foreach_stencil() {
_stencil_interfacial (point, f);{ {  
       _stencil_height_position (point, f, h, G, Z); 
{      





  _stencil_mycs (point, f);     
 _stencil_val(f,0,0,0); 
 
  
 
         
      }
         
      
#line 756
if (p.add)
 {_stencil_val_r(pos,0,0,0);  }
      else
 {_stencil_val_a(pos,0,0,0);  }
    }
      
{_stencil_val_a(pos,0,0,0);  }}
     
    
  
#line 763
}end_foreach_stencil();
  {
#line 740
foreach() {
    if (interfacial (point, f)) {
      double hp = height_position (point, f, h, G, Z);
      if (hp == HUGE) {





 coord n = mycs (point, f), o = {x,y,z}, c;
 double alpha = line_alpha (val(f,0,0,0), n);
 line_length_center(n,alpha,&c);
 hp = 0.;
 
   hp += (o.x + Delta*c.x - Z->x)*G->x;
   
#line 754
hp += (o.y + Delta*c.y - Z->y)*G->y;
      }
      if (p.add)
 val(pos,0,0,0) += hp;
      else
 val(pos,0,0,0) = hp;
    }
    else
      val(pos,0,0,0) = HUGE;
  }end_foreach();}{if(!(fh).x.i)delete((scalar*)((vector[]){h,{{-1},{-1}}}));}
}
#line 4 "./././reconstruction4.h"
coord interface_normal8 (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n;
  if (!h.x.i || (n = height_normal (point, c, h)).x == HUGE)
    n = mycs (point, c);
  return n;
}
#line 4 "./././reconstruction4.h"
static void _stencil_interface_normal8 (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 
   
_stencil_height_normal (point, c, h);
    { _stencil_mycs (point, c); }
        
  
#line 9
return ;
}

void reconstruction4 (const scalar c, vector n, scalar alpha)
{
  vector  h_temp=new_vector("h_temp");
  heights(c,h_temp);
  foreach_stencil() {





_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
      _stencil_val_a(alpha,0,0,0);  
      
 {_stencil_val_a(n.x,0,0,0);  }
 
#line 25
{_stencil_val_a(n.y,0,0,0);  }
    } 
{  






       _stencil_interface_normal8 (point, c, h_temp);
      
 {_stencil_val_a(n.x,0,0,0);  }
 
#line 36
{_stencil_val_a(n.y,0,0,0);  }
      _stencil_val_a(alpha,0,0,0);_stencil_val(c,0,0,0);    
    }}





          
    
  
#line 39
}end_foreach_stencil();
  {
#line 16
foreach() {





    if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
      val(alpha,0,0,0) = 0.;
      
 val(n.x,0,0,0) = 0.;
 
#line 25
val(n.y,0,0,0) = 0.;
    }
    else {






      coord m = interface_normal8 (point, c, h_temp);
      
 val(n.x,0,0,0) = m.x;
 
#line 36
val(n.y,0,0,0) = m.y;
      val(alpha,0,0,0) = line_alpha (val(c,0,0,0), m);
    }
  }end_foreach();}
#line 48 "./././reconstruction4.h"
  
    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;
    
#line 49
_attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;delete((scalar*)((vector[]){h_temp,{{-1},{-1}}}));

}
#line 474 "././my-vof-css-test.h"





static void sweep2_x (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux"), flux_css_test=new_scalar("flux_css_test");

  vector  solid_n=new_vector("solid_n");
  scalar  solid_neg_alpha=new_scalar("solid_neg_alpha");

  vector  css_test_n=new_vector("css_test_n");
  scalar  css_test_alpha=new_scalar("css_test_alpha");
  double cfl = 0.;

  scalar  cs_neg=new_scalar("cs_neg");
  foreach_stencil(){
    _stencil_val_a(cs_neg,0,0,0);_stencil_val(cs,0,0,0);  
  }end_foreach_stencil();
  {
#line 492
foreach(){
    val(cs_neg,0,0,0) = 1.0-val(cs,0,0,0);
  }end_foreach();}
#line 513 "././my-vof-css-test.h"
  scalar  flux2=new_scalar("flux2");

  scalar  fluxg=new_scalar("fluxg");



  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL, * tfluxl_css_test = NULL;
  scalar * gfl2 = NULL, * gflg = NULL, * tfluxl2 = NULL, * tfluxlg = NULL;


  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {

      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      scalar gf2 = new_scalar("gf2"), flux2 = new_scalar("flux2");

      scalar gfg = new_scalar("gfg"), fluxg = new_scalar("fluxg");

      scalar flux_css_test = new_scalar("flux_css_test");

      gfl = list_append (gfl, gf);

      tfluxl = list_append (tfluxl, flux);

      gfl2 = list_append (gfl2, gf2);
      tfluxl2 = list_append (tfluxl2, flux2);

      gflg = list_append (gflg, gfg);
      tfluxlg = list_append (tfluxlg, fluxg);

        tfluxl_css_test = list_append (tfluxl_css_test, flux_css_test);
    }}}




    foreach_stencil() {
      scalar t, gf, gf2, gfg;
      {scalar*_i0= gflg;scalar*_i1= gfl2;scalar*_i2= gfl;scalar*_i3= tracers;if(_i0)for(gfg=*_i0,gf2=*_i1,gf=*_i2,t=*_i3;_i0->i>= 0;gfg=*++_i0,gf2=*++_i1,gf=*++_i2,t=*++_i3){{
       _stencil_val_a(gf,0,0,0); _stencil_vof_concentration_gradient_f_x (point, c, t);

_stencil_val(gf,0,0,0);{
_stencil_val(gf,0,0,0);
            
        
#line 556
} 

        
        
#line 557
_stencil_val_a(gf2,0,0,0); _stencil_val(gf,0,0,0); 
        _stencil_val_a(gfg,0,0,0); _stencil_val(gf,0,0,0); 
      }}}
    }end_foreach_stencil();




    {
#line 549
foreach() {
      scalar t, gf, gf2, gfg;
      {scalar*_i0= gflg;scalar*_i1= gfl2;scalar*_i2= gfl;scalar*_i3= tracers;if(_i0)for(gfg=*_i0,gf2=*_i1,gf=*_i2,t=*_i3;_i0->i>= 0;gfg=*++_i0,gf2=*++_i1,gf=*++_i2,t=*++_i3){{
       val(gf,0,0,0) = vof_concentration_gradient_f_x (point, c, t);

        if(fabs(val(gf,0,0,0))>1e+29){
            printf("gf[]=%g, is true\n",val(gf,0,0,0));
        }
        val(gf2,0,0,0) = val(gf,0,0,0);
        val(gfg,0,0,0) = val(gf,0,0,0);
      }}}
    }end_foreach();}

  }
  boundary_internal ((scalar *)gfl, "././my-vof-css-test.h", 563);
  boundary_internal ((scalar *)gfl2, "././my-vof-css-test.h", 564);
  boundary_internal ((scalar *)gflg, "././my-vof-css-test.h", 565);







if(1==1){
  reconstruction (c, n, alpha);
}else{
  reconstruction4 (c, n, alpha);
}
  reconstruction (cs_neg, solid_n, solid_neg_alpha);

   scalar  topo_mask2=new_scalar("topo_mask2");
   get_topomask2(topo_mask2);

   scalar  topo_mask2_g=new_scalar("topo_mask2_g");
   foreach_stencil(){
      _stencil_val_a(topo_mask2_g,0,0,0);_stencil_val(topo_mask2,0,0,0);  
   }end_foreach_stencil();
   {
#line 584
foreach(){
      val(topo_mask2_g,0,0,0) = -val(topo_mask2,0,0,0);
   }end_foreach();}



  foreach_face_stencil()_stencil_is_face_x(){ {        
#line 599 "././my-vof-css-test.h"
   





    _stencil_val(fm.x,0,0,0); _stencil_val(ulf.x,0,0,0);            
    

    _stencil_val(fm.x,0,0,0); _stencil_val(ugf.x,0,0,0);            
    

    _stencil_val(fm.x,0,0,0); _stencil_val(uf.x,0,0,0);     
    






_stencil_val(cs,0,0,0);{

_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);
             {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);    }

_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);
             {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);    }

_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);
             {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);    }

             

             

             
    
#line 629
} 






       
#line 654 "././my-vof-css-test.h"

_stencil_val(modify_near_region,0,0,0); _stencil_val(cs,0,0,0);{
_stencil_val(cs,o_stencil,0,0);{{
_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);
_stencil_val(n.x,o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val_higher_dimension;_stencil_val(alpha, o_stencil,0,0); 
                      
                
               
            

      
#line 662
} {_stencil_val(cs,o_stencil,0,0);_stencil_val(cs, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);{{     

          
          
          _stencil_val(solid_n.y,o_stencil,0,0);_stencil_val(solid_n.x,o_stencil,0,0);  
          _stencil_val(solid_neg_alpha, o_stencil,0,0);   

            
{{     







                
                  
                 

                 
                


                 

                
                 



_stencil_val(fs.x,0,0,0);{{
_stencil_val(fs.x,0,0,0);
                      
                    
                        
                    
                
#line 698
}
                    
                }



                


        
#line 703
}
              
        }
            

        
#line 707
} {_stencil_val(cs,o_stencil,0,0);_stencil_val(cs, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);{{     


          
          
          _stencil_val(solid_n.y,o_stencil,0,0);_stencil_val(solid_n.x,o_stencil,0,0);  
          _stencil_val(solid_neg_alpha, o_stencil,0,0);   

          _stencil_val(n.y,o_stencil,0,0);_stencil_val(n.x,o_stencil,0,0);  


          _stencil_val(alpha, o_stencil,0,0);   



          
{{    
              
                 
               
               
               
              





_stencil_val(fs.x,0,0,0);{{
_stencil_val(fs.x,0,0,0);
                      
                    
                        
                    
                
#line 740
}
                    
                }


              


              

          
#line 744
}
                
          }
          
      
#line 747
}
            
      }    }}  }}


_stencil_val(cs,0,0,0);_stencil_val(cs, o_stencil,0,0);_stencil_val(cs,o_stencil,0,0); _stencil_val(cs,0,0,0);{   
                _stencil_val(fs.x,0,0,0);   

                _stencil_val(cs,o_stencil,0,0);_stencil_val(cs,0,0,0); 
_stencil_val(fs.x,0,0,0);{
_stencil_val(fs.x,0,0,0);
                      
                
#line 758
}
                 
          
#line 759
}
      


                
  
#line 760
}   
 


    
    
     _stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);{{
_stencil_val(c, o_stencil,0,0); 
      
    
#line 768
}{
_stencil_val(n.x,o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val_higher_dimension;_stencil_val(alpha, o_stencil,0,0);
           
            
            
    
#line 772
}}




_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);{{
_stencil_val(c, o_stencil,0,0); 
      
    
#line 779
}{
_stencil_val(n.x,o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val_higher_dimension;_stencil_val(alpha, o_stencil,0,0);
           
            
            
    
#line 783
}}

_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);{{
_stencil_val(c, o_stencil,0,0); 
      
    
#line 787
}{
_stencil_val(n.x,o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val_higher_dimension;_stencil_val(alpha, o_stencil,0,0);
           
            
            
    
#line 791
}}
          




          

         

    
#line 793
_stencil_val_a(flux,0,0,0);_stencil_val(ulf.x,0,0,0);  
    _stencil_val_a(flux2,0,0,0);_stencil_val(uf.x,0,0,0);  
    _stencil_val_a(fluxg,0,0,0);_stencil_val(ugf.x,0,0,0);  

    _stencil_val_a(flux_css_test,0,0,0);_stencil_val(ulf.x,0,0,0);  





    scalar t, gf, tflux , tflux2 , tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;if(_i0)for(tfluxg=*_i0,tflux2=*_i1,tflux=*_i2,gf=*_i3,t=*_i4;_i0->i>= 0;tfluxg=*++_i0,tflux2=*++_i1,tflux=*++_i2,gf=*++_i3,t=*++_i4){ {     
      _stencil_val(c, o_stencil,0,0);     
      _stencil_val(c, o_stencil,0,0);     
      _stencil_val(c, o_stencil,0,0);




{ {       
          _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
          _stencil_val_a(tflux,0,0,0);_stencil_val(ulf.x,0,0,0);  
          if(!_attribute[t.i].inverse){
            _stencil_val_a(flux_show.x,0,0,0);_stencil_val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
{
         _stencil_val_a(tflux,0,0,0);  
          if(!_attribute[t.i].inverse){



          }
      }}




{ {       
        _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
        _stencil_val_a(tflux2,0,0,0);_stencil_val(uf.x,0,0,0);  
      }
{
        _stencil_val_a(tflux2,0,0,0);
      }}




{ {       
          _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
          _stencil_val_a(tfluxg,0,0,0);_stencil_val(ugf.x,0,0,0);  
      }
{
         _stencil_val_a(tfluxg,0,0,0);  
      }}   

      
                     
       
         
      

      
                 
       
         
      

       
                     
       
         
      
    
#line 865
}}}

  }}end__stencil_is_face_x()end_foreach_face_stencil();



  
#line 590
if(!is_constant(fm.x) && !is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_x(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30);

        if (ung*val(fm.x,0,0,0)*sg/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = ung*val(fm.x,0,0,0)*sg/(val(cm,0,0,0) + 1e-30);

        if (un2*val(fm.x,0,0,0)*s2/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un2*val(fm.x,0,0,0)*s2/(val(cm,0,0,0) + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,i,0,0)>=1.0){
          cf_css_test = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
            rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,i,0,0)>0.0 && val(cs,i,0,0)<1.0) && val(c,i,0,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;

                a2 = face_n.x,b2=face_n.y;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,i,0,0)<1.0 && val(cs,i,0,0)>0.0) && (val(c,i,0,0)<1.0 && val(c,i,0,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

          coord nlg = (coord){val(n.x,i,0,0),val(n.y,i,0,0)};


          double alphalg = val(alpha,i,0,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
              a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
              a3 = face_n.x,b3=face_n.y;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,i,0,0)<1) || (val(cs,i,0,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.x,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,i,0,0))*1.0;
                if(flux1>limit && val(fs.x,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.x,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.){
      cf = val(c,i,0,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,i2,0,0) <= 0. || val(c,i2,0,0) >= 1.){
      cf2 = val(c,i2,0,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.x,i2,0,0), val(n.y,i2,0,0), _val_higher_dimension}, val(alpha,i2,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,ig,0,0) <= 0. || val(c,ig,0,0) >= 1.){
      cfg = val(c,ig,0,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.x,ig,0,0), val(n.y,ig,0,0), _val_higher_dimension}, val(alpha,ig,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.x,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.x,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.x,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,i,0,0);
      double cf21 = cf2, ci2 = val(c,i2,0,0);
      double cf1g = cfg, cig = val(c,ig,0,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.x,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,i2,0,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,i2,0,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.x,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,ig,0,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,ig,0,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.x,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}else if(is_constant(fm.x) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);



  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_x(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30);

        if (ung*_const_fm.x*sg/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = ung*_const_fm.x*sg/(val(cm,0,0,0) + 1e-30);

        if (un2*_const_fm.x*s2/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un2*_const_fm.x*s2/(val(cm,0,0,0) + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,i,0,0)>=1.0){
          cf_css_test = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
            rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,i,0,0)>0.0 && val(cs,i,0,0)<1.0) && val(c,i,0,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;

                a2 = face_n.x,b2=face_n.y;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,i,0,0)<1.0 && val(cs,i,0,0)>0.0) && (val(c,i,0,0)<1.0 && val(c,i,0,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

          coord nlg = (coord){val(n.x,i,0,0),val(n.y,i,0,0)};


          double alphalg = val(alpha,i,0,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
              a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
              a3 = face_n.x,b3=face_n.y;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,i,0,0)<1) || (val(cs,i,0,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.x,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,i,0,0))*1.0;
                if(flux1>limit && val(fs.x,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.x,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.){
      cf = val(c,i,0,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,i2,0,0) <= 0. || val(c,i2,0,0) >= 1.){
      cf2 = val(c,i2,0,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.x,i2,0,0), val(n.y,i2,0,0), _val_higher_dimension}, val(alpha,i2,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,ig,0,0) <= 0. || val(c,ig,0,0) >= 1.){
      cfg = val(c,ig,0,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.x,ig,0,0), val(n.y,ig,0,0), _val_higher_dimension}, val(alpha,ig,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.x,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.x,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.x,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,i,0,0);
      double cf21 = cf2, ci2 = val(c,i2,0,0);
      double cf1g = cfg, cig = val(c,ig,0,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.x,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,i2,0,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,i2,0,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.x,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,ig,0,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,ig,0,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.x,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);



  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_x(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30) > cfl)
             cfl = un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30);

        if (ung*val(fm.x,0,0,0)*sg/(_const_cm + 1e-30) > cfl)
             cfl = ung*val(fm.x,0,0,0)*sg/(_const_cm + 1e-30);

        if (un2*val(fm.x,0,0,0)*s2/(_const_cm + 1e-30) > cfl)
             cfl = un2*val(fm.x,0,0,0)*s2/(_const_cm + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,i,0,0)>=1.0){
          cf_css_test = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
            rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,i,0,0)>0.0 && val(cs,i,0,0)<1.0) && val(c,i,0,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;

                a2 = face_n.x,b2=face_n.y;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,i,0,0)<1.0 && val(cs,i,0,0)>0.0) && (val(c,i,0,0)<1.0 && val(c,i,0,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

          coord nlg = (coord){val(n.x,i,0,0),val(n.y,i,0,0)};


          double alphalg = val(alpha,i,0,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
              a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
              a3 = face_n.x,b3=face_n.y;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,i,0,0)<1) || (val(cs,i,0,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.x,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,i,0,0))*1.0;
                if(flux1>limit && val(fs.x,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.x,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.){
      cf = val(c,i,0,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,i2,0,0) <= 0. || val(c,i2,0,0) >= 1.){
      cf2 = val(c,i2,0,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.x,i2,0,0), val(n.y,i2,0,0), _val_higher_dimension}, val(alpha,i2,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,ig,0,0) <= 0. || val(c,ig,0,0) >= 1.){
      cfg = val(c,ig,0,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.x,ig,0,0), val(n.y,ig,0,0), _val_higher_dimension}, val(alpha,ig,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.x,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.x,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.x,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,i,0,0);
      double cf21 = cf2, ci2 = val(c,i2,0,0);
      double cf1g = cfg, cig = val(c,ig,0,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.x,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,i2,0,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,i2,0,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.x,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,ig,0,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,ig,0,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.x,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);



  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_x(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*_const_fm.x*s/(_const_cm + 1e-30) > cfl)
             cfl = un*_const_fm.x*s/(_const_cm + 1e-30);

        if (ung*_const_fm.x*sg/(_const_cm + 1e-30) > cfl)
             cfl = ung*_const_fm.x*sg/(_const_cm + 1e-30);

        if (un2*_const_fm.x*s2/(_const_cm + 1e-30) > cfl)
             cfl = un2*_const_fm.x*s2/(_const_cm + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,i,0,0)>=1.0){
          cf_css_test = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
            rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,i,0,0)>0.0 && val(cs,i,0,0)<1.0) && val(c,i,0,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;

                a2 = face_n.x,b2=face_n.y;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,i,0,0)<1.0 && val(cs,i,0,0)>0.0) && (val(c,i,0,0)<1.0 && val(c,i,0,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.x,i,0,0),val(solid_n.y,i,0,0)};
          double alphasf = val(solid_neg_alpha,i,0,0);

          coord nlg = (coord){val(n.x,i,0,0),val(n.y,i,0,0)};


          double alphalg = val(alpha,i,0,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
              a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
              a3 = face_n.x,b3=face_n.y;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.x,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.x,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,i,0,0)<1) || (val(cs,i,0,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.x,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,i,0,0))*1.0;
                if(flux1>limit && val(fs.x,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.x,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.){
      cf = val(c,i,0,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), _val_higher_dimension}, val(alpha,i,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,i2,0,0) <= 0. || val(c,i2,0,0) >= 1.){
      cf2 = val(c,i2,0,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.x,i2,0,0), val(n.y,i2,0,0), _val_higher_dimension}, val(alpha,i2,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,ig,0,0) <= 0. || val(c,ig,0,0) >= 1.){
      cfg = val(c,ig,0,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.x,ig,0,0), val(n.y,ig,0,0), _val_higher_dimension}, val(alpha,ig,0,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.x,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.x,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.x,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.x,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,i,0,0);
      double cf21 = cf2, ci2 = val(c,i2,0,0);
      double cf1g = cfg, cig = val(c,ig,0,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,i,0,0)/ci + s*min(1., 1. - s*un)*val(gf,i,0,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.x,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.x,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,i2,0,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,i2,0,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.x,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,ig,0,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,ig,0,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.x,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_x()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}



  scalar * fluxl = list_concat (NULL, tfluxl);
  fluxl = list_concat (fluxl, tfluxl2);
  fluxl = list_concat (fluxl, tfluxlg);
  fluxl = list_append (fluxl, flux);
  fluxl = list_append (fluxl, flux_css_test);
  for (int l = depth() - 1; l >= 0; l--)
    {foreach_halo (prolongation, l) {
#line 886 "././my-vof-css-test.h"
      if ((!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))
 {scalar*_i=(scalar*)( fluxl);if(_i)for(scalar fl=*_i;(&fl)->i>=0;fl=*++_i){
   val(fl,0,0,0) = (fine(fl,0,0,0) + fine(fl,0,1,0))/2.;}}
      if ((!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0))
 {scalar*_i=(scalar*)( fluxl);if(_i)for(scalar fl=*_i;(&fl)->i>=0;fl=*++_i){
   val(fl,1,0,0) = (fine(fl,2,0,0) + fine(fl,2,1,0))/2.;}}
#line 902 "././my-vof-css-test.h"
    }end_foreach_halo();}
  pfree (fluxl,__func__,__FILE__,__LINE__);
#line 952 "././my-vof-css-test.h"
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);
  delete (gfl2); pfree (gfl2,__func__,__FILE__,__LINE__);
  delete (gflg); pfree (gflg,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (ferr);
#line 1071 "././my-vof-css-test.h"
  foreach_stencil() {
_stencil_val(cs,0,0,0);{






             _stencil_val_r(c,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);     

            scalar t, tc, tflux;  
            


              {scalar*_i0= tfluxlg;scalar*_i1= tfluxl2;scalar*_i2= tfluxl;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){{ 
              
              if(_attribute[t.i].inverse){
_stencil_val(topo_mask2_g,0,0,0);{
#line 1098 "././my-vof-css-test.h"
                       _stencil_val_r(t,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);     

                  }
                  
              
#line 1101
} else{
_stencil_val(topo_mask2,0,0,0);{


                       _stencil_val_r(t,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);     


                }
                
              
#line 1109
}

            }}}
      }
      
  
#line 1113
}end_foreach_stencil();
#line 1071 "././my-vof-css-test.h"
  {foreach() {
      if(val(cs,0,0,0)>0.0){






             val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/(max(y,1e-20)*Delta);

            scalar t, tc, tflux;
            scalar tflux2, tfluxg;


              {scalar*_i0= tfluxlg;scalar*_i1= tfluxl2;scalar*_i2= tfluxl;scalar*_i3= tcl;scalar*_i4= tracers;if(_i0)for(tfluxg=*_i0,tflux2=*_i1,tflux=*_i2,tc=*_i3,t=*_i4;_i0->i>= 0;tfluxg=*++_i0,tflux2=*++_i1,tflux=*++_i2,tc=*++_i3,t=*++_i4){{
              int khaki_flag=0;
              if(_attribute[t.i].inverse){
                  if(val(topo_mask2_g,0,0,0)>=-1){
#line 1098 "././my-vof-css-test.h"
                       val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/(max(y,1e-20)*Delta);

                  }
              } else{
                if(val(topo_mask2,0,0,0)>=-1){


                       val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/(max(y,1e-20)*Delta);


                }
              }

            }}}
      }
  }end_foreach();}



  foreach_stencil(){
_stencil_val(modify_near_region,0,0,0); _stencil_val(cs,0,0,0);{
_stencil_val(cs,0,0,0);{ {

          _stencil_val_r(css_test,0,0,0);_stencil_val(flux_css_test,0,0,0); _stencil_val(flux_css_test,1,0,0);_stencil_val(cc_css_test,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);      
        } {_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);{
          _stencil_val_r(css_test,0,0,0);_stencil_val(flux_css_test,0,0,0); _stencil_val(flux_css_test,1,0,0);_stencil_val(cc_css_test,0,0,0);_stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);      
        } }}
           
     
#line 1125
}
      

  
#line 1127
}end_foreach_stencil();



  {
#line 1117
foreach(){
     if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
        if (val(cs,0,0,0) >= 1.0) {

          val(css_test,0,0,0) += dt*(val(flux_css_test,0,0,0) - val(flux_css_test,1,0,0) + (val(cc_css_test,0,0,0))*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/(max(y,1e-20)*Delta);
        }else if(val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0){
          val(css_test,0,0,0) += dt*(val(flux_css_test,0,0,0) - val(flux_css_test,1,0,0) + (val(cc_css_test,0,0,0))*(val(ulf.x,1,0,0) - val(ulf.x,0,0,0)))/(max(y,1e-20)*Delta);
        }
     }

  }end_foreach();}





  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);
   delete (tfluxl2); pfree (tfluxl2,__func__,__FILE__,__LINE__);
   delete (tfluxlg); pfree (tfluxlg,__func__,__FILE__,__LINE__);
   delete (tfluxl_css_test); pfree (tfluxl_css_test,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){topo_mask2_g,topo_mask2,fluxg,flux2,cs_neg,css_test_alpha,css_test_n.x,css_test_n.y,solid_neg_alpha,solid_n.x,solid_n.y,flux_css_test,flux,alpha,n.x,n.y,{-1}}));


}

#line 479
static void sweep2_y (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux"), flux_css_test=new_scalar("flux_css_test");

  vector  solid_n=new_vector("solid_n");
  scalar  solid_neg_alpha=new_scalar("solid_neg_alpha");

  vector  css_test_n=new_vector("css_test_n");
  scalar  css_test_alpha=new_scalar("css_test_alpha");
  double cfl = 0.;

  scalar  cs_neg=new_scalar("cs_neg");
  foreach_stencil(){
    _stencil_val_a(cs_neg,0,0,0);_stencil_val(cs,0,0,0);  
  }end_foreach_stencil();
  {
#line 492
foreach(){
    val(cs_neg,0,0,0) = 1.0-val(cs,0,0,0);
  }end_foreach();}
#line 513 "././my-vof-css-test.h"
  scalar  flux2=new_scalar("flux2");

  scalar  fluxg=new_scalar("fluxg");



  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL, * tfluxl_css_test = NULL;
  scalar * gfl2 = NULL, * gflg = NULL, * tfluxl2 = NULL, * tfluxlg = NULL;


  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {

      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      scalar gf2 = new_scalar("gf2"), flux2 = new_scalar("flux2");

      scalar gfg = new_scalar("gfg"), fluxg = new_scalar("fluxg");

      scalar flux_css_test = new_scalar("flux_css_test");

      gfl = list_append (gfl, gf);

      tfluxl = list_append (tfluxl, flux);

      gfl2 = list_append (gfl2, gf2);
      tfluxl2 = list_append (tfluxl2, flux2);

      gflg = list_append (gflg, gfg);
      tfluxlg = list_append (tfluxlg, fluxg);

        tfluxl_css_test = list_append (tfluxl_css_test, flux_css_test);
    }}}




    foreach_stencil() {
      scalar t, gf, gf2, gfg;
      {scalar*_i0= gflg;scalar*_i1= gfl2;scalar*_i2= gfl;scalar*_i3= tracers;if(_i0)for(gfg=*_i0,gf2=*_i1,gf=*_i2,t=*_i3;_i0->i>= 0;gfg=*++_i0,gf2=*++_i1,gf=*++_i2,t=*++_i3){{
       _stencil_val_a(gf,0,0,0); _stencil_vof_concentration_gradient_f_y (point, c, t);

_stencil_val(gf,0,0,0);{
_stencil_val(gf,0,0,0);
            
        
#line 556
} 

        
        
#line 557
_stencil_val_a(gf2,0,0,0); _stencil_val(gf,0,0,0); 
        _stencil_val_a(gfg,0,0,0); _stencil_val(gf,0,0,0); 
      }}}
    }end_foreach_stencil();




    {
#line 549
foreach() {
      scalar t, gf, gf2, gfg;
      {scalar*_i0= gflg;scalar*_i1= gfl2;scalar*_i2= gfl;scalar*_i3= tracers;if(_i0)for(gfg=*_i0,gf2=*_i1,gf=*_i2,t=*_i3;_i0->i>= 0;gfg=*++_i0,gf2=*++_i1,gf=*++_i2,t=*++_i3){{
       val(gf,0,0,0) = vof_concentration_gradient_f_y (point, c, t);

        if(fabs(val(gf,0,0,0))>1e+29){
            printf("gf[]=%g, is true\n",val(gf,0,0,0));
        }
        val(gf2,0,0,0) = val(gf,0,0,0);
        val(gfg,0,0,0) = val(gf,0,0,0);
      }}}
    }end_foreach();}

  }
  boundary_internal ((scalar *)gfl, "././my-vof-css-test.h", 563);
  boundary_internal ((scalar *)gfl2, "././my-vof-css-test.h", 564);
  boundary_internal ((scalar *)gflg, "././my-vof-css-test.h", 565);







if(1==1){
  reconstruction (c, n, alpha);
}else{
  reconstruction4 (c, n, alpha);
}
  reconstruction (cs_neg, solid_n, solid_neg_alpha);

   scalar  topo_mask2=new_scalar("topo_mask2");
   get_topomask2(topo_mask2);

   scalar  topo_mask2_g=new_scalar("topo_mask2_g");
   foreach_stencil(){
      _stencil_val_a(topo_mask2_g,0,0,0);_stencil_val(topo_mask2,0,0,0);  
   }end_foreach_stencil();
   {
#line 584
foreach(){
      val(topo_mask2_g,0,0,0) = -val(topo_mask2,0,0,0);
   }end_foreach();}



  foreach_face_stencil()_stencil_is_face_y(){ {        
#line 599 "././my-vof-css-test.h"
   





    _stencil_val(fm.y,0,0,0); _stencil_val(ulf.y,0,0,0);            
    

    _stencil_val(fm.y,0,0,0); _stencil_val(ugf.y,0,0,0);            
    

    _stencil_val(fm.y,0,0,0); _stencil_val(uf.y,0,0,0);     
    






_stencil_val(cs,0,0,0);{

_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);
             {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);    }

_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);
             {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);    }

_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);
             {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);    }

             

             

             
    
#line 629
} 






       
#line 654 "././my-vof-css-test.h"

_stencil_val(modify_near_region,0,0,0); _stencil_val(cs,0,0,0);{
_stencil_val(cs,0,o_stencil,0);{{
_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);
_stencil_val(n.y,0,o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val_higher_dimension;_stencil_val(alpha,0, o_stencil,0); 
                      
                
               
            

      
#line 662
} {_stencil_val(cs,0,o_stencil,0);_stencil_val(cs,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);{{     

          
          
          _stencil_val(solid_n.x,0,o_stencil,0);_stencil_val(solid_n.y,0,o_stencil,0);  
          _stencil_val(solid_neg_alpha,0, o_stencil,0);   

            
{{     







                
                  
                 

                 
                


                 

                
                 



_stencil_val(fs.y,0,0,0);{{
_stencil_val(fs.y,0,0,0);
                      
                    
                        
                    
                
#line 698
}
                    
                }



                


        
#line 703
}
              
        }
            

        
#line 707
} {_stencil_val(cs,0,o_stencil,0);_stencil_val(cs,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);{{     


          
          
          _stencil_val(solid_n.x,0,o_stencil,0);_stencil_val(solid_n.y,0,o_stencil,0);  
          _stencil_val(solid_neg_alpha,0, o_stencil,0);   

          _stencil_val(n.x,0,o_stencil,0);_stencil_val(n.y,0,o_stencil,0);  


          _stencil_val(alpha,0, o_stencil,0);   



          
{{    
              
                 
               
               
               
              





_stencil_val(fs.y,0,0,0);{{
_stencil_val(fs.y,0,0,0);
                      
                    
                        
                    
                
#line 740
}
                    
                }


              


              

          
#line 744
}
                
          }
          
      
#line 747
}
            
      }    }}  }}


_stencil_val(cs,0,0,0);_stencil_val(cs,0, o_stencil,0);_stencil_val(cs,0,o_stencil,0); _stencil_val(cs,0,0,0);{   
                _stencil_val(fs.y,0,0,0);   

                _stencil_val(cs,0,o_stencil,0);_stencil_val(cs,0,0,0); 
_stencil_val(fs.y,0,0,0);{
_stencil_val(fs.y,0,0,0);
                      
                
#line 758
}
                 
          
#line 759
}
      


                
  
#line 760
}   
 


    
    
     _stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);{{
_stencil_val(c,0, o_stencil,0); 
      
    
#line 768
}{
_stencil_val(n.y,0,o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val_higher_dimension;_stencil_val(alpha,0, o_stencil,0);
           
            
            
    
#line 772
}}




_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);{{
_stencil_val(c,0, o_stencil,0); 
      
    
#line 779
}{
_stencil_val(n.y,0,o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val_higher_dimension;_stencil_val(alpha,0, o_stencil,0);
           
            
            
    
#line 783
}}

_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);{{
_stencil_val(c,0, o_stencil,0); 
      
    
#line 787
}{
_stencil_val(n.y,0,o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val_higher_dimension;_stencil_val(alpha,0, o_stencil,0);
           
            
            
    
#line 791
}}
          




          

         

    
#line 793
_stencil_val_a(flux,0,0,0);_stencil_val(ulf.y,0,0,0);  
    _stencil_val_a(flux2,0,0,0);_stencil_val(uf.y,0,0,0);  
    _stencil_val_a(fluxg,0,0,0);_stencil_val(ugf.y,0,0,0);  

    _stencil_val_a(flux_css_test,0,0,0);_stencil_val(ulf.y,0,0,0);  





    scalar t, gf, tflux , tflux2 , tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;if(_i0)for(tfluxg=*_i0,tflux2=*_i1,tflux=*_i2,gf=*_i3,t=*_i4;_i0->i>= 0;tfluxg=*++_i0,tflux2=*++_i1,tflux=*++_i2,gf=*++_i3,t=*++_i4){ {     
      _stencil_val(c,0, o_stencil,0);     
      _stencil_val(c,0, o_stencil,0);     
      _stencil_val(c,0, o_stencil,0);




{ {       
          _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
          _stencil_val_a(tflux,0,0,0);_stencil_val(ulf.y,0,0,0);  
          if(!_attribute[t.i].inverse){
            _stencil_val_a(flux_show.y,0,0,0);_stencil_val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
{
         _stencil_val_a(tflux,0,0,0);  
          if(!_attribute[t.i].inverse){



          }
      }}




{ {       
        _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
        _stencil_val_a(tflux2,0,0,0);_stencil_val(uf.y,0,0,0);  
      }
{
        _stencil_val_a(tflux2,0,0,0);
      }}




{ {       
          _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
          _stencil_val_a(tfluxg,0,0,0);_stencil_val(ugf.y,0,0,0);  
      }
{
         _stencil_val_a(tfluxg,0,0,0);  
      }}   

      
                     
       
         
      

      
                 
       
         
      

       
                     
       
         
      
    
#line 865
}}}

  }}end__stencil_is_face_y()end_foreach_face_stencil();



  
#line 590
if(!is_constant(fm.y) && !is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_y(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30);

        if (ung*val(fm.y,0,0,0)*sg/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = ung*val(fm.y,0,0,0)*sg/(val(cm,0,0,0) + 1e-30);

        if (un2*val(fm.y,0,0,0)*s2/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un2*val(fm.y,0,0,0)*s2/(val(cm,0,0,0) + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,0,i,0)>=1.0){
          cf_css_test = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
            rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,0,i,0)>0.0 && val(cs,0,i,0)<1.0) && val(c,0,i,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;

                a2 = face_n.y,b2=face_n.x;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,0,i,0)<1.0 && val(cs,0,i,0)>0.0) && (val(c,0,i,0)<1.0 && val(c,0,i,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

          coord nlg = (coord){val(n.y,0,i,0),val(n.x,0,i,0)};


          double alphalg = val(alpha,0,i,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;
              a2 = nlg.y,b2=nlg.x,c2=-0.5*(nlg.y+nlg.x)-alphalg;
              a3 = face_n.y,b3=face_n.x;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,0,i,0)<1) || (val(cs,0,i,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.y,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,0,i,0))*1.0;
                if(flux1>limit && val(fs.y,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.y,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.){
      cf = val(c,0,i,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,0,i2,0) <= 0. || val(c,0,i2,0) >= 1.){
      cf2 = val(c,0,i2,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.y,0,i2,0), val(n.x,0,i2,0), _val_higher_dimension}, val(alpha,0,i2,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,0,ig,0) <= 0. || val(c,0,ig,0) >= 1.){
      cfg = val(c,0,ig,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.y,0,ig,0), val(n.x,0,ig,0), _val_higher_dimension}, val(alpha,0,ig,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.y,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.y,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.y,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,0,i,0);
      double cf21 = cf2, ci2 = val(c,0,i2,0);
      double cf1g = cfg, cig = val(c,0,ig,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.y,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,0,i2,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,0,i2,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.y,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,0,ig,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,0,ig,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.y,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}else if(is_constant(fm.y) && !is_constant(cm)){struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);



  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_y(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30);

        if (ung*_const_fm.y*sg/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = ung*_const_fm.y*sg/(val(cm,0,0,0) + 1e-30);

        if (un2*_const_fm.y*s2/(val(cm,0,0,0) + 1e-30) > cfl)
             cfl = un2*_const_fm.y*s2/(val(cm,0,0,0) + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,0,i,0)>=1.0){
          cf_css_test = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
            rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,0,i,0)>0.0 && val(cs,0,i,0)<1.0) && val(c,0,i,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;

                a2 = face_n.y,b2=face_n.x;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,0,i,0)<1.0 && val(cs,0,i,0)>0.0) && (val(c,0,i,0)<1.0 && val(c,0,i,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

          coord nlg = (coord){val(n.y,0,i,0),val(n.x,0,i,0)};


          double alphalg = val(alpha,0,i,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;
              a2 = nlg.y,b2=nlg.x,c2=-0.5*(nlg.y+nlg.x)-alphalg;
              a3 = face_n.y,b3=face_n.x;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,0,i,0)<1) || (val(cs,0,i,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.y,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,0,i,0))*1.0;
                if(flux1>limit && val(fs.y,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.y,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.){
      cf = val(c,0,i,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,0,i2,0) <= 0. || val(c,0,i2,0) >= 1.){
      cf2 = val(c,0,i2,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.y,0,i2,0), val(n.x,0,i2,0), _val_higher_dimension}, val(alpha,0,i2,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,0,ig,0) <= 0. || val(c,0,ig,0) >= 1.){
      cfg = val(c,0,ig,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.y,0,ig,0), val(n.x,0,ig,0), _val_higher_dimension}, val(alpha,0,ig,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.y,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.y,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.y,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,0,i,0);
      double cf21 = cf2, ci2 = val(c,0,i2,0);
      double cf1g = cfg, cig = val(c,0,ig,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.y,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,0,i2,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,0,i2,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.y,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,0,ig,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,0,ig,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.y,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}else if(!is_constant(fm.y) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);



  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_y(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30) > cfl)
             cfl = un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30);

        if (ung*val(fm.y,0,0,0)*sg/(_const_cm + 1e-30) > cfl)
             cfl = ung*val(fm.y,0,0,0)*sg/(_const_cm + 1e-30);

        if (un2*val(fm.y,0,0,0)*s2/(_const_cm + 1e-30) > cfl)
             cfl = un2*val(fm.y,0,0,0)*s2/(_const_cm + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,0,i,0)>=1.0){
          cf_css_test = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
            rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,0,i,0)>0.0 && val(cs,0,i,0)<1.0) && val(c,0,i,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;

                a2 = face_n.y,b2=face_n.x;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,0,i,0)<1.0 && val(cs,0,i,0)>0.0) && (val(c,0,i,0)<1.0 && val(c,0,i,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

          coord nlg = (coord){val(n.y,0,i,0),val(n.x,0,i,0)};


          double alphalg = val(alpha,0,i,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;
              a2 = nlg.y,b2=nlg.x,c2=-0.5*(nlg.y+nlg.x)-alphalg;
              a3 = face_n.y,b3=face_n.x;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,0,i,0)<1) || (val(cs,0,i,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.y,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,0,i,0))*1.0;
                if(flux1>limit && val(fs.y,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.y,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.){
      cf = val(c,0,i,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,0,i2,0) <= 0. || val(c,0,i2,0) >= 1.){
      cf2 = val(c,0,i2,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.y,0,i2,0), val(n.x,0,i2,0), _val_higher_dimension}, val(alpha,0,i2,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,0,ig,0) <= 0. || val(c,0,ig,0) >= 1.){
      cfg = val(c,0,ig,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.y,0,ig,0), val(n.x,0,ig,0), _val_higher_dimension}, val(alpha,0,ig,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.y,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.y,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.y,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,0,i,0);
      double cf21 = cf2, ci2 = val(c,0,i2,0);
      double cf1g = cfg, cig = val(c,0,ig,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.y,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,0,i2,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,0,i2,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.y,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,0,ig,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,0,ig,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.y,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}else {struct{double x,y;}_const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);



  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction (max:cfl)){
#line 590
foreach_face_generic()is_face_y(){ {
#line 599 "././my-vof-css-test.h"
   double khaki_velocity=0.0;





    double un = val(ulf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s = sign(un);
    int i = -(s + 1.)/2.;

    double ung = val(ugf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), sg = sign(ung);
    int ig = -(sg + 1.)/2.;

    double un2 = val(uf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s2 = sign(un2);
    int i2 = -(s2 + 1.)/2.;






    if (val(cs,0,0,0) >= 1.){

        if (un*_const_fm.y*s/(_const_cm + 1e-30) > cfl)
             cfl = un*_const_fm.y*s/(_const_cm + 1e-30);

        if (ung*_const_fm.y*sg/(_const_cm + 1e-30) > cfl)
             cfl = ung*_const_fm.y*sg/(_const_cm + 1e-30);

        if (un2*_const_fm.y*s2/(_const_cm + 1e-30) > cfl)
             cfl = un2*_const_fm.y*s2/(_const_cm + 1e-30);
    }
#line 654 "././my-vof-css-test.h"
double cf_css_test=0.0;
if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
      if(val(cs,0,i,0)>=1.0){
          cf_css_test = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
            rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
              (coord){-0.5, -0.5, -0.5},
              (coord){s*un - 0.5, 0.5, 0.5});

      }else if((val(cs,0,i,0)>0.0 && val(cs,0,i,0)<1.0) && val(c,0,i,0)>=1.0){

          double moving_gas=0.0;
          double moving_liquid=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

            coord face_n = (coord){sign(un),0};
            if(fabs(un)>1e-30){







                double face_alpha = -fabs(i)+fabs(un);
                double a1,b1,c1,a2,b2,c2;
                a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;

                a2 = face_n.y,b2=face_n.x;
                c2=face_alpha;


                double data2[13];

                cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                moving_liquid = data2[0];



                if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = moving_liquid/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }


        }else{
            cf_css_test = 0.0;
        }

        }else if((val(cs,0,i,0)<1.0 && val(cs,0,i,0)>0.0) && (val(c,0,i,0)<1.0 && val(c,0,i,0)>0.0)){


          double gas_volume=0.0;
          double liquid_volume=0.0;
          coord nsf = (coord){val(solid_n.y,0,i,0),val(solid_n.x,0,i,0)};
          double alphasf = val(solid_neg_alpha,0,i,0);

          coord nlg = (coord){val(n.y,0,i,0),val(n.x,0,i,0)};


          double alphalg = val(alpha,0,i,0);



          coord face_n = (coord){sign(un),0};
          if(fabs(un)>1e-30){
              double face_alpha = -fabs(i)+fabs(un);
              double a1,b1,c1,a2,b2,c2,a3,b3,c3;
              a1 = nsf.y,b1=nsf.x,c1=-0.5*(nsf.y+nsf.x)-alphasf;
              a2 = nlg.y,b2=nlg.x,c2=-0.5*(nlg.y+nlg.x)-alphalg;
              a3 = face_n.y,b3=face_n.x;
              c3=face_alpha;


              cut_line_test_in_basilisk_3_times((coord){a1,b1},c1,(coord){a2,b2},c2,(coord){a3,b3},c3,&liquid_volume,&gas_volume);


              if(val(fs.y,0,0,0)>0.0){
                    cf_css_test = liquid_volume/(fabs(un)*val(fs.y,0,0,0));
                    if(cf_css_test>1){
                        cf_css_test=1.0;
                    }
                }else{
                    cf_css_test=0.0;
                }

          }else{
              cf_css_test = 0;
          }
      }else{
          cf_css_test = 0.0;
      }


          if(((val(cs,0,0,0)>=1 && val(cs,0,i,0)<1) || (val(cs,0,i,0)>=1 && val(cs,0,0,0)<1)) && fabs(un)>0.0){
                double flux1 = cf_css_test*(fabs(un)*val(fs.y,0,0,0));

                double limit = min(val(cs,0,0,0),val(cs,0,i,0))*1.0;
                if(flux1>limit && val(fs.y,0,0,0)>0.0){
                    cf_css_test = limit/(fabs(un)*val(fs.y,0,0,0));
                }
          }
  }


    double cf;
    double cf2;
     double cfg;
    if (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.){
      cf = val(c,0,i,0);
    }else{
      cf = rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.x,0,i,0), _val_higher_dimension}, val(alpha,0,i,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s*un - 0.5, 0.5, 0.5});
    }




    if (val(c,0,i2,0) <= 0. || val(c,0,i2,0) >= 1.){
      cf2 = val(c,0,i2,0);
    }else{
      cf2 = rectangle_fraction ((coord){-s2*val(n.y,0,i2,0), val(n.x,0,i2,0), _val_higher_dimension}, val(alpha,0,i2,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){s2*un2 - 0.5, 0.5, 0.5});
    }

   if (val(c,0,ig,0) <= 0. || val(c,0,ig,0) >= 1.){
      cfg = val(c,0,ig,0);
    }else{
      cfg = rectangle_fraction ((coord){-sg*val(n.y,0,ig,0), val(n.x,0,ig,0), _val_higher_dimension}, val(alpha,0,ig,0),
          (coord){-0.5, -0.5, -0.5},
          (coord){sg*ung - 0.5, 0.5, 0.5});
    }

    val(flux,0,0,0) = cf*val(ulf.y,0,0,0);
    val(flux2,0,0,0) = cf2*val(uf.y,0,0,0);
    val(fluxg,0,0,0) = cfg*val(ugf.y,0,0,0);

    val(flux_css_test,0,0,0) = cf_css_test*val(ulf.y,0,0,0);





    scalar t, gf, tflux, gf2, tflux2, gfg, tfluxg;


    {scalar*_i0=tfluxlg;scalar*_i1=gflg;scalar*_i2=tfluxl2;scalar*_i3=gfl2;scalar*_i4=tfluxl;scalar*_i5=gfl;scalar*_i6= tracers;if(_i0)for(tfluxg=*_i0,gfg=*_i1,tflux2=*_i2,gf2=*_i3,tflux=*_i4,gf=*_i5,t=*_i6;_i0->i>= 0;tfluxg=*++_i0,gfg=*++_i1,tflux2=*++_i2,gf2=*++_i3,tflux=*++_i4,gf=*++_i5,t=*++_i6){ {
      double cf1 = cf, ci = val(c,0,i,0);
      double cf21 = cf2, ci2 = val(c,0,i2,0);
      double cf1g = cfg, cig = val(c,0,ig,0);

      if (_attribute[t.i].inverse){
            cf1 = 1. - cf1, ci = 1. - ci;
       }
      if (ci > 1e-10) {
          double fff = val(t,0,i,0)/ci + s*min(1., 1. - s*un)*val(gf,0,i,0)*Delta/2.;
          val(tflux,0,0,0) = fff*cf1*val(ulf.y,0,0,0);
          if(!_attribute[t.i].inverse){
            val(flux_show.y,0,0,0)=val(tflux,0,0,0);
#line 833 "././my-vof-css-test.h"
          }
      }
      else{
         val(tflux,0,0,0) = 0.;
          if(!_attribute[t.i].inverse){



          }
      }

      if (_attribute[t.i].inverse){
        cf21 = 1. - cf21, ci2 = 1. - ci2;
       }
      if (ci2 > 1e-10) {
        double fff2 = val(t,0,i2,0)/ci2 + s2*min(1., 1. - s2*un2)*val(gf,0,i2,0)*Delta/2.;
        val(tflux2,0,0,0) = fff2*cf21*val(uf.y,0,0,0);
      }
      else{
        val(tflux2,0,0,0)=0.;
      }

       if (_attribute[t.i].inverse){
            cf1g = 1. - cf1g, cig = 1. - cig;
       }
      if (cig > 1e-10) {
          double fffg = val(t,0,ig,0)/cig + sg*min(1., 1. - sg*ung)*val(gf,0,ig,0)*Delta/2.;
          val(tfluxg,0,0,0) = fffg*cf1g*val(ugf.y,0,0,0);
      }
      else{
         val(tfluxg,0,0,0) = 0.;
      }
    }}}

  }}end_is_face_y()end_foreach_face_generic();mpi_all_reduce_array(&cfl,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 867
}



  scalar * fluxl = list_concat (NULL, tfluxl);
  fluxl = list_concat (fluxl, tfluxl2);
  fluxl = list_concat (fluxl, tfluxlg);
  fluxl = list_append (fluxl, flux);
  fluxl = list_append (fluxl, flux_css_test);
  for (int l = depth() - 1; l >= 0; l--)
    {foreach_halo (prolongation, l) {
#line 886 "././my-vof-css-test.h"
      if ((!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))
 {scalar*_i=(scalar*)( fluxl);if(_i)for(scalar fl=*_i;(&fl)->i>=0;fl=*++_i){
   val(fl,0,0,0) = (fine(fl,0,0,0) + fine(fl,1,0,0))/2.;}}
      if ((!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0))
 {scalar*_i=(scalar*)( fluxl);if(_i)for(scalar fl=*_i;(&fl)->i>=0;fl=*++_i){
   val(fl,0,1,0) = (fine(fl,0,2,0) + fine(fl,1,2,0))/2.;}}
#line 902 "././my-vof-css-test.h"
    }end_foreach_halo();}
  pfree (fluxl,__func__,__FILE__,__LINE__);
#line 952 "././my-vof-css-test.h"
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);
  delete (gfl2); pfree (gfl2,__func__,__FILE__,__LINE__);
  delete (gflg); pfree (gflg,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (ferr);
#line 1071 "././my-vof-css-test.h"
  foreach_stencil() {
_stencil_val(cs,0,0,0);{






             _stencil_val_r(c,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);     

            scalar t, tc, tflux;  
            


              {scalar*_i0= tfluxlg;scalar*_i1= tfluxl2;scalar*_i2= tfluxl;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){{ 
              
              if(_attribute[t.i].inverse){
_stencil_val(topo_mask2_g,0,0,0);{
#line 1098 "././my-vof-css-test.h"
                       _stencil_val_r(t,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);     

                  }
                  
              
#line 1101
} else{
_stencil_val(topo_mask2,0,0,0);{


                       _stencil_val_r(t,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);     


                }
                
              
#line 1109
}

            }}}
      }
      
  
#line 1113
}end_foreach_stencil();
#line 1071 "././my-vof-css-test.h"
  {foreach() {
      if(val(cs,0,0,0)>0.0){






             val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/(max(y,1e-20)*Delta);

            scalar t, tc, tflux;
            scalar tflux2, tfluxg;


              {scalar*_i0= tfluxlg;scalar*_i1= tfluxl2;scalar*_i2= tfluxl;scalar*_i3= tcl;scalar*_i4= tracers;if(_i0)for(tfluxg=*_i0,tflux2=*_i1,tflux=*_i2,tc=*_i3,t=*_i4;_i0->i>= 0;tfluxg=*++_i0,tflux2=*++_i1,tflux=*++_i2,tc=*++_i3,t=*++_i4){{
              int khaki_flag=0;
              if(_attribute[t.i].inverse){
                  if(val(topo_mask2_g,0,0,0)>=-1){
#line 1098 "././my-vof-css-test.h"
                       val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/(max(y,1e-20)*Delta);

                  }
              } else{
                if(val(topo_mask2,0,0,0)>=-1){


                       val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/(max(y,1e-20)*Delta);


                }
              }

            }}}
      }
  }end_foreach();}



  foreach_stencil(){
_stencil_val(modify_near_region,0,0,0); _stencil_val(cs,0,0,0);{
_stencil_val(cs,0,0,0);{ {

          _stencil_val_r(css_test,0,0,0);_stencil_val(flux_css_test,0,0,0); _stencil_val(flux_css_test,0,1,0);_stencil_val(cc_css_test,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);      
        } {_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);{
          _stencil_val_r(css_test,0,0,0);_stencil_val(flux_css_test,0,0,0); _stencil_val(flux_css_test,0,1,0);_stencil_val(cc_css_test,0,0,0);_stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);      
        } }}
           
     
#line 1125
}
      

  
#line 1127
}end_foreach_stencil();



  {
#line 1117
foreach(){
     if(val(modify_near_region,0,0,0)>0 && val(cs,0,0,0)>0.0){
        if (val(cs,0,0,0) >= 1.0) {

          val(css_test,0,0,0) += dt*(val(flux_css_test,0,0,0) - val(flux_css_test,0,1,0) + (val(cc_css_test,0,0,0))*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/(max(y,1e-20)*Delta);
        }else if(val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0){
          val(css_test,0,0,0) += dt*(val(flux_css_test,0,0,0) - val(flux_css_test,0,1,0) + (val(cc_css_test,0,0,0))*(val(ulf.y,0,1,0) - val(ulf.y,0,0,0)))/(max(y,1e-20)*Delta);
        }
     }

  }end_foreach();}





  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);
   delete (tfluxl2); pfree (tfluxl2,__func__,__FILE__,__LINE__);
   delete (tfluxlg); pfree (tfluxlg,__func__,__FILE__,__LINE__);
   delete (tfluxl_css_test); pfree (tfluxl_css_test,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){topo_mask2_g,topo_mask2,fluxg,flux2,cs_neg,css_test_alpha,css_test_n.x,css_test_n.y,solid_neg_alpha,solid_n.x,solid_n.y,flux_css_test,flux,alpha,n.x,n.y,{-1}}));


}
#line 1167 "././my-vof-css-test.h"
void vof_advection (scalar * interfaces, int i)
{

  globalii = i;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {

foreach_stencil(){
    _stencil_val_a(modify_near_region,0,0,0);
{    
      
      _stencil_val(c,0,0,0);

        {foreach_neighbor(1){   
          _stencil_val(c,0,0,0);




_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); 


               
          




                  
        
#line 1190
}end_foreach_neighbor()}



{
            _stencil_val_a(modify_near_region,0,0,0);  
        }



        
    
#line 1197
}  
    
  
#line 1198
}end_foreach_stencil();

{
#line 1173
foreach(){
    val(modify_near_region,0,0,0) = 0.0;
    if(level==level_interface){
      bool not_near_triple=true;
      bool c_me = (val(c,0,0,0)>=0.5);

        {foreach_neighbor(1){
          bool c_nei = (val(c,0,0,0)>=0.5);




            if(((val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0)) && (val(c,0,0,0)<1.0 && val(c,0,0,0)>0.0) && (level==level_interface)){


              not_near_triple = false;
          }
        }end_foreach_neighbor()}



        if(!not_near_triple){
            val(modify_near_region,0,0,0) = 1;
        }
    }
  }end_foreach();}

  foreach_stencil(){
_stencil_val(modify_near_region,0,0,0);{
        bool find_flag=false;
        Point me = point;
        {foreach_neighbor(2){
{
            if(!((me.i==point.i) && (me.j==point.j)) && (!find_flag)){
_stencil_val(modify_near_region,0,0,0); 
                     
                
                
            
#line 1210
}
          }
          
        
#line 1212
}end_foreach_neighbor()}
{
            _stencil_val_a(modify_near_region,0,0,0);  
        }
        
    
#line 1216
}
      
  
#line 1217
}end_foreach_stencil();

  {
#line 1200
foreach(){
    if((level==level_interface) && (val(modify_near_region,0,0,0)==0)){
        bool find_flag=false;
        Point me = point;
        {foreach_neighbor(2){
          if(level==level_interface){
            if(!((me.i==point.i) && (me.j==point.j)) && (!find_flag)){
                if(val(modify_near_region,0,0,0)==1){
                    find_flag = true;
                }
            }
          }
        }end_foreach_neighbor()}
        if(find_flag){
            val(modify_near_region,0,0,0) = 2;
        }
    }
  }end_foreach();}

  foreach_stencil(){
_stencil_val(modify_near_region,0,0,0);{
        bool find_flag=false;
        Point me = point;
        {foreach_neighbor(2){
{
            if(!((me.i==point.i) && (me.j==point.j)) && (!find_flag)){
_stencil_val(modify_near_region,0,0,0); 
                     
                
                
            
#line 1229
}
          }
          
        
#line 1231
}end_foreach_neighbor()}
{
            _stencil_val_a(modify_near_region,0,0,0);  
        }
        
    
#line 1235
}
      
  
#line 1236
}end_foreach_stencil();

  {
#line 1219
foreach(){
    if((level==level_interface) && (val(modify_near_region,0,0,0)==0)){
        bool find_flag=false;
        Point me = point;
        {foreach_neighbor(2){
          if(level==level_interface){
            if(!((me.i==point.i) && (me.j==point.j)) && (!find_flag)){
                if(val(modify_near_region,0,0,0)==2){
                    find_flag = true;
                }
            }
          }
        }end_foreach_neighbor()}
        if(find_flag){
            val(modify_near_region,0,0,0) = 3;
        }
    }
  }end_foreach();}
#line 1245 "././my-vof-css-test.h"
    scalar  cc=new_scalar("cc"), * tcl = NULL, * tracers = _attribute[c.i].tracers;


    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar tc = new_scalar("tc");
      tcl = list_append (tcl, tc);

      if (_attribute[t.i].refine != vof_concentration_refine) {
 _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
 _attribute[t.i].restriction = restriction_volume_average;
 _attribute[t.i].dirty = true;
 _attribute[t.i].c = c;
      }

    }}}
    foreach_stencil() {
      _stencil_val_a(cc,0,0,0);_stencil_val(c,0,0,0);    
      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   {_stencil_val_a(tc,0,0,0); _stencil_val(c,0,0,0); _stencil_val(t,0,0,0); _stencil_val(c,0,0,0);       }
 else
   {_stencil_val_a(tc,0,0,0); _stencil_val(c,0,0,0); _stencil_val(t,0,0,0);_stencil_val(c,0,0,0);      }
      }}}
    }end_foreach_stencil();
    {
#line 1260
foreach() {
      val(cc,0,0,0) = (val(c,0,0,0) > 0.5);
      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   val(tc,0,0,0) = val(c,0,0,0) < 0.5 ? val(t,0,0,0)/(1. - val(c,0,0,0)) : 0.;
 else
   val(tc,0,0,0) = val(c,0,0,0) > 0.5 ? val(t,0,0,0)/val(c,0,0,0) : 0.;
      }}}
    }end_foreach();}
#line 1284 "././my-vof-css-test.h"
     foreach_stencil(){

      _stencil_val_a(cc_css_test,0,0,0);_stencil_val(css_test,0,0,0);_stencil_val(cs,0,0,0);_stencil_val(css_test,0,0,0);
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
          _stencil_val_a(cc_css_test,0,0,0);  
      }    
         

    
#line 1291
}end_foreach_stencil();
#line 1284 "././my-vof-css-test.h"
     {foreach(){

      val(cc_css_test,0,0,0) = (val(css_test,0,0,0) > (val(cs,0,0,0)-val(css_test,0,0,0)));
      if(val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0){
          val(cc_css_test,0,0,0) = 0;
      }

    }end_foreach();}

    void (* sweep[2]) (scalar, scalar, scalar *);

    int d = 0;
    {

      sweep[d++] = sweep2_x;
    }
#line 1296
{

      sweep[d++] = sweep2_y;
    }
    for (d = 0; d < 2; d++){
      vof_flag = (i + d) % 2;


      sweep[(i + d) % 2] (c, cc, tcl);



    }



    delete (tcl), pfree (tcl,__func__,__FILE__,__LINE__);
#line 1323 "././my-vof-css-test.h"
    vector  n=new_vector("n");
    scalar  alpha=new_scalar("alpha");
    vector  solid_n=new_vector("solid_n");
    scalar  solid_neg_alpha=new_scalar("solid_neg_alpha");
    scalar  cs_neg=new_scalar("cs_neg");
    foreach_stencil(){
      _stencil_val_a(cs_neg,0,0,0);_stencil_val(cs,0,0,0);  
    }end_foreach_stencil();
    {
#line 1328
foreach(){
      val(cs_neg,0,0,0) = 1.0-val(cs,0,0,0);
    }end_foreach();}
    reconstruction(cs_neg,solid_n,solid_neg_alpha);

    reconstruction(c,n,alpha);
  foreach_stencil(){






_stencil_val(modify_near_region,0,0,0);{{  
       _stencil_val(c,0,0,0);
_stencil_val(cs,0,0,0);{{
              _stencil_val_a(c,0,0,0); _stencil_val(css_test,0,0,0); 
          } {_stencil_val(cs,0,0,0);{{
              _stencil_val_a(c,0,0,0); _stencil_val(c,0,0,0); 
          }{
_stencil_val(css_test,0,0,0);_stencil_val(cs,0,0,0);{{
                    _stencil_val_a(c,0,0,0);  
              } {_stencil_val(css_test,0,0,0);{{
                    _stencil_val_a(c,0,0,0);  
              }{      
                    
                    
                    
                    _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);  
                     _stencil_val(solid_neg_alpha,0,0,0);    
                     


                    _stencil_val(n.y,0,0,0);_stencil_val(n.x,0,0,0); 


                     
                     
#line 1394
{
                    double c_min,c_max;  
                    

                    c_min = c_min+1e-10;
                    c_max = c_max-1e-10;
                    int iter = 0;  
                    
                    double max_iter =20;   
                    
                     _stencil_val(css_test,0,0,0);
                    bool find_target=false;    
                    
                       

                    
                    
                       

                    
                    
                     
                     
                    while(iter < max_iter && (!find_target)) {      

                         


                        

                        
                           
                             
                         
                             
                           

                             
                         
                             

                                  

                        iter++;



                    }   


                         
#line 1454 "././my-vof-css-test.h"
                         _stencil_val(c,0,0,0);
                        _stencil_val_a(c,0,0,0);



_stencil_val(c,0,0,0);{
                            
_stencil_val(css_test,0,0,0);_stencil_val(css_test,0,0,0);_stencil_val(cs,0,0,0);_stencil_val(alpha,0,0,0);_stencil_val(c,0,0,0);
                            
                            
                            
                        
#line 1464
}    



                        

                  
#line 1466
}
#line 1394 "././my-vof-css-test.h"
                  

                        
                  


              
#line 1472
}}}}
              
          
#line 1473
}}}}

_stencil_val(cs,0,0,0);{
                        {scalar*_i=(scalar*)( tracers);if(_i)for(scalar tt=*_i;(&tt)->i>=0;tt=*++_i){{    
                           
                             
                                   
                                   
                              

                                
                                   
                                   
                              
                           if(!_attribute[tt.i].inverse){
_stencil_val(c,0,0,0);{
{ 
_stencil_val(tt,0,0,0); 
                                    
                                 
#line 1491
}
                                 
                                      
                                 
                                  
#line 1494
_stencil_val_a(tt,0,0,0); _stencil_val(c,0,0,0); 
                              }
                              
                           
#line 1496
}else{
_stencil_val(c,0,0,0);{
{ 
_stencil_val(tt,0,0,0);
                                     
                                 
#line 1500
}
                                 
                                      
                                 
                                   
#line 1503
_stencil_val_a(tt,0,0,0);_stencil_val(c,0,0,0);  
                              }
                              
                           
#line 1505
}
                        }}}
         }
          

         

     
#line 1509
}{
_stencil_val(cs,0,0,0);{{
                _stencil_val_a(css_test,0,0,0);_stencil_val(c,0,0,0);
            } {_stencil_val(cs,0,0,0);{{
                _stencil_val_a(css_test,0,0,0);
            }{
_stencil_val(c,0,0,0);{{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(cs,0,0,0); 
                } {_stencil_val(c,0,0,0);{{
                    _stencil_val_a(css_test,0,0,0);  
                }{   
                    _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);  
                     _stencil_val(solid_neg_alpha,0,0,0);   
                    _stencil_val(n.y,0,0,0);_stencil_val(n.x,0,0,0); 
                    _stencil_val(alpha,0,0,0);  
                      
                     
                     

                    
                    
                    _stencil_val_a(css_test,0,0,0);  
                }}}}
                
            
#line 1532
}}}}
            
     
#line 1533
}}






      
  
#line 1534
}end_foreach_stencil();
  {
#line 1334
foreach(){






      if(val(modify_near_region,0,0,0)==1){
      double c_old2 = val(c,0,0,0);
          if(val(cs,0,0,0)>=1){
              val(c,0,0,0) = val(css_test,0,0,0);
          }else if(val(cs,0,0,0)<=0){
              val(c,0,0,0) = val(c,0,0,0);
          }else{
              if(val(css_test,0,0,0)>=val(cs,0,0,0)){
                    val(c,0,0,0) = 1.0;
              }else if(val(css_test,0,0,0)<=0){
                    val(c,0,0,0) = 0.0;
              }else{
                    double a1,b1,c1,a2,b2,c2;
                    double gas_volume=0.0;
                    double liquid_volume=0.0;
                    coord nsf = (coord){val(solid_n.x,0,0,0),val(solid_n.y,0,0,0)};
                    double alphasf = val(solid_neg_alpha,0,0,0);
                    a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;


                    coord nlg = (coord){val(n.x,0,0,0),val(n.y,0,0,0)};


                    double alphalg;
                    a2 = nlg.x,b2=nlg.y;
#line 1394 "././my-vof-css-test.h"
                if(!(fabs(a2)<1e-20 && fabs(b2)<1e-20)){
                    double c_min,c_max;
                    line_intersection_range(nlg, &c_min, &c_max);

                    c_min = c_min+1e-10;
                    c_max = c_max-1e-10;
                    int iter = 0;
                    double c_mid, area_mid;
                    double max_iter =20;
                    double c_mid_alpha;
                    double target_area = val(css_test,0,0,0);
                    bool find_target=false;
                    double tol=1e-8;
                    double data3[13];

                    cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c_min,data3);
                    double area_cmin = data3[1];
                    double data4[13];

                    cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c_max,data4);
                    double area_cmax = data4[1];
                    bool min_max_increase=true;
                    min_max_increase = area_cmax>area_cmin;
                    while(iter < max_iter && (!find_target)) {

                        c_mid = (c_min + c_max) / 2.0;


                        double data2[13];

                        cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c_mid,data2);
                        area_mid = data2[1];
                        if (fabs(area_mid - target_area) < tol) {

                            find_target = true;
                        }

                        if ((area_mid < target_area && min_max_increase) || (area_mid>target_area && (!min_max_increase))) {
                            c_min = c_mid;
                        } else {
                            c_max = c_mid;
                        }

                        iter++;



                    }


                      c_mid_alpha = -0.5*(a2+b2) - c_mid;
#line 1454 "././my-vof-css-test.h"
                        double c_old = val(c,0,0,0);
                        val(c,0,0,0) = line_area(nlg.x, nlg.y, c_mid_alpha);



                        if(val(c,0,0,0)==0){
                            printf("target=%g result=%g error=%g cs[]=%g a2=%g b2 =%g alpha[]=%g c_mid_alpha=%g area_cmin=%g area_cmax=%g c_old=%g c[]===%g c_mid=%g\n",
                            val(css_test,0,0,0),area_mid,val(css_test,0,0,0)-area_mid,val(cs,0,0,0),a2,b2,val(alpha,0,0,0),c_mid_alpha,area_cmin,area_cmax,c_old,val(c,0,0,0),c_mid);
                            printf("nsf.x=%g nsf.y=%g alphasf=%g c1=%g\n",a1,b1,alphasf,c1);
                            printf("lelele\n");
                        }

                  }else{

                        printf("xiaolaji\n");
                  }


              }
          }

         if(val(cs,0,0,0)>0.0){
                        {scalar*_i=(scalar*)( tracers);if(_i)for(scalar tt=*_i;(&tt)->i>=0;tt=*++_i){{
                           double T_temp = Tsat00;
                           double value_l,value_g;

                              if(energy_advecting_flag){
                                  value_l = Trhol*Tcpl;
                                  value_g = Trhog*Tcpg;
                              }else{
                                  value_l = 1.0;
                                  value_g = 1.0;
                              }
                           if(!_attribute[tt.i].inverse){
                              if(val(c,0,0,0)>0.0){
                                 if(c_old2>0.0){
                                    T_temp = val(tt,0,0,0)/(c_old2*value_l);
                                 }else{
                                    T_temp = Tsat00;
                                 }
                                  val(tt,0,0,0) = val(c,0,0,0)*T_temp*value_l;
                              }
                           }else{
                              if(1.0-val(c,0,0,0)>0.0){
                                 if(1.0-c_old2>0.0){
                                    T_temp = val(tt,0,0,0)/((1.0-c_old2)*value_g);
                                 }else{
                                    T_temp = Tsat00;
                                 }
                                   val(tt,0,0,0) = (1.0-val(c,0,0,0))*T_temp*value_g;
                              }
                           }
                        }}}
         }

     }else{
            if(val(cs,0,0,0)>=1){
                val(css_test,0,0,0)=val(c,0,0,0);
            }else if(val(cs,0,0,0)<=0){
                val(css_test,0,0,0)=0.0;
            }else{
                if(val(c,0,0,0)>=1){
                    val(css_test,0,0,0) = val(cs,0,0,0);
                }else if(val(c,0,0,0)<=0){
                    val(css_test,0,0,0) = 0.0;
                }else{
                    coord nsf = (coord){val(solid_n.x,0,0,0),val(solid_n.y,0,0,0)};
                    double alphasf = val(solid_neg_alpha,0,0,0);
                    coord nlg = (coord){val(n.x,0,0,0),val(n.y,0,0,0)};
                    double alphalg=val(alpha,0,0,0);
                    double a1,b1,c1,a2,b2,c2;
                    a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
                    a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;

                    double data2[13];
                    cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
                    val(css_test,0,0,0) = data2[1];
                }
            }
     }
  }end_foreach();}

    foreach_stencil(){
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{
            _stencil_val_a(Tlff,0,0,0);
            _stencil_val_a(Tgff,0,0,0);_stencil_val(c,0,0,0);_stencil_val(Tgff,0,0,0);
            _stencil_val_a(c,0,0,0);
      }
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{
            _stencil_val_a(Tgff,0,0,0);
            _stencil_val_a(Tlff,0,0,0);_stencil_val(c,0,0,0);_stencil_val(Tlff,0,0,0);
            _stencil_val_a(c,0,0,0);
      }
       
       
    
#line 1547
}end_foreach_stencil();

    {
#line 1536
foreach(){
      if(val(c,0,0,0)>0.0 && val(c,0,0,0)<1e-8){
            val(Tlff,0,0,0)=0.0;
            val(Tgff,0,0,0)=(1.0-0.0)/(1.0-val(c,0,0,0))*val(Tgff,0,0,0);
            val(c,0,0,0)=0.0;
      }
      if(val(c,0,0,0)<1.0 && val(c,0,0,0)>1-1e-8){
            val(Tgff,0,0,0)=0.0;
            val(Tlff,0,0,0)=(1.0)/val(c,0,0,0)*val(Tlff,0,0,0);
            val(c,0,0,0)=1.0;
      }
    }end_foreach();}delete((scalar*)((scalar[]){cs_neg,solid_neg_alpha,solid_n.x,solid_n.y,alpha,n.x,n.y,cc,{-1}}));


  }}}
}


extern vector usf;
extern double thick_init,L0;

static int vof_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int vof_0(const int i,const double t,Event *_ev){tracing("vof_0","././my-vof-css-test.h",1557);{







  scalar  temp_cold=new_scalar("temp_cold");
  foreach_stencil(){
 _stencil_val_a(temp_cold,0,0,0); _stencil_val(ff,0,0,0); 
  }end_foreach_stencil();
  {
#line 1566
foreach(){
 val(temp_cold,0,0,0) = val(ff,0,0,0);
  }end_foreach();}

  vof_advection (interfaces, i);

  boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "././my-vof-css-test.h", 1572);
#line 1586 "././my-vof-css-test.h"
  scalar  div2=new_scalar("div2");
  foreach_stencil(){
       _stencil_val_a(div2,0,0,0);   
        _stencil_val(ff,0,0,0);
       {
          
{_stencil_val_a(div2,0,0,0); _stencil_val(div2,0,0,0); _stencil_val(ulf.x,1,0,0); _stencil_val(ulf.x,0,0,0);    }
         
       
#line 1593
}
#line 1590
{
          
{_stencil_val_a(div2,0,0,0); _stencil_val(div2,0,0,0); _stencil_val(ulf.y,0,1,0); _stencil_val(ulf.y,0,0,0);    }
         
       
#line 1593
}
  }end_foreach_stencil();
  {
#line 1587
foreach(){
       val(div2,0,0,0) =0.0;
       double ff_temp = val(ff,0,0,0);
       {
         if(ff_temp>0.0)
          val(div2,0,0,0) = val(div2,0,0,0) + val(ulf.x,1,0,0) - val(ulf.x,0,0,0) ;
       }
#line 1590
{
         if(ff_temp>0.0)
          val(div2,0,0,0) = val(div2,0,0,0) + val(ulf.y,0,1,0) - val(ulf.y,0,0,0) ;
       }
  }end_foreach();}delete((scalar*)((scalar[]){div2,temp_cold,{-1}}));
#line 1610 "././my-vof-css-test.h"
}{end_tracing("vof_0","././my-vof-css-test.h",1610);return 0;}end_tracing("vof_0","././my-vof-css-test.h",1610);}
#line 15 "./axi-two-phase.h"


scalar  ff={12}, * interfaces = ((scalar[]){{12},{-1}});
scalar  ff_oppo={13};
scalar  f_height={14};
double Trhol = 1., mu1 = 0., Trhog = 1., mu2 = 0.;
double Tkg,Tkl,Tcpg,Tcpl,hfg;
double k1,k0;
scalar  rhocp={15};
double Trhos;
double Tcps;
double Tks;

extern scalar T;
extern scalar css_test3, css_test3_n;
extern scalar fs_solid;
extern vector fss_test3_n;
extern scalar topo_mask_s;
extern scalar intersect_true;






vector  alphav={{16},{17}};
scalar  rhov={18};






static int defaults_4_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}      static int defaults_4(const int i,const double t,Event *_ev){tracing("defaults_4","./axi-two-phase.h",48); {
  alpha = alphav;
  rho = rhov;





  if (mu1 || mu2)
    mu = new_face_vector("mu");




  display ((struct _display){"draw_vof (c = 'ff');"});
}{end_tracing("defaults_4","./axi-two-phase.h",63);return 0;}end_tracing("defaults_4","./axi-two-phase.h",63);}
#line 93 "./axi-two-phase.h"
static int tracer_advection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int tracer_advection(const int i,const double t,Event *_ev){tracing("tracer_advection","./axi-two-phase.h",93);
{
#line 127 "./axi-two-phase.h"
 _attribute[ff.i].refine = _attribute[ff.i].prolongation = fraction_refine;
 _attribute[ff.i].dirty = true;

}{end_tracing("tracer_advection","./axi-two-phase.h",130);return 0;}end_tracing("tracer_advection","./axi-two-phase.h",130);}

static int properties_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int properties_0(const int i,const double t,Event *_ev){tracing("properties_0","./axi-two-phase.h",132);
{

  scalar  true_interface=new_scalar("true_interface");
  foreach_stencil(){
      _stencil_val_a(true_interface,0,0,0); 
      





_stencil_val(intersect_true,0,0,0); 
                 
      
_stencil_val(topo_mask_s,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
          _stencil_val_a(true_interface,0,0,0);
      }





       
           
  
#line 150
}end_foreach_stencil();
  {
#line 136
foreach(){
      val(true_interface,0,0,0)=0;
      bool flag=false;





       if(val(intersect_true,0,0,0)==1){
                flag = true;
      }
      if(val(topo_mask_s,0,0,0)==0 && flag && (val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0)){
          val(true_interface,0,0,0)=1;
      }
  }end_foreach();}

  bool flag_rho=true;

      if(flag_rho){
        foreach_face_stencil(){_stencil_is_face_x(){ { 


                
_stencil_val(topo_mask_s,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);_stencil_val(true_interface,0,0,0);{ 
                     
                { 
_stencil_val(ff,0,0,0);
                     
                
#line 163
}}
_stencil_val(topo_mask_s,-1,0,0);_stencil_val(ff,-1,0,0); _stencil_val(ff,-1,0,0);_stencil_val(true_interface,-1,0,0);{ 
                     
                { 
_stencil_val(ff,-1,0,0);
                     
                
#line 168
}}     
                     
                     

                
                
#line 171
_stencil_val_a(alphav.x,0,0,0); _stencil_val(fm.x,0,0,0);     
                if (mu1 || mu2) {
                    vector muv = mu;

                    _stencil_val_a(muv.x,0,0,0); _stencil_val(fm.x,0,0,0);     
                  }
        }}end__stencil_is_face_x()
#line 155
_stencil_is_face_y(){ { 


                
_stencil_val(topo_mask_s,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);_stencil_val(true_interface,0,0,0);{ 
                     
                { 
_stencil_val(ff,0,0,0);
                     
                
#line 163
}}
_stencil_val(topo_mask_s,0,-1,0);_stencil_val(ff,0,-1,0); _stencil_val(ff,0,-1,0);_stencil_val(true_interface,0,-1,0);{ 
                     
                { 
_stencil_val(ff,0,-1,0);
                     
                
#line 168
}}     
                     
                     

                
                
#line 171
_stencil_val_a(alphav.y,0,0,0); _stencil_val(fm.y,0,0,0);     
                if (mu1 || mu2) {
                    vector muv = mu;

                    _stencil_val_a(muv.y,0,0,0); _stencil_val(fm.y,0,0,0);     
                  }
        }}end__stencil_is_face_y()}end_foreach_face_stencil();
        
#line 155
if(!is_constant(fm.x)){{foreach_face_generic(){is_face_x(){ {


                double sf0,sf1;
                if(val(topo_mask_s,0,0,0)==0 && (val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0) && (val(true_interface,0,0,0)!=1)){
                    sf1 = 1.0;
                }else{
                    sf1 = val(ff,0,0,0);
                }
                if(val(topo_mask_s,-1,0,0)==0 && (val(ff,-1,0,0)<1.0 && val(ff,-1,0,0)>0.0) && (val(true_interface,-1,0,0)!=1)){
                    sf0 = 1.0;
                }else{
                    sf0 = val(ff,-1,0,0);
                }

                double fff1 = (sf1 + sf0)/2.;
                val(alphav.x,0,0,0) = val(fm.x,0,0,0)/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
                if (mu1 || mu2) {
                    vector muv = mu;

                    val(muv.x,0,0,0) = val(fm.x,0,0,0)*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
                  }
        }}end_is_face_x()
#line 155
is_face_y(){ {


                double sf0,sf1;
                if(val(topo_mask_s,0,0,0)==0 && (val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0) && (val(true_interface,0,0,0)!=1)){
                    sf1 = 1.0;
                }else{
                    sf1 = val(ff,0,0,0);
                }
                if(val(topo_mask_s,0,-1,0)==0 && (val(ff,0,-1,0)<1.0 && val(ff,0,-1,0)>0.0) && (val(true_interface,0,-1,0)!=1)){
                    sf0 = 1.0;
                }else{
                    sf0 = val(ff,0,-1,0);
                }

                double fff1 = (sf1 + sf0)/2.;
                val(alphav.y,0,0,0) = val(fm.y,0,0,0)/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
                if (mu1 || mu2) {
                    vector muv = mu;

                    val(muv.y,0,0,0) = val(fm.y,0,0,0)*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
                  }
        }}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
        {
#line 155
foreach_face_generic(){is_face_x(){ {


                double sf0,sf1;
                if(val(topo_mask_s,0,0,0)==0 && (val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0) && (val(true_interface,0,0,0)!=1)){
                    sf1 = 1.0;
                }else{
                    sf1 = val(ff,0,0,0);
                }
                if(val(topo_mask_s,-1,0,0)==0 && (val(ff,-1,0,0)<1.0 && val(ff,-1,0,0)>0.0) && (val(true_interface,-1,0,0)!=1)){
                    sf0 = 1.0;
                }else{
                    sf0 = val(ff,-1,0,0);
                }

                double fff1 = (sf1 + sf0)/2.;
                val(alphav.x,0,0,0) = _const_fm.x/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
                if (mu1 || mu2) {
                    vector muv = mu;

                    val(muv.x,0,0,0) = _const_fm.x*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
                  }
        }}end_is_face_x()
#line 155
is_face_y(){ {


                double sf0,sf1;
                if(val(topo_mask_s,0,0,0)==0 && (val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0) && (val(true_interface,0,0,0)!=1)){
                    sf1 = 1.0;
                }else{
                    sf1 = val(ff,0,0,0);
                }
                if(val(topo_mask_s,0,-1,0)==0 && (val(ff,0,-1,0)<1.0 && val(ff,0,-1,0)>0.0) && (val(true_interface,0,-1,0)!=1)){
                    sf0 = 1.0;
                }else{
                    sf0 = val(ff,0,-1,0);
                }

                double fff1 = (sf1 + sf0)/2.;
                val(alphav.y,0,0,0) = _const_fm.y/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
                if (mu1 || mu2) {
                    vector muv = mu;

                    val(muv.y,0,0,0) = _const_fm.y*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
                  }
        }}end_is_face_y()}end_foreach_face_generic();}}
      }else{
          foreach_face_stencil(){_stencil_is_face_x(){ {    


           _stencil_val(ff,-1,0,0);_stencil_val(ff,0,0,0);    

           _stencil_val(fs_solid,-1,0,0);_stencil_val(fs_solid,0,0,0);

          _stencil_val_a(alphav.x,0,0,0); _stencil_val(fm.x,0,0,0);     
          if (mu1 || mu2) {
              vector muv = mu;

              _stencil_val_a(muv.x,0,0,0); _stencil_val(fm.x,0,0,0);     
            }
        }}end__stencil_is_face_x()
#line 179
_stencil_is_face_y(){ {    


           _stencil_val(ff,0,-1,0);_stencil_val(ff,0,0,0);    

           _stencil_val(fs_solid,0,-1,0);_stencil_val(fs_solid,0,0,0);

          _stencil_val_a(alphav.y,0,0,0); _stencil_val(fm.y,0,0,0);     
          if (mu1 || mu2) {
              vector muv = mu;

              _stencil_val_a(muv.y,0,0,0); _stencil_val(fm.y,0,0,0);     
            }
        }}end__stencil_is_face_y()}end_foreach_face_stencil();
          
#line 179
if(!is_constant(fm.x)){{foreach_face_generic(){is_face_x(){ {


          double fff1 = (val(ff,0,0,0) + val(ff,-1,0,0))/2.;

          double ffs2 = (val(fs_solid,0,0,0) + val(fs_solid,-1,0,0))/2.;

          val(alphav.x,0,0,0) = val(fm.x,0,0,0)/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
          if (mu1 || mu2) {
              vector muv = mu;

              val(muv.x,0,0,0) = val(fm.x,0,0,0)*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
            }
        }}end_is_face_x()
#line 179
is_face_y(){ {


          double fff1 = (val(ff,0,0,0) + val(ff,0,-1,0))/2.;

          double ffs2 = (val(fs_solid,0,0,0) + val(fs_solid,0,-1,0))/2.;

          val(alphav.y,0,0,0) = val(fm.y,0,0,0)/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
          if (mu1 || mu2) {
              vector muv = mu;

              val(muv.y,0,0,0) = val(fm.y,0,0,0)*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
            }
        }}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
          {
#line 179
foreach_face_generic(){is_face_x(){ {


          double fff1 = (val(ff,0,0,0) + val(ff,-1,0,0))/2.;

          double ffs2 = (val(fs_solid,0,0,0) + val(fs_solid,-1,0,0))/2.;

          val(alphav.x,0,0,0) = _const_fm.x/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
          if (mu1 || mu2) {
              vector muv = mu;

              val(muv.x,0,0,0) = _const_fm.x*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
            }
        }}end_is_face_x()
#line 179
is_face_y(){ {


          double fff1 = (val(ff,0,0,0) + val(ff,0,-1,0))/2.;

          double ffs2 = (val(fs_solid,0,0,0) + val(fs_solid,0,-1,0))/2.;

          val(alphav.y,0,0,0) = _const_fm.y/(clamp(fff1,0.,1.)*(Trhol - Trhog) + Trhog);
          if (mu1 || mu2) {
              vector muv = mu;

              val(muv.y,0,0,0) = _const_fm.y*(clamp(fff1,0.,1.)*(mu1 - mu2) + mu2);
            }
        }}end_is_face_y()}end_foreach_face_generic();}}
      }





foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{





       _stencil_val_a(rhocp,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(cm,0,0,0);     



    } {_stencil_val(css_test3_n,0,0,0);{{





       _stencil_val_a(rhocp,0,0,0);_stencil_val(cm,0,0,0);  

    }{




      _stencil_val_a(rhocp,0,0,0);_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(cm,0,0,0);       



    }}}}
    
  
#line 228
}end_foreach_stencil();






#line 199
if(!is_constant(cm)){{foreach(){
    if(val(css_test3_n,0,0,0)>=1.0){





       val(rhocp,0,0,0)= (clamp(val(ff,0,0,0),0.,1.)*(Trhol*Tcpl - Trhog*Tcpg) + Trhog*Tcpg)*val(cm,0,0,0);



    }else if(val(css_test3_n,0,0,0)<=0.0){





       val(rhocp,0,0,0) = Trhos*Tcps*val(cm,0,0,0);

    }else{




      val(rhocp,0,0,0) = ((1.0-val(css_test3_n,0,0,0))*Trhos*Tcps + val(css_test3_n,0,0,0)*(clamp(val(ff,0,0,0),0.,1.)*(Trhol*Tcpl - Trhog*Tcpg) + Trhog*Tcpg))*val(cm,0,0,0);



    }
  }end_foreach();}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);





{
#line 199
foreach(){
    if(val(css_test3_n,0,0,0)>=1.0){





       val(rhocp,0,0,0)= (clamp(val(ff,0,0,0),0.,1.)*(Trhol*Tcpl - Trhog*Tcpg) + Trhog*Tcpg)*_const_cm;



    }else if(val(css_test3_n,0,0,0)<=0.0){





       val(rhocp,0,0,0) = Trhos*Tcps*_const_cm;

    }else{




      val(rhocp,0,0,0) = ((1.0-val(css_test3_n,0,0,0))*Trhos*Tcps + val(css_test3_n,0,0,0)*(clamp(val(ff,0,0,0),0.,1.)*(Trhol*Tcpl - Trhog*Tcpg) + Trhog*Tcpg))*_const_cm;



    }
  }end_foreach();}}

  foreach_stencil(){
      if(flag_rho){
_stencil_val(topo_mask_s,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);_stencil_val(true_interface,0,0,0);{{
              _stencil_val_a(rhov,0,0,0); _stencil_val(cm,0,0,0);     
          }{
              _stencil_val_a(rhov,0,0,0); _stencil_val(cm,0,0,0);_stencil_val(ff,0,0,0);     
          }}
               
      
#line 237
}else{
          _stencil_val_a(rhov,0,0,0); _stencil_val(cm,0,0,0);_stencil_val(ff,0,0,0);     
      }
  }end_foreach_stencil();

  
#line 230
if(!is_constant(cm)){{foreach(){
      if(flag_rho){
          if(val(topo_mask_s,0,0,0)==0 && (val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0) && (val(true_interface,0,0,0)!=1)){
              val(rhov,0,0,0) = val(cm,0,0,0)*(clamp(1.0,0.,1.)*(Trhol - Trhog) + Trhog);
          }else{
              val(rhov,0,0,0) = val(cm,0,0,0)*(clamp(val(ff,0,0,0),0.,1.)*(Trhol - Trhog) + Trhog);
          }
      }else{
          val(rhov,0,0,0) = val(cm,0,0,0)*(clamp(val(ff,0,0,0),0.,1.)*(Trhol - Trhog) + Trhog);
      }
  }end_foreach();}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);

  {
#line 230
foreach(){
      if(flag_rho){
          if(val(topo_mask_s,0,0,0)==0 && (val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0) && (val(true_interface,0,0,0)!=1)){
              val(rhov,0,0,0) = _const_cm*(clamp(1.0,0.,1.)*(Trhol - Trhog) + Trhog);
          }else{
              val(rhov,0,0,0) = _const_cm*(clamp(val(ff,0,0,0),0.,1.)*(Trhol - Trhog) + Trhog);
          }
      }else{
          val(rhov,0,0,0) = _const_cm*(clamp(val(ff,0,0,0),0.,1.)*(Trhol - Trhog) + Trhog);
      }
  }end_foreach();}}
#line 286 "./axi-two-phase.h"
  _attribute[ff.i].refine = _attribute[ff.i].prolongation = fraction_refine;
 _attribute[ff.i].dirty = true;delete((scalar*)((scalar[]){true_interface,{-1}}));

}{end_tracing("properties_0","./axi-two-phase.h",289);return 0;}end_tracing("properties_0","./axi-two-phase.h",289);}
#line 15 "template01.c"
#line 1 "./embed-solid.h"
#line 1 "././embed-solid.h"
extern scalar css_test3,css_test3_n;
extern vector fss_test3,fss_test3_n;
extern scalar ff;

extern scalar css_test,css_test2;
extern vector fss_test,fss_test2;
extern double Tsat00,Tsat0;


#line 1 "./curvature.h"
#line 11 "././embed-solid.h"




static int init_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t=0);*ip=i;*tp=t;return ret;}static int init_0(const int i,const double t,Event *_ev){{

}return 0;}
#line 55 "././embed-solid.h"
void embed_fraction_refine_s (Point point, scalar css_test3)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(css_test3,0,0,0);





  if (cc <= 0. || cc >= 1.) {
    {foreach_child()
      val(css_test3,0,0,0) = cc;end_foreach_child()}
  }
  else {






    coord n = facet_normal (point, css_test3, fss_test3);
    double alpha = line_alpha (cc, n);

    {foreach_child() {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x;
 
#line 81
nc.y = child.y*n.y;
      val(css_test3,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }end_foreach_child()}
  }
}


void embed_fraction_refine_s_n (Point point, scalar css_test3_n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(css_test3_n,0,0,0);





  if (cc <= 0. || cc >= 1.) {
    {foreach_child()
      val(css_test3_n,0,0,0) = cc;end_foreach_child()}
  }
  else {






    coord n = facet_normal (point, css_test3_n, fss_test3_n);
    double alpha = line_alpha (cc, n);

    {foreach_child() {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x;
 
#line 114
nc.y = child.y*n.y;
      val(css_test3_n,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }end_foreach_child()}
  }
}





void embed_face_fraction_refine_s_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fss_test3 = _attribute[s.i].v;





  if (val(css_test3,0,0,0) <= 0. || val(css_test3,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test3.x,1,j,k) = val(css_test3,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0) && neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test3.x,2*i,j,k) = val(fss_test3.x,i,0,0);
  }
  else {






    coord n = facet_normal (point, css_test3, fss_test3);
    double alpha = line_alpha (val(css_test3,0,0,0), n);
#line 171 "././embed-solid.h"
    if (2.*fabs(alpha) < fabs(n.y)) {
      double yc = alpha/n.y;
      int i = yc > 0.;
      fine(fss_test3.x,1,1 - i,0) = n.y < 0. ? 1. - i : i;
      fine(fss_test3.x,1,i,0) = n.y < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test3.x,1,0,0) = fine(fss_test3.x,1,1,0) = alpha > 0.;
#line 203 "././embed-solid.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0)))) {
 if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0)) {
   if (val(fss_test3.x,i,0,0) <= 0. || val(fss_test3.x,i,0,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test3.x,2*i,j,k) = val(fss_test3.x,i,0,0);
   else {






     double a = val(fss_test3.y,0,1,0) <= 0. || val(fss_test3.y,2*i-1,1,0) <= 0. ||
       val(fss_test3.y,0,0,0) >= 1. || val(fss_test3.y,2*i-1,0,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test3.x,i,0,0) - 0.5) > 0.) {
       fine(fss_test3.x,2*i,0,0) = a;
       fine(fss_test3.x,2*i,1,0) = 2.*val(fss_test3.x,i,0,0) - a;
     }
     else {
       fine(fss_test3.x,2*i,0,0) = 2.*val(fss_test3.x,i,0,0) + a - 1.;
       fine(fss_test3.x,2*i,1,0) = 1. - a;
     }
#line 245 "././embed-solid.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test3.x,2*i,j,k) && !fine(css_test3,i,j,k))
       fine(fss_test3.x,2*i,j,k) = 0.;
      }
  }
}

#line 124
void embed_face_fraction_refine_s_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fss_test3 = _attribute[s.i].v;





  if (val(css_test3,0,0,0) <= 0. || val(css_test3,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test3.y,j,1,k) = val(css_test3,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0) && neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test3.y,j,2*i,k) = val(fss_test3.y,0,i,0);
  }
  else {






    coord n = facet_normal (point, css_test3, fss_test3);
    double alpha = line_alpha (val(css_test3,0,0,0), n);
#line 171 "././embed-solid.h"
    if (2.*fabs(alpha) < fabs(n.x)) {
      double yc = alpha/n.x;
      int i = yc > 0.;
      fine(fss_test3.y,1 - i,1,0) = n.x < 0. ? 1. - i : i;
      fine(fss_test3.y,i,1,0) = n.x < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test3.y,0,1,0) = fine(fss_test3.y,1,1,0) = alpha > 0.;
#line 203 "././embed-solid.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0)))) {
 if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0)) {
   if (val(fss_test3.y,0,i,0) <= 0. || val(fss_test3.y,0,i,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test3.y,j,2*i,k) = val(fss_test3.y,0,i,0);
   else {






     double a = val(fss_test3.x,1,0,0) <= 0. || val(fss_test3.x,1,2*i-1,0) <= 0. ||
       val(fss_test3.x,0,0,0) >= 1. || val(fss_test3.x,0,2*i-1,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test3.y,0,i,0) - 0.5) > 0.) {
       fine(fss_test3.y,0,2*i,0) = a;
       fine(fss_test3.y,1,2*i,0) = 2.*val(fss_test3.y,0,i,0) - a;
     }
     else {
       fine(fss_test3.y,0,2*i,0) = 2.*val(fss_test3.y,0,i,0) + a - 1.;
       fine(fss_test3.y,1,2*i,0) = 1. - a;
     }
#line 245 "././embed-solid.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test3.y,j,2*i,k) && !fine(css_test3,j,i,k))
       fine(fss_test3.y,j,2*i,k) = 0.;
      }
  }
}
#line 268 "././embed-solid.h"

void embed_face_fraction_refine_s_n_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fss_test3_n = _attribute[s.i].v;





  if (val(css_test3_n,0,0,0) <= 0. || val(css_test3_n,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test3_n.x,1,j,k) = val(css_test3_n,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0) && neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test3_n.x,2*i,j,k) = val(fss_test3_n.x,i,0,0);
  }
  else {






    coord n = facet_normal (point, css_test3_n, fss_test3_n);
    double alpha = line_alpha (val(css_test3_n,0,0,0), n);
#line 316 "././embed-solid.h"
    if (2.*fabs(alpha) < fabs(n.y)) {
      double yc = alpha/n.y;
      int i = yc > 0.;
      fine(fss_test3_n.x,1,1 - i,0) = n.y < 0. ? 1. - i : i;
      fine(fss_test3_n.x,1,i,0) = n.y < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test3_n.x,1,0,0) = fine(fss_test3_n.x,1,1,0) = alpha > 0.;
#line 348 "././embed-solid.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0)))) {
 if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0)) {
   if (val(fss_test3_n.x,i,0,0) <= 0. || val(fss_test3_n.x,i,0,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test3_n.x,2*i,j,k) = val(fss_test3_n.x,i,0,0);
   else {






     double a = val(fss_test3_n.y,0,1,0) <= 0. || val(fss_test3_n.y,2*i-1,1,0) <= 0. ||
       val(fss_test3_n.y,0,0,0) >= 1. || val(fss_test3_n.y,2*i-1,0,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test3_n.x,i,0,0) - 0.5) > 0.) {
       fine(fss_test3_n.x,2*i,0,0) = a;
       fine(fss_test3_n.x,2*i,1,0) = 2.*val(fss_test3_n.x,i,0,0) - a;
     }
     else {
       fine(fss_test3_n.x,2*i,0,0) = 2.*val(fss_test3_n.x,i,0,0) + a - 1.;
       fine(fss_test3_n.x,2*i,1,0) = 1. - a;
     }
#line 390 "././embed-solid.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test3_n.x,2*i,j,k) && !fine(css_test3_n,i,j,k))
       fine(fss_test3_n.x,2*i,j,k) = 0.;
      }
  }
}

#line 269
void embed_face_fraction_refine_s_n_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fss_test3_n = _attribute[s.i].v;





  if (val(css_test3_n,0,0,0) <= 0. || val(css_test3_n,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test3_n.y,j,1,k) = val(css_test3_n,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0) && neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test3_n.y,j,2*i,k) = val(fss_test3_n.y,0,i,0);
  }
  else {






    coord n = facet_normal (point, css_test3_n, fss_test3_n);
    double alpha = line_alpha (val(css_test3_n,0,0,0), n);
#line 316 "././embed-solid.h"
    if (2.*fabs(alpha) < fabs(n.x)) {
      double yc = alpha/n.x;
      int i = yc > 0.;
      fine(fss_test3_n.y,1 - i,1,0) = n.x < 0. ? 1. - i : i;
      fine(fss_test3_n.y,i,1,0) = n.x < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test3_n.y,0,1,0) = fine(fss_test3_n.y,1,1,0) = alpha > 0.;
#line 348 "././embed-solid.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0)))) {
 if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0)) {
   if (val(fss_test3_n.y,0,i,0) <= 0. || val(fss_test3_n.y,0,i,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test3_n.y,j,2*i,k) = val(fss_test3_n.y,0,i,0);
   else {






     double a = val(fss_test3_n.x,1,0,0) <= 0. || val(fss_test3_n.x,1,2*i-1,0) <= 0. ||
       val(fss_test3_n.x,0,0,0) >= 1. || val(fss_test3_n.x,0,2*i-1,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test3_n.y,0,i,0) - 0.5) > 0.) {
       fine(fss_test3_n.y,0,2*i,0) = a;
       fine(fss_test3_n.y,1,2*i,0) = 2.*val(fss_test3_n.y,0,i,0) - a;
     }
     else {
       fine(fss_test3_n.y,0,2*i,0) = 2.*val(fss_test3_n.y,0,i,0) + a - 1.;
       fine(fss_test3_n.y,1,2*i,0) = 1. - a;
     }
#line 390 "././embed-solid.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test3_n.y,j,2*i,k) && !fine(css_test3_n,j,i,k))
       fine(fss_test3_n.y,j,2*i,k) = 0.;
      }
  }
}







void restriction_three_phase1 (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0.;
  {foreach_child(){
    sum += val(s,0,0,0);

  }end_foreach_child()}
  val(s,0,0,0) = sum/(1 << 2);





}


double bilinear3 (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



    return (9.*coarse(s,0,0,0) +
     3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
     coarse(s,child.x,child.y,0))/16.;
#line 445 "././embed-solid.h"
}

void refine_three_phase11 (Point point, scalar s){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
   {foreach_child(){
        val(s,0,0,0) = bilinear3 (point, s);
   }end_foreach_child()}
}

void refine_three_phase1 (Point point, scalar s){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
   {foreach_child(){



            val(s,0,0,0) = (9.*coarse(s,0,0,0) +
                3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
                coarse(s,child.x,child.y,0))/16.;
#line 469 "././embed-solid.h"
   }end_foreach_child()}
}
#line 607 "././embed-solid.h"




void D_restriction(Point point, scalar s){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
    scalar f1 = _attribute[s.i].f1;
    scalar f2 = _attribute[s.i].f2;
}
#line 662 "././embed-solid.h"
void refine_embed_linear_css_test3 (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child() {
    if (!val(css_test3,0,0,0)){
       val(s,0,0,0) = Tsat00;
    }else {
      if (!(coarse(css_test3,0,0,0))) qassert ("././embed-solid.h", 669, "coarse(css_test3)");
      int i = (child.x + 1)/2, j = (child.y + 1)/2;

      if (coarse(fss_test3.x,i,0,0) && coarse(fss_test3.y,0,j,0) &&
   (coarse(css_test3,0,0,0) == 1. || coarse(css_test3,child.x,0,0) == 1. ||
    coarse(css_test3,0,child.y,0) == 1. || coarse(css_test3,child.x,child.y,0) == 1.)) {
 if (!(coarse(css_test3,child.x,0,0) && coarse(css_test3,0,child.y,0))) qassert ("././embed-solid.h", 675, "coarse(css_test3,child.x) && coarse(css_test3,0,child.y)");
 if (coarse(fss_test3.x,i,child.y,0) && coarse(fss_test3.y,child.x,j,0)) {

   if (!(coarse(css_test3,child.x,child.y,0))) qassert ("././embed-solid.h", 678, "coarse(css_test3,child.x,child.y)");
   val(s,0,0,0) = (9.*coarse(s,0,0,0) +
   3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
   coarse(s,child.x,child.y,0))/16.;
 }
 else

   val(s,0,0,0) = (2.*coarse(s,0,0,0) + coarse(s,child.x,0,0) + coarse(s,0,child.y,0))/4.;
      }
      else if (coarse(css_test3,child.x,child.y,0) &&
        ((coarse(fss_test3.x,i,0,0) && coarse(fss_test3.y,child.x,j,0)) ||
  (coarse(fss_test3.y,0,j,0) && coarse(fss_test3.x,i,child.y,0)))) {

 val(s,0,0,0) = (3.*coarse(s,0,0,0) + coarse(s,child.x,child.y,0))/4.;
      }
#line 741 "././embed-solid.h"
      else {

 val(s,0,0,0) = coarse(s,0,0,0);
  {
   if (coarse(fss_test3.x,(child.x + 1)/2,0,0) && coarse(css_test3,child.x,0,0))
     val(s,0,0,0) += (coarse(s,child.x,0,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test3.x,(- child.x + 1)/2,0,0) && coarse(css_test3,- child.x,0,0))
     val(s,0,0,0) -= (coarse(s,- child.x,0,0) - coarse(s,0,0,0))/4.;
 } 
#line 744
{
   if (coarse(fss_test3.y,0,(child.y + 1)/2,0) && coarse(css_test3,0,child.y,0))
     val(s,0,0,0) += (coarse(s,0,child.y,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test3.y,0,(- child.y + 1)/2,0) && coarse(css_test3,0,- child.y,0))
     val(s,0,0,0) -= (coarse(s,0,- child.y,0) - coarse(s,0,0,0))/4.;
 }
      }
    }
  }end_foreach_child()}
}

void refine_embed_linear_css_test3_n (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child() {
    if (!val(css_test3_n,0,0,0)){

      if(_attribute[s.i].boundary[0] != _attribute[s.i].boundary_homogeneous[0])
       val(s,0,0,0) = Tsat00;
     else
       val(s,0,0,0) = 0.0;
    }else {
      if (!(coarse(css_test3_n,0,0,0))) qassert ("././embed-solid.h", 766, "coarse(css_test3_n)");
      int i = (child.x + 1)/2, j = (child.y + 1)/2;

      if (coarse(fss_test3_n.x,i,0,0) && coarse(fss_test3_n.y,0,j,0) &&
   (coarse(css_test3_n,0,0,0) == 1. || coarse(css_test3_n,child.x,0,0) == 1. ||
    coarse(css_test3_n,0,child.y,0) == 1. || coarse(css_test3_n,child.x,child.y,0) == 1.)) {
 if (!(coarse(css_test3_n,child.x,0,0) && coarse(css_test3_n,0,child.y,0))) qassert ("././embed-solid.h", 772, "coarse(css_test3_n,child.x) && coarse(css_test3_n,0,child.y)");
 if (coarse(fss_test3_n.x,i,child.y,0) && coarse(fss_test3_n.y,child.x,j,0)) {

   if (!(coarse(css_test3_n,child.x,child.y,0))) qassert ("././embed-solid.h", 775, "coarse(css_test3_n,child.x,child.y)");
   val(s,0,0,0) = (9.*coarse(s,0,0,0) +
   3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
   coarse(s,child.x,child.y,0))/16.;
 }
 else

   val(s,0,0,0) = (2.*coarse(s,0,0,0) + coarse(s,child.x,0,0) + coarse(s,0,child.y,0))/4.;
      }
      else if (coarse(css_test3_n,child.x,child.y,0) &&
        ((coarse(fss_test3_n.x,i,0,0) && coarse(fss_test3_n.y,child.x,j,0)) ||
  (coarse(fss_test3_n.y,0,j,0) && coarse(fss_test3_n.x,i,child.y,0)))) {

 val(s,0,0,0) = (3.*coarse(s,0,0,0) + coarse(s,child.x,child.y,0))/4.;
      }
#line 838 "././embed-solid.h"
      else {

 val(s,0,0,0) = coarse(s,0,0,0);
  {
   if (coarse(fss_test3_n.x,(child.x + 1)/2,0,0) && coarse(css_test3_n,child.x,0,0))
     val(s,0,0,0) += (coarse(s,child.x,0,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test3_n.x,(- child.x + 1)/2,0,0) && coarse(css_test3_n,- child.x,0,0))
     val(s,0,0,0) -= (coarse(s,- child.x,0,0) - coarse(s,0,0,0))/4.;
 } 
#line 841
{
   if (coarse(fss_test3_n.y,0,(child.y + 1)/2,0) && coarse(css_test3_n,0,child.y,0))
     val(s,0,0,0) += (coarse(s,0,child.y,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test3_n.y,0,(- child.y + 1)/2,0) && coarse(css_test3_n,0,- child.y,0))
     val(s,0,0,0) -= (coarse(s,0,- child.y,0) - coarse(s,0,0,0))/4.;
 }
      }
    }
  }end_foreach_child()}
}

void restriction_embed_linear_css_test3 (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  if (!val(css_test3,0,0,0) ) {
       val(s,0,0,0) = Tsat00;
    return;
  }






  double val = 0., nv = 0.;
  for (int i = 0; i <= 1; i++)



      if (fine(css_test3,0,i,j) && fine(css_test3,1,!i,!j))
 val += (fine(s,0,i,j) + fine(s,1,!i,!j))/2., nv++;
  if (nv > 0.) {
    val(s,0,0,0) = val/nv;
    return;
  }





  coord p = {0.,0.,0.};
  {foreach_child()
    if (val(css_test3,0,0,0))
      p.x += x, p.y += y, p.z += z, val += val(s,0,0,0), nv++;end_foreach_child()}
  if (!(nv > 0.)) qassert ("././embed-solid.h", 886, "nv > 0.");
  val(s,0,0,0) = val/nv;
}
#line 16 "template01.c"
#line 1 "./linear2-tree-1-2.h"
#line 1 "././linear2-tree-1-2.h"
#line 1 "./heights.h"
#line 2 "././linear2-tree-1-2.h"


#line 1 "././linear2-tree-2.h"
#line 1 "./././linear2-tree-2.h"

coord interface_normal3 (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n;
  if (!h.x.i || (n = height_normal (point, c, h)).x == HUGE)
    n = mycs (point, c);
  return n;
}
#line 16 "template01.c"
#line 1 "./linear2-tree-1-2.h"
#line 1 "././linear2-tree-1-2.h"
#line 1 "./heights.h"
#line 2 "././linear2-tree-1-2.h"


#line 1 "././linear2-tree-2.h"
#line 1 "./././linear2-tree-2.h"

static void _stencil_interface_normal3 (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 
   
_stencil_height_normal (point, c, h);
    { _stencil_mycs (point, c); }
        
  
#line 7
return ;
}






void restriction_zero (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar ff6 = _attribute[s.i].ff6;
  double sum = 0.;
  double weight= 0.;
  {foreach_child(){
    if(val(ff6,0,0,0)>0.0){
        sum += val(s,0,0,0)*val(ff6,0,0,0);
        weight += val(ff6,0,0,0);
    }
  }end_foreach_child()}

  if(weight>0.0){
    val(s,0,0,0) = sum/weight;
  }
}


void restriction_flux_sum (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0.;
  {foreach_child(){
        sum += val(s,0,0,0);
  }end_foreach_child()}
  val(s,0,0,0) = sum;
}

double bilinear_no_cs3 (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



        return (9.*coarse(s,0,0,0) +
          3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
          coarse(s,child.x,child.y,0))/16.;
#line 58 "./././linear2-tree-2.h"
    return 0.0;

}

static inline double bilinear_embed_css_test3 (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (!coarse(css_test3,0,0,0) || !coarse(css_test3,child.x,0,0))
    return coarse(s,0,0,0);

  if (!coarse(css_test3,0,child.y,0) || !coarse(css_test3,child.x,child.y,0))
    return coarse(s,0,0,0);







  return bilinear_no_cs3 (point, s);
}

static inline double bilinear_embed_css_test2 (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (!coarse(css_test2,0,0,0) || !coarse(css_test2,child.x,0,0))
    return coarse(s,0,0,0);

  if (!coarse(css_test2,0,child.y,0) || !coarse(css_test2,child.x,child.y,0))
    return coarse(s,0,0,0);







  return bilinear_no_cs3 (point, s);
}

static inline double bilinear_embed_css_test (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  if (!coarse(css_test,0,0,0) || !coarse(css_test,child.x,0,0))
    return coarse(s,0,0,0);

  if (!coarse(css_test,0,child.y,0) || !coarse(css_test,child.x,child.y,0))
    return coarse(s,0,0,0);







  return bilinear_no_cs3 (point, s);
}


double bilinear_embed_ff6 (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar ff6 = _attribute[s.i].ff6;
  if (!coarse(ff6,0,0,0) || !coarse(ff6,child.x,0,0)){
     if(val(ff6,0,0,0)>=0.5){
        return coarse(s,0,0,0);
     }else{
        return 0.0;
     }
  }

  if (!coarse(ff6,0,child.y,0) || !coarse(ff6,child.x,child.y,0)){
    if(val(ff6,0,0,0)>=0.5){
        return coarse(s,0,0,0);
     }else{
        return 0.0;
     }
  }
#line 144 "./././linear2-tree-2.h"
  return bilinear_no_cs3 (point, s);
}
#line 5 "././linear2-tree-1-2.h"
#line 1 "././vof2front-advanced-copy.h"
#line 1 "./././vof2front-advanced-copy.h"


#line 1 "./././my-distance.h"
#line 1 "././././my-distance.h"
#line 18 "././././my-distance.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdint.h"
#include <stdint.h>
#line 19 "././././my-distance.h"
#line 1 "./././PointTriangle.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/PointTriangle.h"
#line 13 "/home/xiangbin2/basilisk_new/basilisk/src/PointTriangle.h"
double PointTriangleDistance (const coord * P,
         const coord * P0,
         const coord * P1,
         const coord * P2,
         double * s, double * t)
{

  double d2;
  coord diff = ((coord){(*P0).x - (*P).x, (*P0).y - (*P).y, (*P0).z - (*P).z});
  coord edge0 = ((coord){(*P1).x - (*P0).x, (*P1).y - (*P0).y, (*P1).z - (*P0).z});
  coord edge1 = ((coord){(*P2).x - (*P0).x, (*P2).y - (*P0).y, (*P2).z - (*P0).z});
  double a00 = ((edge0).x*(edge0).x + (edge0).y*(edge0).y + (edge0).z*(edge0).z);
  double a01 = ((edge0).x*(edge1).x + (edge0).y*(edge1).y + (edge0).z*(edge1).z);
  double a11 = ((edge1).x*(edge1).x + (edge1).y*(edge1).y + (edge1).z*(edge1).z);
  double b0 = ((diff).x*(edge0).x + (diff).y*(edge0).y + (diff).z*(edge0).z);
  double b1 = ((diff).x*(edge1).x + (diff).y*(edge1).y + (diff).z*(edge1).z);
  double c = ((diff).x*(diff).x + (diff).y*(diff).y + (diff).z*(diff).z);
  double det = fabs(a00*a11 - a01*a01);
  *s = a01*b1 - a11*b0;
  *t = a01*b0 - a00*b1;

  if (*s + *t <= det)
  {
    if (*s < 0.0)
    {
      if (*t < 0.0)
      {
        if (b0 < 0.0)
        {
          *t = 0.0;
          if (-b0 >= a00)
          {
            *s = 1.0;
            d2 = a00 + 2.0*b0 + c;
          }
          else
          {
            *s = -b0/a00;
            d2 = b0**s + c;
          }
        }
        else
        {
          *s = 0.0;
          if (b1 >= 0.0)
          {
            *t = 0.0;
            d2 = c;
          }
          else if (-b1 >= a11)
          {
            *t = 1.0;
            d2 = a11 + 2.0*b1 + c;
          }
          else
          {
            *t = -b1/a11;
            d2 = b1**t + c;
          }
        }
      }
      else
      {
        *s = 0.0;
        if (b1 >= 0.0)
        {
          *t = 0.0;
          d2 = c;
        }
        else if (-b1 >= a11)
        {
          *t = 1.0;
          d2 = a11 + 2.0*b1 + c;
        }
        else
        {
          *t = -b1/a11;
          d2 = b1**t + c;
        }
      }
    }
    else if (*t < 0.0)
    {
      *t = 0.0;
      if (b0 >= 0.0)
      {
        *s = 0.0;
        d2 = c;
      }
      else if (-b0 >= a00)
      {
        *s = 1.0;
        d2 = a00 + 2.0*b0 + c;
      }
      else
      {
        *s = -b0/a00;
        d2 = b0**s + c;
      }
    }
    else
    {
      if (det == 0.)
 d2 = HUGE;
      else {
 double invDet = 1.0/det;
 *s *= invDet;
 *t *= invDet;
 d2 = *s*(a00**s + a01**t + 2.0*b0) + *t*(a01**s + a11**t + 2.0*b1) + c;
      }
    }
  }
  else
  {
    if (*s < 0.0)
    {
      double tmp0 = a01 + b0;
      double tmp1 = a11 + b1;
      if (tmp1 > tmp0)
      {
        double numer = tmp1 - tmp0;
        double denom = a00 - 2.0*a01 + a11;
        if (numer >= denom)
        {
          *s = 1.0;
          *t = 0.0;
          d2 = a00 + 2.0*b0 + c;
        }
        else
        {
          *s = numer/denom;
          *t = 1.0 - *s;
          d2 = *s*(a00**s + a01**t + 2.0*b0) + *t*(a01**s + a11**t + 2.0*b1) + c;
        }
      }
      else
      {
        *s = 0.0;
        if (tmp1 <= 0.0)
        {
          *t = 1.0;
          d2 = a11 + 2.0*b1 + c;
        }
        else if (b1 >= 0.0)
        {
          *t = 0.0;
          d2 = c;
        }
        else
        {
          *t = -b1/a11;
          d2 = b1**t + c;
        }
      }
    }
    else if (*t < 0.0)
    {
      double tmp0 = a01 + b1;
      double tmp1 = a00 + b0;
      if (tmp1 > tmp0)
      {
        double numer = tmp1 - tmp0;
        double denom = a00 - 2.0*a01 + a11;
        if (numer >= denom)
        {
          *t = 1.0;
          *s = 0.0;
          d2 = a11 + 2.0*b1 + c;
        }
        else
        {
          *t = numer/denom;
          *s = 1.0 - *t;
          d2 = *s*(a00**s + a01**t + 2.0*b0) + *t*(a01**s + a11**t + 2.0*b1) + c;
        }
      }
      else
      {
        *t = 0.0;
        if (tmp1 <= 0.0)
        {
          *s = 1.0;
          d2 = a00 + 2.0*b0 + c;
        }
        else if (b0 >= 0.0)
        {
          *s = 0.0;
          d2 = c;
        }
        else
        {
          *s = -b0/a00;
          d2 = b0**s + c;
        }
      }
    }
    else
    {
      double numer = a11 + b1 - a01 - b0;
      if (numer <= 0.0)
      {
        *s = 0.0;
        *t = 1.0;
        d2 = a11 + 2.0*b1 + c;
      }
      else
      {
        double denom = a00 - 2.0*a01 + a11;
        if (numer >= denom)
        {
          *s = 1.0;
          *t = 0.0;
          d2 = a00 + 2.0*b0 + c;
        }
        else
        {
          *s = numer/denom;
          *t = 1.0 - *s;
          d2 = *s*(a00**s + a01**t + 2.0*b0) + *t*(a01**s + a11**t + 2.0*b1) + c;
        }
      }
    }
  }


  if (d2 < 0.0)
  {
    d2 = 0.0;
  }

  return d2;
}

int PointTriangleOrientation (const coord * P,
         const coord * P0,
         const coord * P1,
         const coord * P2)
{
  coord diff = ((coord){(*P0).x - (*P).x, (*P0).y - (*P).y, (*P0).z - (*P).z});
  coord edge0 = ((coord){(*P1).x - (*P0).x, (*P1).y - (*P0).y, (*P1).z - (*P0).z});
  coord edge1 = ((coord){(*P2).x - (*P0).x, (*P2).y - (*P0).y, (*P2).z - (*P0).z});
  coord n = ((coord){(edge0).y*(edge1).z - (edge0).z*(edge1).y, (edge0).z*(edge1).x - (edge0).x*(edge1).z, (edge0).x*(edge1).y - (edge0).y*(edge1).x});
  return sign (((diff).x*(n).x + (diff).y*(n).y + (diff).z*(n).z));
}




double PointSegmentDistance (const coord * p, const coord * p0, const coord * p1,
        coord * segmentClosest, double * segmentParameter)
{


  coord direction = ((coord){(*p1).x - (*p0).x, (*p1).y - (*p0).y, (*p1).z - (*p0).z});
  coord diff = ((coord){(*p).x - (*p1).x, (*p).y - (*p1).y, (*p).z - (*p1).z});
  double t = ((direction).x*(diff).x + (direction).y*(diff).y + (direction).z*(diff).z);
  if (t >= (double)0)
    {
      *segmentParameter = (double)1;
      *segmentClosest = *p1;
    }
  else
    {
      diff = ((coord){(*p).x - (*p0).x, (*p).y - (*p0).y, (*p).z - (*p0).z});
      t = ((direction).x*(diff).x + (direction).y*(diff).y + (direction).z*(diff).z);
      if (t <= (double)0)
        {
   *segmentParameter = (double)0;
   *segmentClosest = *p0;
        }
      else
        {
   double sqrLength = ((direction).x*(direction).x + (direction).y*(direction).y + (direction).z*(direction).z);
   if (sqrLength > (double)0)
            {
       t /= sqrLength;
       *segmentParameter = t;
       (*segmentClosest).z = 0.;
       
  (*segmentClosest).x = (*p0).x + t * direction.x;
  
#line 292
(*segmentClosest).y = (*p0).y + t * direction.y;
            }
   else
            {
       *segmentParameter = (double)0;
       *segmentClosest = *p0;
            }
        }
    }

  diff = ((coord){(*p).x - (*segmentClosest).x, (*p).y - (*segmentClosest).y, (*p).z - (*segmentClosest).z});
  return ((diff).x*(diff).x + (diff).y*(diff).y + (diff).z*(diff).z);
}

int PointSegmentOrientation (const coord * P,
        const coord * P0,
        const coord * P1)
{
  coord diff = ((coord){(*P0).x - (*P).x, (*P0).y - (*P).y, (*P0).z - (*P).z});
  coord edge0 = ((coord){(*P0).x - (*P1).x, (*P0).y - (*P1).y, (*P0).z - (*P1).z});
  coord n = ((coord){(diff).y*(edge0).z - (diff).z*(edge0).y, (diff).z*(edge0).x - (diff).x*(edge0).z, (diff).x*(edge0).y - (diff).y*(edge0).x});
  return sign(n.z);
}
#line 20 "././././my-distance.h"
#line 29 "././././my-distance.h"
static inline double bilinear_no_cs2 (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



    return (9.*coarse(s,0,0,0) +
     3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
     coarse(s,child.x,child.y,0))/16.;
#line 45 "././././my-distance.h"
}


     
coord * input_stl2 (FILE * fp)
{tracing("input_stl2","././././my-distance.h",49);
  Array * a = array_new();
  char tag[6];

  if (fgets (tag, 6, fp) != tag) {
    fprintf (ferr, "input_stl2(): error reading tag\n");
    exit(1);
  }
  rewind (fp);
  if (!strcmp (tag, "solid")) {
    fprintf (ferr, "input_stl2(): ASCII STL not implemented yet "
      "(use binary instead)\n");
    exit(1);
  }
  else {
    uint32_t nf;
    char header[80];
    unsigned i;

    if (fread (header, sizeof (char), 80, fp) != 80) {
      fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: incomplete header\n");
      exit (1);
    }
    if (fread (&nf, sizeof (uint32_t), 1, fp) != 1) {
      fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing number of facets\n");
      exit (1);
    }
    i = nf;
    while (i > 0) {
      float x, y, z;
      unsigned j;
      uint16_t attbytecount;

      if (fread (&x, sizeof (float), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing normal x-coordinate\n");
 exit (1);
      }
      if (fread (&y, sizeof (float), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing normal y-coordinate\n");
 exit (1);
      }
      if (fread (&z, sizeof (float), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing normal z-coordinate\n");
 exit (1);
      }

      for (j = 0; j < 3; j++) {
 if (fread (&x, sizeof (float), 1, fp) != 1) {
   fprintf (ferr, "Input file is not a valid STL file\n"
     "stdin: missing vertex x-coordinate\n");
   exit (1);
 }
 if (fread (&y, sizeof (float), 1, fp) != 1) {
   fprintf (ferr, "Input file is not a valid STL file\n"
     "stdin: missing vertex y-coordinate\n");
   exit (1);
 }
 if (fread (&z, sizeof (float), 1, fp) != 1) {
   fprintf (ferr, "Input file is not a valid STL file\n"
     "stdin: missing vertex z-coordinate\n");
   exit (1);
 }
 coord p = {x,y,z};
 array_append (a, &p, sizeof(coord));
      }

      if (fread (&attbytecount, sizeof (uint16_t), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing attribute byte count\n");
 exit (1);
      }
      i--;
    }
  }
  coord p = {HUGE};
  array_append (a, &p, sizeof(coord));
  { coord  * _ret= (coord *) array_shrink (a);end_tracing("input_stl2","././././my-distance.h",131);return _ret;}
end_tracing("input_stl2","././././my-distance.h",132);}
#line 148 "././././my-distance.h"
     
coord * input_xy2 (FILE * fp)
{tracing("input_xy2","././././my-distance.h",149);
  Array * a = array_new();
  coord p = {0}, last, * la = NULL;
  while (!feof(fp)) {
    if (fscanf (fp, "%lf %lf", &p.x, &p.y) == 2) {
      if (la) {
 array_append (a, la, sizeof(coord));
 array_append (a, &p, sizeof(coord));
      }
      last = p, la = &last;
    }
    else {
      int c;
      while ((c = fgetc(fp)) != EOF && c != '\n');
      la = NULL;
    }
  }
  p.x = HUGE;
  array_append (a, &p, sizeof(coord));
  { coord  * _ret= (coord *) array_shrink (a);end_tracing("input_xy2","././././my-distance.h",169);return _ret;}
end_tracing("input_xy2","././././my-distance.h",170);}





void bounding_box2 (coord * p, coord * min, coord * max)
{
  
    (*min).x = HUGE, (*max).x = - HUGE;
    
#line 179
(*min).y = HUGE, (*max).y = - HUGE;
  while (p->x != HUGE) {
     {
      if ((*p).x < (*min).x)
 (*min).x = (*p).x;
      if ((*p).x > (*max).x)
 (*max).x = (*p).x;
    } 
#line 181
{
      if ((*p).y < (*min).y)
 (*min).y = (*p).y;
      if ((*p).y > (*max).y)
 (*max).y = (*p).y;
    }
    p++;
  }
}








#line 208 "././././my-distance.h"
typedef struct {
  double d2;
  coord * v;
  int type;
} closest_t2;
#line 240 "././././my-distance.h"
static void update_distance2 (Point point, coord ** i, scalar d)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar surface2 = _attribute[d.i].surface2;
  Array * a = array_new();
  coord c = {x,y,z}, closest = {0};
  closest_t2 q[2];
  for (int i = 0; i < 2; i++)
    q[i].d2 = HUGE;
  int nd = 0;
  double r2 = sq(3.*Delta/2.);
  bool first = (level == 0);
  while (*i) {
    coord * p = *i;

    coord r;
    double s, d2 = PointSegmentDistance (&c, p, p + 1, &r, &s);




    for (int i = 0; i < 2; i++)
      if (d2 < q[i].d2) {
 for (int j = 2 - 1; j > i; j--)
   q[j] = q[j-1];
 q[i].d2 = d2, q[i].v = p;


 if (s == 0.)
   q[i].type = 0;
 else if (s == 1.)
   q[i].type = 1;
 else

   q[i].type = 3;
 if (i == 0)
   closest = r;
#line 295 "././././my-distance.h"
 if (i >= nd)
   nd = i + 1;
 break;
      }

    if (d2 < r2 || first)
      array_append (a, &p, sizeof(coord *));
    first = false, i++;
  }
  if (a->len) {

    coord * p = NULL;
    array_append (a, &p, sizeof(coord *));
    p = (coord *) array_shrink (a);
    if (!(sizeof(double) >= sizeof(void *))) qassert ("././././my-distance.h", 309, "sizeof(double) >= sizeof(void *)");
    memcpy (&val(surface2,0,0,0), &p, sizeof(void *));

    int orient;

    if (q[0].type == 3)

      orient = PointSegmentOrientation (&c, q[0].v, q[0].v + 1);
    else {

      if (nd == 1)

 orient = sign(bilinear_no_cs2 (point, d));
      else {
 orient = PointSegmentOrientation (&c, q[0].v, q[0].v + 1);
 if (orient != PointSegmentOrientation (&c, q[1].v, q[1].v + 1)) {
   coord n = {0};
   for (int i = 0; i < 2; i++) {




     coord ab = ((coord){(*(q[i].v + 1)).x - (*q[i].v).x, (*(q[i].v + 1)).y - (*q[i].v).y, (*(q[i].v + 1)).z - (*q[i].v).z});
     double nn = sqrt(((ab).x*(ab).x + (ab).y*(ab).y + (ab).z*(ab).z));
     if (!(nn > 0.)) qassert ("././././my-distance.h", 333, "nn > 0.");
     n.x -= ab.y/nn, n.y += ab.x/nn;
   }





   coord diff = ((coord){(closest).x - (c).x, (closest).y - (c).y, (closest).z - (c).z});
   orient = sign(((n).x*(diff).x + (n).y*(diff).y + (n).z*(diff).z));
 }
      }
    }
#line 409 "././././my-distance.h"
    val(d,0,0,0) = sqrt (q[0].d2)*orient;
  }
  else {
    pfree (a,__func__,__FILE__,__LINE__);
    val(surface2,0,0,0) = 0.;
    if (level > 0)
      val(d,0,0,0) = bilinear_no_cs2 (point, d);
    else
      val(d,0,0,0) = 0.;
  }
}



static void refine_distance2 (Point point, scalar d)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar surface2 = _attribute[d.i].surface2;
  if (val(surface2,0,0,0) == 0.)
    {foreach_child() {
      val(surface2,0,0,0) = 0.;
      val(d,0,0,0) = bilinear_no_cs2 (point, d);
    }end_foreach_child()}
  else {
    coord ** ap = (coord **) (*((void **) &(val(surface2,0,0,0))));
    int s = 0;
    {foreach_child() {
      update_distance2 (point, ap, d);
      s += sign(val(d,0,0,0));
    }end_foreach_child()}







    if (fabs(val(d,0,0,0)) > sqrt(2)*Delta/4.) {
      if (abs(s) != 1 << 2) {
 s = sign(s);
 {foreach_child()
   val(d,0,0,0) = s*fabs(val(d,0,0,0));end_foreach_child()}
      }
      if (sign(val(d,0,0,0)) != sign(s))
 val(d,0,0,0) = - val(d,0,0,0);
    }
  }
}

static void restriction_distance2 (Point point, scalar d) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;}

static void coarsen_distance2 (Point point, scalar d) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar surface2 = _attribute[d.i].surface2;
  {foreach_child()
    pfree ((*((void **) &(val(surface2,0,0,0)))),__func__,__FILE__,__LINE__);end_foreach_child()}
}

static void delete_distance2 (scalar d) {
  scalar surface2 = _attribute[d.i].surface2;
  {foreach_level (0)
    pfree (*((void **)(*((void **) &(val(surface2,0,0,0))))),__func__,__FILE__,__LINE__);end_foreach_level();}
  for (int l = 0; l <= depth(); l++)
    {foreach_level (l)
      pfree ((*((void **) &(val(surface2,0,0,0)))),__func__,__FILE__,__LINE__);end_foreach_level();}
  delete (((scalar[]){surface2,{-1}}));
}

     
void distance2 (scalar d, coord * p)
{tracing("distance2","././././my-distance.h",476);
  scalar surface2 = _attribute[d.i].surface2;
  if (surface2.i)
    delete_distance2 (d);
  surface2 = new_scalar("surface2");
  _attribute[surface2.i].restriction = no_restriction;

  _attribute[surface2.i].prolongation = no_restriction;
  _attribute[surface2.i].refine = no_restriction;
  _attribute[d.i].prolongation = refine_bilinear;
  _attribute[d.i].refine = refine_distance2;
  _attribute[d.i].coarsen = coarsen_distance2;
  _attribute[d.i].dirty = true;

  _attribute[d.i].surface2 = surface2;
  _attribute[d.i].delete = delete_distance2;
  _attribute[d.i].restriction = restriction_distance2;

  Array * a = array_new();
  while (p->x != HUGE) {






      array_append (a, &p, sizeof (coord *));
    p += 2;
  }
  p = NULL;
  array_append (a, &p, sizeof (coord *));
  p = (coord *) array_shrink (a);

  {foreach_level(0)
    update_distance2 (point, (coord **) p, d);end_foreach_level();}
  pfree (p,__func__,__FILE__,__LINE__);

  boundary_level (((scalar[]){d,{-1}}), 0);
  for (int l = 0; l < depth(); l++) {
    {foreach_coarse_level (l)
      refine_distance2 (point, d);end_foreach_coarse_level();}
    boundary_level (((scalar[]){d,{-1}}), l + 1);
  }
end_tracing("distance2","././././my-distance.h",520);}
#line 4 "./././vof2front-advanced-copy.h"


extern bool flag_test;




coord interface_normal2(Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n;
  if (!_attribute[c.i].height.x.i || (n = height_normal (point, c, _attribute[c.i].height)).x == HUGE)
    n = mycs (point, c);
  else {
    double nn = 0.;
    
      nn += fabs(n.x);
      
#line 19
nn += fabs(n.y);
    
      n.x /= nn;
      
#line 21
n.y /= nn;
  }
  return n;
}





#line 11
static void _stencil_interface_normal2(Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES; 
   
_stencil_height_normal (point, c, _attribute[c.i].height);{
    { _stencil_mycs (point, c); }   
    
     
       
    
        
   
}
        
  
  
#line 23
return ;
}



void reconstruction2(const scalar c, vector n, scalar alpha)
{
  foreach_stencil() {





_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
      _stencil_val_a(alpha,0,0,0);  
      
 {_stencil_val_a(n.x,0,0,0);  }
 
#line 39
{_stencil_val_a(n.y,0,0,0);  }
    } 
{  






       _stencil_interface_normal2(point, c);
      
 {_stencil_val_a(n.x,0,0,0);  }
 
#line 50
{_stencil_val_a(n.y,0,0,0);  }
      _stencil_val_a(alpha,0,0,0);_stencil_val(c,0,0,0);    
    }}





          
    
  
#line 53
}end_foreach_stencil();
  {
#line 30
foreach() {





    if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
      val(alpha,0,0,0) = 0.;
      
 val(n.x,0,0,0) = 0.;
 
#line 39
val(n.y,0,0,0) = 0.;
    }
    else {






      coord m = interface_normal2(point, c);
      
 val(n.x,0,0,0) = m.x;
 
#line 50
val(n.y,0,0,0) = m.y;
      val(alpha,0,0,0) = line_alpha (val(c,0,0,0), m);
    }
  }end_foreach();}
#line 62 "./././vof2front-advanced-copy.h"
  
    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;
    
#line 63
_attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;







  boundary_internal ((scalar *)((scalar[]){n.x,n.y, alpha,{-1}}), "./././vof2front-advanced-copy.h", 77);
}

void vof2dist(scalar c, scalar phi){



  if (_attribute[c.i].height.x.i)
    heights (c, _attribute[c.i].height);




  scalar  alpha_front=new_scalar("alpha_front");
  vector  n_front=new_vector("n_front");

  reconstruction2(c, n_front, alpha_front);



  foreach_vertex_stencil()
    {_stencil_val_a(phi,0,0,0);  }end_foreach_vertex_stencil();



  {
#line 97
foreach_vertex()
    val(phi,0,0,0) = L0*sqrt(2)+1;end_foreach_vertex();}
#line 116 "./././vof2front-advanced-copy.h"
  boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "./././vof2front-advanced-copy.h", 116);

  restriction(((scalar[]){phi,{-1}}));



  {foreach_vertex(){

    double vertex_signed_distance = val(phi,0,0,0);
    coord vertex_c = (coord){x,y,0};

    int _s = 2;
    int _nn = _s + 0 ? _s + 0 : 2;
    int _i = point.i, _j = point.j;

    for (int _k = - _nn; _k <= _nn-1; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn-1; _l++) {
        point.j = _j + _l;
        POINT_VARIABLES;
    if (fabs(val(c,0,0,0) - 0.5) <= (0.5-1e-6)){






          if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0)){
            static const coord a = {-0.5,-0.5,-0.5}, b = {0.5,0.5,0.5};







            {foreach_child(){



              coord n = {val(n_front.x,0,0,0), val(n_front.y,0,0,0), 0.0};
              if (fabs(rectangle_fraction (n, val(alpha_front,0,0,0), a, b) - 0.5) <= (0.5-1e-6)){

                coord segment[2];
                coord temp1;
                coord temp2;
                if (facets (n, val(alpha_front,0,0,0), segment) == 2){

                  segment[0] = (coord){x + segment[0].x*Delta, y + segment[0].y*Delta, 0.0};
                  segment[1] = (coord){x + segment[1].x*Delta, y + segment[1].y*Delta, 0.0};

                  if ((sign(segment[1].y -segment[0].y) == sign(n.x)) && (sign(segment[0].x -segment[1].x) == sign(n.y))){
                     temp1 = segment[1];
                     temp2 = segment[0];
                  }
                  else{
                    temp1 = segment[0];
                    temp2 = segment[1];
                  }
                  coord r;
                  double s, d2 = PointSegmentDistance (&vertex_c, &(temp1), &(temp2), &r, &s);
                  if (sqrt(d2) < fabs(vertex_signed_distance)){
                    vertex_signed_distance = sqrt(d2)*((double)PointSegmentOrientation(&vertex_c, &(temp1), &(temp2)));}
                }
              }
            }end_foreach_child()}
          }

          else{

                coord n = {val(n_front.x,0,0,0), val(n_front.y,0,0,0), 0.0};

                coord segment[2];
                coord temp1;
                coord temp2;
                if (facets (n, val(alpha_front,0,0,0), segment) == 2){

                  segment[0] = (coord){x + segment[0].x*Delta, y + segment[0].y*Delta, 0.0};
                  segment[1] = (coord){x + segment[1].x*Delta, y + segment[1].y*Delta, 0.0};

                  if ((sign(segment[1].y -segment[0].y) == sign(n.x)) && (sign(segment[0].x -segment[1].x) == sign(n.y))){
                     temp1 = segment[1];
                     temp2 = segment[0];
                  }
                  else{
                    temp1 = segment[0];
                    temp2 = segment[1];
                  }
                  coord r;
                  double s, d2 = PointSegmentDistance (&vertex_c, &(temp1), &(temp2), &r, &s);
                  if (sqrt(d2) < fabs(vertex_signed_distance)){
                    vertex_signed_distance = sqrt(d2)*((double)PointSegmentOrientation(&vertex_c, &(temp1), &(temp2)));}
                }

          }
        }
      }
    }
    point.i = _i; point.j = _j;
    POINT_VARIABLES;
    val(phi,0,0,0) = vertex_signed_distance;
  }end_foreach_vertex();}
#line 291 "./././vof2front-advanced-copy.h"
  boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "./././vof2front-advanced-copy.h", 291);







  foreach_vertex_stencil()
    for (int ii = -1; ii<=0; ii++)
      for (int jj = -1; jj<=0; jj++){

_stencil_neighbor(ii,jj,0); _stencil_neighbor(ii,jj,0); _stencil_neighbor(ii,jj,0);{{
_stencil_fine(c,ii,jj,0);
            {_stencil_val_a(phi,0,0,0);_stencil_fine(c,ii,jj,0);_stencil_val(phi,0,0,0);    }
               
          
#line 306
}
{

_stencil_val(c,ii,jj,0);
            {_stencil_val_a(phi,0,0,0);_stencil_val(c,ii,jj,0);_stencil_val(phi,0,0,0);    }

               
            
#line 311
}}

              
        
      
#line 312
}end_foreach_vertex_stencil();







  {
#line 299
foreach_vertex()
    for (int ii = -1; ii<=0; ii++)
      for (int jj = -1; jj<=0; jj++){

        if (!is_leaf (neighbor(ii,jj,0)) && neighbor(ii,jj,0).neighbors && neighbor(ii,jj,0).pid >= 0){
          if (fabs(fine(c,ii,jj,0) - 0.5) > (0.5-1e-6))
            val(phi,0,0,0) = sign(fine(c,ii,jj,0) - 0.5)*fabs(val(phi,0,0,0));
          }
        else{

          if (fabs(val(c,ii,jj,0) - 0.5) > (0.5-1e-6))
            val(phi,0,0,0) = sign(val(c,ii,jj,0) - 0.5)*fabs(val(phi,0,0,0));
            }
      }end_foreach_vertex();}
#line 333 "./././vof2front-advanced-copy.h"
  boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "./././vof2front-advanced-copy.h", 333);delete((scalar*)((scalar[]){n_front.x,n_front.y,alpha_front,{-1}}));


}
#line 346 "./././vof2front-advanced-copy.h"
void dist_cleanup(scalar c, scalar phi){

  scalar  num_faces=new_scalar("num_faces");

  _attribute[num_faces.i].prolongation = _attribute[num_faces.i].refine = refine_injection;
  _attribute[num_faces.i].restriction = no_restriction;

  foreach_stencil(){
    _stencil_val_a(num_faces,0,0,0);  
    _stencil_val_r(num_faces,0,0,0);_stencil_val(phi,0,0,0);_stencil_val(phi,1,0,0);        
    _stencil_val_r(num_faces,0,0,0);_stencil_val(phi,0,0,0);_stencil_val(phi,0,1,0);        
    _stencil_val_r(num_faces,0,0,0);_stencil_val(phi,1,0,0);_stencil_val(phi,1,1,0);        
    _stencil_val_r(num_faces,0,0,0);_stencil_val(phi,0,1,0);_stencil_val(phi,1,1,0);        
  }end_foreach_stencil();

  {
#line 353
foreach(){
    val(num_faces,0,0,0) = 0;
    val(num_faces,0,0,0) += (((val(phi,0,0,0))*(val(phi,1,0,0)) < 0.) ? 1 : 0);
    val(num_faces,0,0,0) += (((val(phi,0,0,0))*(val(phi,0,1,0)) < 0.) ? 1 : 0);
    val(num_faces,0,0,0) += (((val(phi,1,0,0))*(val(phi,1,1,0)) < 0.) ? 1 : 0);
    val(num_faces,0,0,0) += (((val(phi,0,1,0))*(val(phi,1,1,0)) < 0.) ? 1 : 0);
  }end_foreach();}

  boundary_internal ((scalar *)((scalar[]){num_faces,{-1}}), "./././vof2front-advanced-copy.h", 361);

  foreach_vertex_stencil(){    
    
    
    for (int ii = -1; ii<=0; ii++)
      for (int jj = -1; jj<=0; jj++){
_stencil_neighbor(ii,jj,0); _stencil_neighbor(ii,jj,0); _stencil_neighbor(ii,jj,0);{{
_stencil_fine(num_faces,ii,jj,0);{ 
              
_stencil_fine(c,ii,jj,0); 
            
#line 371
}
             
        
#line 372
}
{
_stencil_val(num_faces,ii,jj,0);{
             
_stencil_val(c,ii,jj,0);
           
#line 376
}
           
        
#line 377
}}
              
        
      
#line 378
} 
{
{{
        _stencil_val_a(phi,0,0,0);_stencil_val(phi,0,0,0); _stencil_val(phi,0,0,0);       }
{
        _stencil_val_a(phi,0,0,0);_stencil_val(phi,0,0,0); _stencil_val(phi,0,0,0);       }}
         
      
    
#line 384
}
     
  
#line 385
}end_foreach_vertex_stencil();

  {
#line 363
foreach_vertex(){
    bool to_change = false;
    double f_cell;
    for (int ii = -1; ii<=0; ii++)
      for (int jj = -1; jj<=0; jj++){
        if (!is_leaf (neighbor(ii,jj,0)) && neighbor(ii,jj,0).neighbors && neighbor(ii,jj,0).pid >= 0){
          if (fine(num_faces,ii,jj,0) > 2){
            to_change = true;
            f_cell = fine(c,ii,jj,0);}
        }
        else{
        if (val(num_faces,ii,jj,0) > 2){
          to_change = true;
          f_cell = val(c,ii,jj,0);}
        }
      }
    if (to_change) {
      if (f_cell < 0.5){
        val(phi,0,0,0) = (val(phi,0,0,0) >= 0.0 ? -0.00001 : val(phi,0,0,0));}
      else{
        val(phi,0,0,0) = (val(phi,0,0,0) <= 0.0 ? 0.00001 : val(phi,0,0,0));}
    }
  }end_foreach_vertex();}
  boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "./././vof2front-advanced-copy.h", 386);delete((scalar*)((scalar[]){num_faces,{-1}}));
}
#line 6 "././linear2-tree-1-2.h"



extern int globali,outstep,level_interface;
extern scalar css_test3_n;
extern scalar deltac;
extern scalar T_solid;

extern scalar css_test2;
extern vector fss_test2;

extern scalar css_test;
extern vector fss_test;
extern bool energy_advecting_flag;
extern bool flag_topos_advect_uf;
extern scalar intersect_true;
extern bool flag_average_source;







static inline void face_rejection2_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector f = _attribute[s.i].v;
  for (int i = 0; i <= 1; i++) {
    val(f.x,i,0,0) = 1.0;

    val(f.x,i,1,0) = 1.0;





  }
}

#line 30
static inline void face_rejection2_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector f = _attribute[s.i].v;
  for (int i = 0; i <= 1; i++) {
    val(f.y,0,i,0) = 1.0;

    val(f.y,1,i,0) = 1.0;





  }
}

#line 1 "./myc2d2.h"
#line 46 "././linear2-tree-1-2.h"
 extern vector smallmodl,bigmodl,smallmodg,bigmodg;


struct Threephases {
  scalar ff4;

  vector modphase1;
  vector modphase0;

};

void get_modphase01_2(struct Threephases q){
#line 73 "././linear2-tree-1-2.h"
    scalar ff4=q.ff4;
    vector modphase1=q.modphase1;
    vector modphase0=q.modphase0;

    vector  hhh=new_vector("hhh");
    heights(ff4,hhh);
    vector  nn4=new_vector("nn4");
    scalar  alpha4=new_scalar("alpha4");






    _attribute[ff4.i].refine = _attribute[ff4.i].prolongation = fraction_refine;

    boundary_internal ((scalar *)((vector[]){hhh,{{-1},{-1}}}), "././linear2-tree-1-2.h", 89);

    restriction(((scalar[]){ff4,{-1}}));


foreach_stencil() {

_stencil_val(ff4,0,0,0); _stencil_val(ff4,0,0,0);{ {
      _stencil_val_a(alpha4,0,0,0);  
      
        {_stencil_val_a(nn4.x,0,0,0);  }
        
#line 99
{_stencil_val_a(nn4.y,0,0,0);  }
      }{  
       _stencil_interface_normal3 (point, ff4, hhh);
      
         {_stencil_val_a(nn4.x,0,0,0);  }
         
#line 103
{_stencil_val_a(nn4.y,0,0,0);  }
      _stencil_val_a(alpha4,0,0,0);_stencil_val(ff4,0,0,0);    
    }}

          
  
#line 106
}end_foreach_stencil();


{
#line 94
foreach() {

    if (val(ff4,0,0,0) <= 0. || val(ff4,0,0,0) >= 1.) {
      val(alpha4,0,0,0) = 0.;
      
        val(nn4.x,0,0,0) = 0.;
        
#line 99
val(nn4.y,0,0,0) = 0.;
      }else{
      coord m = interface_normal3 (point, ff4, hhh);
      
         val(nn4.x,0,0,0) = m.x;
         
#line 103
val(nn4.y,0,0,0) = m.y;
      val(alpha4,0,0,0) = line_alpha (val(ff4,0,0,0), m);
    }
  }end_foreach();}


  
    _attribute[nn4.x.i].refine = _attribute[nn4.x.i].prolongation = refine_injection;
    
#line 110
_attribute[nn4.y.i].refine = _attribute[nn4.y.i].prolongation = refine_injection;

  _attribute[alpha4.i].n = nn4;
  _attribute[alpha4.i].refine = _attribute[alpha4.i].prolongation = alpha_refine;




  double lim_cut = 1e-2;
  restriction(((scalar[]){ff4,nn4.x,nn4.y,alpha4,{-1}}));
  vector  complete1=new_face_vector("complete1");
#line 141 "././linear2-tree-1-2.h"
  foreach_face_stencil(){_stencil_is_face_x(){{
          _stencil_val_a(complete1.x,0,0,0);  
          _stencil_val_a(modphase1.x,0,0,0);  
          _stencil_val_a(modphase0.x,0,0,0);  
  }}end__stencil_is_face_x()
#line 141
_stencil_is_face_y(){{
          _stencil_val_a(complete1.y,0,0,0);  
          _stencil_val_a(modphase1.y,0,0,0);  
          _stencil_val_a(modphase0.y,0,0,0);  
  }}end__stencil_is_face_y()}end_foreach_face_stencil();
#line 141 "././linear2-tree-1-2.h"
  {foreach_face_generic(){is_face_x(){{
          val(complete1.x,0,0,0) = 0;
          val(modphase1.x,0,0,0) = HUGE;
          val(modphase0.x,0,0,0) = HUGE;
  }}end_is_face_x()
#line 141
is_face_y(){{
          val(complete1.y,0,0,0) = 0;
          val(modphase1.y,0,0,0) = HUGE;
          val(modphase0.y,0,0,0) = HUGE;
  }}end_is_face_y()}end_foreach_face_generic();}



          foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(ff4,-1,0,0); _stencil_val(ff4,0,0,0);_stencil_val(ff4,-1,0,0); _stencil_val(ff4,0,0,0);{{
                     _stencil_val_a(modphase1.x,0,0,0);
                     _stencil_val_a(modphase0.x,0,0,0);
                     _stencil_val_a(complete1.x,0,0,0);  
                } {_stencil_val(ff4,-1,0,0);_stencil_val(ff4,0,0,0);_stencil_val(ff4,-1,0,0);_stencil_val(ff4,0,0,0);{{
                    _stencil_val_a(complete1.x,0,0,0);
_stencil_val(ff4,-1,0,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.x,0,0,0);{{
_stencil_val(hhh.x,0,0,0);_stencil_val(hhh.x,0,0,0);{
                        _stencil_val_a(modphase0.x,0,0,0);_stencil_val(hhh.x,0,0,0);
                          _stencil_val_a(modphase1.x,0,0,0);_stencil_val(modphase0.x,0,0,0);
                          _stencil_val_a(complete1.x,0,0,0);
                         }
                          

                   
#line 163
} {_stencil_val(ff4,-1,0,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.x,0,0,0);{
_stencil_val(hhh.x,0,0,0);_stencil_val(hhh.x,0,0,0);{
                           _stencil_val_a(modphase1.x,0,0,0);_stencil_val(hhh.x,0,0,0);
                           _stencil_val_a(modphase0.x,0,0,0);_stencil_val(modphase1.x,0,0,0);
                           _stencil_val_a(complete1.x,0,0,0);
                          }
                          
                   
#line 169
}    }}
_stencil_val(complete1.x,0,0,0);{
_stencil_val(ff4,-1,0,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.x,-1,0,0);{{
_stencil_val(hhh.x,-1,0,0);_stencil_val(hhh.x,-1,0,0);{
                        _stencil_val_a(modphase1.x,0,0,0);_stencil_val(hhh.x,-1,0,0);
                          _stencil_val_a(modphase0.x,0,0,0);_stencil_val(modphase1.x,0,0,0);
                          _stencil_val_a(complete1.x,0,0,0);
                         }
                          

                   
#line 178
} {_stencil_val(ff4,-1,0,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.x,-1,0,0);{
_stencil_val(hhh.x,-1,0,0);_stencil_val(hhh.x,-1,0,0);{
                           _stencil_val_a(modphase0.x,0,0,0);_stencil_val(hhh.x,-1,0,0);
                           _stencil_val_a(modphase1.x,0,0,0);_stencil_val(modphase0.x,0,0,0);
                           _stencil_val_a(complete1.x,0,0,0);
                          }
                          
                   
#line 184
}    }}
                       
                   
#line 185
}
_stencil_val(complete1.x,0,0,0);_stencil_val(modphase1.x,0,0,0);{{
                             _stencil_val_a(modphase1.x,0,0,0);  
                             _stencil_val_a(modphase0.x,0,0,0); _stencil_val(modphase1.x,0,0,0);   
                             _stencil_val_a(complete1.x,0,0,0);  
                    } {_stencil_val(complete1.x,0,0,0);_stencil_val(modphase1.x,0,0,0);{
                             _stencil_val_a(modphase1.x,0,0,0);    
                             _stencil_val_a(modphase0.x,0,0,0); _stencil_val(modphase1.x,0,0,0);   
                             _stencil_val_a(complete1.x,0,0,0);  
                   }  }}
                       
                 
                   

            
#line 196
}{
                  _stencil_val_a(modphase1.x,0,0,0);  
                  _stencil_val_a(modphase0.x,0,0,0);  
                  _stencil_val_a(complete1.x,0,0,0);  
           }}       }}
                   
        
#line 201
}}end__stencil_is_face_x()
#line 149
_stencil_is_face_y(){{
_stencil_val(ff4,0,-1,0); _stencil_val(ff4,0,0,0);_stencil_val(ff4,0,-1,0); _stencil_val(ff4,0,0,0);{{
                     _stencil_val_a(modphase1.y,0,0,0);
                     _stencil_val_a(modphase0.y,0,0,0);
                     _stencil_val_a(complete1.y,0,0,0);  
                } {_stencil_val(ff4,0,-1,0);_stencil_val(ff4,0,0,0);_stencil_val(ff4,0,-1,0);_stencil_val(ff4,0,0,0);{{
                    _stencil_val_a(complete1.y,0,0,0);
_stencil_val(ff4,0,-1,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.y,0,0,0);{{
_stencil_val(hhh.y,0,0,0);_stencil_val(hhh.y,0,0,0);{
                        _stencil_val_a(modphase0.y,0,0,0);_stencil_val(hhh.y,0,0,0);
                          _stencil_val_a(modphase1.y,0,0,0);_stencil_val(modphase0.y,0,0,0);
                          _stencil_val_a(complete1.y,0,0,0);
                         }
                          

                   
#line 163
} {_stencil_val(ff4,0,-1,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.y,0,0,0);{
_stencil_val(hhh.y,0,0,0);_stencil_val(hhh.y,0,0,0);{
                           _stencil_val_a(modphase1.y,0,0,0);_stencil_val(hhh.y,0,0,0);
                           _stencil_val_a(modphase0.y,0,0,0);_stencil_val(modphase1.y,0,0,0);
                           _stencil_val_a(complete1.y,0,0,0);
                          }
                          
                   
#line 169
}    }}
_stencil_val(complete1.y,0,0,0);{
_stencil_val(ff4,0,-1,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.y,0,-1,0);{{
_stencil_val(hhh.y,0,-1,0);_stencil_val(hhh.y,0,-1,0);{
                        _stencil_val_a(modphase1.y,0,0,0);_stencil_val(hhh.y,0,-1,0);
                          _stencil_val_a(modphase0.y,0,0,0);_stencil_val(modphase1.y,0,0,0);
                          _stencil_val_a(complete1.y,0,0,0);
                         }
                          

                   
#line 178
} {_stencil_val(ff4,0,-1,0);_stencil_val(ff4,0,0,0);_stencil_val(hhh.y,0,-1,0);{
_stencil_val(hhh.y,0,-1,0);_stencil_val(hhh.y,0,-1,0);{
                           _stencil_val_a(modphase0.y,0,0,0);_stencil_val(hhh.y,0,-1,0);
                           _stencil_val_a(modphase1.y,0,0,0);_stencil_val(modphase0.y,0,0,0);
                           _stencil_val_a(complete1.y,0,0,0);
                          }
                          
                   
#line 184
}    }}
                       
                   
#line 185
}
_stencil_val(complete1.y,0,0,0);_stencil_val(modphase1.y,0,0,0);{{
                             _stencil_val_a(modphase1.y,0,0,0);  
                             _stencil_val_a(modphase0.y,0,0,0); _stencil_val(modphase1.y,0,0,0);   
                             _stencil_val_a(complete1.y,0,0,0);  
                    } {_stencil_val(complete1.y,0,0,0);_stencil_val(modphase1.y,0,0,0);{
                             _stencil_val_a(modphase1.y,0,0,0);    
                             _stencil_val_a(modphase0.y,0,0,0); _stencil_val(modphase1.y,0,0,0);   
                             _stencil_val_a(complete1.y,0,0,0);  
                   }  }}
                       
                 
                   

            
#line 196
}{
                  _stencil_val_a(modphase1.y,0,0,0);  
                  _stencil_val_a(modphase0.y,0,0,0);  
                  _stencil_val_a(complete1.y,0,0,0);  
           }}       }}
                   
        
#line 201
}}end__stencil_is_face_y()}end_foreach_face_stencil();



          {
#line 149
foreach_face_generic(){is_face_x(){{
               if((val(ff4,-1,0,0)==0.0 && val(ff4,0,0,0)==1.0) || (val(ff4,-1,0,0)==1.0 && val(ff4,0,0,0)==0.0)){
                     val(modphase1.x,0,0,0)=0.5;
                     val(modphase0.x,0,0,0)=0.5;
                     val(complete1.x,0,0,0) = 6;
                }else if( ((val(ff4,-1,0,0)>=0.5) && !(val(ff4,0,0,0)>=0.5)) || (!(val(ff4,-1,0,0)>=0.5) && (val(ff4,0,0,0)>=0.5))){
                    val(complete1.x,0,0,0)=3;
                   if(((val(ff4,-1,0,0)>=0.5) && !(val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.x,0,0,0))==0){
                        if(height(val(hhh.x,0,0,0))>-1.0 && height(val(hhh.x,0,0,0))<0.0){
                        val(modphase0.x,0,0,0)=fabs(height(val(hhh.x,0,0,0)));
                          val(modphase1.x,0,0,0)=1.0-val(modphase0.x,0,0,0);
                          val(complete1.x,0,0,0)=2;
                         }

                   }else if((!(val(ff4,-1,0,0)>=0.5) && (val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.x,0,0,0))==1){
                        if(height(val(hhh.x,0,0,0))<0.0 && height(val(hhh.x,0,0,0)>-1.0)){
                           val(modphase1.x,0,0,0)=fabs(height(val(hhh.x,0,0,0)));
                           val(modphase0.x,0,0,0)=1.0-val(modphase1.x,0,0,0);
                           val(complete1.x,0,0,0)=2;
                          }
                   }
                 if(val(complete1.x,0,0,0)==3){
                   if(((val(ff4,-1,0,0)>=0.5) && !(val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.x,-1,0,0))==0){
                        if(height(val(hhh.x,-1,0,0))>0.0 && height(val(hhh.x,-1,0,0))<1.0){
                        val(modphase1.x,0,0,0)=fabs(height(val(hhh.x,-1,0,0)));
                          val(modphase0.x,0,0,0)=1.0-val(modphase1.x,0,0,0);
                          val(complete1.x,0,0,0)=2;
                         }

                   }else if((!(val(ff4,-1,0,0)>=0.5) && (val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.x,-1,0,0))==1){
                        if(height(val(hhh.x,-1,0,0))>0.0 && height(val(hhh.x,-1,0,0)<1.0)){
                           val(modphase0.x,0,0,0)=fabs(height(val(hhh.x,-1,0,0)));
                           val(modphase1.x,0,0,0)=1.0-val(modphase0.x,0,0,0);
                           val(complete1.x,0,0,0)=2;
                          }
                   }
                   }
                 if(val(complete1.x,0,0,0)==2 && (val(modphase1.x,0,0,0)<lim_cut)){
                             val(modphase1.x,0,0,0) = lim_cut;
                             val(modphase0.x,0,0,0) = 1.0 - val(modphase1.x,0,0,0);
                             val(complete1.x,0,0,0) = 5;
                    }else if(val(complete1.x,0,0,0)==2 && (val(modphase1.x,0,0,0)>1.0-lim_cut)){
                             val(modphase1.x,0,0,0) = 1.0 - lim_cut;
                             val(modphase0.x,0,0,0) = 1.0 - val(modphase1.x,0,0,0);
                             val(complete1.x,0,0,0) = 5;
                   }

            }else{
                  val(modphase1.x,0,0,0) = 1.0;
                  val(modphase0.x,0,0,0) = 1.0;
                  val(complete1.x,0,0,0) = 7;
           }
        }}end_is_face_x()
#line 149
is_face_y(){{
               if((val(ff4,0,-1,0)==0.0 && val(ff4,0,0,0)==1.0) || (val(ff4,0,-1,0)==1.0 && val(ff4,0,0,0)==0.0)){
                     val(modphase1.y,0,0,0)=0.5;
                     val(modphase0.y,0,0,0)=0.5;
                     val(complete1.y,0,0,0) = 6;
                }else if( ((val(ff4,0,-1,0)>=0.5) && !(val(ff4,0,0,0)>=0.5)) || (!(val(ff4,0,-1,0)>=0.5) && (val(ff4,0,0,0)>=0.5))){
                    val(complete1.y,0,0,0)=3;
                   if(((val(ff4,0,-1,0)>=0.5) && !(val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.y,0,0,0))==0){
                        if(height(val(hhh.y,0,0,0))>-1.0 && height(val(hhh.y,0,0,0))<0.0){
                        val(modphase0.y,0,0,0)=fabs(height(val(hhh.y,0,0,0)));
                          val(modphase1.y,0,0,0)=1.0-val(modphase0.y,0,0,0);
                          val(complete1.y,0,0,0)=2;
                         }

                   }else if((!(val(ff4,0,-1,0)>=0.5) && (val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.y,0,0,0))==1){
                        if(height(val(hhh.y,0,0,0))<0.0 && height(val(hhh.y,0,0,0)>-1.0)){
                           val(modphase1.y,0,0,0)=fabs(height(val(hhh.y,0,0,0)));
                           val(modphase0.y,0,0,0)=1.0-val(modphase1.y,0,0,0);
                           val(complete1.y,0,0,0)=2;
                          }
                   }
                 if(val(complete1.y,0,0,0)==3){
                   if(((val(ff4,0,-1,0)>=0.5) && !(val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.y,0,-1,0))==0){
                        if(height(val(hhh.y,0,-1,0))>0.0 && height(val(hhh.y,0,-1,0))<1.0){
                        val(modphase1.y,0,0,0)=fabs(height(val(hhh.y,0,-1,0)));
                          val(modphase0.y,0,0,0)=1.0-val(modphase1.y,0,0,0);
                          val(complete1.y,0,0,0)=2;
                         }

                   }else if((!(val(ff4,0,-1,0)>=0.5) && (val(ff4,0,0,0)>=0.5)) && orientation(val(hhh.y,0,-1,0))==1){
                        if(height(val(hhh.y,0,-1,0))>0.0 && height(val(hhh.y,0,-1,0)<1.0)){
                           val(modphase0.y,0,0,0)=fabs(height(val(hhh.y,0,-1,0)));
                           val(modphase1.y,0,0,0)=1.0-val(modphase0.y,0,0,0);
                           val(complete1.y,0,0,0)=2;
                          }
                   }
                   }
                 if(val(complete1.y,0,0,0)==2 && (val(modphase1.y,0,0,0)<lim_cut)){
                             val(modphase1.y,0,0,0) = lim_cut;
                             val(modphase0.y,0,0,0) = 1.0 - val(modphase1.y,0,0,0);
                             val(complete1.y,0,0,0) = 5;
                    }else if(val(complete1.y,0,0,0)==2 && (val(modphase1.y,0,0,0)>1.0-lim_cut)){
                             val(modphase1.y,0,0,0) = 1.0 - lim_cut;
                             val(modphase0.y,0,0,0) = 1.0 - val(modphase1.y,0,0,0);
                             val(complete1.y,0,0,0) = 5;
                   }

            }else{
                  val(modphase1.y,0,0,0) = 1.0;
                  val(modphase0.y,0,0,0) = 1.0;
                  val(complete1.y,0,0,0) = 7;
           }
        }}end_is_face_y()}end_foreach_face_generic();}
    foreach_face_stencil ()_stencil_is_face_x(){{
_stencil_val(complete1.x,0,0,0); _stencil_val(modphase1.x,0,0,0);{ 
               
               for(int i0=-1;i0<2;i0++){
                  for(int j0=-1;j0<2;j0++){    

                            
                            
                            
                             
_stencil_val(nn4.x,i0,j0,0); _stencil_val(nn4.y,i0,j0,0);  
                              

                             _stencil_val(nn4.x,i0-1,j0,0); _stencil_val(nn4.y,i0-1,j0,0);   
                              
                             
#line 216
_stencil_val(alpha4,i0,j0,0);  
                             _stencil_val(alpha4,i0-1,j0,0);  


                                
                                


                                
                                

                                 
                                
                                  
                                

                                   

                  }
                }          

                
                
                
                
                          
                  
                     
               

                
                  

                   
                         
                     
                         
                  

                _stencil_val_a(modphase1.x,0,0,0);
                _stencil_val_a(modphase0.x,0,0,0);_stencil_val(modphase1.x,0,0,0);

                _stencil_val_a(complete1.x,0,0,0);  

          }
           
  
#line 261
}}end__stencil_is_face_x()end_foreach_face_stencil();
    {
#line 202
foreach_face_generic ()is_face_x(){{
          if(val(complete1.x,0,0,0)==3 && val(modphase1.x,0,0,0)>HUGE/2.0){
               double c_temp[3][3];
               for(int i0=-1;i0<2;i0++){
                  for(int j0=-1;j0<2;j0++){

                            double leftvolume,rightvolume;
                            coord a_left,b_left;
                            coord a_right,b_right;
                            coord n_temp;
                            n_temp.x = val(nn4.x,i0,j0,0), n_temp.y = val(nn4.y,i0,j0,0);

                            coord n_temp0;
                            n_temp0.x = val(nn4.x,i0-1,j0,0), n_temp0.y = val(nn4.y,i0-1,j0,0);
                            double alpha_temp = val(alpha4,i0,j0,0);
                            double alpha_temp0 = val(alpha4,i0-1,j0,0);


                                a_left=(coord){-0.5,-0.5};
                                b_left=(coord){0.5,0.5};


                                a_right=(coord){-0.5,-0.5};
                                b_right=(coord){0.5,0.5};

                                b_left.x = 0.0;
                                leftvolume=rectangle_fraction(n_temp,alpha_temp,a_left,b_left)*(b_left.x-a_left.x);
                                a_right.x = 0.0;
                                rightvolume=rectangle_fraction(n_temp0,alpha_temp0,a_right,b_right)*(b_right.x-a_right.x);

                                c_temp[i0+1][j0+1] = rightvolume + leftvolume;

                  }
                }

                coord n_middle = mycs2(c_temp);
                double c_middle = c_temp[0+1][0+1];
                double alpha_middle = line_alpha(c_middle,n_middle);
                double test=0;
                if(fabs(n_middle.x) > 1e-12){
            test = alpha_middle/n_middle.x - (-0.5);

                }

                if(test>lim_cut && test<1-lim_cut)
                  {
                        test = test;
                  }else if(test>1.0-lim_cut){
                        test = 1.0 - lim_cut;
                  }else if(test<lim_cut){
                        test = lim_cut;
                  }

                val(modphase1.x,0,0,0)=test;
                val(modphase0.x,0,0,0)=1.0-val(modphase1.x,0,0,0);

                val(complete1.x,0,0,0) = 4;

          }
  }}end_is_face_x()end_foreach_face_generic();}
    foreach_face_stencil ()_stencil_is_face_y(){{
_stencil_val(complete1.y,0,0,0); _stencil_val(modphase1.y,0,0,0);{ 
               
               for(int i0=-1;i0<2;i0++){
                  for(int j0=-1;j0<2;j0++){    

                          
                          
                          

                           
_stencil_val(nn4.x,i0,j0,0); _stencil_val(nn4.y,i0,j0,0);  
                            
                           _stencil_val(nn4.x,i0,j0-1,0); _stencil_val(nn4.y,i0,j0-1,0);   
                            

                           
#line 277
_stencil_val(alpha4,i0,j0,0);  
                           _stencil_val(alpha4,i0,j0-1,0);  


                          
                          


                          
                          

                           
                          
                            
                          

                             

                  }
                }          
                
                
                
                
                          
                  
                     
                       

                
                  

                   
                         
                     
                         
                  

                _stencil_val_a(modphase1.y,0,0,0);
                _stencil_val_a(modphase0.y,0,0,0);_stencil_val(modphase1.y,0,0,0);

                _stencil_val_a(complete1.y,0,0,0);  

          }
           
  
#line 321
}}end__stencil_is_face_y()end_foreach_face_stencil();
    {
#line 262
foreach_face_generic ()is_face_y(){{
          if(val(complete1.y,0,0,0)==3 && val(modphase1.y,0,0,0)>HUGE/2.0){
               double c_temp[3][3];
               for(int i0=-1;i0<2;i0++){
                  for(int j0=-1;j0<2;j0++){

                          double leftvolume,rightvolume;
                          coord a_left,b_left;
                          coord a_right,b_right;

                          coord n_temp;
                          n_temp.x = val(nn4.x,i0,j0,0), n_temp.y = val(nn4.y,i0,j0,0);
                          coord n_temp0;
                          n_temp0.x = val(nn4.x,i0,j0-1,0), n_temp0.y = val(nn4.y,i0,j0-1,0);

                          double alpha_temp = val(alpha4,i0,j0,0);
                          double alpha_temp0 = val(alpha4,i0,j0-1,0);


                          a_left=(coord){-0.5,-0.5};
                          b_left=(coord){0.5,0.5};


                          a_right=(coord){-0.5,-0.5};
                          b_right=(coord){0.5,0.5};

                          b_left.y = 0.0;
                          leftvolume=rectangle_fraction(n_temp,alpha_temp,a_left,b_left)*(b_left.y-a_left.y);
                          a_right.y = 0.0;
                          rightvolume=rectangle_fraction(n_temp0,alpha_temp0,a_right,b_right)*(b_right.y-a_right.y);

                          c_temp[i0+1][j0+1] = rightvolume + leftvolume;

                  }
                }
                coord n_middle = mycs2(c_temp);
                double c_middle = c_temp[0+1][0+1];
                double alpha_middle = line_alpha(c_middle,n_middle);
                double test=0;;
                if(fabs(n_middle.y) > 1e-12){
                    test = alpha_middle/n_middle.y - (-0.5);

                }

                if(test>lim_cut && test<1-lim_cut)
                  {
                        test = test;
                  }else if(test>1.0-lim_cut){
                        test = 1.0 - lim_cut;
                  }else if(test<lim_cut){
                        test = lim_cut;
                  }

                val(modphase1.y,0,0,0)=test;
                val(modphase0.y,0,0,0)=1.0-val(modphase1.y,0,0,0);

                val(complete1.y,0,0,0) = 4;

          }
  }}end_is_face_y()end_foreach_face_generic();}
#line 330 "././linear2-tree-1-2.h"
    foreach_face_stencil(){_stencil_is_face_x(){ {

    }}end__stencil_is_face_x()
#line 330
_stencil_is_face_y(){ {

    }}end__stencil_is_face_y()}end_foreach_face_stencil();
#line 330 "././linear2-tree-1-2.h"
    {foreach_face_generic(){is_face_x(){ {

    }}end_is_face_x()
#line 330
is_face_y(){ {

    }}end_is_face_y()}end_foreach_face_generic();}
        foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(modphase0.x,0,0,0);{{
                          _stencil_val_a(modphase0.x,0,0,0);
                          _stencil_val_a(modphase1.x,0,0,0);_stencil_val(modphase0.x,0,0,0);
                     } {_stencil_val(modphase1.x,0,0,0);{
                          _stencil_val_a(modphase1.x,0,0,0);
                          _stencil_val_a(modphase0.x,0,0,0);_stencil_val(modphase1.x,0,0,0);
                     }}}
_stencil_val(modphase0.x,0,0,0);{
                          _stencil_val_a(modphase0.x,0,0,0);  
                     }
_stencil_val(modphase1.x,0,0,0);{
                          _stencil_val_a(modphase1.x,0,0,0);  
                     }
                     
                     
                     
         
#line 347
}}end__stencil_is_face_x()
#line 333
_stencil_is_face_y(){{
_stencil_val(modphase0.y,0,0,0);{{
                          _stencil_val_a(modphase0.y,0,0,0);
                          _stencil_val_a(modphase1.y,0,0,0);_stencil_val(modphase0.y,0,0,0);
                     } {_stencil_val(modphase1.y,0,0,0);{
                          _stencil_val_a(modphase1.y,0,0,0);
                          _stencil_val_a(modphase0.y,0,0,0);_stencil_val(modphase1.y,0,0,0);
                     }}}
_stencil_val(modphase0.y,0,0,0);{
                          _stencil_val_a(modphase0.y,0,0,0);  
                     }
_stencil_val(modphase1.y,0,0,0);{
                          _stencil_val_a(modphase1.y,0,0,0);  
                     }
                     
                     
                     
         
#line 347
}}end__stencil_is_face_y()}end_foreach_face_stencil();
        {
#line 333
foreach_face_generic(){is_face_x(){{
                     if(fabs(val(modphase0.x,0,0,0))<lim_cut){
                          val(modphase0.x,0,0,0)=lim_cut;
                          val(modphase1.x,0,0,0)=1.0-val(modphase0.x,0,0,0);
                     }else if(fabs(val(modphase1.x,0,0,0))<lim_cut){
                          val(modphase1.x,0,0,0)=lim_cut;
                          val(modphase0.x,0,0,0)=1.0-val(modphase1.x,0,0,0);
                     }
                     if(val(modphase0.x,0,0,0)>1){
                          val(modphase0.x,0,0,0) = 1.0;
                     }
                     if(val(modphase1.x,0,0,0)>1){
                          val(modphase1.x,0,0,0) = 1.0;
                     }
         }}end_is_face_x()
#line 333
is_face_y(){{
                     if(fabs(val(modphase0.y,0,0,0))<lim_cut){
                          val(modphase0.y,0,0,0)=lim_cut;
                          val(modphase1.y,0,0,0)=1.0-val(modphase0.y,0,0,0);
                     }else if(fabs(val(modphase1.y,0,0,0))<lim_cut){
                          val(modphase1.y,0,0,0)=lim_cut;
                          val(modphase0.y,0,0,0)=1.0-val(modphase1.y,0,0,0);
                     }
                     if(val(modphase0.y,0,0,0)>1){
                          val(modphase0.y,0,0,0) = 1.0;
                     }
                     if(val(modphase1.y,0,0,0)>1){
                          val(modphase1.y,0,0,0) = 1.0;
                     }
         }}end_is_face_y()}end_foreach_face_generic();}
    {
      _attribute[modphase0.x.i].restriction = face_rejection2_x ;

         _attribute[modphase1.x.i].restriction = face_rejection2_x ;

    }
#line 348
{
      _attribute[modphase0.y.i].restriction = face_rejection2_y ;

         _attribute[modphase1.y.i].restriction = face_rejection2_y ;

    }
       restriction(((scalar[]){modphase0.x, modphase0.y, modphase1.x,modphase1.y,{-1}}));
     boundary_internal ((scalar *)((vector[]){modphase1,modphase0,{{-1},{-1}}}), "././linear2-tree-1-2.h", 355);delete((scalar*)((scalar[]){complete1.x,complete1.y,alpha4,nn4.x,nn4.y,hhh.x,hhh.y,{-1}}));
#line 376 "././linear2-tree-1-2.h"
  }





extern scalar masstr;
extern scalar source_pc;
extern scalar source_pc2;
extern scalar vtr;
extern double Tkg,Tkl,Trhog,Trhol,Tcpg,Tcpl,hfg;
extern double source_total,total_area;

extern scalar phase0Tgrad,phase1Tgrad;
extern scalar aiml,aimg;



#line 1 "./Tgrad-leon.h"
#line 1 "././Tgrad-leon.h"
#line 9 "././Tgrad-leon.h"
extern scalar topo_mask;
extern scalar topo_mask_s;
extern int level_interface,globali;
extern scalar css_test3_n,css_test3,css_test,css_test2;
extern scalar T;
extern double Tsat00;


extern scalar intersect_true;

coord interface_normal7 (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  coord n;
  if (!h.x.i || (n = height_normal (point, c, h)).x == HUGE)
    n = mycs (point, c);
  return n;
}





struct Tgradleon {
  scalar ff5;
  scalar phaseg;
  scalar phasel;
  scalar aiml;
  scalar aimg;
};



void Tgrad_leon(struct Tgradleon q){
  scalar ff5 = q.ff5;
  scalar phaseg = q.phaseg;
  scalar phasel = q.phasel;
  double length_threshold = 0.05;
 bool is_constant_m=false;


    vector  hh2=new_vector("hh2");

    heights(ff5,hh2);

    scalar  distanceT=new_scalar("distanceT");
    scalar  get_novalue_flag=new_scalar("get_novalue_flag");


    foreach_stencil(){
        _stencil_val_a(phaseg,0,0,0);
        _stencil_val_a(phasel,0,0,0);
        _stencil_val_a(distanceT,0,0,0);  
    }end_foreach_stencil();


    {
#line 57
foreach(){
        val(phaseg,0,0,0)=0.0;
        val(phasel,0,0,0)=0.0;
        val(distanceT,0,0,0) = HUGE;
    }end_foreach();}
    double threshold = 0.5;
    int sign1;
        vector  nnn=new_vector("nnn");
      foreach_stencil() {
_stencil_val(ff5,0,0,0); _stencil_val(ff5,0,0,0);{ {
            
                    {_stencil_val_a(nnn.x,0,0,0);  }
                    
#line 68
{_stencil_val_a(nnn.y,0,0,0);  }
            } 
{  
             _stencil_mycs (point, ff5);
            
                    {_stencil_val_a(nnn.x,0,0,0);  }
                    
#line 73
{_stencil_val_a(nnn.y,0,0,0);  }
            }}
                  
            
      
#line 75
}end_foreach_stencil();
      {
#line 65
foreach() {
            if (val(ff5,0,0,0) <= 0. || val(ff5,0,0,0) >= 1.) {
            
                    val(nnn.x,0,0,0) = 0.;
                    
#line 68
val(nnn.y,0,0,0) = 0.;
            }
            else {
            coord m = mycs (point, ff5);
            
                    val(nnn.x,0,0,0) = m.x;
                    
#line 73
val(nnn.y,0,0,0) = m.y;
            }
      }end_foreach();}
    for(int phase=0;phase<=1;phase++){

 sign1=2*phase-1;

            foreach_stencil(){ 



_stencil_val(css_test3_n,0,0,0);_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask,0,0,0);{   
                
                
                
                
                {foreach_neighbor(2){ 


_stencil_val(topo_mask,0,0,0); _stencil_val(css_test3_n,0,0,0);_stencil_val(ff5,0,0,0);_stencil_val(ff5,0,0,0);{  


                            


                            
                            { 
_stencil_val(nnn.x,0,0,0); 
                                
                            
#line 101
}
#line 99
{ 
_stencil_val(nnn.y,0,0,0); 
                                
                            
#line 101
} 
                            _stencil_val(ff5,0,0,0);    
                             
                            
       
                               
                                

                            
                            
                            





{

                            }  
                            
                             
                                   
                            
                             
                            

                             

                              
                                 



                                     


                            
                    
#line 132
}


                                
                
#line 133
}end_foreach_neighbor()}

{
{{
                            _stencil_val_a(distanceT,0,0,0);     
                            _stencil_val(distanceT,0,0,0);_stencil_val(T,0,0,0);



                            if(phase==0){
                                _stencil_val_a(phaseg,0,0,0);
                            }else{
                                _stencil_val_a(phasel,0,0,0);

                            }
                  }{
                            _stencil_val_a(distanceT,0,0,0);     
                            _stencil_val(distanceT,0,0,0);_stencil_val(T,0,0,0);



                            if(phase==0){
                                _stencil_val_a(phaseg,0,0,0);
                            }else{
                                _stencil_val_a(phasel,0,0,0);

                            }
_stencil_val(ff5,0,0,0); 
                               
               
#line 161
}}
                   
                
#line 162
}

                  

            
#line 164
}



                 

        
#line 166
}end_foreach_stencil();

            {
#line 80
foreach(){



        if(level==level_interface && val(css_test3_n,0,0,0)>=0.5 && ((val(topo_mask,0,0,0)==1*sign1) || (val(topo_mask,0,0,0)==2*sign1)) && (!(cell.pid < 0))){
                double colinearity=0.0;
                coord pure;
                pure.x=x,pure.y=y;
                double puretoint=HUGE;
                {foreach_neighbor(2){


                      if(level==level_interface && val(topo_mask,0,0,0)==0 && val(css_test3_n,0,0,0)>=0.5 && (val(ff5,0,0,0)>1e-6) && ((1.0-val(ff5,0,0,0))>1e-6) && (!(cell.pid < 0))){


                            double colinearity_temp;


                            coord nn;
                            {
                                nn.x = val(nnn.x,0,0,0);
                            }
#line 99
{
                                nn.y = val(nnn.y,0,0,0);
                            }
                            double alpha2=line_alpha(val(ff5,0,0,0),nn);;
                            coord rela_areacp,real_areacp;
                            line_length_center(nn,alpha2,&rela_areacp);
       normalize(&nn);
                            real_areacp.x = x + Delta*rela_areacp.x;
                            real_areacp.y = y + Delta*rela_areacp.y;

                            coord mixed;
                            coord deltapure;
                            double leng1;
                            mixed.x=x,mixed.y=y;
                            {
                                deltapure.x = pure.x - mixed.x;
                            }
#line 113
{
                                deltapure.y = pure.y - mixed.y;
                            }
                            leng1 = sqrt(sq(deltapure.x)+sq(deltapure.y));
                            if(leng1<0.0001){

                            }

                            colinearity_temp = fabs(nn.x*deltapure.x/leng1+nn.y*deltapure.y/leng1);

                            if(colinearity_temp>colinearity){
                                colinearity = colinearity_temp;



                                    puretoint = fabs(nn.x*(pure.x-real_areacp.x)+nn.y*(pure.y-real_areacp.y));


                            }
                    }
                }end_foreach_neighbor()}

                if(puretoint < (Delta*3.0*sqrt(2.0))){
                 if(puretoint > Delta*0.1){
                            val(distanceT,0,0,0) = puretoint;
                            double temp8 = (val(T,0,0,0)-Tsat00)/val(distanceT,0,0,0);



                            if(phase==0){
                                val(phaseg,0,0,0)=temp8;
                            }else{
                                val(phasel,0,0,0)=-temp8;

                            }
                  }else{
                            val(distanceT,0,0,0) = Delta*0.1;
                            double temp8 = (val(T,0,0,0)-Tsat00)/val(distanceT,0,0,0);



                            if(phase==0){
                                val(phaseg,0,0,0)=temp8;
                            }else{
                                val(phasel,0,0,0)=-temp8;

                            }
                               printf("puretoint less than 0.1*Delta, puretoint=%g ff=%g globali=%d\n", puretoint,val(ff5,0,0,0),globali);
               }
                }

            }

        }end_foreach();}
    }


  for(int phase=0;phase<=1;phase++){
    sign1 = 2*phase-1;

        foreach_stencil(){
           _stencil_val_a(get_novalue_flag,0,0,0); 

_stencil_val(topo_mask,0,0,0); _stencil_val(css_test3_n,0,0,0);_stencil_val(ff5,0,0,0);_stencil_val(ff5,0,0,0);{   
                
                

                  _stencil_mycs (point, ff5);    
                

                
                
                

                
                {foreach_neighbor(2){ 



_stencil_val(css_test3_n,0,0,0);_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask,0,0,0);{      
                         
                            
                         
                           
                            

                        
                         
#line 209 "././Tgrad-leon.h"
                                 

_stencil_val(distanceT,0,0,0);{ 

                                     
                                    if(phase==1){ 
_stencil_val(phasel,0,0,0); 
                                        
                                    
#line 216
}else{ 
_stencil_val(phaseg,0,0,0);
                                         
                                    
#line 218
} 
                                     




                                }

                                


                    
#line 227
}



                         
                
#line 228
}end_foreach_neighbor()}
{{
                        if(phase==1){
{

                            }
                             
                            
#line 234
_stencil_val_a(phasel,0,0,0);







                        }else{
{

                            }
                            
                            
#line 246
_stencil_val_a(phaseg,0,0,0);






                        }
                }{
                    _stencil_val_a(get_novalue_flag,0,0,0);     
                    
                    

                    
                    {foreach_neighbor(1){
_stencil_val(intersect_true,0,0,0); 
                             
                        
                        
                    
#line 264
}end_foreach_neighbor()}



                    if(1==1){
                            if(phase==0){

_stencil_val(ff5,0,0,0);{{ 
_stencil_mycs (point, css_test2);  
                                    
                                    
#line 273
_stencil_val(css_test2,0,0,0);      
                                    
                                    
                                    
{{
                                        _stencil_val_a(phaseg,0,0,0);_stencil_val(T,0,0,0);     
                                         
                                    }{
                                         _stencil_val_a(phaseg,0,0,0);_stencil_val(T,0,0,0);    
                                          
                                    }}
                                     
                                
#line 284
}{
                                    if(1==1){ 
_stencil_mycs (point, css_test2); 
                                         
                                        
#line 287
_stencil_val(css_test2,0,0,0);        
                                        
                                        
                                        


                                        
                                        
                                        {foreach_neighbor(2){
_stencil_val(css_test3_n,0,0,0); _stencil_val(ff5,0,0,0);{ 
_stencil_val(T,0,0,0);  
                                                    
                                                    
                                            
#line 299
}
                                               
                                        
#line 300
}end_foreach_neighbor()}
{{   
                                            
{{
                                                _stencil_val_a(phaseg,0,0,0);    
                                                  
                                            }{
                                                _stencil_val_a(phaseg,0,0,0);    
                                                  
                                            }}
                                            

                                        
#line 311
}{
                                            _stencil_val_a(phaseg,0,0,0);  
                                        }}
                                        

                                    
#line 315
}


                                }}
_stencil_val(aimg,0,0,0);{
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
_stencil_mycs (point, css_test2); 
                                         
                                        
#line 322
_stencil_val(css_test2,0,0,0);   
                                        
                                        

                                         _stencil_mycs (point, css_test3); 
                                        _stencil_val(css_test3,0,0,0);      
                                        
                                        
                                        
{{
                                            _stencil_val_a(phaseg,0,0,0);_stencil_val(aimg,0,0,0);    
                                        }{
                                            _stencil_val_a(phaseg,0,0,0);_stencil_val(aimg,0,0,0);    
                                        }}
                                         
                                    
#line 336
}
                                     
                                
#line 337
}

                                
                                  
                            
#line 338
}else{

_stencil_val(ff5,0,0,0);{{ 
_stencil_mycs (point, css_test); 
                                     
                                    
#line 342
_stencil_val(css_test,0,0,0);      
                                    
                                    
                                    
{{
                                        _stencil_val_a(phasel,0,0,0);_stencil_val(T,0,0,0);    
                                          
                                    }{
                                         _stencil_val_a(phasel,0,0,0);_stencil_val(T,0,0,0);    
                                          
                                    }}
                                    
                                
#line 353
}{


                                    if(1==1){ 
_stencil_mycs (point, css_test); 
                                         
                                        
#line 358
_stencil_val(css_test,0,0,0);        
                                        
                                        
                                        


                                        
                                        
                                        {foreach_neighbor(2){
_stencil_val(css_test3_n,0,0,0); _stencil_val(ff5,0,0,0);{ 
_stencil_val(T,0,0,0);  
                                                    
                                                    
                                            
#line 370
}
                                               
                                        
#line 371
}end_foreach_neighbor()}
{{   
                                            
{{
                                                _stencil_val_a(phasel,0,0,0);    
                                                  
                                            }{
                                                _stencil_val_a(phasel,0,0,0);    
                                                  
                                            }}
                                            

                                        
#line 382
}{
                                            _stencil_val_a(phasel,0,0,0);  
                                        }}
                                        

                                    
#line 386
}

                                }}
_stencil_val(aiml,0,0,0);{
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
_stencil_mycs (point, css_test); 
                                         
                                        
#line 392
_stencil_val(css_test,0,0,0);   
                                        
                                        

                                         _stencil_mycs (point, css_test3); 
                                        _stencil_val(css_test3,0,0,0);      
                                        
                                        
                                        
{{
                                            _stencil_val_a(phasel,0,0,0);_stencil_val(aiml,0,0,0);    
                                        }{
                                            _stencil_val_a(phasel,0,0,0);_stencil_val(aiml,0,0,0);    
                                        }}
                                        
                                    
#line 406
}
                                     
                                
#line 407
}

                                
                                  
                            
#line 408
}
                    }
                }}
                
            
#line 411
}

                     
    
#line 412
}end_foreach_stencil();

        {
#line 173
foreach(){
           val(get_novalue_flag,0,0,0)=0;

           if(level==level_interface && val(topo_mask,0,0,0)==0 && val(css_test3_n,0,0,0)>0.0 && (val(ff5,0,0,0)>1e-6) && ((1.0-val(ff5,0,0,0))>1e-6) && (!(cell.pid < 0))){
                coord mixed;
                mixed.x=x,mixed.y=y;

                 coord nn = mycs (point, ff5);
                normalize(&nn);

                double weight_tot=0.0;
                double val_tot=0.0;
                int num_tot=0;

                double gradT_inner=0.0;
                {foreach_neighbor(2){



            if(level==level_interface && val(css_test3_n,0,0,0)>=0.5 && (!(cell.pid < 0)) && ((val(topo_mask,0,0,0)==1*sign1) || (val(topo_mask,0,0,0)==2*sign1)) && (!(cell.pid < 0))){
                        coord pure;
                        pure.x = x, pure.y = y;
                        coord puretomixed;
                        puretomixed.x = pure.x - mixed.x;
                        puretomixed.y = pure.y - mixed.y;

                        double leng1 = sqrt(sq(puretomixed.x)+sq(puretomixed.y));
                        double colinearity;
#line 209 "././Tgrad-leon.h"
                                colinearity = fabs(nn.x*puretomixed.x/leng1+nn.y*puretomixed.y/leng1);

                                if(val(distanceT,0,0,0)<(Delta*3.0*sqrt(2.0))){

                                    weight_tot += colinearity;
                                    if(phase==1){
                                        val_tot += val(phasel,0,0,0)*colinearity;
                                    }else{
                                        val_tot += val(phaseg,0,0,0)*colinearity;
                                    }
                                    num_tot += 1;




                                }


                    }
                }end_foreach_neighbor()}
                if(num_tot>=1){
                        if(phase==1){
                             if(weight_tot<0.001){

                            }
                            val(phasel,0,0,0)=val_tot/weight_tot;







                        }else{
                            if(weight_tot<0.001){

                            }
                            val(phaseg,0,0,0)=val_tot/weight_tot;






                        }
                }else{
                    val(get_novalue_flag,0,0,0)=1;
                    coord m;
                    bool flag = false;

                    bool intersect_true_neighbour=false;
                    {foreach_neighbor(1){
                        if(val(intersect_true,0,0,0)==1){
                            intersect_true_neighbour = true;
                        }
                    }end_foreach_neighbor()}



                    if(1==1){
                            if(phase==0){

                                if(val(ff5,0,0,0)<=0.5){
                                    m = mycs (point, css_test2);
                                    double alpha_g=line_alpha(val(css_test2,0,0,0),m);
                                    coord area_center;
                                    line_length_center(m,alpha_g,&area_center);
                                    double length_g = sqrt(sq(area_center.x) + sq(area_center.y));
                                     if(length_g>length_threshold){
                                        val(phaseg,0,0,0) = (val(T,0,0,0) - Tsat00)/(length_g*Delta);
                                        flag = true;
                                    }else{
                                         val(phaseg,0,0,0) = (val(T,0,0,0) - Tsat00)/(length_threshold*Delta);
                                        flag = true;
                                    }
                                }else{
                                    if(1==1){
                                        m = mycs (point, css_test2);
                                        double alpha_g=line_alpha(val(css_test2,0,0,0),m);
                                        coord area_center;
                                        line_length_center(m,alpha_g,&area_center);
                                        double length_g = sqrt(sq(area_center.x) + sq(area_center.y));


                                        double total=0.0;
                                        double weight=0.0;
                                        {foreach_neighbor(2){
                                            if(val(css_test3_n,0,0,0)>0.5 && level==level_interface && val(ff5,0,0,0)<=0.5){
                                                    total += val(T,0,0,0);
                                                    weight +=1;
                                            }
                                        }end_foreach_neighbor()}
                                        if(weight>=1){
                                            double T_average = total/weight;
                                            if(length_g>length_threshold){
                                                val(phaseg,0,0,0) = (T_average - Tsat00)/(length_g*Delta);
                                                flag = true;
                                            }else{
                                                val(phaseg,0,0,0) = (T_average - Tsat00)/(length_threshold*Delta);
                                                flag = true;
                                            }

                                        }else{
                                            val(phaseg,0,0,0) = 0.0;
                                        }

                                    }


                                }
                                if((!flag) && (val(aimg,0,0,0)>=Tsat00)){
                                    if(val(css_test3,0,0,0)<1.0 && val(css_test3,0,0,0)>0.0){
                                        m = mycs (point, css_test2);
                                        double alpha_g=line_alpha(val(css_test2,0,0,0),m);
                                        coord area_center;
                                        line_length_center(m,alpha_g,&area_center);

                                        coord ms = mycs (point, css_test3);
                                        double alpha_s=line_alpha(val(css_test3,0,0,0),ms);
                                        coord area_centers;
                                        line_length_center(ms,alpha_s,&area_centers);
                                        double length_sg = sqrt(sq(area_center.x-area_centers.x) + sq(area_center.y-area_centers.y));
                                         if(length_sg>length_threshold){
                                            val(phaseg,0,0,0) = (val(aimg,0,0,0) - Tsat00)/(Delta*length_sg);
                                        }else{
                                            val(phaseg,0,0,0) = (val(aimg,0,0,0) - Tsat00)/(Delta*length_threshold);
                                        }
                                    }
                                }
                            }else{

                                if(val(ff5,0,0,0)>=0.5){
                                    m = mycs (point, css_test);
                                    double alpha_l=line_alpha(val(css_test,0,0,0),m);
                                    coord area_center;
                                    line_length_center(m,alpha_l,&area_center);
                                    double length_l = sqrt(sq(area_center.x) + sq(area_center.y));
                                    if(length_l>length_threshold){
                                        val(phasel,0,0,0) = -(val(T,0,0,0) - Tsat00)/(length_l*Delta);
                                        flag = true;
                                    }else{
                                         val(phasel,0,0,0) = -(val(T,0,0,0) - Tsat00)/(length_threshold*Delta);
                                        flag = true;
                                    }
                                }else{


                                    if(1==1){
                                        m = mycs (point, css_test);
                                        double alpha_l=line_alpha(val(css_test,0,0,0),m);
                                        coord area_center;
                                        line_length_center(m,alpha_l,&area_center);
                                        double length_l = sqrt(sq(area_center.x) + sq(area_center.y));


                                        double total=0.0;
                                        double weight=0.0;
                                        {foreach_neighbor(2){
                                            if(val(css_test3_n,0,0,0)>0.5 && level==level_interface && val(ff5,0,0,0)>=0.5){
                                                    total += val(T,0,0,0);
                                                    weight +=1;
                                            }
                                        }end_foreach_neighbor()}
                                        if(weight>=1){
                                            double T_average = total/weight;
                                            if(length_l>length_threshold){
                                                val(phasel,0,0,0) = -(T_average - Tsat00)/(length_l*Delta);
                                                flag = true;
                                            }else{
                                                val(phasel,0,0,0) = -(T_average - Tsat00)/(length_threshold*Delta);
                                                flag = true;
                                            }

                                        }else{
                                            val(phasel,0,0,0) = 0.0;
                                        }

                                    }

                                }
                                if((!flag) && (val(aiml,0,0,0)>=Tsat00)){
                                    if(val(css_test3,0,0,0)<1.0 && val(css_test3,0,0,0)>0.0){
                                        m = mycs (point, css_test);
                                        double alpha_l=line_alpha(val(css_test,0,0,0),m);
                                        coord area_center;
                                        line_length_center(m,alpha_l,&area_center);

                                        coord ms = mycs (point, css_test3);
                                        double alpha_s=line_alpha(val(css_test3,0,0,0),ms);
                                        coord area_centers;
                                        line_length_center(ms,alpha_s,&area_centers);
                                        double length_sl = sqrt(sq(area_center.x-area_centers.x) + sq(area_center.y-area_centers.y));
                                        if(length_sl>length_threshold){
                                            val(phasel,0,0,0) = -(val(aiml,0,0,0) - Tsat00)/(Delta*length_sl);
                                        }else{
                                            val(phasel,0,0,0) = -(val(aiml,0,0,0) - Tsat00)/(Delta*length_threshold);
                                        }
                                    }
                                }
                            }
                    }
                }
            }
    }end_foreach();}
    if(((q.aiml.i && phase==1) || (q.aimg.i && phase==0)) && 1==0){

      vector  nnn_s=new_vector("nnn_s");
      vector  center_s=new_vector("center_s");
      foreach_stencil() { 
                
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ {
                  { 
                           
                          _stencil_val_a(nnn_s.x,0,0,0);  
                  }
#line 420
{ 
                           
                          _stencil_val_a(nnn_s.y,0,0,0);  
                  }
                } 
{ 
_stencil_mycs (point, css_test3);
                   
                  
                          
#line 428
{_stencil_val_a(nnn_s.x,0,0,0);  }
                          
#line 428
{_stencil_val_a(nnn_s.y,0,0,0);  } 
                  _stencil_val(css_test3,0,0,0); 
                  
                  
                  {
                      _stencil_val_a(center_s.x,0,0,0);  
                  }
#line 432
{
                      _stencil_val_a(center_s.y,0,0,0);  
                  }
                }}
                      
                
      
#line 436
}end_foreach_stencil();
      {
#line 417
foreach() {
                coord m;
                if (val(css_test3,0,0,0) <= 0. || val(css_test3,0,0,0) >= 1.) {
                  {
                          m.x = 0;
                          val(nnn_s.x,0,0,0) = 0.;
                  }
#line 420
{
                          m.y = 0;
                          val(nnn_s.y,0,0,0) = 0.;
                  }
                }
                else {
                  m = mycs (point, css_test3);
                  
                          val(nnn_s.x,0,0,0) = m.x;
                          
#line 428
val(nnn_s.y,0,0,0) = m.y;
                  double alpha2=line_alpha(val(css_test3,0,0,0),m);;
                  coord center_s1;
                  line_length_center(m,alpha2,&center_s1);
                  {
                      val(center_s.x,0,0,0) = center_s1.x;
                  }
#line 432
{
                      val(center_s.y,0,0,0) = center_s1.y;
                  }
                }
      }end_foreach();}
        foreach_stencil(){
_stencil_val(get_novalue_flag,0,0,0);{ 

              
              { 
_stencil_val(nnn.x,0,0,0); 
                            
              
#line 443
}
#line 441
{ 
_stencil_val(nnn.y,0,0,0); 
                            
              
#line 443
} 
              _stencil_val(ff5,0,0,0);   
              
              





              
              
              {foreach_neighbor(1){
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{
                      if(phase==1){    
                            _stencil_val(nnn_s.y,0,0,0);_stencil_val(nnn_s.x,0,0,0);
_stencil_val(q.aiml,0,0,0);{   
                                    _stencil_val(center_s.y,0,0,0);_stencil_val(center_s.x,0,0,0);

{
                                       
_stencil_val(q.aiml,0,0,0); 
                                        
                                    
#line 464
}

                                    
                              
#line 465
}
                              
                      
#line 466
}else{    
                            _stencil_val(nnn_s.y,0,0,0);_stencil_val(nnn_s.x,0,0,0);
_stencil_val(q.aimg,0,0,0);{   
                                    _stencil_val(center_s.y,0,0,0);_stencil_val(center_s.x,0,0,0);

{
                                      
_stencil_val(q.aimg,0,0,0);
                                          
                                    
#line 474
}

                                    
                              
#line 475
}
                              
                      
#line 476
}
                  }
                   
              
#line 478
}end_foreach_neighbor()}
{
                      
                    if(phase==1){
                        _stencil_val_a(phasel,0,0,0);  
                    }else{
                        _stencil_val_a(phaseg,0,0,0);  
                    }
              }
              


          
#line 489
}
          
        
#line 490
}end_foreach_stencil();
        {
#line 437
foreach(){
          if(fabs(val(get_novalue_flag,0,0,0)-1)<1e-6){

              coord nn;
              {
                            nn.x = val(nnn.x,0,0,0);
              }
#line 441
{
                            nn.y = val(nnn.y,0,0,0);
              }
              double alpha2=line_alpha(val(ff5,0,0,0),nn);;
              coord center_f;
              line_length_center(nn,alpha2,&center_f);





              double distance_select=HUGE;
              double value=0.0;
              {foreach_neighbor(1){
                  if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                      if(phase==1){
                            double direction_juge = nn.x*val(nnn_s.x,0,0,0) +nn.y*val(nnn_s.y,0,0,0);
                            if(fabs(val(q.aiml,0,0,0))>0.0 && direction_juge>0.0){
                                    double distance = sqrt(sq(center_f.x-val(center_s.x,0,0,0))+sq(center_f.y-val(center_s.y,0,0,0)));

                                    if(distance_select>distance){
                                      distance_select=distance;
                                      value = (Tsat00 - val(q.aiml,0,0,0));
                                    }
                              }
                      }else{
                            double direction_juge = -nn.x*val(nnn_s.x,0,0,0) +(-nn.y)*val(nnn_s.y,0,0,0);
                            if(fabs(val(q.aimg,0,0,0))>0.0 && direction_juge>0.0){
                                    double distance = sqrt(sq(center_f.x-val(center_s.x,0,0,0))+sq(center_f.y-val(center_s.y,0,0,0)));

                                    if(distance_select>distance){
                                      distance_select=distance;
                                      value = (val(q.aimg,0,0,0) - Tsat00);
                                    }
                              }
                      }
                  }
              }end_foreach_neighbor()}
              if(distance_select<HUGE/2.0){
                    distance_select = max(0.1,distance_select)*Delta;
                    if(phase==1){
                        val(phasel,0,0,0) = value/distance_select;
                    }else{
                        val(phaseg,0,0,0) = value/distance_select;
                    }
              }


          }
        }end_foreach();}delete((scalar*)((vector[]){center_s,nnn_s,{{-1},{-1}}}));
    }


  }

   if (is_constant_m) {
      foreach_stencil(){
        _stencil_val_a(phasel,0,0,0);  
        _stencil_val_a(phaseg,0,0,0);  
      }end_foreach_stencil();
      {
#line 497
foreach(){
        val(phasel,0,0,0) = -38.5;
        val(phaseg,0,0,0) = 0.0;
      }end_foreach();}
   }delete((scalar*)((scalar[]){nnn.x,nnn.y,get_novalue_flag,distanceT,hh2.x,hh2.y,{-1}}));
}






void Tgrad_leon_s(struct Tgradleon q){
  scalar ff5 = q.ff5;
  scalar phaseg = q.phaseg;
  scalar phasel = q.phasel;


    vector  hh2=new_vector("hh2");

    heights(ff5,hh2);

    scalar  distanceT=new_scalar("distanceT");


    foreach_stencil(){
        _stencil_val_a(phaseg,0,0,0);
        _stencil_val_a(phasel,0,0,0);
        _stencil_val_a(distanceT,0,0,0);  
    }end_foreach_stencil();


    {
#line 522
foreach(){
        val(phaseg,0,0,0)=0.0;
        val(phasel,0,0,0)=0.0;
        val(distanceT,0,0,0) = HUGE;
    }end_foreach();}
    double threshold = 0.5;
    int sign1;
    for(int phase=0;phase<=1;phase++){

 sign1=2*phase-1;
        {foreach(){

    if(level==level_interface && ((val(topo_mask_s,0,0,0)==1*sign1) || (val(topo_mask_s,0,0,0)==2*sign1))){
                double colinearity=0.0;
                coord pure;
                pure.x=x,pure.y=y;
                double puretoint=HUGE;
                {foreach_neighbor(2){
                    if(level==level_interface && val(topo_mask_s,0,0,0)==0 && (val(ff5,0,0,0)>1e-6) && ((1.0-val(ff5,0,0,0))>1e-6) && (!(cell.pid < 0))){


                            double colinearity_temp;
                            coord nn = interface_normal7(point,ff5,hh2);
                            double alpha2=line_alpha(val(ff5,0,0,0),nn);;
                            coord rela_areacp,real_areacp;
                            line_length_center(nn,alpha2,&rela_areacp);
       normalize(&nn);
                            real_areacp.x = x + Delta*rela_areacp.x;
                            real_areacp.y = y + Delta*rela_areacp.y;

                            coord mixed;
                            coord deltapure;
                            double leng1;
                            mixed.x=x,mixed.y=y,mixed.z=z;
                            {
                                deltapure.x = pure.x - mixed.x;
                            }
#line 556
{
                                deltapure.y = pure.y - mixed.y;
                            }
                            leng1 = sqrt(sq(deltapure.x)+sq(deltapure.y));
                            if(leng1<0.0001){

                            }
                            colinearity_temp = fabs(nn.x*deltapure.x/leng1+nn.y*deltapure.y/leng1);

                            if(colinearity_temp>colinearity){
                                colinearity = colinearity_temp;



                                    puretoint = fabs(nn.x*(pure.x-real_areacp.x)+nn.y*(pure.y-real_areacp.y));


                            }
                    }
                }end_foreach_neighbor()}

                if(puretoint < (Delta*3.0*sqrt(2.0))){
                 if(puretoint > Delta*0.1){
                  val(distanceT,0,0,0) = puretoint;
                    double temp8 = (val(T,0,0,0)-Tsat00)/val(distanceT,0,0,0);
                    if(phase==0){
                        val(phaseg,0,0,0)=temp8;
                    }else{
                        val(phasel,0,0,0)=-temp8;
                    }
                  }else{
                               printf("puretoint less than 0.1*Delta, puretoint=%g ff=%g globali=%d\n", puretoint,val(ff5,0,0,0),globali);







               }
                }

            }

        }end_foreach();}
    }
        printf("pid=%d, T_leon halfway\n",pid());

  for(int phase=0;phase<=1;phase++){
    sign1 = 2*phase-1;
    {foreach(){
            if(level==level_interface && val(topo_mask_s,0,0,0)==0 && (val(ff5,0,0,0)>1e-6) && ((1.0-val(ff5,0,0,0))>1e-6)){
                coord mixed;
                mixed.x=x,mixed.y=y;
                coord nn=interface_normal7(point,ff5,hh2);;
                normalize(&nn);

                double weight_tot=0.0;
                double val_tot=0.0;
                int num_tot=0;
                {foreach_neighbor(2){

     if(level==level_interface && (!(cell.pid < 0)) && ((val(topo_mask_s,0,0,0)==1*sign1) || (val(topo_mask_s,0,0,0)==2*sign1))){
                        coord pure;
                        pure.x = x, pure.y = y;
                        coord puretomixed;
                        puretomixed.x = pure.x - mixed.x;
                        puretomixed.y = pure.y - mixed.y;

                        double leng1 = sqrt(sq(puretomixed.x)+sq(puretomixed.y));
                        double colinearity;
                        colinearity = fabs(nn.x*puretomixed.x/leng1+nn.y*puretomixed.y/leng1);
                        if(val(distanceT,0,0,0)<(Delta*3.0*sqrt(2.0))){

                            weight_tot += colinearity;
                            if(phase==1){
                                val_tot += val(phasel,0,0,0)*colinearity;
                            }else{
                                val_tot += val(phaseg,0,0,0)*colinearity;
                            }
                            num_tot += 1;

                        }

                    }
                }end_foreach_neighbor()}
                if(num_tot>=1){
                        if(phase==1){
                             if(weight_tot<0.001){
                                printf("weight_tot=%g val_tot=%g phasel=%g\n",weight_tot,val_tot,val(phasel,0,0,0));
                            }
                            val(phasel,0,0,0)=val_tot/weight_tot;

                        }else{
                            if(weight_tot<0.001){
                              printf("weight_tot=%g val_tot=%g phaseg=%g\n",weight_tot,val_tot,val(phaseg,0,0,0));
                            }
                            val(phaseg,0,0,0)=val_tot/weight_tot;

                        }
                }
            }
    }end_foreach();}
  }
      printf("pid=%d, T_leon finish\n",pid());delete((scalar*)((scalar[]){distanceT,hh2.x,hh2.y,{-1}}));
}
#line 395 "././linear2-tree-1-2.h"


#line 1 "././my-tag.h"
#line 1 "./././my-tag.h"
#line 13 "./././my-tag.h"
static void restriction_tag (Point point, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double min = HUGE;
  {foreach_child()
    if (val(t,0,0,0) < min)
      min = val(t,0,0,0);end_foreach_child()}
  val(t,0,0,0) = min;
}







static long lookup_tag (Array * a, double tag)
{
  long len = a->len/sizeof(double);
  double * p = (double *) a->p;
  if (tag == p[0])
    return 0;
  if (tag == p[len - 1])
    return len - 1;

  long s = 0, e = len - 1;
  while (s < e - 1) {
    long m = (s + e)/2;
    if (p[m] <= tag)
      s = m;
    else
      e = m;
  }
  return s;
}


static int compar_double (const void * p1, const void * p2)
{
  const double * a = p1, * b = p2;
  return *a > *b;
}







     
int tag (scalar t)
{tracing("tag","./././my-tag.h",62);




  _attribute[t.i].restriction = restriction_tag;

  _attribute[t.i].refine = _attribute[t.i].prolongation = refine_injection;
  _attribute[t.i].dirty = true;
#line 82 "./././my-tag.h"
  scalar  index=new_scalar("index");
  z_indexing (index, true);
  foreach_stencil()
    {_stencil_val_a(t,0,0,0);_stencil_val(t,0,0,0);_stencil_val(index,0,0,0);      }end_foreach_stencil();
  {
#line 84
foreach()
    val(t,0,0,0) = (val(t,0,0,0) != 0)*(val(index,0,0,0) + 1);end_foreach();}
#line 99 "./././my-tag.h"
  bool changed;
  do {






    restriction (((scalar[]){t,{-1}}));





    changed = false;
    for (int l = 1; l <= grid->maxdepth; l++) {






      {foreach_level(l)
 if (coarse(t,0,0,0))
   val(t,0,0,0) = coarse(t,0,0,0);end_foreach_level();}
      boundary_level (((scalar[]){t,{-1}}), l);







      
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(||:changed)){
#line 132
foreach_level (l)
        if (val(t,0,0,0)) {
   double min = val(t,0,0,0);
   {foreach_neighbor(1)
     if (val(t,0,0,0) && val(t,0,0,0) < min)
       min = val(t,0,0,0);end_foreach_neighbor()}






   
     for (int i = -1; i <= 2; i += 3)
       if ((!is_leaf (neighbor((2*i - 1)/3,0,0)) && neighbor((2*i - 1)/3,0,0).neighbors && neighbor((2*i - 1)/3,0,0).pid >= 0))
  for (int j = 0; j <= 1; j++)
    for (int k = 0; k <= 1; k++)
      if (fine(t,i,j,k) && fine(t,i,j,k) < min)
        min = fine(t,i,j,k);
     
#line 145
for (int i = -1; i <= 2; i += 3)
       if ((!is_leaf (neighbor(0,(2*i - 1)/3,0)) && neighbor(0,(2*i - 1)/3,0).neighbors && neighbor(0,(2*i - 1)/3,0).pid >= 0))
  for (int j = 0; j <= 1; j++)
    for (int k = 0; k <= 1; k++)
      if (fine(t,j,i,k) && fine(t,j,i,k) < min)
        min = fine(t,j,i,k);


   if (val(t,0,0,0) != min) {
     changed = true;
     val(t,0,0,0) = min;
   }
 }end_foreach_level();mpi_all_reduce_array(&changed,bool,MPI_LOR,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
      
#line 158
boundary_level (((scalar[]){t,{-1}}), l);
    }
  } while (changed);
#line 171 "./././my-tag.h"
  Array * a = array_new();
  foreach_stencil ()
    {_stencil_val(t,0,0,0); {        







       _stencil_val(t,0,0,0);   
           
      
     
   
       
  
    
               
          
                






      
  
    
       
         
    





}   }end_foreach_stencil();
  
#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 172
foreach ()
    if (val(t,0,0,0) > 0) {







      double tag = val(t,0,0,0), * ap = (double *) a->p;
      long s = -1;
      if (a->len == 0 || tag > ap[a->len/sizeof(double) - 1])
 s = a->len/sizeof(double);
      else if (tag < ap[0])
 s = 0;
      else {






 s = lookup_tag (a, tag) + 1;
 if (tag == ap[s - 1] || tag == ap[s])
   s = -1;
      }
      if (s >= 0) {





 array_append (a, &tag, sizeof(double)), ap = (double *) a->p;
 for (int i = a->len/sizeof(double) - 1; i > s; i--)
   ap[i] = ap[i-1];
 ap[s] = tag;
      }
    }end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif

#line 222 "./././my-tag.h"
  long lmax = a->len;
  mpi_all_reduce (lmax, MPI_LONG, MPI_MAX);
  a->p = prealloc (a->p, lmax,__func__,__FILE__,__LINE__);
  lmax /= sizeof(double);






  double * q = a->p;
  for (int i = a->len/sizeof(double); i < lmax; i++)
    q[i] = -1;
  double p[lmax*npe()];
  MPI_Allgather (a->p, lmax, MPI_DOUBLE, p, lmax, MPI_DOUBLE, MPI_COMM_WORLD);
  qsort (p, lmax*npe(), sizeof(double), compar_double);







  array_free (a);
  a = array_new();
  double last = -1;
  for (int i = 0; i < lmax*npe(); i++)
    if (p[i] != last) {
      array_append (a, &p[i], sizeof(double));
      last = p[i];
    }






  foreach_stencil()
    {_stencil_val(t,0,0,0);
      {_stencil_val_a(t,0,0,0); _stencil_val(t,0,0,0);     }   }end_foreach_stencil();






  {
#line 259
foreach()
    if (val(t,0,0,0) > 0)
      val(t,0,0,0) = lookup_tag (a, val(t,0,0,0)) + 1;end_foreach();}




  int n = a->len/sizeof(double);
  array_free (a);
  {delete((scalar*)((scalar[]){index,{-1}}));{end_tracing("tag","./././my-tag.h",268);return n;}}delete((scalar*)((scalar[]){index,{-1}}));
end_tracing("tag","./././my-tag.h",269);}
#line 278 "./././my-tag.h"
struct RemoveDroplets {
  scalar f;
  int minsize;
  double threshold;
  bool bubbles;
};

void remove_droplets (struct RemoveDroplets p)
{
  scalar  d=new_scalar("d"), f = p.f;
  double threshold = p.threshold ? p.threshold : 1e-4;
  foreach_stencil()
    {_stencil_val_a(d,0,0,0); _stencil_val(f,0,0,0); _stencil_val(f,0,0,0);        }end_foreach_stencil();
  {
#line 289
foreach()
    val(d,0,0,0) = (p.bubbles ? 1. - val(f,0,0,0) : val(f,0,0,0)) > threshold;end_foreach();}
  int n = tag (d), size[n];
  for (int i = 0; i < n; i++)
    size[i] = 0;
  foreach_stencil ()
    {_stencil_val(d,0,0,0);
      { _stencil_val(d,0,0,0);  }   }end_foreach_stencil();
  
#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 294
foreach ()
    if (val(d,0,0,0) > 0)
      size[((int) val(d,0,0,0)) - 1]++;end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif


  
#line 298
MPI_Allreduce (MPI_IN_PLACE, size, n, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  int minsize = pow (p.minsize ? p.minsize : 3, 2);
  foreach_stencil()
    {_stencil_val(d,0,0,0); _stencil_val(d,0,0,0);
      {_stencil_val_a(f,0,0,0);  }         }end_foreach_stencil();
  {
#line 301
foreach()
    if (val(d,0,0,0) > 0 && size[((int) val(d,0,0,0)) - 1] < minsize)
      val(f,0,0,0) = p.bubbles;end_foreach();}delete((scalar*)((scalar[]){d,{-1}}));
}
#line 398 "././linear2-tree-1-2.h"

void mass_transfer_rate(){


   source_total= 0.0;
   total_area=0.0;



     Tgrad_leon((struct Tgradleon){ff,phase0Tgrad,phase1Tgrad,aiml,aimg});
#line 452 "././linear2-tree-1-2.h"
  scalar  d_tag=new_scalar("d_tag");
  double threshold = 1e-10;
  foreach_stencil()
    {_stencil_val_a(d_tag,0,0,0);_stencil_val(topo_mask_s,0,0,0); _stencil_val(topo_mask,0,0,0);_stencil_val(ff,0,0,0);      }end_foreach_stencil();
  {
#line 454
foreach()
    val(d_tag,0,0,0) = (val(topo_mask_s,0,0,0)==0 && val(topo_mask,0,0,0)==0)? (val(ff,0,0,0) > threshold):0;end_foreach();}
  int n_tag = tag (d_tag), size[n_tag];
   double total_source[n_tag];
 double area_source[n_tag];
  for (int i = 0; i < n_tag; i++){
    size[i] = 0;
    total_source[i]=0.0;
    area_source[i] = 0.0;
  }
  foreach_stencil ()
    {_stencil_val(d_tag,0,0,0);
      { _stencil_val(d_tag,0,0,0);  }   }end_foreach_stencil();
  
#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 464
foreach ()
    if (val(d_tag,0,0,0) > 0)
      size[((int) val(d_tag,0,0,0)) - 1]++;end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif


  
#line 468
MPI_Allreduce (MPI_IN_PLACE, size, n_tag, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
#line 478 "././linear2-tree-1-2.h"
   foreach_stencil(
){
         _stencil_val_a(masstr,0,0,0);
         _stencil_val_a(source_pc,0,0,0);



_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{{
            _stencil_val_a(masstr,0,0,0);_stencil_val(phase0Tgrad,0,0,0);_stencil_val(phase1Tgrad,0,0,0);    

  }{
       _stencil_val_a(masstr,0,0,0);
  }}        



   

       
        
#line 495
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); {  
        _stencil_mycs (point, ff);     

       _stencil_val(ff,0,0,0); 
                  

     }

             


                 
#line 504
_stencil_val_a(source_pc,0,0,0); _stencil_val(masstr,0,0,0);   

                  _stencil_val_a(source_pc2,0,0,0); _stencil_val(source_pc,0,0,0); 
                     



_stencil_val(source_pc2,0,0,0); 



          
#line 512
_stencil_val(d_tag,0,0,0);{
_stencil_val(d_tag,0,0,0); _stencil_val(source_pc2,0,0,0);
          
        
#line 514
}

_stencil_val(cs,0,0,0);{
_stencil_val(d_tag,0,0,0);{ 
               
_stencil_val(d_tag,0,0,0);
            
          
#line 520
}
          
        
#line 521
}
        

        


   
#line 524
}end_foreach_stencil();
#line 478 "././linear2-tree-1-2.h"
   
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel 
   reduction(+:area_source[:n_tag]) reduction(+:total_source[:n_tag]) reduction(+:total_area)reduction(+:source_total)){
#line 478
foreach(
){
         val(masstr,0,0,0)=0.0;
         val(source_pc,0,0,0) = 0.0;



  if(val(ff,0,0,0)<1.0-0.0000000001 && val(ff,0,0,0)>0.0000000001){
            val(masstr,0,0,0) = Tkg/hfg*val(phase0Tgrad,0,0,0) - Tkl/hfg*val(phase1Tgrad,0,0,0);

  }else{
       val(masstr,0,0,0)=0.0;
  }

       double area = 0.;
        coord pp = {0.,0.};

     if (val(ff,0,0,0) > 0.0000000001 && val(ff,0,0,0) < 1. - 0.0000000001) {
       coord n = mycs (point, ff);

       double alpha = line_alpha (val(ff,0,0,0), n);
               area = line_length_center(n, alpha, &pp);

     }


                 val(source_pc,0,0,0) = val(masstr,0,0,0)*(1.0/Trhog - 1.0/Trhol)*area/Delta;

                  val(source_pc2,0,0,0) = val(source_pc,0,0,0)*max(1e-20,(y+pp.y*Delta));
                  area = area*max(1e-20,(y+pp.y*Delta));



        source_total = source_total + val(source_pc2,0,0,0);
        if(val(d_tag,0,0,0)>0){
          total_source[((int)val(d_tag,0,0,0))-1]+= val(source_pc2,0,0,0);
        }

        if(val(cs,0,0,0)>0.0){
          if(val(d_tag,0,0,0)>0){
            total_area = total_area + area;
            area_source[((int)val(d_tag,0,0,0))-1]+=area;
          }
        }


   }end_foreach();mpi_all_reduce_array(area_source,double,MPI_SUM,n_tag);mpi_all_reduce_array(total_source,double,MPI_SUM,n_tag);mpi_all_reduce_array(&total_area,double,MPI_SUM,1);mpi_all_reduce_array(&source_total,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}


    
#line 527
if(flag_average_source){
        foreach_stencil(){
_stencil_val(cs,0,0,0);{{
_stencil_val(d_tag,0,0,0);{    
                    
                    
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); {  
                         _stencil_mycs (point, ff);     

                        _stencil_val(ff,0,0,0); 
                                 

                      }
                            


                                  



                        
#line 546
_stencil_val_a(source_pc2,0,0,0);_stencil_val(d_tag,0,0,0);_stencil_val(d_tag,0,0,0);  

                        _stencil_val_a(masstr,0,0,0);_stencil_val(source_pc2,0,0,0);  
                  }
                
            
#line 550
}{
              _stencil_val_a(source_pc2,0,0,0);  
            }}
            
        
#line 553
}end_foreach_stencil();
        {
#line 528
foreach(){
            if(val(cs,0,0,0)>0.0){
                if(val(d_tag,0,0,0)>0){
                    double area=0.0;
                    coord pp = {0.,0.};
                    if (val(ff,0,0,0) > 0.0000000001 && val(ff,0,0,0) < 1. - 0.0000000001) {
                        coord n = mycs (point, ff);

                        double alpha = line_alpha (val(ff,0,0,0), n);
                              area = line_length_center(n, alpha, &pp);

                      }


                                area = area*max(1e-20,(y+pp.y*Delta));



                        val(source_pc2,0,0,0) = total_source[((int)val(d_tag,0,0,0))-1]*area/area_source[((int)val(d_tag,0,0,0))-1];

                        val(masstr,0,0,0)=val(source_pc2,0,0,0)/((1.0/Trhog - 1.0/Trhol)*area/Delta);
                  }
            }else{
              val(source_pc2,0,0,0) = 0.0;
            }
        }end_foreach();}
    }
#line 605 "././linear2-tree-1-2.h"
     foreach_stencil(){
         _stencil_val_a(vtr,0,0,0);
_stencil_val(masstr,0,0,0);{
            _stencil_val_a(vtr,0,0,0);_stencil_val(masstr,0,0,0);
         }
         
     
#line 610
}end_foreach_stencil();
#line 605 "././linear2-tree-1-2.h"
     {foreach(){
         val(vtr,0,0,0)=0.0;
         if(fabs(val(masstr,0,0,0))>0.0){
            val(vtr,0,0,0)=val(masstr,0,0,0)/Trhol;
         }
     }end_foreach();}delete((scalar*)((scalar[]){d_tag,{-1}}));



}



void LevelSetShift2VOFChange(double dt){

     scalar  overshoot=new_scalar("overshoot");
     foreach_stencil(){
          _stencil_val_a(deltac,0,0,0);  
     }end_foreach_stencil();
     {
#line 621
foreach(){
          val(deltac,0,0,0) = 0.0;
     }end_foreach();}
int flag_overshoot=0;
     foreach_stencil(){
              _stencil_val_a(overshoot,0,0,0);

_stencil_val(ff,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);{ 
               _stencil_mycs (point, ff);     
             _stencil_val(ff,0,0,0);      
              
              
               _stencil_val(masstr,0,0,0);    


       
              

{{ 
                  
                 _stencil_val_a(overshoot,0,0,0);      
                 _stencil_val_a(deltac,0,0,0); _stencil_val(deltac,0,0,0); _stencil_val(ff,0,0,0);    
              }{{  
                 
                 _stencil_val_a(overshoot,0,0,0);      
                 _stencil_val_a(deltac,0,0,0); _stencil_val(deltac,0,0,0); _stencil_val(ff,0,0,0);  
              }{     
                   
                 
                 _stencil_val_a(deltac,0,0,0); _stencil_val(deltac,0,0,0); _stencil_val(ff,0,0,0);    
              }}}

                       






           
#line 658
}

          
     
#line 659
}end_foreach_stencil();
     
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:flag_overshoot)){
#line 625
foreach(){
              val(overshoot,0,0,0)=0.0;

      if(val(ff,0,0,0)>1e-6 && (val(ff,0,0,0)<1-1e-6) && (val(css_test3_n,0,0,0)>0.0)){
              coord n= mycs (point, ff);
             double alpha_old = line_alpha (val(ff,0,0,0), n);
              double magn=sqrt(n.x*n.x + n.y*n.y);
              double magn1=fabs(n.x)+fabs(n.y);
              double nshift = val(masstr,0,0,0)*dt/Trhol/Delta;


       double dalpha=-nshift*magn;
              double alpha_new = alpha_old;

              if(alpha_old + dalpha > 0.5){
                 alpha_new = 0.5;
                 val(overshoot,0,0,0) = alpha_old + dalpha - 0.5;
                 val(deltac,0,0,0) = val(deltac,0,0,0) + (1.0 - val(ff,0,0,0));
              }else if(alpha_old + dalpha < -0.5){
                alpha_new = - 0.5;
                 val(overshoot,0,0,0) = alpha_old + dalpha - (-0.5);
                 val(deltac,0,0,0) = val(deltac,0,0,0) - val(ff,0,0,0);
              }else{
               alpha_new = alpha_old + dalpha;
                 double ffnew = line_area(n.x, n.y, alpha_new);
                 val(deltac,0,0,0) = val(deltac,0,0,0) + (ffnew - val(ff,0,0,0));
              }






           }
     }end_foreach();mpi_all_reduce_array(&flag_overshoot,int,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}




     
#line 664
if(flag_overshoot == 1){
          fprintf(ferr,"overshoot*magn >= 0.1 \n");
          exit(1);
      }


     scalar  intmask=new_scalar("intmask");
     foreach_stencil(){
       _stencil_val_a(intmask,0,0,0);
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
          _stencil_val_a(intmask,0,0,0);  
        }  
         
     
#line 676
}end_foreach_stencil();
     {
#line 671
foreach(){
       val(intmask,0,0,0) = 3;
        if(val(ff,0,0,0)<1.0-0.0000000001 && val(ff,0,0,0)>0.0000000001){
          val(intmask,0,0,0) = 0;
        }
     }end_foreach();}
     foreach_stencil(){  
       
        {
_stencil_val(intmask,1,0,0);_stencil_val(intmask,-1,0,0); 
                 
           
           
        
#line 683
}
#line 679
{
_stencil_val(intmask,0,1,0);_stencil_val(intmask,0,-1,0); 
                 
           
           
        
#line 683
} 
_stencil_val(intmask,0,0,0);{
           _stencil_val_a(intmask,0,0,0); _stencil_val(ff,0,0,0);      
        }
          

     
#line 688
}end_foreach_stencil();
     {
#line 677
foreach(){
       bool is1= false;
        {
       if(((val(intmask,1,0,0)==0) || (val(intmask,-1,0,0)==0)) && level==level_interface){
                is1 = true;
           }
        }
#line 679
{
       if(((val(intmask,0,1,0)==0) || (val(intmask,0,-1,0)==0)) && level==level_interface){
                is1 = true;
           }
        }
        if (is1 && val(intmask,0,0,0)!=0){
           val(intmask,0,0,0) = val(ff,0,0,0)>0.5-0.0000000001 ? 1 : -1 ;
        }

     }end_foreach();}
#line 704 "././linear2-tree-1-2.h"
     double normal_limit;

   normal_limit = 1e-3;
#line 715 "././linear2-tree-1-2.h"
     vector  position2=new_vector("position2");
     scalar  deltac_temp=new_scalar("deltac_temp");
#line 725 "././linear2-tree-1-2.h"
     foreach_stencil(){

        _stencil_val_a(deltac_temp,0,0,0);
{
        _stencil_val_a(position2.x,0,0,0);
        _stencil_val_a(position2.y,0,0,0);



_stencil_val(overshoot,0,0,0);_stencil_val(css_test3_n,0,0,0);{   

              


               _stencil_mycs (point, ff); 
#line 757 "././linear2-tree-1-2.h"
              
{
_stencil_val(overshoot,0,0,0);
                      
                   
                     
                  
                
               
#line 764
}
{
_stencil_val(overshoot,0,0,0);
                          
                   
                         
                  
                  
               
#line 771
}
#line 787
_stencil_neighbor(o_stencil,o_stencil,0);_stencil_val(css_test3_n,0,0,0);{

_stencil_val(intmask,o_stencil,o_stencil,0);{     

                   _stencil_val(ff,o_stencil,o_stencil,0);    

                    _stencil_val(overshoot,0,0,0);

{{

_stencil_val(ff,0,0,0);     

                        


                         
                        
                        
#line 835 "././linear2-tree-1-2.h"
                   }{

_stencil_val(ff,0,0,0);      

                        


                         

                        
                        
#line 873 "././linear2-tree-1-2.h"
                   }}     

                      


             

              
#line 878
_stencil_val_a(deltac_temp,0,0,0); _stencil_val(ff,o_stencil,o_stencil,0);   
              _stencil_val_a(position2.x,0,0,0);
              _stencil_val_a(position2.y,0,0,0);

            }

                 

           
#line 884
}  
              
              







                
                   
               





         
        
#line 885
}



     
       
#line 886
}  
        
     
#line 887
}end_foreach_stencil();
#line 725 "././linear2-tree-1-2.h"
     {foreach(){

        val(deltac_temp,0,0,0) = 0.0;
        if(level==level_interface){
        val(position2.x,0,0,0)=0;
        val(position2.y,0,0,0)=0;



   if(fabs(val(overshoot,0,0,0))>0.0 && (val(css_test3_n,0,0,0)>0.0)){

              coord accept_possition;


              coord n = mycs (point, ff);
#line 757 "././linear2-tree-1-2.h"
              int xx=0,yy=0;
              if(fabs(n.x)>normal_limit){
                if(val(overshoot,0,0,0)>0.0){
                    xx = sign(n.x);
                  }else{
                    xx = -sign(n.x);
                  }
               }
              if(fabs(n.y)>normal_limit){
                  if(val(overshoot,0,0,0)>0.0){
                        yy = sign(n.y);
                  }else{
                        yy = -sign(n.y);
                  }
               }







              if(xx==0 && yy==0){
                   fprintf (ferr, "WARNING: xx=0 && yy=0 && zz==0\n");
               }





     if(!(neighbor(xx,yy,0).pid < 0) && (val(css_test3_n,0,0,0))>0.0){

                 if(fabs(val(intmask,xx,yy,0)-3.0)>0.5){

                   double alpha_old = line_alpha (val(ff,xx,yy,0), n);

                   double alpha_new = (alpha_old + val(overshoot,0,0,0));

                   if(alpha_new>0.5){

                        fprintf (ferr, "WARNING: Overfilling a cell already accommodating overfilling t=%g alp_new=%g ff=%g \n",t,alpha_new,val(ff,0,0,0));


                        alpha_new = 0.5;
                        int flag3=0;
                        double shoot_cut=1e-12;
#line 835 "././linear2-tree-1-2.h"
                   }else if(alpha_new < -0.5){

                        fprintf (ferr, "WARNING: Draining a cell already accommodating overdrainage! t=%g alp_new=%g ff=%g \n", t,alpha_new,val(ff,0,0,0));


                        alpha_new = -0.5;

                        int flag3=0;
                        double shoot_cut=1e-12;
#line 873 "././linear2-tree-1-2.h"
                   }


             double ffnew = line_area(n.x, n.y, alpha_new);

              val(deltac_temp,0,0,0) = ffnew - val(ff,xx,yy,0);
              val(position2.x,0,0,0)=xx;
              val(position2.y,0,0,0)=yy;

            }

           }
        }
       }
     }end_foreach();}






scalar  flagi=new_scalar("flagi");
foreach_stencil(){
   _stencil_val_a(flagi,0,0,0);
}end_foreach_stencil();
{
#line 895
foreach(){
   val(flagi,0,0,0)=0;
}end_foreach();}
foreach_stencil(){

_stencil_val(intmask,0,0,0); _stencil_val(css_test3_n,0,0,0);{
    for(int i0=-1; i0<=1; i0=i0+1){
       for(int j0=-1; j0<=1; j0=j0+1){


                  if(!(i0==0 && j0==0) ){
_stencil_val(deltac_temp,i0,j0,0);{ 
                                _stencil_val(position2.x,i0,j0,0); 
                                _stencil_val(position2.y,i0,j0,0);
_stencil_val(css_test3_n,i0,j0,0); {
                                      _stencil_val_a(deltac,0,0,0); _stencil_val(deltac,0,0,0); _stencil_val(deltac_temp,i0,j0,0);  

                                              _stencil_val_a(flagi,0,0,0); _stencil_val(flagi,0,0,0);   

                                }
                                    
                      
#line 915
}
                      
                 
#line 916
}

       }
    }
  }

    

#line 921
}end_foreach_stencil();
{
#line 898
foreach(){

   if(fabs(val(intmask,0,0,0)-3.0)>0.5 && val(css_test3_n,0,0,0)>0.0){
    for(int i0=-1; i0<=1; i0=i0+1){
       for(int j0=-1; j0<=1; j0=j0+1){


                  if(!(i0==0 && j0==0) ){
                      if(fabs(val(deltac_temp,i0,j0,0))>0.0){
                                int i1=-round(val(position2.x,i0,j0,0));
                                int j1=-round(val(position2.y,i0,j0,0));
                                if(i0==i1 && j0==j1 && (val(css_test3_n,i0,j0,0)>0.0)) {
                                      val(deltac,0,0,0) = val(deltac,0,0,0) + val(deltac_temp,i0,j0,0);

                                              val(flagi,0,0,0) = val(flagi,0,0,0) + 1;

                                }
                      }
                 }

       }
    }
  }
}end_foreach();}delete((scalar*)((scalar[]){flagi,deltac_temp,position2.x,position2.y,intmask,overshoot,{-1}}));


}


void mov_interface_dc(bool flag_topos_uf,bool flag_cant_smaller_than_half,double base, double over_half){

double small_fraction_limit_T = 1e-12;
#line 942 "././linear2-tree-1-2.h"
scalar  f_old=new_scalar("f_old");
foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
          _stencil_val_a(T_solid,0,0,0);_stencil_val(T,0,0,0);
      }
      
   
#line 947
}end_foreach_stencil();
{
#line 943
foreach(){
      if(val(css_test3_n,0,0,0)<1.0){
          val(T_solid,0,0,0)=val(T,0,0,0);
      }
   }end_foreach();}



foreach_stencil(){

        _stencil_val_a(f_old,0,0,0); _stencil_val(ff,0,0,0); 
        if(!flag_topos_uf){
            _stencil_val_a(ff,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(deltac,0,0,0);  
        }else{
_stencil_val(topo_mask_s,0,0,0); _stencil_val(intersect_true,0,0,0);{

              _stencil_val_a(ff,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(deltac,0,0,0);  
            }
             
        
#line 961
}


   }end_foreach_stencil();



{
#line 951
foreach(){

        val(f_old,0,0,0) = val(ff,0,0,0);
        if(!flag_topos_uf){
            val(ff,0,0,0) = val(ff,0,0,0) + val(deltac,0,0,0);
        }else{
            if(!(val(topo_mask_s,0,0,0)==0 && val(intersect_true,0,0,0)==0)){

              val(ff,0,0,0) = val(ff,0,0,0) + val(deltac,0,0,0);
            }
        }


   }end_foreach();}

if(flag_cant_smaller_than_half){
  double total_dc_add=0.0;
  int total_dc_number=0;
  int number_interface=0;
  double y_interface_triple=0.0;
  foreach_stencil(
){
_stencil_val(topo_mask_s,0,0,0);{ 
      

      {foreach_neighbor(2){
_stencil_val(intersect_true,0,0,0);
                      
          
          
      
#line 980
}end_foreach_neighbor()}
_stencil_val(f_old,0,0,0); _stencil_val(f_old,0,0,0);{

_stencil_val(ff,0,0,0); _stencil_val(deltac,0,0,0);{ 
_stencil_val(deltac,0,0,0);  
                  
                  
                  
#line 986
_stencil_val_a(ff,0,0,0); _stencil_val(f_old,0,0,0); 
            }

             
        
#line 988
}
           
    
#line 989
}
_stencil_val(intersect_true,0,0,0);
        
        
    
    
    
  
#line 994
}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:total_dc_number)
   reduction(+:y_interface_triple) reduction(+:number_interface)reduction(+:total_dc_add)){
#line 971
foreach(
){
    if(val(topo_mask_s,0,0,0)==0){
      bool flag=false;

      {foreach_neighbor(2){
          if(val(intersect_true,0,0,0)==1){
                      flag=true;
          }
      }end_foreach_neighbor()}
        if(val(f_old,0,0,0)<1.0 && val(f_old,0,0,0)>0.0 && (!flag)){

            if((val(ff,0,0,0)<base+over_half) && val(deltac,0,0,0)<0.0){
                  total_dc_add += val(deltac,0,0,0)*y;
                  total_dc_number +=1;
                  val(ff,0,0,0) = val(f_old,0,0,0);
            }
        }
    }
    if(val(intersect_true,0,0,0)==1){
        number_interface+=1;
        y_interface_triple+=y;
    }
  }end_foreach();mpi_all_reduce_array(&total_dc_number,int,MPI_SUM,1);mpi_all_reduce_array(&y_interface_triple,double,MPI_SUM,1);mpi_all_reduce_array(&number_interface,int,MPI_SUM,1);mpi_all_reduce_array(&total_dc_add,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}

  
#line 996
if(total_dc_number>=1 && number_interface>=1){
    foreach_stencil(){
_stencil_val(intersect_true,0,0,0);{

            _stencil_val_a(ff,0,0,0); _stencil_val(f_old,0,0,0);   
        }
        
    
#line 1002
}end_foreach_stencil();
    {
#line 997
foreach(){
        if(val(intersect_true,0,0,0)==1){

            val(ff,0,0,0) = val(f_old,0,0,0) + y/y_interface_triple*total_dc_add/y;
        }
    }end_foreach();}
  }
}

{scalar*_i=(scalar*) ((scalar[]){T,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
      foreach_stencil(){   
           
           
           
        if(energy_advecting_flag){
_stencil_val(css_test3_n,0,0,0);{
#line 1027
_stencil_val(ff,0,0,0); _stencil_val(f_old,0,0,0);{{
_stencil_val(ff,0,0,0); 
                            _stencil_val(ff,0,0,0); 
                           _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0);
                           _stencil_val(ff,0,0,0);
                            
                    
#line 1032
} {_stencil_val(ff,0,0,0);_stencil_val(f_old,0,0,0);{{
_stencil_val(ff,0,0,0);
                            _stencil_val(ff,0,0,0);
                             _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0);
                            _stencil_val(ff,0,0,0);
                           
                    
#line 1037
}{ 
_stencil_val(s,0,0,0);
                         
                          
                    
#line 1040
}}      }} 
#line 1027 "././linear2-tree-1-2.h"
                          
                     
           
#line 1042
}
_stencil_val(css_test3_n,0,0,0);{{
                _stencil_val_a(s,0,0,0);_stencil_val(css_test3_n,0,0,0); _stencil_val(T_solid,0,0,0);_stencil_val(css_test3_n,0,0,0);   
            }{
                _stencil_val_a(s,0,0,0);  
            }}
           
           
      
#line 1048
}else{
_stencil_val(css_test3_n,0,0,0);{
_stencil_val(ff,0,0,0); _stencil_val(f_old,0,0,0);{{
_stencil_val(ff,0,0,0);
                           _stencil_val(ff,0,0,0);
                           

                    
#line 1054
} {_stencil_val(ff,0,0,0);_stencil_val(f_old,0,0,0);{{
_stencil_val(ff,0,0,0);
                            _stencil_val(ff,0,0,0);
                            
                    
#line 1057
}{ 
_stencil_val(s,0,0,0);
                         
                          
                    
#line 1060
}}      }}
                          
                      
           
#line 1062
}
        





     
#line 1068
}
    }end_foreach_stencil();
      {
#line 1007
foreach(){
           double val_tot=0.0;
           double wei=0.0;
           double val1=0.0;
        if(energy_advecting_flag){
           if(val(css_test3_n,0,0,0)>0.0){
#line 1027 "././linear2-tree-1-2.h"
                    if(val(ff,0,0,0) > 0.5 && val(f_old,0,0,0) <= 0.5 ){
                        val_tot = val_tot + Tsat00*val(ff,0,0,0);
                        wei = wei + val(ff,0,0,0);
                        val_tot = val_tot + val(T,0,0,0)*(1.0-val(ff,0,0,0));
                        wei = wei + (1.0-val(ff,0,0,0));
                    }else if(1.0-val(ff,0,0,0) > 0.5 && 1.0-val(f_old,0,0,0) <= 0.5){
                        val_tot = val_tot + Tsat00*(1.0-val(ff,0,0,0));
                        wei = wei + (1.0-val(ff,0,0,0));
                        val_tot = val_tot + val(T,0,0,0)*val(ff,0,0,0);
                        wei = wei + val(ff,0,0,0);
                    }else{
                        val_tot = val(s,0,0,0);
                        wei = 1.0;
                    }
                    val1 = val_tot/wei;
           }
           if(val(css_test3_n,0,0,0)<1.0){
                val(s,0,0,0) = val1*val(css_test3_n,0,0,0) + val(T_solid,0,0,0)*(1.0-val(css_test3_n,0,0,0));
            }else{
                val(s,0,0,0) = val1;
            }
      }else{
        if(val(css_test3_n,0,0,0)>0.5){
                    if(val(ff,0,0,0) >= 0.5 && val(f_old,0,0,0) < 0.5 ){
                        val_tot = Tsat00*val(ff,0,0,0);
                        wei = wei + val(ff,0,0,0);

                    }else if(1.0-val(ff,0,0,0) > 0.5 && 1.0-val(f_old,0,0,0) <= 0.5){
                        val_tot = val_tot + Tsat00*(1.0-val(ff,0,0,0));
                        wei = wei + (1.0-val(ff,0,0,0));
                    }else{
                        val_tot = val(s,0,0,0);
                        wei = 1.0;
                    }
                    val1 = val_tot/wei;
           }





     }
    }end_foreach();}

}}}
boundary_internal ((scalar *)((scalar[]){T,{-1}}), "././linear2-tree-1-2.h", 1072);delete((scalar*)((scalar[]){f_old,{-1}}));
#line 1084 "././linear2-tree-1-2.h"
}


void ulf_ugf_function(scalar topo_mask, scalar topo_mask_g){
    vector  facemask=new_face_vector("facemask");
    foreach_face_stencil(){_stencil_is_face_x(){{
        _stencil_val_a(facemask.x,0,0,0);



_stencil_neighbor(-1,0,0);{

             _stencil_val_a(facemask.x,0,0,0);
        }



              
     
#line 1098
}}end__stencil_is_face_x()
#line 1089
_stencil_is_face_y(){{
        _stencil_val_a(facemask.y,0,0,0);



_stencil_neighbor(-1,0,0);{

             _stencil_val_a(facemask.y,0,0,0);
        }



              
     
#line 1098
}}end__stencil_is_face_y()}end_foreach_face_stencil();
    {
#line 1089
foreach_face_generic(){is_face_x(){{
        val(facemask.x,0,0,0)=1;



        if((cell.pid < 0) || (neighbor(-1,0,0).pid < 0)){

             val(facemask.x,0,0,0)=1;
        }
     }}end_is_face_x()
#line 1089
is_face_y(){{
        val(facemask.y,0,0,0)=1;



        if((cell.pid < 0) || (neighbor(0,-1,0).pid < 0)){

             val(facemask.y,0,0,0)=1;
        }
     }}end_is_face_y()}end_foreach_face_generic();}

     foreach_face_stencil(){_stencil_is_face_x(){{
        _stencil_val_a(ulf.x,0,0,0);  
         _stencil_val_a(ugf.x,0,0,0);  
     }}end__stencil_is_face_x()
#line 1100
_stencil_is_face_y(){{
        _stencil_val_a(ulf.y,0,0,0);  
         _stencil_val_a(ugf.y,0,0,0);  
     }}end__stencil_is_face_y()}end_foreach_face_stencil();

     {
#line 1100
foreach_face_generic(){is_face_x(){{
        val(ulf.x,0,0,0) = 0.0;
         val(ugf.x,0,0,0) = 0.0;
     }}end_is_face_x()
#line 1100
is_face_y(){{
        val(ulf.y,0,0,0) = 0.0;
         val(ugf.y,0,0,0) = 0.0;
     }}end_is_face_y()}end_foreach_face_generic();}





     foreach_face_stencil(){_stencil_is_face_x(){{


{{  
              
#line 1124 "././linear2-tree-1-2.h"
                    if(flag_topos_advect_uf){
_stencil_val(topo_mask_s,0,0,0); _stencil_val(topo_mask_s,-1,0,0);{{
                            _stencil_val_a(ulf.x,0,0,0); _stencil_val(uf.x,0,0,0); 
                        }{
                            _stencil_val_a(ulf.x,0,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(usf.x,0,0,0);  
                        }}
                         

                    
#line 1131
}else{
                        _stencil_val_a(ulf.x,0,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(usf.x,0,0,0);  
                    }




          }{

               _stencil_val_a(ulf.x,0,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(usf.x,0,0,0);  
          }}


           
_stencil_val(fs.x,0,0,0);{
             _stencil_val_a(ulf.x,0,0,0);  
             _stencil_val_a(usf.x,0,0,0);  
             _stencil_val_a(uf.x,0,0,0);  
         }



         

     
#line 1151
}}end__stencil_is_face_x()
#line 1109
_stencil_is_face_y(){{


{{  
              
#line 1124 "././linear2-tree-1-2.h"
                    if(flag_topos_advect_uf){
_stencil_val(topo_mask_s,0,0,0); _stencil_val(topo_mask_s,0,-1,0);{{
                            _stencil_val_a(ulf.y,0,0,0); _stencil_val(uf.y,0,0,0); 
                        }{
                            _stencil_val_a(ulf.y,0,0,0); _stencil_val(uf.y,0,0,0); _stencil_val(usf.y,0,0,0);  
                        }}
                         

                    
#line 1131
}else{
                        _stencil_val_a(ulf.y,0,0,0); _stencil_val(uf.y,0,0,0); _stencil_val(usf.y,0,0,0);  
                    }




          }{

               _stencil_val_a(ulf.y,0,0,0); _stencil_val(uf.y,0,0,0); _stencil_val(usf.y,0,0,0);  
          }}


           
_stencil_val(fs.y,0,0,0);{
             _stencil_val_a(ulf.y,0,0,0);  
             _stencil_val_a(usf.y,0,0,0);  
             _stencil_val_a(uf.y,0,0,0);  
         }



         

     
#line 1151
}}end__stencil_is_face_y()}end_foreach_face_stencil();





     {
#line 1109
foreach_face_generic(){is_face_x(){{


          if (level==level_interface){
              int correct1 =0;
#line 1124 "././linear2-tree-1-2.h"
                    if(flag_topos_advect_uf){
                        if(val(topo_mask_s,0,0,0)==0 || val(topo_mask_s,-1,0,0)==0){
                            val(ulf.x,0,0,0) = val(uf.x,0,0,0);
                        }else{
                            val(ulf.x,0,0,0) = val(uf.x,0,0,0) + val(usf.x,0,0,0);
                        }

                    }else{
                        val(ulf.x,0,0,0) = val(uf.x,0,0,0) + val(usf.x,0,0,0);
                    }




          }else{

               val(ulf.x,0,0,0) = val(uf.x,0,0,0) + val(usf.x,0,0,0);
          }



         if(fabs(val(fs.x,0,0,0))<=0){
             val(ulf.x,0,0,0) = 0.0;
             val(usf.x,0,0,0) = 0.0;
             val(uf.x,0,0,0) = 0.;
         }

     }}end_is_face_x()
#line 1109
is_face_y(){{


          if (level==level_interface){
              int correct1 =0;
#line 1124 "././linear2-tree-1-2.h"
                    if(flag_topos_advect_uf){
                        if(val(topo_mask_s,0,0,0)==0 || val(topo_mask_s,0,-1,0)==0){
                            val(ulf.y,0,0,0) = val(uf.y,0,0,0);
                        }else{
                            val(ulf.y,0,0,0) = val(uf.y,0,0,0) + val(usf.y,0,0,0);
                        }

                    }else{
                        val(ulf.y,0,0,0) = val(uf.y,0,0,0) + val(usf.y,0,0,0);
                    }




          }else{

               val(ulf.y,0,0,0) = val(uf.y,0,0,0) + val(usf.y,0,0,0);
          }



         if(fabs(val(fs.y,0,0,0))<=0){
             val(ulf.y,0,0,0) = 0.0;
             val(usf.y,0,0,0) = 0.0;
             val(uf.y,0,0,0) = 0.;
         }

     }}end_is_face_y()}end_foreach_face_generic();}



    foreach_face_stencil(){_stencil_is_face_x(){{

_stencil_val(facemask.x,0,0,0);{
{{  
              
_stencil_val(topo_mask_g,-1,0,0); _stencil_val(topo_mask_g,0,0,0);_stencil_val(topo_mask_g,0,0,0); _stencil_val(topo_mask_g,-1,0,0);{{

                      _stencil_val_a(ugf.x,0,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(usfg.x,0,0,0);  
                }{
                      _stencil_val_a(ugf.x,0,0,0); _stencil_val(uf.x,0,0,0); 
                }}
                   
          
#line 1166
}{
              _stencil_val_a(ugf.x,0,0,0); _stencil_val(uf.x,0,0,0); 
          }}
           

        
#line 1170
}

_stencil_val(fs.x,0,0,0);{
            _stencil_val_a(ugf.x,0,0,0);  
            _stencil_val_a(usfg.x,0,0,0);  
            _stencil_val_a(uf.x,0,0,0);  
        }

       

        



     
#line 1180
}}end__stencil_is_face_x()
#line 1155
_stencil_is_face_y(){{

_stencil_val(facemask.y,0,0,0);{
{{  
              
_stencil_val(topo_mask_g,0,-1,0); _stencil_val(topo_mask_g,0,0,0);_stencil_val(topo_mask_g,0,0,0); _stencil_val(topo_mask_g,0,-1,0);{{

                      _stencil_val_a(ugf.y,0,0,0); _stencil_val(uf.y,0,0,0); _stencil_val(usfg.y,0,0,0);  
                }{
                      _stencil_val_a(ugf.y,0,0,0); _stencil_val(uf.y,0,0,0); 
                }}
                   
          
#line 1166
}{
              _stencil_val_a(ugf.y,0,0,0); _stencil_val(uf.y,0,0,0); 
          }}
           

        
#line 1170
}

_stencil_val(fs.y,0,0,0);{
            _stencil_val_a(ugf.y,0,0,0);  
            _stencil_val_a(usfg.y,0,0,0);  
            _stencil_val_a(uf.y,0,0,0);  
        }

       

        



     
#line 1180
}}end__stencil_is_face_y()}end_foreach_face_stencil();



    {
#line 1155
foreach_face_generic(){is_face_x(){{

       if(val(facemask.x,0,0,0)==1){
          if (level==level_interface){
              int correct1 =0;
              if((val(topo_mask_g,-1,0,0)<1 && val(topo_mask_g,0,0,0)<1) && (val(topo_mask_g,0,0,0)==0 || val(topo_mask_g,-1,0,0)==0) ){

                      val(ugf.x,0,0,0) = val(uf.x,0,0,0) + val(usfg.x,0,0,0);
                }else{
                      val(ugf.x,0,0,0) = val(uf.x,0,0,0);
                }
          }else{
              val(ugf.x,0,0,0) = val(uf.x,0,0,0);
          }

        }

        if(fabs(val(fs.x,0,0,0))<=0){
            val(ugf.x,0,0,0) = 0.0;
            val(usfg.x,0,0,0) = 0.0;
            val(uf.x,0,0,0) = 0.;
        }



     }}end_is_face_x()
#line 1155
is_face_y(){{

       if(val(facemask.y,0,0,0)==1){
          if (level==level_interface){
              int correct1 =0;
              if((val(topo_mask_g,0,-1,0)<1 && val(topo_mask_g,0,0,0)<1) && (val(topo_mask_g,0,0,0)==0 || val(topo_mask_g,0,-1,0)==0) ){

                      val(ugf.y,0,0,0) = val(uf.y,0,0,0) + val(usfg.y,0,0,0);
                }else{
                      val(ugf.y,0,0,0) = val(uf.y,0,0,0);
                }
          }else{
              val(ugf.y,0,0,0) = val(uf.y,0,0,0);
          }

        }

        if(fabs(val(fs.y,0,0,0))<=0){
            val(ugf.y,0,0,0) = 0.0;
            val(usfg.y,0,0,0) = 0.0;
            val(uf.y,0,0,0) = 0.;
        }



     }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((vector[]){facemask,{{-1},{-1}}}));
#line 1191 "././linear2-tree-1-2.h"
}

static void embed_fraction_refine_css_test (Point point, scalar css_test)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(css_test,0,0,0);





  if (cc <= 0. || cc >= 1.) {
    {foreach_child()
      val(css_test,0,0,0) = cc;end_foreach_child()}
  }
  else {






    coord n = facet_normal (point, css_test, fss_test);
    double alpha = line_alpha (cc, n);

    {foreach_child() {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x;
 
#line 1220
nc.y = child.y*n.y;
      val(css_test,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }end_foreach_child()}
  }
}


static void embed_face_fraction_fss_test_refine_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  vector fss_test = _attribute[s.i].v;





  if (val(css_test,0,0,0) <= 0. || val(css_test,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test.x,1,j,k) = val(css_test,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0) && neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test.x,2*i,j,k) = val(fss_test.x,i,0,0);
  }
  else {






    coord n = facet_normal (point, css_test, fss_test);
    double alpha = line_alpha (val(css_test,0,0,0), n);
#line 1275 "././linear2-tree-1-2.h"
    if (2.*fabs(alpha) < fabs(n.y)) {
      double yc = alpha/n.y;
      int i = yc > 0.;
      fine(fss_test.x,1,1 - i,0) = n.y < 0. ? 1. - i : i;
      fine(fss_test.x,1,i,0) = n.y < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test.x,1,0,0) = fine(fss_test.x,1,1,0) = alpha > 0.;
#line 1308 "././linear2-tree-1-2.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0)))) {
 if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0)) {
   if (val(fss_test.x,i,0,0) <= 0. || val(fss_test.x,i,0,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test.x,2*i,j,k) = val(fss_test.x,i,0,0);
   else {






     double a = val(fss_test.y,0,1,0) <= 0. || val(fss_test.y,2*i-1,1,0) <= 0. ||
       val(fss_test.y,0,0,0) >= 1. || val(fss_test.y,2*i-1,0,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test.x,i,0,0) - 0.5) > 0.) {
       fine(fss_test.x,2*i,0,0) = a;
       fine(fss_test.x,2*i,1,0) = 2.*val(fss_test.x,i,0,0) - a;
     }
     else {
       fine(fss_test.x,2*i,0,0) = 2.*val(fss_test.x,i,0,0) + a - 1.;
       fine(fss_test.x,2*i,1,0) = 1. - a;
     }
#line 1350 "././linear2-tree-1-2.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test.x,2*i,j,k) && !fine(css_test,i,j,k))
       fine(fss_test.x,2*i,j,k) = 0.;
      }
  }
}

#line 1227
static void embed_face_fraction_fss_test_refine_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  vector fss_test = _attribute[s.i].v;





  if (val(css_test,0,0,0) <= 0. || val(css_test,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test.y,j,1,k) = val(css_test,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0) && neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test.y,j,2*i,k) = val(fss_test.y,0,i,0);
  }
  else {






    coord n = facet_normal (point, css_test, fss_test);
    double alpha = line_alpha (val(css_test,0,0,0), n);
#line 1275 "././linear2-tree-1-2.h"
    if (2.*fabs(alpha) < fabs(n.x)) {
      double yc = alpha/n.x;
      int i = yc > 0.;
      fine(fss_test.y,1 - i,1,0) = n.x < 0. ? 1. - i : i;
      fine(fss_test.y,i,1,0) = n.x < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test.y,0,1,0) = fine(fss_test.y,1,1,0) = alpha > 0.;
#line 1308 "././linear2-tree-1-2.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0)))) {
 if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0)) {
   if (val(fss_test.y,0,i,0) <= 0. || val(fss_test.y,0,i,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test.y,j,2*i,k) = val(fss_test.y,0,i,0);
   else {






     double a = val(fss_test.x,1,0,0) <= 0. || val(fss_test.x,1,2*i-1,0) <= 0. ||
       val(fss_test.x,0,0,0) >= 1. || val(fss_test.x,0,2*i-1,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test.y,0,i,0) - 0.5) > 0.) {
       fine(fss_test.y,0,2*i,0) = a;
       fine(fss_test.y,1,2*i,0) = 2.*val(fss_test.y,0,i,0) - a;
     }
     else {
       fine(fss_test.y,0,2*i,0) = 2.*val(fss_test.y,0,i,0) + a - 1.;
       fine(fss_test.y,1,2*i,0) = 1. - a;
     }
#line 1350 "././linear2-tree-1-2.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test.y,j,2*i,k) && !fine(css_test,j,i,k))
       fine(fss_test.y,j,2*i,k) = 0.;
      }
  }
}


static void embed_fraction_refine_css_test2 (Point point, scalar css_test2)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(css_test2,0,0,0);





  if (cc <= 0. || cc >= 1.) {
    {foreach_child()
      val(css_test2,0,0,0) = cc;end_foreach_child()}
  }
  else {






    coord n = facet_normal (point, css_test2, fss_test2);
    double alpha = line_alpha (cc, n);

    {foreach_child() {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x;
 
#line 1394
nc.y = child.y*n.y;
      val(css_test2,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }end_foreach_child()}
  }
}


static void embed_face_fraction_fss_test2_refine_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fss_test2 = _attribute[s.i].v;





  if (val(css_test2,0,0,0) <= 0. || val(css_test2,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test2.x,1,j,k) = val(css_test2,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0) && neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test2.x,2*i,j,k) = val(fss_test2.x,i,0,0);
  }
  else {






    coord n = facet_normal (point, css_test2, fss_test2);
    double alpha = line_alpha (val(css_test2,0,0,0), n);
#line 1448 "././linear2-tree-1-2.h"
    if (2.*fabs(alpha) < fabs(n.y)) {
      double yc = alpha/n.y;
      int i = yc > 0.;
      fine(fss_test2.x,1,1 - i,0) = n.y < 0. ? 1. - i : i;
      fine(fss_test2.x,1,i,0) = n.y < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test2.x,1,0,0) = fine(fss_test2.x,1,1,0) = alpha > 0.;
#line 1480 "././linear2-tree-1-2.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(2*i-1,0,0).neighbors &&
   (is_local(cell) || is_local(neighbor(2*i-1,0,0)))) {
 if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0)) {
   if (val(fss_test2.x,i,0,0) <= 0. || val(fss_test2.x,i,0,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test2.x,2*i,j,k) = val(fss_test2.x,i,0,0);
   else {






     double a = val(fss_test2.y,0,1,0) <= 0. || val(fss_test2.y,2*i-1,1,0) <= 0. ||
       val(fss_test2.y,0,0,0) >= 1. || val(fss_test2.y,2*i-1,0,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test2.x,i,0,0) - 0.5) > 0.) {
       fine(fss_test2.x,2*i,0,0) = a;
       fine(fss_test2.x,2*i,1,0) = 2.*val(fss_test2.x,i,0,0) - a;
     }
     else {
       fine(fss_test2.x,2*i,0,0) = 2.*val(fss_test2.x,i,0,0) + a - 1.;
       fine(fss_test2.x,2*i,1,0) = 1. - a;
     }
#line 1522 "././linear2-tree-1-2.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test2.x,2*i,j,k) && !fine(css_test2,i,j,k))
       fine(fss_test2.x,2*i,j,k) = 0.;
      }
  }
}

#line 1401
static void embed_face_fraction_fss_test2_refine_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  vector fss_test2 = _attribute[s.i].v;





  if (val(css_test2,0,0,0) <= 0. || val(css_test2,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(fss_test2.y,j,1,k) = val(css_test2,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0) && neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0))))
 for (int j = 0; j <= 1; j++)
   for (int k = 0; k <= 1; k++)
     fine(fss_test2.y,j,2*i,k) = val(fss_test2.y,0,i,0);
  }
  else {






    coord n = facet_normal (point, css_test2, fss_test2);
    double alpha = line_alpha (val(css_test2,0,0,0), n);
#line 1448 "././linear2-tree-1-2.h"
    if (2.*fabs(alpha) < fabs(n.x)) {
      double yc = alpha/n.x;
      int i = yc > 0.;
      fine(fss_test2.y,1 - i,1,0) = n.x < 0. ? 1. - i : i;
      fine(fss_test2.y,i,1,0) = n.x < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(fss_test2.y,0,1,0) = fine(fss_test2.y,1,1,0) = alpha > 0.;
#line 1480 "././linear2-tree-1-2.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(0,2*i-1,0).neighbors &&
   (is_local(cell) || is_local(neighbor(0,2*i-1,0)))) {
 if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0)) {
   if (val(fss_test2.y,0,i,0) <= 0. || val(fss_test2.y,0,i,0) >= 1.)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
  fine(fss_test2.y,j,2*i,k) = val(fss_test2.y,0,i,0);
   else {






     double a = val(fss_test2.x,1,0,0) <= 0. || val(fss_test2.x,1,2*i-1,0) <= 0. ||
       val(fss_test2.x,0,0,0) >= 1. || val(fss_test2.x,0,2*i-1,0) >= 1.;
     if ((2.*a - 1)*(val(fss_test2.y,0,i,0) - 0.5) > 0.) {
       fine(fss_test2.y,0,2*i,0) = a;
       fine(fss_test2.y,1,2*i,0) = 2.*val(fss_test2.y,0,i,0) - a;
     }
     else {
       fine(fss_test2.y,0,2*i,0) = 2.*val(fss_test2.y,0,i,0) + a - 1.;
       fine(fss_test2.y,1,2*i,0) = 1. - a;
     }
#line 1522 "././linear2-tree-1-2.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(fss_test2.y,j,2*i,k) && !fine(css_test2,j,i,k))
       fine(fss_test2.y,j,2*i,k) = 0.;
      }
  }
}





void restriction_Tlff (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0.;
  double weight= 0.;
  {foreach_child(){

    if(val(ff,0,0,0)>0.0){



        sum += val(s,0,0,0) ;
    }
  }end_foreach_child()}

  if(weight>1e-12){

    val(s,0,0,0) = sum/(1 << 2);
  }
}

void restriction_Tgff (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double sum = 0.;
  double weight= 0.;
  {foreach_child(){

      if(1.0-val(ff,0,0,0)>0.0){



        sum += val(s,0,0,0) ;
    }
  }end_foreach_child()}

  if(weight>1e-12){

    val(s,0,0,0) = sum/(1 << 2);
  }
}






void refine_embed_linear_css_test (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child() {
    if (!val(css_test,0,0,0)){
       val(s,0,0,0) = Tsat00;
    }else {
      if (!(coarse(css_test,0,0,0))) qassert ("././linear2-tree-1-2.h", 1594, "coarse(css_test)");
      int i = (child.x + 1)/2, j = (child.y + 1)/2;

      if (coarse(fss_test.x,i,0,0) && coarse(fss_test.y,0,j,0) &&
   (coarse(css_test,0,0,0) == 1. || coarse(css_test,child.x,0,0) == 1. ||
    coarse(css_test,0,child.y,0) == 1. || coarse(css_test,child.x,child.y,0) == 1.)) {
 if (!(coarse(css_test,child.x,0,0) && coarse(css_test,0,child.y,0))) qassert ("././linear2-tree-1-2.h", 1600, "coarse(css_test,child.x) && coarse(css_test,0,child.y)");
 if (coarse(fss_test.x,i,child.y,0) && coarse(fss_test.y,child.x,j,0)) {

   if (!(coarse(css_test,child.x,child.y,0))) qassert ("././linear2-tree-1-2.h", 1603, "coarse(css_test,child.x,child.y)");
   val(s,0,0,0) = (9.*coarse(s,0,0,0) +
   3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
   coarse(s,child.x,child.y,0))/16.;
 }
 else

   val(s,0,0,0) = (2.*coarse(s,0,0,0) + coarse(s,child.x,0,0) + coarse(s,0,child.y,0))/4.;
      }
      else if (coarse(css_test,child.x,child.y,0) &&
        ((coarse(fss_test.x,i,0,0) && coarse(fss_test.y,child.x,j,0)) ||
  (coarse(fss_test.y,0,j,0) && coarse(fss_test.x,i,child.y,0)))) {

 val(s,0,0,0) = (3.*coarse(s,0,0,0) + coarse(s,child.x,child.y,0))/4.;
      }
#line 1666 "././linear2-tree-1-2.h"
      else {

 val(s,0,0,0) = coarse(s,0,0,0);
  {
   if (coarse(fss_test.x,(child.x + 1)/2,0,0) && coarse(css_test,child.x,0,0))
     val(s,0,0,0) += (coarse(s,child.x,0,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test.x,(- child.x + 1)/2,0,0) && coarse(css_test,- child.x,0,0))
     val(s,0,0,0) -= (coarse(s,- child.x,0,0) - coarse(s,0,0,0))/4.;
 } 
#line 1669
{
   if (coarse(fss_test.y,0,(child.y + 1)/2,0) && coarse(css_test,0,child.y,0))
     val(s,0,0,0) += (coarse(s,0,child.y,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test.y,0,(- child.y + 1)/2,0) && coarse(css_test,0,- child.y,0))
     val(s,0,0,0) -= (coarse(s,0,- child.y,0) - coarse(s,0,0,0))/4.;
 }
      }
    }
  }end_foreach_child()}
}







void refine_embed_linear_css_test2 (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  {foreach_child() {
    if (!val(css_test2,0,0,0)){
       val(s,0,0,0) = Tsat00;
    }else {
      if (!(coarse(css_test2,0,0,0))) qassert ("././linear2-tree-1-2.h", 1693, "coarse(css_test2)");
      int i = (child.x + 1)/2, j = (child.y + 1)/2;

      if (coarse(fss_test2.x,i,0,0) && coarse(fss_test2.y,0,j,0) &&
   (coarse(css_test2,0,0,0) == 1. || coarse(css_test2,child.x,0,0) == 1. ||
    coarse(css_test2,0,child.y,0) == 1. || coarse(css_test2,child.x,child.y,0) == 1.)) {
 if (!(coarse(css_test2,child.x,0,0) && coarse(css_test2,0,child.y,0))) qassert ("././linear2-tree-1-2.h", 1699, "coarse(css_test2,child.x) && coarse(css_test2,0,child.y)");
 if (coarse(fss_test2.x,i,child.y,0) && coarse(fss_test2.y,child.x,j,0)) {

   if (!(coarse(css_test2,child.x,child.y,0))) qassert ("././linear2-tree-1-2.h", 1702, "coarse(css_test2,child.x,child.y)");
   val(s,0,0,0) = (9.*coarse(s,0,0,0) +
   3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
   coarse(s,child.x,child.y,0))/16.;
 }
 else

   val(s,0,0,0) = (2.*coarse(s,0,0,0) + coarse(s,child.x,0,0) + coarse(s,0,child.y,0))/4.;
      }
      else if (coarse(css_test2,child.x,child.y,0) &&
        ((coarse(fss_test2.x,i,0,0) && coarse(fss_test2.y,child.x,j,0)) ||
  (coarse(fss_test2.y,0,j,0) && coarse(fss_test2.x,i,child.y,0)))) {

 val(s,0,0,0) = (3.*coarse(s,0,0,0) + coarse(s,child.x,child.y,0))/4.;
      }
#line 1765 "././linear2-tree-1-2.h"
      else {

 val(s,0,0,0) = coarse(s,0,0,0);
  {
   if (coarse(fss_test2.x,(child.x + 1)/2,0,0) && coarse(css_test2,child.x,0,0))
     val(s,0,0,0) += (coarse(s,child.x,0,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test2.x,(- child.x + 1)/2,0,0) && coarse(css_test2,- child.x,0,0))
     val(s,0,0,0) -= (coarse(s,- child.x,0,0) - coarse(s,0,0,0))/4.;
 } 
#line 1768
{
   if (coarse(fss_test2.y,0,(child.y + 1)/2,0) && coarse(css_test2,0,child.y,0))
     val(s,0,0,0) += (coarse(s,0,child.y,0) - coarse(s,0,0,0))/4.;
   else if (coarse(fss_test2.y,0,(- child.y + 1)/2,0) && coarse(css_test2,0,- child.y,0))
     val(s,0,0,0) -= (coarse(s,0,- child.y,0) - coarse(s,0,0,0))/4.;
 }
      }
    }
  }end_foreach_child()}
}






void restriction_embed_linear_css_test (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  if (!val(css_test,0,0,0) ) {
       val(s,0,0,0) = Tsat00;
    return;
  }






  double val = 0., nv = 0.;
  for (int i = 0; i <= 1; i++)



      if (fine(css_test,0,i,j) && fine(css_test,1,!i,!j))
 val += (fine(s,0,i,j) + fine(s,1,!i,!j))/2., nv++;
  if (nv > 0.) {
    val(s,0,0,0) = val/nv;
    return;
  }





  coord p = {0.,0.,0.};
  {foreach_child()
    if (val(css_test,0,0,0))
      p.x += x, p.y += y, p.z += z, val += val(s,0,0,0), nv++;end_foreach_child()}
  if (!(nv > 0.)) qassert ("././linear2-tree-1-2.h", 1818, "nv > 0.");
  val(s,0,0,0) = val/nv;
}






void restriction_embed_linear_css_test2 (Point point, scalar s)

{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

  if (!val(css_test2,0,0,0) ) {
       val(s,0,0,0) = Tsat00;
    return;
  }






  double val = 0., nv = 0.;
  for (int i = 0; i <= 1; i++)



      if (fine(css_test2,0,i,j) && fine(css_test2,1,!i,!j))
 val += (fine(s,0,i,j) + fine(s,1,!i,!j))/2., nv++;
  if (nv > 0.) {
    val(s,0,0,0) = val/nv;
    return;
  }





  coord p = {0.,0.,0.};
  {foreach_child()
    if (val(css_test2,0,0,0))
      p.x += x, p.y += y, p.z += z, val += val(s,0,0,0), nv++;end_foreach_child()}
  if (!(nv > 0.)) qassert ("././linear2-tree-1-2.h", 1861, "nv > 0.");
  val(s,0,0,0) = val/nv;
}

void conservative_refine (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(ff,0,0,0);
  double scc = val(s,0,0,0);
  if (cc <= 0. || cc >= 1.)
    refine_bilinear(point,s);
  else {

    coord n = mycs (point, ff);
    double alpha = line_alpha (cc, n);

    coord a, b;
     {
      a.x = 0.; b.x = 0.5;
    } 
#line 1877
{
      a.y = 0.; b.y = 0.5;
    }

    {foreach_child() {
      coord nc;
      
        nc.x = child.x*n.x;
        
#line 1884
nc.y = child.y*n.y;
      double crefine = rectangle_fraction (nc, alpha, a, b);
      if (_attribute[s.i].inverse)
        val(s,0,0,0) = scc/(1. - cc)*(1. - crefine);
      else
        val(s,0,0,0) = scc/cc*crefine;
    }end_foreach_child()}
  }
}


void refine_aim(Point point, scalar s){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  double cc = val(css_test3,0,0,0);
  double s_value = val(s,0,0,0);
    if(cc<0 && cc>1.0){
          {foreach_child(){
              val(s,0,0,0) = 0;
          }end_foreach_child()}
    }else{
        coord n = mycs (point, css_test3);
        double alpha = line_alpha (cc, n);

        coord m;
        double alphac = 2.*alpha;
        
              m.x = n.x;
              
#line 1909
m.y = n.y;

        {foreach_child(){
              coord p_c_child_c;
              double cc2;
              double alpha_child;

              static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
              coord nc;
              {
                  nc.x = child.x * n.x;
              }
#line 1918
{
                  nc.y = child.y * n.y;
              }
              cc2 = rectangle_fraction(nc,alpha,a,b);
              alpha_child=alphac;
              if(cc2>0.0 && cc2<1.0){
                  val(s,0,0,0) = s_value;
              }else{
                  val(s,0,0,0) = 0;
              }
        }end_foreach_child()}
    }
}

void restriction_aim(Point point, scalar s){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
    double volume_total=0.0;
    {foreach_child(){
        volume_total += val(css_test3,0,0,0);
    }end_foreach_child()}
    volume_total = volume_total /(1<<2);
    if(volume_total>0.0 && volume_total<1.0){
        double weight=0.0;
        double value_tot=0.0;
        {foreach_child(){
            if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                double weight_local = 1;
                weight += weight_local;
                value_tot += (weight_local*val(s,0,0,0));
            }
        }end_foreach_child()}
        if(weight>0){
            val(s,0,0,0) = value_tot/weight;
        }
    }
}

void across_interface(scalar f_old, scalar f_new, scalar TT){
  foreach_stencil(){
_stencil_val(css_test3,0,0,0);{
_stencil_val(f_old,0,0,0); _stencil_val(f_new,0,0,0);_stencil_val(f_old,0,0,0); _stencil_val(f_new,0,0,0);{
            _stencil_val_a(TT,0,0,0);  
        }
            
    
#line 1960
}
    
  
#line 1961
}end_foreach_stencil();
  {
#line 1955
foreach(){
    if(val(css_test3,0,0,0)<=0.0){
        if((val(f_old,0,0,0)<0.5 && val(f_new,0,0,0)>=0.5) || (val(f_old,0,0,0)>=0.5 && val(f_new,0,0,0)<0.5)){
            val(TT,0,0,0) = Tsat00;
        }
    }
  }end_foreach();}

}



struct smooth1 {
  scalar df;
  scalar tempf;
};
void smooth_for_arm(struct smooth1 q){
  scalar  smf=new_scalar("smf");
   scalar  ssmf=new_scalar("ssmf");
   scalar  sssmf=new_scalar("sssmf");
   scalar ssssmf = q.df;
   scalar tempf = q.tempf;





    foreach_stencil()
        {_stencil_val_a(smf,0,0,0);_stencil_val(tempf,0,0,0);
_stencil_val(tempf,0,1,0); _stencil_val(tempf,0,-1,0); _stencil_val(tempf,1,0,0); _stencil_val(tempf,-1,0,0);
          _stencil_val(tempf,-1,-1,0); _stencil_val(tempf,1,-1,0); _stencil_val(tempf,1,1,0); _stencil_val(tempf,-1,1,0);  
                  
#line 1985
}end_foreach_stencil();





    {
#line 1982
foreach()
        val(smf,0,0,0) = (4.*val(tempf,0,0,0) +
          2.*(val(tempf,0,1,0) + val(tempf,0,-1,0) + val(tempf,1,0,0) + val(tempf,-1,0,0)) +
          val(tempf,-1,-1,0) + val(tempf,1,-1,0) + val(tempf,1,1,0) + val(tempf,-1,1,0))/16.;end_foreach();}


    foreach_stencil()
        {_stencil_val_a(ssmf,0,0,0);_stencil_val(smf,0,0,0);
_stencil_val(smf,0,1,0); _stencil_val(smf,0,-1,0); _stencil_val(smf,1,0,0); _stencil_val(smf,-1,0,0);
          _stencil_val(smf,-1,-1,0); _stencil_val(smf,1,-1,0); _stencil_val(smf,1,1,0); _stencil_val(smf,-1,1,0);  
                  
#line 1991
}end_foreach_stencil();


    {
#line 1988
foreach()
        val(ssmf,0,0,0) = (4.*val(smf,0,0,0) +
          2.*(val(smf,0,1,0) + val(smf,0,-1,0) + val(smf,1,0,0) + val(smf,-1,0,0)) +
          val(smf,-1,-1,0) + val(smf,1,-1,0) + val(smf,1,1,0) + val(smf,-1,1,0))/16.;end_foreach();}

    foreach_stencil()
        {_stencil_val_a(sssmf,0,0,0);_stencil_val(ssmf,0,0,0);
_stencil_val(ssmf,0,1,0); _stencil_val(ssmf,0,-1,0); _stencil_val(ssmf,1,0,0); _stencil_val(ssmf,-1,0,0);
          _stencil_val(ssmf,-1,-1,0); _stencil_val(ssmf,1,-1,0); _stencil_val(ssmf,1,1,0); _stencil_val(ssmf,-1,1,0);  
                  
#line 1996
}end_foreach_stencil();

    {
#line 1993
foreach()
        val(sssmf,0,0,0) = (4.*val(ssmf,0,0,0) +
          2.*(val(ssmf,0,1,0) + val(ssmf,0,-1,0) + val(ssmf,1,0,0) + val(ssmf,-1,0,0)) +
          val(ssmf,-1,-1,0) + val(ssmf,1,-1,0) + val(ssmf,1,1,0) + val(ssmf,-1,1,0))/16.;end_foreach();}

    foreach_stencil()
        {_stencil_val_a(ssssmf,0,0,0);_stencil_val(sssmf,0,0,0);
_stencil_val(sssmf,0,1,0); _stencil_val(sssmf,0,-1,0); _stencil_val(sssmf,1,0,0); _stencil_val(sssmf,-1,0,0);
          _stencil_val(sssmf,-1,-1,0); _stencil_val(sssmf,1,-1,0); _stencil_val(sssmf,1,1,0); _stencil_val(sssmf,-1,1,0);  
                  
#line 2001
}end_foreach_stencil();

    {
#line 1998
foreach()
        val(ssssmf,0,0,0) = (4.*val(sssmf,0,0,0) +
          2.*(val(sssmf,0,1,0) + val(sssmf,0,-1,0) + val(sssmf,1,0,0) + val(sssmf,-1,0,0)) +
          val(sssmf,-1,-1,0) + val(sssmf,1,-1,0) + val(sssmf,1,1,0) + val(sssmf,-1,1,0))/16.;end_foreach();}delete((scalar*)((scalar[]){sssmf,ssmf,smf,{-1}}));
#line 2065 "././linear2-tree-1-2.h"
}





void normalizeVector(double* vx, double* vy) {
    double magnitude = sqrt((*vx) * (*vx) + (*vy) * (*vy));
    if (magnitude != 0) {
        *vx /= magnitude;
        *vy /= magnitude;
    }
}


void transformVectorToSurfaceCoordinate(double ux, double uy, double nx, double ny, double* un, double* ut) {

    normalizeVector(&nx, &ny);


    *un = ux * nx + uy * ny;
    *ut = ux * (-ny) + uy * nx;
}


void transformSurfaceCoordinateToVector(double un, double ut, double nx, double ny, double* ux, double* uy) {

    normalizeVector(&nx, &ny);


    *ux = un * nx + ut * (-ny);
    *uy = un * ny + ut * nx;
}





extern int maxl;

void get_u_ghost(vector u){
      vector  u_surface=new_vector("u_surface");

      double lambdas = HUGE;

      scalar  css_test3_n_neg=new_scalar("css_test3_n_neg");
      foreach_stencil(){
        _stencil_val_a(css_test3_n_neg,0,0,0);_stencil_val(css_test3_n,0,0,0);  
      }end_foreach_stencil();
      {
#line 2111
foreach(){
        val(css_test3_n_neg,0,0,0) = 1.0-val(css_test3_n,0,0,0);
      }end_foreach();}
      scalar  solid_neg_alpha=new_scalar("solid_neg_alpha");
      vector  solid_n=new_vector("solid_n");
      reconstruction (css_test3_n_neg, solid_n, solid_neg_alpha);



      foreach_stencil(){
_stencil_val(topo_mask_s,0,0,0);{  
               _stencil_val(u.x,0,0,0);  
               _stencil_val(u.y,0,0,0);  
               _stencil_val(solid_n.x,0,0,0);  
               _stencil_val(solid_n.y,0,0,0);  
                   


              
              _stencil_val_a(u_surface.x,0,0,0);  
              _stencil_val_a(u_surface.y,0,0,0);  
         }
         
      
#line 2133
}end_foreach_stencil();



      {
#line 2120
foreach(){
         if(val(topo_mask_s,0,0,0)==0){
              double ux = val(u.x,0,0,0);
              double uy = val(u.y,0,0,0);
              double nx = val(solid_n.x,0,0,0);
              double ny = val(solid_n.y,0,0,0);
              double un, ut;


              transformVectorToSurfaceCoordinate(ux, uy, nx, ny, &un, &ut);
              val(u_surface.x,0,0,0) = un;
              val(u_surface.y,0,0,0) = ut;
         }
      }end_foreach();}







      vector  o3=new_vector("o3"), o1=new_vector("o1");
      foreach_stencil(){ 
        
        {
          _stencil_val_a(o3.x,0,0,0);
_stencil_val(solid_n.x,0,0,0);  
           
           
        
#line 2148
}
#line 2144
{
          _stencil_val_a(o3.y,0,0,0);
_stencil_val(solid_n.y,0,0,0);  
           
           
        
#line 2148
}
_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);{     
            _stencil_val(css_test3_n,0,0,0);   
            
            _stencil_val_a(o3.x,0,0,0);  
            _stencil_val_a(o3.y,0,0,0);  
        }
         
      
#line 2155
}end_foreach_stencil();
      {
#line 2142
foreach(){
        coord n_css_test3_n,o3_temp;
        {
          val(o3.x,0,0,0)=0.0;
          n_css_test3_n.x = -val(solid_n.x,0,0,0);
          o3_temp.x = 0.0;
        }
#line 2144
{
          val(o3.y,0,0,0)=0.0;
          n_css_test3_n.y = -val(solid_n.y,0,0,0);
          o3_temp.y = 0.0;
        }
        if(val(css_test3_n,0,0,0)>0.0 && val(css_test3_n,0,0,0)<1.0){
            double alpha = line_alpha (val(css_test3_n,0,0,0), n_css_test3_n);
            double area = line_length_center(n_css_test3_n,alpha,&o3_temp);
            val(o3.x,0,0,0)=x + o3_temp.x*Delta;
            val(o3.y,0,0,0)=y + o3_temp.y*Delta;
        }
      }end_foreach();}

    foreach_stencil(){ 
      
      {
        _stencil_val_a(o1.x,0,0,0);
_stencil_val(solid_n.x,0,0,0);  
         
         
      
#line 2163
}
#line 2159
{
        _stencil_val_a(o1.y,0,0,0);
_stencil_val(solid_n.y,0,0,0);  
         
         
      
#line 2163
}
_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);{     
         _stencil_val(css_test3_n,0,0,0);
_stencil_val(css_test3_n,0,0,0);
         
         
#line 2167
_stencil_val_a(o1.x,0,0,0);  
         _stencil_val_a(o1.y,0,0,0);  
      }
       
    
#line 2170
}end_foreach_stencil();

    {
#line 2157
foreach(){
      coord n_css_test3_n,o1_temp;
      {
        val(o1.x,0,0,0)=0.0;
        n_css_test3_n.x = -val(solid_n.x,0,0,0);
        o1_temp.x = 0.0;
      }
#line 2159
{
        val(o1.y,0,0,0)=0.0;
        n_css_test3_n.y = -val(solid_n.y,0,0,0);
        o1_temp.y = 0.0;
      }
      if(val(css_test3_n,0,0,0)>0.0 && val(css_test3_n,0,0,0)<1.0){
         double alpha = line_alpha (val(css_test3_n,0,0,0), n_css_test3_n);
         line_center(n_css_test3_n,alpha,val(css_test3_n,0,0,0),&o1_temp);
         val(o1.x,0,0,0)=x + o1_temp.x*Delta;
         val(o1.y,0,0,0)=y + o1_temp.y*Delta;
      }
    }end_foreach();}


    scalar  a1=new_scalar("a1");
    foreach_stencil(){
        _stencil_val_a(a1,0,0,0);

_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);{ 
            
            { 
_stencil_val(o1.x,0,0,0); _stencil_val(o3.x,0,0,0); 
                
            
#line 2181
}
#line 2179
{ 
_stencil_val(o1.y,0,0,0); _stencil_val(o3.y,0,0,0); 
                
            
#line 2181
} 
            
_stencil_val(solid_n.x,0,0,0);_stencil_val(solid_n.y,0,0,0);
{     
              _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);
              _stencil_val_a(a1,0,0,0);  
            } 
             
            
        
#line 2188
}  

         
    
#line 2189
}end_foreach_stencil();
    {
#line 2174
foreach(){
        val(a1,0,0,0) = 0;

        if(val(css_test3_n,0,0,0)>0.0 && val(css_test3_n,0,0,0)<1.0){
            coord o1_o3;
            {
               o1_o3.x = val(o1.x,0,0,0) - val(o3.x,0,0,0);
            }
#line 2179
{
               o1_o3.y = val(o1.y,0,0,0) - val(o3.y,0,0,0);
            }
            double n_mod;
            n_mod = sqrt(sq(val(solid_n.x,0,0,0))+sq(val(solid_n.y,0,0,0)));
            if(n_mod>1e-20){
              double dott = (o1_o3.x*val(solid_n.x,0,0,0) + o1_o3.y*val(solid_n.y,0,0,0))/n_mod;
              val(a1,0,0,0) = fabs(dott);
            }
        }
    }end_foreach();}

    scalar  solid_u=new_scalar("solid_u");
    foreach_stencil(){
_stencil_val(topo_mask_s,0,0,0);{
        _stencil_val_a(solid_u,0,0,0); _stencil_val(u_surface.y,0,0,0);_stencil_val(a1,0,0,0);_stencil_val(a1,0,0,0); 
      }
      
    
#line 2196
}end_foreach_stencil();
    {
#line 2192
foreach(){
      if(val(topo_mask_s,0,0,0)==0){
        val(solid_u,0,0,0) = val(u_surface.y,0,0,0)*val(a1,0,0,0)/(val(a1,0,0,0)+lambdas);
      }
    }end_foreach();}


    foreach_stencil(){
_stencil_val(topo_mask_s,0,0,0);{{          
          
          

          
          


_stencil_val(topo_mask_s,1,0,0);{    
              



              _stencil_val(solid_n.y,1,0,0);_stencil_val(solid_n.x,1,0,0);
{   
                _stencil_val(solid_neg_alpha,1,0,0);_stencil_val(solid_n.y,1,0,0);_stencil_val(solid_n.x,1,0,0);
_stencil_val(a1,1,0,0);_stencil_val(u_surface.x,1,0,0); 
                  _stencil_val(u_surface.y,1,0,0);_stencil_val(a1,1,0,0);    
                 
                
                
                 
#line 2220
_stencil_val(solid_n.x,1,0,0);  
                 _stencil_val(solid_n.y,1,0,0);      
                
                         

                

                   
                 

                   
                 
              }
              
         
#line 2233
}



{
                _stencil_val_a(u.x,0,0,0);  
                _stencil_val_a(u.y,0,0,0);  
         }


         



          
      
#line 2241
} {_stencil_val(topo_mask_s,0,0,0);{
          _stencil_val_a(u.x,0,0,0);  
          _stencil_val_a(u.y,0,0,0);  
      }}}
        
    
#line 2245
}end_foreach_stencil();


    {
#line 2199
foreach(){
      if(val(topo_mask_s,0,0,0)==1 && level==level_interface){
          double totalx =0.0;
          double weightx = 0.0;

          double totaly =0.0;
          double weighty = 0.0;


         if(val(topo_mask_s,1,0,0)==0){
              coord u_surface_local;



              double n_mod = sqrt(sq(val(solid_n.x,1,0,0))+sq(val(solid_n.y,1,0,0)));
              if(n_mod>1e-20){
                double a2 = fabs(val(solid_n.x,1,0,0)*(-1)+val(solid_n.y,1,0,0)*0-val(solid_neg_alpha,1,0,0))/n_mod*Delta;
                u_surface_local.x = -(a2)/(val(a1,1,0,0))*val(u_surface.x,1,0,0);
                u_surface_local.y = val(u_surface.y,1,0,0)*(lambdas-a2)/(val(a1,1,0,0)+lambdas);
                double ux;
                double uy;
                double nx = val(solid_n.x,1,0,0);
                double ny = val(solid_n.y,1,0,0);
                double un = u_surface_local.x;
                double ut = u_surface_local.y;

                transformSurfaceCoordinateToVector(un, ut, nx, ny, &ux, &uy);

                totalx += ux * 1;
                weightx += 1;

                totaly += uy * 1;
                weighty += 1;
              }
         }



        if(weightx>0.0 && weighty>0.0){
                val(u.x,0,0,0) = totalx/weightx;
                val(u.y,0,0,0) = totaly/weighty;
         }
      }else if(val(topo_mask_s,0,0,0)>=2){
          val(u.x,0,0,0) = 0;
          val(u.y,0,0,0) = 0;
      }
    }end_foreach();}delete((scalar*)((scalar[]){solid_u,a1,o1.x,o1.y,o3.x,o3.y,solid_n.x,solid_n.y,solid_neg_alpha,css_test3_n_neg,u_surface.x,u_surface.y,{-1}}));


}




void get_ps_ghost(scalar ps){
      scalar  p_surface=new_scalar("p_surface");

      scalar  css_test3_n_neg=new_scalar("css_test3_n_neg");
      foreach_stencil(){
        _stencil_val_a(css_test3_n_neg,0,0,0);_stencil_val(css_test3_n,0,0,0);  
      }end_foreach_stencil();
      {
#line 2257
foreach(){
        val(css_test3_n_neg,0,0,0) = 1.0-val(css_test3_n,0,0,0);
      }end_foreach();}
      scalar  solid_neg_alpha=new_scalar("solid_neg_alpha");
      vector  solid_n=new_vector("solid_n");
      reconstruction (css_test3_n_neg, solid_n, solid_neg_alpha);
#line 2287 "././linear2-tree-1-2.h"
      vector  o3=new_vector("o3"), o1=new_vector("o1");
      foreach_stencil(){ 
        
        {
          _stencil_val_a(o3.x,0,0,0);
_stencil_val(solid_n.x,0,0,0);  
           
           
        
#line 2294
}
#line 2290
{
          _stencil_val_a(o3.y,0,0,0);
_stencil_val(solid_n.y,0,0,0);  
           
           
        
#line 2294
}
_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);{     
            _stencil_val(css_test3_n,0,0,0);   
            
            _stencil_val_a(o3.x,0,0,0);  
            _stencil_val_a(o3.y,0,0,0);  
        }
         
      
#line 2301
}end_foreach_stencil();
      {
#line 2288
foreach(){
        coord n_css_test3_n,o3_temp;
        {
          val(o3.x,0,0,0)=0.0;
          n_css_test3_n.x = -val(solid_n.x,0,0,0);
          o3_temp.x = 0.0;
        }
#line 2290
{
          val(o3.y,0,0,0)=0.0;
          n_css_test3_n.y = -val(solid_n.y,0,0,0);
          o3_temp.y = 0.0;
        }
        if(val(css_test3_n,0,0,0)>0.0 && val(css_test3_n,0,0,0)<1.0){
            double alpha = line_alpha (val(css_test3_n,0,0,0), n_css_test3_n);
            double area = line_length_center(n_css_test3_n,alpha,&o3_temp);
            val(o3.x,0,0,0)=x + o3_temp.x*Delta;
            val(o3.y,0,0,0)=y + o3_temp.y*Delta;
        }
      }end_foreach();}

    foreach_stencil(){ 
      
      {
        _stencil_val_a(o1.x,0,0,0);
_stencil_val(solid_n.x,0,0,0);  
         
         
      
#line 2309
}
#line 2305
{
        _stencil_val_a(o1.y,0,0,0);
_stencil_val(solid_n.y,0,0,0);  
         
         
      
#line 2309
}
_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);{     
         _stencil_val(css_test3_n,0,0,0);
_stencil_val(css_test3_n,0,0,0);
         
         
#line 2313
_stencil_val_a(o1.x,0,0,0);  
         _stencil_val_a(o1.y,0,0,0);  
      }
       
    
#line 2316
}end_foreach_stencil();

    {
#line 2303
foreach(){
      coord n_css_test3_n,o1_temp;
      {
        val(o1.x,0,0,0)=0.0;
        n_css_test3_n.x = -val(solid_n.x,0,0,0);
        o1_temp.x = 0.0;
      }
#line 2305
{
        val(o1.y,0,0,0)=0.0;
        n_css_test3_n.y = -val(solid_n.y,0,0,0);
        o1_temp.y = 0.0;
      }
      if(val(css_test3_n,0,0,0)>0.0 && val(css_test3_n,0,0,0)<1.0){
         double alpha = line_alpha (val(css_test3_n,0,0,0), n_css_test3_n);
         line_center(n_css_test3_n,alpha,val(css_test3_n,0,0,0),&o1_temp);
         val(o1.x,0,0,0)=x + o1_temp.x*Delta;
         val(o1.y,0,0,0)=y + o1_temp.y*Delta;
      }
    }end_foreach();}


    scalar  a1=new_scalar("a1");
    foreach_stencil(){
        _stencil_val_a(a1,0,0,0);

_stencil_val(css_test3_n,0,0,0); _stencil_val(css_test3_n,0,0,0);{ 
            
            { 
_stencil_val(o1.x,0,0,0); _stencil_val(o3.x,0,0,0); 
                
            
#line 2327
}
#line 2325
{ 
_stencil_val(o1.y,0,0,0); _stencil_val(o3.y,0,0,0); 
                
            
#line 2327
} 
            
_stencil_val(solid_n.x,0,0,0);_stencil_val(solid_n.y,0,0,0);
{     
              _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);
              _stencil_val_a(a1,0,0,0);  
            } 
             
            
        
#line 2334
}  

         
    
#line 2335
}end_foreach_stencil();
    {
#line 2320
foreach(){
        val(a1,0,0,0) = 0;

        if(val(css_test3_n,0,0,0)>0.0 && val(css_test3_n,0,0,0)<1.0){
            coord o1_o3;
            {
               o1_o3.x = val(o1.x,0,0,0) - val(o3.x,0,0,0);
            }
#line 2325
{
               o1_o3.y = val(o1.y,0,0,0) - val(o3.y,0,0,0);
            }
            double n_mod;
            n_mod = sqrt(sq(val(solid_n.x,0,0,0))+sq(val(solid_n.y,0,0,0)));
            if(n_mod>1e-20){
              double dott = (o1_o3.x*val(solid_n.x,0,0,0) + o1_o3.y*val(solid_n.y,0,0,0))/n_mod;
              val(a1,0,0,0) = fabs(dott);
            }
        }
    }end_foreach();}



    foreach_stencil(){
_stencil_val(topo_mask_s,0,0,0); _stencil_val(topo_mask,0,0,0);{      
          
          

          
          {foreach_neighbor(){
_stencil_val(intersect_true,0,0,0);
                
            
            
          
#line 2349
}end_foreach_neighbor()}


_stencil_val(topo_mask_s,1,0,0);{    
              



              _stencil_val(solid_n.y,1,0,0);_stencil_val(solid_n.x,1,0,0);
{   
                _stencil_val(solid_neg_alpha,1,0,0);_stencil_val(solid_n.y,1,0,0);_stencil_val(solid_n.x,1,0,0);
_stencil_val(a1,1,0,0);_stencil_val(ps,1,0,0);   
                 
                   
                 
              
#line 2363
}
              
         
#line 2364
}



{
                _stencil_val_a(ps,0,0,0);  
         }


           



        
      
#line 2371
}
         
    
#line 2372
}end_foreach_stencil();



    {
#line 2339
foreach(){
      if(val(topo_mask_s,0,0,0)==1 && level==level_interface && val(topo_mask,0,0,0)<=0){
          double totalx =0.0;
          double weightx = 0.0;

          bool flag=false;
          {foreach_neighbor(){
            if(val(intersect_true,0,0,0)==1){
                flag=true;
            }
          }end_foreach_neighbor()}


         if(val(topo_mask_s,1,0,0)==0 && flag){
              double p_surface_local;



              double n_mod = sqrt(sq(val(solid_n.x,1,0,0))+sq(val(solid_n.y,1,0,0)));
              if(n_mod>1e-20){
                double a2 = fabs(val(solid_n.x,1,0,0)*(-1)+val(solid_n.y,1,0,0)*0-val(solid_neg_alpha,1,0,0))/n_mod*Delta;
                p_surface_local = -(a2)/(val(a1,1,0,0))*val(ps,1,0,0);
                totalx += p_surface_local * 1;
                weightx += 1;
              }
         }



        if(weightx>0.0){
                val(ps,0,0,0) = totalx/weightx;
         }
      }
    }end_foreach();}delete((scalar*)((scalar[]){a1,o1.x,o1.y,o3.x,o3.y,solid_n.x,solid_n.y,solid_neg_alpha,css_test3_n_neg,p_surface,{-1}}));


}
#line 17 "template01.c"





#line 1 "./axi-diffusion1.h"
#line 1 "././axi-diffusion1.h"
#line 25 "././axi-diffusion1.h"
#line 1 "././axi-poisson1.h"
#line 1 "./././axi-poisson1.h"
#line 31 "./././axi-poisson1.h"
extern double Tkl,Tkg;
extern vector modphase0;
extern vector modphase1;
extern int phase_flag3;
extern scalar ff;
extern int minl;
extern int level_interface;
extern double Tsat00;
extern scalar cs,T;
extern vector fs;


double k_value;

extern int maxl;



extern vector smallmodl,bigmodl,smallmodg,bigmodg;
extern scalar resl,resg;


void mg_cycle1 (scalar * a, scalar * res, scalar * da,
        void (* relax1) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = min (minlevel, maxlevel);
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {foreach_level_or_leaf (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = 0.;}}end_foreach_level_or_leaf();}





    else
      {foreach_level (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
   {
     val(s,0,0,0) = bilinear_embed(point, s);
    }
  }}}end_foreach_level();}




    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax1 (da, res, l, data);
      boundary_level (da, l);
    }
  }




  foreach_stencil() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 {_stencil_val_r(s,0,0,0); _stencil_val(ds,0,0,0); }}}
  }end_foreach_stencil();




  {
#line 106
foreach() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 val(s,0,0,0) += val(ds,0,0,0);}}
  }end_foreach();}
}
#line 124 "./././axi-poisson1.h"
int NITERMAX1 = 10, NITERMIN1 = 1;
double TOLERANCE1 = 1e-2;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats1;
#line 147 "./././axi-poisson1.h"
struct MGSolve1 {
  scalar * a, * b;
  double (* residual1) (scalar * a, scalar * b, scalar * res,
         void * data);
  void (* relax1) (scalar * da, scalar * res, int depth,
    void * data);
  void * data;

  int nrelax;
  scalar * res;
  int minlevel;
  double tolerance;
};

mgstats1 mg_solve1 (struct MGSolve1 p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    res = list_clone (p.b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats1 s = {0};
  double sum = 0.;
  foreach_stencil ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { _stencil_val(s,0,0,0); }}}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:sum)){
#line 186
foreach ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      sum += val(s,0,0,0);}}end_foreach();mpi_all_reduce_array(&sum,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
  
#line 189
s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual1 (p.a, p.b, res, p.data);






  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE1;
  for (s.i = 0;
       s.i < NITERMAX1 && (s.i < NITERMIN1 || s.resa > p.tolerance);
       s.i++) {
    mg_cycle1 (p.a, res, da, p.relax1, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual1 (p.a, p.b, res, p.data);
#line 221 "./././axi-poisson1.h"
    if (s.resa > p.tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = p.minlevel;


{scalar*_i=(scalar*)( res);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
    if(phase_flag3==0){
      foreach_stencil(){
          _stencil_val_a(resg,0,0,0); _stencil_val(s,0,0,0); 
      }end_foreach_stencil();
      {
#line 241
foreach(){
          val(resg,0,0,0) = val(s,0,0,0);
      }end_foreach();}
    }else{
        foreach_stencil(){
          _stencil_val_a(resl,0,0,0); _stencil_val(s,0,0,0); 
      }end_foreach_stencil();
        {
#line 245
foreach(){
          val(resl,0,0,0) = val(s,0,0,0);
      }end_foreach();}
    }
}}}



  if (s.resa > p.tolerance) {
#line 312 "./././axi-poisson1.h"
    scalar v = p.a[0];
    fprintf (ferr,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax), fflush (ferr);
  }




  if (!p.res)
    delete (res), pfree (res,__func__,__FILE__,__LINE__);
  delete (da), pfree (da,__func__,__FILE__,__LINE__);

  return s;
}
#line 350 "./././axi-poisson1.h"
struct Poisson1 {
  scalar a, b;
          vector alpha;
          scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;
};





static void relax1 (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson1 * p = (struct Poisson1 *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
#line 388 "./././axi-poisson1.h"
  scalar c = a;






  if(!is_constant(lambda) && !is_constant(alpha.x) && !is_constant(fm.x)){{foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
               {
                if(1==0){
                      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
                      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);


                      if(left_s | center_mix){
                              left_k = val(alpha.x,0,0,0);
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.x,1,0,0);
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
                      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);


                      if(left_s | center_mix){
                              left_k = val(alpha.y,0,0,0);
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.y,0,1,0);
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else if(is_constant(lambda) && !is_constant(alpha.x) && !is_constant(fm.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
               {
                if(1==0){
                      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
                      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);


                      if(left_s | center_mix){
                              left_k = val(alpha.x,0,0,0);
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.x,1,0,0);
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
                      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);


                      if(left_s | center_mix){
                              left_k = val(alpha.y,0,0,0);
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.y,0,1,0);
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else if(!is_constant(lambda) && is_constant(alpha.x) && !is_constant(fm.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
               {
                if(1==0){
                      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
                      d += _const_alpha.x + _const_alpha.x;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);


                      if(left_s | center_mix){
                              left_k = _const_alpha.x;
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.x;
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
                      d += _const_alpha.y + _const_alpha.y;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);


                      if(left_s | center_mix){
                              left_k = _const_alpha.y;
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.y;
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else if(is_constant(lambda) && is_constant(alpha.x) && !is_constant(fm.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
               {
                if(1==0){
                      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
                      d += _const_alpha.x + _const_alpha.x;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);


                      if(left_s | center_mix){
                              left_k = _const_alpha.x;
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.x;
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
                      d += _const_alpha.y + _const_alpha.y;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);


                      if(left_s | center_mix){
                              left_k = _const_alpha.y;
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.y;
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else if(!is_constant(lambda) && !is_constant(alpha.x) && is_constant(fm.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
               {
                if(1==0){
                      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
                      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;


                      if(left_s | center_mix){
                              left_k = val(alpha.x,0,0,0);
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.x,1,0,0);
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
                      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;


                      if(left_s | center_mix){
                              left_k = val(alpha.y,0,0,0);
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.y,0,1,0);
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else if(is_constant(lambda) && !is_constant(alpha.x) && is_constant(fm.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
               {
                if(1==0){
                      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
                      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;


                      if(left_s | center_mix){
                              left_k = val(alpha.x,0,0,0);
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.x,1,0,0);
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
                      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;


                      if(left_s | center_mix){
                              left_k = val(alpha.y,0,0,0);
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = val(alpha.y,0,1,0);
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else if(!is_constant(lambda) && is_constant(alpha.x) && is_constant(fm.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
               {
                if(1==0){
                      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
                      d += _const_alpha.x + _const_alpha.x;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;


                      if(left_s | center_mix){
                              left_k = _const_alpha.x;
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.x;
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
                      d += _const_alpha.y + _const_alpha.y;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;


                      if(left_s | center_mix){
                              left_k = _const_alpha.y;
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.y;
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);






  {
#line 395
foreach_level_or_leaf (l) {
     if(val(css_test3_n,0,0,0)>=0.0){



          bool ff_flag = ((((val(ff,0,0,0)>=0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
          bool solid_flag = (val(css_test3_n,0,0,0)<1.0);
          if(ff_flag || solid_flag){
              double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
               {
                if(1==0){
                      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
                      d += _const_alpha.x + _const_alpha.x;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,1,0,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,-1,0,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                                    leftd = val(modphase0.x,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,-1,0,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,1,0,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,1,0,0);
                                value_left = val(a,-1,0,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;


                      if(left_s | center_mix){
                              left_k = _const_alpha.x;
                              value_left = val(a,-1,0,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.x;
                              value_right = val(a,1,0,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              } 
#line 404
{
                if(1==0){
                      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
                      d += _const_alpha.y + _const_alpha.y;
                }else{

                        double rightd;
                        double leftd;
                        double value_left;
                        double value_right;
                        bool left_s = false;
                        bool right_s =false;

                        bool center_mix = false;
                        if(solid_flag){
                            center_mix = true;
                        }
                        if(val(css_test3_n,0,1,0)<1.0){
                            right_s = true;
                        }
                        if(val(css_test3_n,0,-1,0)<1.0){
                            left_s = true;
                        }


                          if( l==level_interface){
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                                    leftd = val(modphase0.y,0,0,0);
                              }
                            if(fabs(rightd)<1e-2){
                                  rightd = 1.0;
                              }else if(fabs(rightd)>1.0){
                                  rightd = 1.0;
                              }else if(right_s | center_mix ){
                                  rightd = 1.0;
                              }
                              if(fabs(leftd)<1e-2){
                                  leftd = 1.0;
                              }else if(fabs(leftd)>1.0){
                                  leftd =1.0;
                              }else if(left_s | center_mix){
                                  leftd = 1.0;
                              }
                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0){
                                          value_left = 0.0;
                                    }else{
                                          value_left = val(a,0,-1,0);
                                    }





                                    if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                          value_right = 0.0;
                                    }else{
                                          value_right = val(a,0,1,0);
                                    }




                          }else{
                              rightd = 1.0;
                              leftd = 1.0;
                              value_right = val(a,0,1,0);
                                value_left = val(a,0,-1,0);






                          }
                      double left_k,right_k;
#line 499 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;


                      if(left_s | center_mix){
                              left_k = _const_alpha.y;
                              value_left = val(a,0,-1,0);
                        }
                        if(right_s | center_mix){
                              right_k = _const_alpha.y;
                              value_right = val(a,0,1,0);
                        }






                      n += 2.0*(right_k)/((rightd+leftd)*(rightd))*value_right + 2.0*(left_k)/((rightd+leftd)*(leftd))*value_left;
                      d += 2.0*(right_k)/((rightd+leftd)*(rightd)) + 2.0*(left_k)/((rightd+leftd)*(leftd));




                }
              }
#line 535 "./././axi-poisson1.h"
                val(c,0,0,0) = n/d;
      }else{
          val(c,0,0,0) =0.0;
      }
    }else{
       val(c,0,0,0) = 0.0;
    }
  }end_foreach_level_or_leaf();}}
#line 560 "./././axi-poisson1.h"
}






extern bool poisson_check;
static double residual1 (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson1 * p = (struct Poisson1 *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;



  double maxres = 0.;


  vector  g=new_face_vector("g");
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(g.x,0,0,0); _stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);           }}end__stencil_is_face_x()
#line 581
_stencil_is_face_y(){
    {_stencil_val_a(g.y,0,0,0); _stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);           }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 581
if(!is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(g.x,0,0,0) = val(alpha.x,0,0,0)*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta);}end_is_face_x()
#line 581
is_face_y(){
    val(g.y,0,0,0) = val(alpha.y,0,0,0)*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 581
foreach_face_generic(){is_face_x(){
    val(g.x,0,0,0) = _const_alpha.x*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta);}end_is_face_x()
#line 581
is_face_y(){
    val(g.y,0,0,0) = _const_alpha.y*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}
  foreach_stencil () {   


    
_stencil_val(css_test3_n,0,0,0);{{             
           _stencil_val(ff,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(ff,0,0,0);
{{
                _stencil_val_a(res,0,0,0); _stencil_val(b,0,0,0); _stencil_val(lambda,0,0,0);_stencil_val(a,0,0,0);  
                {
                  if(1==0){
                    _stencil_val_r(res,0,0,0);_stencil_val(g.x,1,0,0); _stencil_val(g.x,0,0,0);   
                  }else{          

            
                    
                    
                    
                    
                    
_stencil_val(css_test3_n,1,0,0); 
                         
                     
_stencil_val(css_test3_n,-1,0,0);



{{
                          if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                 _stencil_val(modphase1.x,0,0,0); 
                                
                          
#line 613
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                  _stencil_val(modphase0.x,0,0,0);
                                 
                          
#line 616
}  
                               
                           
                                
                          
                                
                            
                                
                           
                                
                          
                                
                          


_stencil_val(ff,0,0,0);_stencil_val(ff,-1,0,0);{ 
                                     

                              { 
_stencil_val(a,-1,0,0);
                                     
                              
#line 636
}}

_stencil_val(ff,0,0,0);_stencil_val(ff,1,0,0);{ 
                                     

                                { 
_stencil_val(a,1,0,0);
                                     
                                
#line 643
}}
                           
                           
                                 

                                   
                      
#line 644
}{  
                           
                            
_stencil_val(a,-1,0,0);
                              _stencil_val(a,1,0,0);
                             
                      
#line 649
}}   
                         
                     
                     
                     

                    





                   
#line 655
_stencil_val(a,0,0,0); 

                  
#line 674
_stencil_val(fm.x,0,0,0); 
#line 674 "./././axi-poisson1.h"
                                 
_stencil_val(fm.x,1,0,0);

{ 
_stencil_val(alpha.x,0,0,0);
                          _stencil_val(a,-1,0,0);
                         
                  
#line 680
}
{ 
_stencil_val(alpha.x,1,0,0);
                          _stencil_val(a,1,0,0);
                         

                  
#line 685
} 
                                 

                    
                    






                
#line 692
if(phase_flag3==0){
                    _stencil_val_a(smallmodg.x,0,0,0);
                    _stencil_val_a(bigmodg.x,0,0,0);
                }else{
                    _stencil_val_a(smallmodl.x,0,0,0);
                    _stencil_val_a(bigmodl.x,0,0,0);
                }
                  _stencil_val_r(res,0,0,0);    


                  }
                }
#line 591
{
                  if(1==0){
                    _stencil_val_r(res,0,0,0);_stencil_val(g.y,0,1,0); _stencil_val(g.y,0,0,0);   
                  }else{          

            
                    
                    
                    
                    
                    
_stencil_val(css_test3_n,0,1,0); 
                         
                     
_stencil_val(css_test3_n,0,-1,0);



{{
                          if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                 _stencil_val(modphase1.y,0,0,0); 
                                
                          
#line 613
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                  _stencil_val(modphase0.y,0,0,0);
                                 
                          
#line 616
}  
                               
                           
                                
                          
                                
                            
                                
                           
                                
                          
                                
                          


_stencil_val(ff,0,0,0);_stencil_val(ff,0,-1,0);{ 
                                     

                              { 
_stencil_val(a,0,-1,0);
                                     
                              
#line 636
}}

_stencil_val(ff,0,0,0);_stencil_val(ff,0,1,0);{ 
                                     

                                { 
_stencil_val(a,0,1,0);
                                     
                                
#line 643
}}
                           
                           
                                 

                                   
                      
#line 644
}{  
                           
                            
_stencil_val(a,0,-1,0);
                              _stencil_val(a,0,1,0);
                             
                      
#line 649
}}   
                         
                     
                     
                     

                    





                   
#line 655
_stencil_val(a,0,0,0); 

                  
#line 674
_stencil_val(fm.y,0,0,0); 
#line 674 "./././axi-poisson1.h"
                                 
_stencil_val(fm.y,0,1,0);

{ 
_stencil_val(alpha.y,0,0,0);
                          _stencil_val(a,0,-1,0);
                         
                  
#line 680
}
{ 
_stencil_val(alpha.y,0,1,0);
                          _stencil_val(a,0,1,0);
                         

                  
#line 685
} 
                                 

                    
                    






                
#line 692
if(phase_flag3==0){
                    _stencil_val_a(smallmodg.y,0,0,0);
                    _stencil_val_a(bigmodg.y,0,0,0);
                }else{
                    _stencil_val_a(smallmodl.y,0,0,0);
                    _stencil_val_a(bigmodl.y,0,0,0);
                }
                  _stencil_val_r(res,0,0,0);    


                  }
                }
            } {_stencil_val(ff,0,0,0);{{
                  _stencil_val_a(a,0,0,0);  
                  _stencil_val_a(res,0,0,0);  
             }{
                  _stencil_val_a(a,0,0,0);  
                    _stencil_val_a(res,0,0,0);  
                }}}}
           
_stencil_val(res,0,0,0);{
_stencil_val(res,0,0,0); 
                    



                
#line 717
}

                    
    
#line 718
}{

       _stencil_val_a(res,0,0,0);  
    }}
    
  
#line 722
}end_foreach_stencil();
  
#line 583
if(!is_constant(lambda) && !is_constant(fm.x) && !is_constant(alpha.x)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);

                  if(left_s || solid_flag){
                        left_k = val(alpha.x,0,0,0);
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.x,1,0,0);
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);

                  if(left_s || solid_flag){
                        left_k = val(alpha.y,0,0,0);
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.y,0,1,0);
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else if(is_constant(lambda) && !is_constant(fm.x) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);

                  if(left_s || solid_flag){
                        left_k = val(alpha.x,0,0,0);
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.x,1,0,0);
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);

                  if(left_s || solid_flag){
                        left_k = val(alpha.y,0,0,0);
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.y,0,1,0);
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else if(!is_constant(lambda) && is_constant(fm.x) && !is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;

                  if(left_s || solid_flag){
                        left_k = val(alpha.x,0,0,0);
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.x,1,0,0);
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;

                  if(left_s || solid_flag){
                        left_k = val(alpha.y,0,0,0);
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.y,0,1,0);
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else if(is_constant(lambda) && is_constant(fm.x) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;

                  if(left_s || solid_flag){
                        left_k = val(alpha.x,0,0,0);
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.x,1,0,0);
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;

                  if(left_s || solid_flag){
                        left_k = val(alpha.y,0,0,0);
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = val(alpha.y,0,1,0);
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else if(!is_constant(lambda) && !is_constant(fm.x) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);

                  if(left_s || solid_flag){
                        left_k = _const_alpha.x;
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.x;
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);

                  if(left_s || solid_flag){
                        left_k = _const_alpha.y;
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.y;
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else if(is_constant(lambda) && !is_constant(fm.x) && is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.x,0,0,0);
                                right_k = k_value*val(fm.x,1,0,0);

                  if(left_s || solid_flag){
                        left_k = _const_alpha.x;
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.x;
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*val(fm.y,0,0,0);
                                right_k = k_value*val(fm.y,0,1,0);

                  if(left_s || solid_flag){
                        left_k = _const_alpha.y;
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.y;
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else if(!is_constant(lambda) && is_constant(fm.x) && is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;

                  if(left_s || solid_flag){
                        left_k = _const_alpha.x;
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.x;
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;

                  if(left_s || solid_flag){
                        left_k = _const_alpha.y;
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.y;
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 583
foreach () {


    bool solid_flag = false;
    if(val(css_test3_n,0,0,0)>=1){
           bool ff_flag = ((((val(ff,0,0,0)>0.5 ) && (phase_flag3==1)) || ((val(ff,0,0,0)<0.5 ) && (phase_flag3==0))) && (fabs(val(ff,0,0,0)-0.5)>1e-6));
           if(ff_flag){
                val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
                {
                  if(1==0){
                    val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,1,0,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,-1,0,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.x,1,0,0);
                                leftd = val(modphase1.x,0,0,0);
                          }else{
                                rightd = val(modphase0.x,1,0,0);
                                leftd = val(modphase0.x,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,-1,0,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,-1,0,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,1,0,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,1,0,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,-1,0,0);
                            value_right = val(a,1,0,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.x;
                                right_k = k_value*_const_fm.x;

                  if(left_s || solid_flag){
                        left_k = _const_alpha.x;
                        value_left = val(a,-1,0,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.x;
                        value_right = val(a,1,0,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.x,0,0,0)=leftd;
                    val(bigmodg.x,0,0,0)=rightd;
                }else{
                    val(smallmodl.x,0,0,0)=leftd;
                    val(bigmodl.x,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
#line 591
{
                  if(1==0){
                    val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;
                  }else{

            double rightd;
                    double leftd;
                    double value_left;
                    double value_right;
                    bool left_s = false;
                    bool right_s = false;
                     if(val(css_test3_n,0,1,0)<1.0){
                        right_s = true;
                     }
                     if(val(css_test3_n,0,-1,0)<1.0){
                        left_s = true;
                     }

                    if(level==level_interface){
                          if(phase_flag3==1){
                                rightd = val(modphase1.y,0,1,0);
                                leftd = val(modphase1.y,0,0,0);
                          }else{
                                rightd = val(modphase0.y,0,1,0);
                                leftd = val(modphase0.y,0,0,0);
                          }
                          if(fabs(rightd)<1e-2){
                              rightd = 1.0;
                          }else if(fabs(rightd)>1.0){
                              rightd = 1.0;
                          }else if(right_s || solid_flag){
                              rightd = 1.0;
                          }
                          if(fabs(leftd)<1e-2){
                              leftd = 1.0;
                          }else if(fabs(leftd)>1.0){
                              leftd =1.0;
                          }else if(left_s || solid_flag){
                              leftd = 1.0;
                          }
                              if(((val(ff,0,0,0)>0.5)^(val(ff,0,-1,0)>0.5)) && fabs(leftd)<1.0 ){
                                    value_left = Tsat00;

                              }else{
                                    value_left = val(a,0,-1,0);
                              }

                                if(((val(ff,0,0,0)>0.5)^(val(ff,0,1,0)>0.5)) && fabs(rightd)<1.0 ){
                                    value_right = Tsat00;

                                }else{
                                    value_right = val(a,0,1,0);
                                }
                      }else{
                          rightd = 1.0;
                          leftd = 1.0;
                            value_left = val(a,0,-1,0);
                            value_right = val(a,0,1,0);
                      }





                  double value_center = val(a,0,0,0);

                  double left_k,right_k;
#line 674 "./././axi-poisson1.h"
                                left_k = k_value*_const_fm.y;
                                right_k = k_value*_const_fm.y;

                  if(left_s || solid_flag){
                        left_k = _const_alpha.y;
                        value_left = val(a,0,-1,0);
                  }
                  if(right_s || solid_flag){
                        right_k = _const_alpha.y;
                        value_right = val(a,0,1,0);

                  }






                if(phase_flag3==0){
                    val(smallmodg.y,0,0,0)=leftd;
                    val(bigmodg.y,0,0,0)=rightd;
                }else{
                    val(smallmodl.y,0,0,0)=leftd;
                    val(bigmodl.y,0,0,0)=rightd;
                }
                  val(res,0,0,0) -= (2.0*(right_k)*(value_right-value_center)/(Delta*rightd) - 2.0*(left_k)*(value_center-value_left)/(Delta*leftd))/((rightd+leftd)*Delta);


                  }
                }
            }else if(fabs(val(ff,0,0,0)-0.5)<=1e-6){
                  val(a,0,0,0) = Tsat00;
                  val(res,0,0,0) = 0.0;
             }else{
                  val(a,0,0,0) = Tsat00;
                    val(res,0,0,0) = 0.0;
                }

                if (fabs (val(res,0,0,0)) > maxres){
                  maxres = fabs (val(res,0,0,0));



                }
    }else{

       val(res,0,0,0) = 0.0;
    }
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 722
}
#line 742 "./././axi-poisson1.h"
  if(poisson_check){
      if(pid()==0){
            char name93[80];
            sprintf(name93,"poisson_check.dat");
            FILE * fp93 = fopen(name93,"a");
            int num2=0;
              fprintf (fp93," %g\n", maxres);
            fclose(fp93);
      }
  }
  {delete((scalar*)((vector[]){g,{{-1},{-1}}}));return maxres;}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}
#line 764 "./././axi-poisson1.h"
mgstats1 poisson1 (struct Poisson1 p)
{
  if(phase_flag3==1){
      k_value = Tkl;
  }else{
      k_value = Tkg;
  }
   p.minlevel = minl;





  if (!p.alpha.x.i)
    p.alpha = unityf;
  if (!p.lambda.i)
    p.lambda = zeroc;




  vector alpha = p.alpha;
  scalar lambda = p.lambda;
  restriction (((scalar[]){alpha.x,alpha.y,lambda,{-1}}));





  double defaultol = TOLERANCE1;
  if (p.tolerance)
    TOLERANCE1 = p.tolerance;

  scalar a = p.a, b = p.b;
  mgstats1 s = mg_solve1 ((struct MGSolve1){((scalar[]){a,{-1}}), ((scalar[]){b,{-1}}), residual1, relax1,
   &p, p.nrelax, p.res, .minlevel = max(1, p.minlevel)});




  if (p.tolerance)
    TOLERANCE1 = defaultol;

  return s;
}
#line 827 "./././axi-poisson1.h"
struct Project1 {
  vector uf;
  scalar p;
  vector alpha;
  double dt;
  int nrelax;
};

     
mgstats1 project1 (struct Project1 q)
{tracing("project1","./././axi-poisson1.h",836);
  vector uf = q.uf;
  scalar p = q.p;
          vector alpha = q.alpha.x.i ? q.alpha : unityf;
  double dt = q.dt ? q.dt : 1.;
  int nrelax = q.nrelax ? q.nrelax : 4;






  scalar  div=new_scalar("div");
  foreach_stencil() {
    _stencil_val_a(div,0,0,0);  
    
      {_stencil_val_r(div,0,0,0); _stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);  }
      
#line 853
{_stencil_val_r(div,0,0,0); _stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);  }
    _stencil_val_r(div,0,0,0);  
  }end_foreach_stencil();
  {
#line 850
foreach() {
    val(div,0,0,0) = 0.;
    
      val(div,0,0,0) += val(uf.x,1,0,0) - val(uf.x,0,0,0);
      
#line 853
val(div,0,0,0) += val(uf.y,0,1,0) - val(uf.y,0,0,0);
    val(div,0,0,0) /= dt*Delta;
  }end_foreach();}
#line 881 "./././axi-poisson1.h"
  TOLERANCE1 = 1e-6;
  mgstats1 mgp = poisson1 ((struct Poisson1){p, div, alpha,
    .tolerance = TOLERANCE1, .nrelax = nrelax});




  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_r(uf.x,0,0,0);_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);            }}end__stencil_is_face_x()
#line 888
_stencil_is_face_y(){
    {_stencil_val_r(uf.y,0,0,0);_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);            }}end__stencil_is_face_y()}end_foreach_face_stencil();




  
#line 888
if(!is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*val(alpha.x,0,0,0)*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 888
is_face_y(){
    val(uf.y,0,0,0) -= dt*val(alpha.y,0,0,0)*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);




  {
#line 888
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*_const_alpha.x*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 888
is_face_y(){
    val(uf.y,0,0,0) -= dt*_const_alpha.y*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}

  {delete((scalar*)((scalar[]){div,{-1}}));{end_tracing("project1","./././axi-poisson1.h",891);return mgp;}}delete((scalar*)((scalar[]){div,{-1}}));
end_tracing("project1","./././axi-poisson1.h",892);}
#line 26 "././axi-diffusion1.h"
#line 39 "././axi-diffusion1.h"
extern int phase_flag3;

struct Diffusion1 {

  scalar f;
  double dt;

  vector D;
  scalar r, beta;
  scalar theta;
};

     
mgstats1 diffusion1 (struct Diffusion1 p)
{tracing("diffusion1","././axi-diffusion1.h",52);




  if (p.dt == 0.) {
    mgstats1 s = {0};
    {end_tracing("diffusion1","././axi-diffusion1.h",60);return s;}
  }




  scalar f = p.f,   r=(p.r).i?(p.r):new_scalar("r");




  const scalar idt =  new_const_scalar("idt",6, - 1./p.dt);
          scalar theta_idt = p.theta.i ? p.theta : idt;

  if (p.theta.i) {
    scalar theta_idt = p.theta;
    foreach_stencil()
      {_stencil_val_r(theta_idt,0,0,0); _stencil__val_constant(idt,0,0,0); }end_foreach_stencil();
    {
#line 76
foreach()
      val(theta_idt,0,0,0) *= _val_constant(idt,0,0,0);end_foreach();}
  }




  if (p.r.i)
    {
    
#line 84
foreach_stencil()
      {_stencil_val_a(r,0,0,0); _stencil_val(theta_idt,0,0,0);_stencil_val(f,0,0,0); _stencil_val(r,0,0,0);  }end_foreach_stencil();
#line 84
if(!is_constant(theta_idt)){{foreach()
      val(r,0,0,0) = val(theta_idt,0,0,0)*val(f,0,0,0) - val(r,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);{
#line 84
foreach()
      val(r,0,0,0) = _const_theta_idt*val(f,0,0,0) - val(r,0,0,0);end_foreach();}}}
  else {
    foreach_stencil()
      {_stencil_val_a(r,0,0,0); _stencil_val(theta_idt,0,0,0);_stencil_val(f,0,0,0); }end_foreach_stencil();
    
#line 87
if(!is_constant(theta_idt)){{foreach()
      val(r,0,0,0) = val(theta_idt,0,0,0)*val(f,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);
    {
#line 87
foreach()
      val(r,0,0,0) = _const_theta_idt*val(f,0,0,0);end_foreach();}}
  }






  scalar lambda = theta_idt;
  if (p.beta.i) {
    scalar beta = p.beta;
    foreach_stencil()
      {_stencil_val_r(beta,0,0,0); _stencil_val(theta_idt,0,0,0); }end_foreach_stencil();
    
#line 99
if(!is_constant(theta_idt)){{foreach()
      val(beta,0,0,0) += val(theta_idt,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);
    {
#line 99
foreach()
      val(beta,0,0,0) += _const_theta_idt;end_foreach();}}
    lambda = beta;
  }



double toleranceT;
if(phase_flag3==0){
      toleranceT=1e-5;
}else{
      toleranceT=2e-2;
}
  { mgstats1 _ret= poisson1 ((struct Poisson1){f, r, p.D, lambda, toleranceT});{if(!(p.r).i)delete((scalar*)((scalar[]){r,{-1}}));}{end_tracing("diffusion1","././axi-diffusion1.h",112);return _ret;}}{if(!(p.r).i)delete((scalar*)((scalar[]){r,{-1}}));}
end_tracing("diffusion1","././axi-diffusion1.h",113);}
#line 23 "template01.c"
#line 1 "./diffusion5.h"
#line 1 "././diffusion5.h"
#line 25 "././diffusion5.h"
#line 1 "./poisson5.h"
#line 1 "././poisson5.h"
#line 32 "././poisson5.h"
extern scalar poisson_source2;
extern scalar ff,css_test3_n;
extern scalar T;
extern int maxl;
void mg_cycle5 (scalar * a, scalar * res, scalar * da,
        void (* relax5) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = min (minlevel, maxlevel);
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {foreach_level_or_leaf (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = 0.;}}end_foreach_level_or_leaf();}





    else
      {foreach_level (l)
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = bilinear_embed(point, s);}}end_foreach_level();}





    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax5 (da, res, l, data);
      boundary_level (da, l);
    }
  }




  foreach_stencil() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 {_stencil_val_r(s,0,0,0); _stencil_val(ds,0,0,0); }}}
  }end_foreach_stencil();




  {
#line 88
foreach() {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 val(s,0,0,0) += val(ds,0,0,0);}}
  }end_foreach();}
}
#line 106 "././poisson5.h"
int NITERMAX5 = 100, NITERMIN5 = 1;
double TOLERANCE5 = 1e-3;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats5;
#line 129 "././poisson5.h"
struct MGSolve5 {
  scalar * a, * b;
  double (* residual5) (scalar * a, scalar * b, scalar * res,
         void * data);
  void (* relax5) (scalar * da, scalar * res, int depth,
    void * data);
  void * data;

  int nrelax;
  scalar * res;
  int minlevel;
  double tolerance;
};

mgstats5 mg_solve5 (struct MGSolve5 p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    res = list_clone (p.b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats5 s = {0};
  double sum = 0.;
  foreach_stencil ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { _stencil_val(s,0,0,0); }}}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:sum)){
#line 168
foreach ()
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      sum += val(s,0,0,0);}}end_foreach();mpi_all_reduce_array(&sum,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
  
#line 171
s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual5 (p.a, p.b, res, p.data);






  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE5;
  for (s.i = 0;
       s.i < NITERMAX5 && (s.i < NITERMIN5 || s.resa > p.tolerance);
       s.i++) {
    mg_cycle5 (p.a, res, da, p.relax5, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual5 (p.a, p.b, res, p.data);
#line 203 "././poisson5.h"
    if (s.resa > p.tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = p.minlevel;




  if (s.resa > p.tolerance) {
#line 281 "././poisson5.h"
    scalar v = p.a[0];
    fprintf (ferr,
      "poisson5--WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax), fflush (ferr);
  }




  if (!p.res)
    delete (res), pfree (res,__func__,__FILE__,__LINE__);
  delete (da), pfree (da,__func__,__FILE__,__LINE__);

  return s;
}
#line 319 "././poisson5.h"
struct Poisson5 {
  scalar a, b;
          vector alpha;
          scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;
};





static void relax5 (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson5 * p = (struct Poisson5 *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
#line 357 "././poisson5.h"
  scalar c = a;






  if(!is_constant(lambda) && !is_constant(alpha.x)){{foreach_level_or_leaf (l) {

      bool no_solid = (val(css_test3_n,0,0,0)>=1.0);
        if( (val(css_test3_n,0,0,0)<1.0) || no_solid){

                  double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
                   {
                    n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
                    d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
                  } 
#line 370
{
                    n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
                    d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
                  }
#line 385 "././poisson5.h"
                  if (!d)
                    val(c,0,0,0) = val(b,0,0,0) = 0.;
                  else
                      val(c,0,0,0) = n/d;

       }else{

             val(c,0,0,0) = 0.;
       }
  }end_foreach_level_or_leaf();}}else if(is_constant(lambda) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);






  {
#line 364
foreach_level_or_leaf (l) {

      bool no_solid = (val(css_test3_n,0,0,0)>=1.0);
        if( (val(css_test3_n,0,0,0)<1.0) || no_solid){

                  double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
                   {
                    n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
                    d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
                  } 
#line 370
{
                    n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
                    d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
                  }
#line 385 "././poisson5.h"
                  if (!d)
                    val(c,0,0,0) = val(b,0,0,0) = 0.;
                  else
                      val(c,0,0,0) = n/d;

       }else{

             val(c,0,0,0) = 0.;
       }
  }end_foreach_level_or_leaf();}}else if(!is_constant(lambda) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);






  {
#line 364
foreach_level_or_leaf (l) {

      bool no_solid = (val(css_test3_n,0,0,0)>=1.0);
        if( (val(css_test3_n,0,0,0)<1.0) || no_solid){

                  double n = - sq(Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*sq(Delta);
                   {
                    n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
                    d += _const_alpha.x + _const_alpha.x;
                  } 
#line 370
{
                    n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
                    d += _const_alpha.y + _const_alpha.y;
                  }
#line 385 "././poisson5.h"
                  if (!d)
                    val(c,0,0,0) = val(b,0,0,0) = 0.;
                  else
                      val(c,0,0,0) = n/d;

       }else{

             val(c,0,0,0) = 0.;
       }
  }end_foreach_level_or_leaf();}}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);






  {
#line 364
foreach_level_or_leaf (l) {

      bool no_solid = (val(css_test3_n,0,0,0)>=1.0);
        if( (val(css_test3_n,0,0,0)<1.0) || no_solid){

                  double n = - sq(Delta)*val(b,0,0,0), d = - _const_lambda*sq(Delta);
                   {
                    n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
                    d += _const_alpha.x + _const_alpha.x;
                  } 
#line 370
{
                    n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
                    d += _const_alpha.y + _const_alpha.y;
                  }
#line 385 "././poisson5.h"
                  if (!d)
                    val(c,0,0,0) = val(b,0,0,0) = 0.;
                  else
                      val(c,0,0,0) = n/d;

       }else{

             val(c,0,0,0) = 0.;
       }
  }end_foreach_level_or_leaf();}}
#line 412 "././poisson5.h"
}






static double residual5 (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson5 * p = (struct Poisson5 *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;



  double maxres = 0.;


  vector  g=new_face_vector("g");


  foreach_stencil () {
_stencil_val(css_test3_n,0,0,0);{{
              _stencil_val_a(res,0,0,0); _stencil_val(b,0,0,0); _stencil_val(lambda,0,0,0);_stencil_val(a,0,0,0);  
              {



        _stencil_val_r(res,0,0,0);_stencil_val(alpha.x,1,0,0);_stencil_val(a,1,0,0);_stencil_val(a,0,0,0);_stencil_val(alpha.x,0,0,0);_stencil_val(a,0,0,0);_stencil_val(a,-1,0,0);    


              }
#line 437
{



        _stencil_val_r(res,0,0,0);_stencil_val(alpha.y,0,1,0);_stencil_val(a,0,1,0);_stencil_val(a,0,0,0);_stencil_val(alpha.y,0,0,0);_stencil_val(a,0,0,0);_stencil_val(a,0,-1,0);    


              }







      }{
        _stencil_val_a(res,0,0,0);  
      }}
_stencil_val(res,0,0,0);
                {_stencil_val(res,0,0,0);   }
      
                  
  
#line 457
}end_foreach_stencil();


  
#line 434
if(!is_constant(lambda) && !is_constant(alpha.x)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 434
foreach () {
      if(val(css_test3_n,0,0,0)<1.0){
              val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
              {



        val(res,0,0,0) -= (2.0*(val(alpha.x,1,0,0))*(val(a,1,0,0)-val(a,0,0,0))/(Delta) - 2.0*(val(alpha.x,0,0,0))*(val(a,0,0,0)-val(a,-1,0,0))/(Delta))/(2.0*Delta);


              }
#line 437
{



        val(res,0,0,0) -= (2.0*(val(alpha.y,0,1,0))*(val(a,0,1,0)-val(a,0,0,0))/(Delta) - 2.0*(val(alpha.y,0,0,0))*(val(a,0,0,0)-val(a,0,-1,0))/(Delta))/(2.0*Delta);


              }







      }else{
        val(res,0,0,0) = 0.0;
      }
              if (fabs (val(res,0,0,0)) > maxres)
                maxres = fabs (val(res,0,0,0));
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 457
}else if(is_constant(lambda) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);


  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 434
foreach () {
      if(val(css_test3_n,0,0,0)<1.0){
              val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
              {



        val(res,0,0,0) -= (2.0*(val(alpha.x,1,0,0))*(val(a,1,0,0)-val(a,0,0,0))/(Delta) - 2.0*(val(alpha.x,0,0,0))*(val(a,0,0,0)-val(a,-1,0,0))/(Delta))/(2.0*Delta);


              }
#line 437
{



        val(res,0,0,0) -= (2.0*(val(alpha.y,0,1,0))*(val(a,0,1,0)-val(a,0,0,0))/(Delta) - 2.0*(val(alpha.y,0,0,0))*(val(a,0,0,0)-val(a,0,-1,0))/(Delta))/(2.0*Delta);


              }







      }else{
        val(res,0,0,0) = 0.0;
      }
              if (fabs (val(res,0,0,0)) > maxres)
                maxres = fabs (val(res,0,0,0));
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 457
}else if(!is_constant(lambda) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);


  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 434
foreach () {
      if(val(css_test3_n,0,0,0)<1.0){
              val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
              {



        val(res,0,0,0) -= (2.0*(_const_alpha.x)*(val(a,1,0,0)-val(a,0,0,0))/(Delta) - 2.0*(_const_alpha.x)*(val(a,0,0,0)-val(a,-1,0,0))/(Delta))/(2.0*Delta);


              }
#line 437
{



        val(res,0,0,0) -= (2.0*(_const_alpha.y)*(val(a,0,1,0)-val(a,0,0,0))/(Delta) - 2.0*(_const_alpha.y)*(val(a,0,0,0)-val(a,0,-1,0))/(Delta))/(2.0*Delta);


              }







      }else{
        val(res,0,0,0) = 0.0;
      }
              if (fabs (val(res,0,0,0)) > maxres)
                maxres = fabs (val(res,0,0,0));
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 457
}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);


  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres)){
#line 434
foreach () {
      if(val(css_test3_n,0,0,0)<1.0){
              val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
              {



        val(res,0,0,0) -= (2.0*(_const_alpha.x)*(val(a,1,0,0)-val(a,0,0,0))/(Delta) - 2.0*(_const_alpha.x)*(val(a,0,0,0)-val(a,-1,0,0))/(Delta))/(2.0*Delta);


              }
#line 437
{



        val(res,0,0,0) -= (2.0*(_const_alpha.y)*(val(a,0,1,0)-val(a,0,0,0))/(Delta) - 2.0*(_const_alpha.y)*(val(a,0,0,0)-val(a,0,-1,0))/(Delta))/(2.0*Delta);


              }







      }else{
        val(res,0,0,0) = 0.0;
      }
              if (fabs (val(res,0,0,0)) > maxres)
                maxres = fabs (val(res,0,0,0));
  }end_foreach();mpi_all_reduce_array(&maxres,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 457
}




  {delete((scalar*)((vector[]){g,{{-1},{-1}}}));return maxres;}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}
#line 474 "././poisson5.h"
mgstats5 poisson5 (struct Poisson5 p)
{






  if (!p.alpha.x.i)
    p.alpha = unityf;
  if (!p.lambda.i)
    p.lambda = zeroc;




  vector alpha = p.alpha;
  scalar lambda = p.lambda;
  restriction (((scalar[]){alpha.x,alpha.y,lambda,{-1}}));





  double defaultol = TOLERANCE5;
  if (p.tolerance)
    TOLERANCE5 = p.tolerance;

  scalar a = p.a, b = p.b;
#line 512 "././poisson5.h"
      TOLERANCE5 = 2e-2;

  mgstats5 s = mg_solve5 ((struct MGSolve5){((scalar[]){a,{-1}}), ((scalar[]){b,{-1}}), residual5, relax5,
   &p, p.nrelax, p.res, .minlevel = max(1, p.minlevel)});




  if (p.tolerance)
    TOLERANCE5 = defaultol;

  return s;
}
#line 543 "././poisson5.h"
struct Project5 {
  vector uf;
  scalar p;
  vector alpha;
  double dt;
  int nrelax;
};

     
mgstats5 project5 (struct Project5 q)
{tracing("project5","././poisson5.h",552);
  vector uf = q.uf;
  scalar p = q.p;
          vector alpha = q.alpha.x.i ? q.alpha : unityf;
  double dt = q.dt ? q.dt : 1.;
  int nrelax = q.nrelax ? q.nrelax : 4;






  scalar  div=new_scalar("div");
  foreach_stencil() {
    _stencil_val_a(div,0,0,0);  
    
      {_stencil_val_r(div,0,0,0); _stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);  }
      
#line 569
{_stencil_val_r(div,0,0,0); _stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);  }
    _stencil_val_r(div,0,0,0);  
  }end_foreach_stencil();
  {
#line 566
foreach() {
    val(div,0,0,0) = 0.;
    
      val(div,0,0,0) += val(uf.x,1,0,0) - val(uf.x,0,0,0);
      
#line 569
val(div,0,0,0) += val(uf.y,0,1,0) - val(uf.y,0,0,0);
    val(div,0,0,0) /= dt*Delta;
  }end_foreach();}
#line 582 "././poisson5.h"
  mgstats5 mgp = poisson5 ((struct Poisson5){p, div, alpha,
    .tolerance = TOLERANCE5/sq(dt), .nrelax = nrelax});




  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_r(uf.x,0,0,0);_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);            }}end__stencil_is_face_x()
#line 588
_stencil_is_face_y(){
    {_stencil_val_r(uf.y,0,0,0);_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);            }}end__stencil_is_face_y()}end_foreach_face_stencil();




  
#line 588
if(!is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*val(alpha.x,0,0,0)*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 588
is_face_y(){
    val(uf.y,0,0,0) -= dt*val(alpha.y,0,0,0)*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);




  {
#line 588
foreach_face_generic(){is_face_x(){
    val(uf.x,0,0,0) -= dt*_const_alpha.x*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}end_is_face_x()
#line 588
is_face_y(){
    val(uf.y,0,0,0) -= dt*_const_alpha.y*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}end_is_face_y()}end_foreach_face_generic();}}

  {delete((scalar*)((scalar[]){div,{-1}}));{end_tracing("project5","././poisson5.h",591);return mgp;}}delete((scalar*)((scalar[]){div,{-1}}));
end_tracing("project5","././poisson5.h",592);}
#line 26 "././diffusion5.h"
#line 39 "././diffusion5.h"
struct Diffusion5 {

  scalar f;
  double dt;

  vector D;
  scalar r, beta;
  scalar theta;
};

     
mgstats5 diffusion5 (struct Diffusion5 p)
{tracing("diffusion5","././diffusion5.h",50);




  if (p.dt == 0.) {
    mgstats5 s = {0};
    {end_tracing("diffusion5","././diffusion5.h",58);return s;}
  }




  scalar f = p.f,   r=(p.r).i?(p.r):new_scalar("r");




  const scalar idt =  new_const_scalar("idt",7, - 1./p.dt);
          scalar theta_idt = p.theta.i ? p.theta : idt;

  if (p.theta.i) {
    scalar theta_idt = p.theta;
    foreach_stencil()
      {_stencil_val_r(theta_idt,0,0,0); _stencil__val_constant(idt,0,0,0); }end_foreach_stencil();
    {
#line 74
foreach()
      val(theta_idt,0,0,0) *= _val_constant(idt,0,0,0);end_foreach();}
  }




  if (p.r.i)
    {
    
#line 82
foreach_stencil()
      {_stencil_val_a(r,0,0,0); _stencil_val(theta_idt,0,0,0);_stencil_val(f,0,0,0); _stencil_val(r,0,0,0);  }end_foreach_stencil();
#line 82
if(!is_constant(theta_idt)){{foreach()
      val(r,0,0,0) = val(theta_idt,0,0,0)*val(f,0,0,0) - val(r,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);{
#line 82
foreach()
      val(r,0,0,0) = _const_theta_idt*val(f,0,0,0) - val(r,0,0,0);end_foreach();}}}
  else
    {
    
#line 85
foreach_stencil()
      {_stencil_val_a(r,0,0,0); _stencil_val(theta_idt,0,0,0);_stencil_val(f,0,0,0); }end_foreach_stencil();
#line 85
if(!is_constant(theta_idt)){{foreach()
      val(r,0,0,0) = val(theta_idt,0,0,0)*val(f,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);{
#line 85
foreach()
      val(r,0,0,0) = _const_theta_idt*val(f,0,0,0);end_foreach();}}}




  scalar lambda = theta_idt;
  if (p.beta.i) {
    scalar beta = p.beta;
    foreach_stencil()
      {_stencil_val_r(beta,0,0,0); _stencil_val(theta_idt,0,0,0); }end_foreach_stencil();
    
#line 94
if(!is_constant(theta_idt)){{foreach()
      val(beta,0,0,0) += val(theta_idt,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);
    {
#line 94
foreach()
      val(beta,0,0,0) += _const_theta_idt;end_foreach();}}
    lambda = beta;
  }




  { mgstats5 _ret= poisson5 ((struct Poisson5){f, r, p.D, lambda});{if(!(p.r).i)delete((scalar*)((scalar[]){r,{-1}}));}{end_tracing("diffusion5","././diffusion5.h",102);return _ret;}}{if(!(p.r).i)delete((scalar*)((scalar[]){r,{-1}}));}
end_tracing("diffusion5","././diffusion5.h",103);}
#line 24 "template01.c"
#line 1 "./my-diffusion.h"
#line 1 "././my-diffusion.h"
#line 25 "././my-diffusion.h"
#line 1 "././my-poisson.h"
#line 26 "././my-diffusion.h"
#line 39 "././my-diffusion.h"
struct Diffusion {

  scalar f;
  double dt;

  vector D;
  scalar r, beta;
  scalar theta;
};

     
mgstats diffusion (struct Diffusion p)
{tracing("diffusion","././my-diffusion.h",50);




  if (p.dt == 0.) {
    mgstats s = {0};
    {end_tracing("diffusion","././my-diffusion.h",58);return s;}
  }




  scalar f = p.f,   r=(p.r).i?(p.r):new_scalar("r");




  const scalar idt =  new_const_scalar("idt",8, - 1./p.dt);
          scalar theta_idt = p.theta.i ? p.theta : idt;

  if (p.theta.i) {
    scalar theta_idt = p.theta;
    foreach_stencil()
      {_stencil_val_r(theta_idt,0,0,0); _stencil__val_constant(idt,0,0,0); }end_foreach_stencil();
    {
#line 74
foreach()
      val(theta_idt,0,0,0) *= _val_constant(idt,0,0,0);end_foreach();}
  }




  if (p.r.i)
    {
    
#line 82
foreach_stencil()
      {_stencil_val_a(r,0,0,0); _stencil_val(theta_idt,0,0,0);_stencil_val(f,0,0,0); _stencil_val(r,0,0,0);  }end_foreach_stencil();
#line 82
if(!is_constant(theta_idt)){{foreach()
      val(r,0,0,0) = val(theta_idt,0,0,0)*val(f,0,0,0) - val(r,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);{
#line 82
foreach()
      val(r,0,0,0) = _const_theta_idt*val(f,0,0,0) - val(r,0,0,0);end_foreach();}}}
  else
    {
    
#line 85
foreach_stencil()
      {_stencil_val_a(r,0,0,0); _stencil_val(theta_idt,0,0,0);_stencil_val(f,0,0,0); }end_foreach_stencil();
#line 85
if(!is_constant(theta_idt)){{foreach()
      val(r,0,0,0) = val(theta_idt,0,0,0)*val(f,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);{
#line 85
foreach()
      val(r,0,0,0) = _const_theta_idt*val(f,0,0,0);end_foreach();}}}




  scalar lambda = theta_idt;
  if (p.beta.i) {
    scalar beta = p.beta;
    foreach_stencil()
      {_stencil_val_r(beta,0,0,0); _stencil_val(theta_idt,0,0,0); }end_foreach_stencil();
    
#line 94
if(!is_constant(theta_idt)){{foreach()
      val(beta,0,0,0) += val(theta_idt,0,0,0);end_foreach();}}else {double _const_theta_idt=_constant[theta_idt.i-_NVARMAX];NOT_UNUSED(_const_theta_idt);
    {
#line 94
foreach()
      val(beta,0,0,0) += _const_theta_idt;end_foreach();}}
    lambda = beta;
  }




  { mgstats _ret= poisson ((struct Poisson){f, r, p.D, lambda});{if(!(p.r).i)delete((scalar*)((scalar[]){r,{-1}}));}{end_tracing("diffusion","././my-diffusion.h",102);return _ret;}}{if(!(p.r).i)delete((scalar*)((scalar[]){r,{-1}}));}
end_tracing("diffusion","././my-diffusion.h",103);}
#line 25 "template01.c"
#line 1 "./my-tension.h"
#line 1 "././my-tension.h"
#line 15 "././my-tension.h"
#line 1 "./iforce.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
#line 20 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"








static int defaults_5_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}

      static int defaults_5(const int i,const double t,Event *_ev){tracing("defaults_5","/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",30); {
  if (is_constant(a.x)) {
    a = new_face_vector("a");
    foreach_face_stencil(){_stencil_is_face_x(){
      {_stencil_val_a(a.x,0,0,0);  }}end__stencil_is_face_x()
#line 33
_stencil_is_face_y(){
      {_stencil_val_a(a.y,0,0,0);  }}end__stencil_is_face_y()}end_foreach_face_stencil();
    
#line 33
if(!is_constant(a.x)){{foreach_face_generic(){is_face_x(){
      val(a.x,0,0,0) = 0.;}end_is_face_x()
#line 33
is_face_y(){
      val(a.y,0,0,0) = 0.;}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
    {
#line 33
foreach_face_generic(){is_face_x(){
      _const_a.x = 0.;}end_is_face_x()
#line 33
is_face_y(){
      _const_a.y = 0.;}end_is_face_y()}end_foreach_face_generic();}}
  }
}{end_tracing("defaults_5","/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",36);return 0;}end_tracing("defaults_5","/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",36);}






static int acceleration_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int acceleration_0(const int i,const double t,Event *_ev){tracing("acceleration_0","/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",43);
{





  scalar * list = NULL;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].phi.i) {
      list = list_add (list, f);






      foreach_stencil()
 {_stencil_val_a(f,0,0,0);_stencil_val(f,0,0,0);     }end_foreach_stencil();






      {
#line 60
foreach()
 val(f,0,0,0) = clamp (val(f,0,0,0), 0., 1.);end_foreach();}
    }}}
#line 72 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    _attribute[f.i].prolongation = _attribute[p.i].prolongation;
    _attribute[f.i].dirty = true;
  }}}
#line 86 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
  vector ia = a;
  foreach_face_stencil(){_stencil_is_face_x(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val(fm.x,0,0,0); {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);
   
#line 104
_stencil_val(phi,-1,0,0); 
#line 103
_stencil_val(phi,0,0,0);
   
#line 103
_stencil_val(phi,0,0,0); 
#line 102
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 101
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0);

 



_stencil_val_r(ia.x,0,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0);    
      }     }}}}end__stencil_is_face_x()
#line 87
_stencil_is_face_y(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val(fm.y,0,0,0); {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);
   
#line 104
_stencil_val(phi,0,-1,0); 
#line 103
_stencil_val(phi,0,0,0);
   
#line 103
_stencil_val(phi,0,0,0); 
#line 102
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 101
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0);

 



_stencil_val_r(ia.y,0,0,0); _stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0);    
      }     }}}}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 87
if(!is_constant(fm.x) && !is_constant(alpha.x)){{foreach_face_generic(){is_face_x(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && val(fm.x,0,0,0) > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,-1,0,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,-1,0,0) < HUGE ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += val(alpha.x,0,0,0)/(val(fm.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}end_is_face_x()
#line 87
is_face_y(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && val(fm.y,0,0,0) > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,0,-1,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,0,-1,0) < HUGE ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += val(alpha.y,0,0,0)/(val(fm.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}end_is_face_y()}end_foreach_face_generic();}}else if(is_constant(fm.x) && !is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  {
#line 87
foreach_face_generic(){is_face_x(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && _const_fm.x > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,-1,0,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,-1,0,0) < HUGE ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += val(alpha.x,0,0,0)/(_const_fm.x + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}end_is_face_x()
#line 87
is_face_y(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && _const_fm.y > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,0,-1,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,0,-1,0) < HUGE ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += val(alpha.y,0,0,0)/(_const_fm.y + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}end_is_face_y()}end_foreach_face_generic();}}else if(!is_constant(fm.x) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 87
foreach_face_generic(){is_face_x(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && val(fm.x,0,0,0) > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,-1,0,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,-1,0,0) < HUGE ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += _const_alpha.x/(val(fm.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}end_is_face_x()
#line 87
is_face_y(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && val(fm.y,0,0,0) > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,0,-1,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,0,-1,0) < HUGE ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += _const_alpha.y/(val(fm.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}end_is_face_y()}end_foreach_face_generic();}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  {
#line 87
foreach_face_generic(){is_face_x(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && _const_fm.x > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,-1,0,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,-1,0,0) < HUGE ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += _const_alpha.x/(_const_fm.x + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}end_is_face_x()
#line 87
is_face_y(){
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && _const_fm.y > 0.) {
#line 99 "/home/xiangbin2/basilisk_new/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < HUGE && val(phi,0,-1,0) < HUGE) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < HUGE ? val(phi,0,0,0) :
   val(phi,0,-1,0) < HUGE ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += _const_alpha.y/(_const_fm.y + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}end_is_face_y()}end_foreach_face_generic();}}






  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    _attribute[f.i].prolongation = fraction_refine;
    _attribute[f.i].dirty = true;
  }}}






  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    scalar phi = _attribute[f.i].phi;
    delete (((scalar[]){phi,{-1}}));
    _attribute[f.i].phi.i = 0;
  }}}
  pfree (list,__func__,__FILE__,__LINE__);
}{end_tracing("acceleration_0","/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",131);return 0;}end_tracing("acceleration_0","/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",131);}
#line 16 "././my-tension.h"






#line 36 "././my-tension.h"
extern int stefan_flat;
static int stability_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int stability_1(const int i,const double t,Event *_ev){tracing("stability_1","././my-tension.h",37);
{





  double amin = HUGE, amax = -HUGE, dmin = HUGE;
  foreach_face_stencil (){_stencil_is_face_x(){
    {_stencil_val(fm.x,0,0,0); {
_stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); }
_stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); }   
         
         

             




    
#line 55
}   }}end__stencil_is_face_x()
#line 45
_stencil_is_face_y(){
    {_stencil_val(fm.y,0,0,0); {
_stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); }
_stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); }   
         
         

             




    
#line 55
}   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  
#line 45
if(!is_constant(fm.x) && !is_constant(alpha.x)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(min:dmin) reduction(max:amax)reduction(min:amin)){
#line 45
foreach_face_generic (){is_face_x(){
    if (val(fm.x,0,0,0) > 0.) {
      if (val(alpha.x,0,0,0)/val(fm.x,0,0,0) > amax) amax = val(alpha.x,0,0,0)/val(fm.x,0,0,0);
      if (val(alpha.x,0,0,0)/val(fm.x,0,0,0) < amin) amin = val(alpha.x,0,0,0)/val(fm.x,0,0,0);

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_x()
#line 45
is_face_y(){
    if (val(fm.y,0,0,0) > 0.) {
      if (val(alpha.y,0,0,0)/val(fm.y,0,0,0) > amax) amax = val(alpha.y,0,0,0)/val(fm.y,0,0,0);
      if (val(alpha.y,0,0,0)/val(fm.y,0,0,0) < amin) amin = val(alpha.y,0,0,0)/val(fm.y,0,0,0);

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dmin,double,MPI_MIN,1);mpi_all_reduce_array(&amax,double,MPI_MAX,1);mpi_all_reduce_array(&amin,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 55
}else if(is_constant(fm.x) && !is_constant(alpha.x)){struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(min:dmin) reduction(max:amax)reduction(min:amin)){
#line 45
foreach_face_generic (){is_face_x(){
    if (_const_fm.x > 0.) {
      if (val(alpha.x,0,0,0)/_const_fm.x > amax) amax = val(alpha.x,0,0,0)/_const_fm.x;
      if (val(alpha.x,0,0,0)/_const_fm.x < amin) amin = val(alpha.x,0,0,0)/_const_fm.x;

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_x()
#line 45
is_face_y(){
    if (_const_fm.y > 0.) {
      if (val(alpha.y,0,0,0)/_const_fm.y > amax) amax = val(alpha.y,0,0,0)/_const_fm.y;
      if (val(alpha.y,0,0,0)/_const_fm.y < amin) amin = val(alpha.y,0,0,0)/_const_fm.y;

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dmin,double,MPI_MIN,1);mpi_all_reduce_array(&amax,double,MPI_MAX,1);mpi_all_reduce_array(&amin,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 55
}else if(!is_constant(fm.x) && is_constant(alpha.x)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(min:dmin) reduction(max:amax)reduction(min:amin)){
#line 45
foreach_face_generic (){is_face_x(){
    if (val(fm.x,0,0,0) > 0.) {
      if (_const_alpha.x/val(fm.x,0,0,0) > amax) amax = _const_alpha.x/val(fm.x,0,0,0);
      if (_const_alpha.x/val(fm.x,0,0,0) < amin) amin = _const_alpha.x/val(fm.x,0,0,0);

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_x()
#line 45
is_face_y(){
    if (val(fm.y,0,0,0) > 0.) {
      if (_const_alpha.y/val(fm.y,0,0,0) > amax) amax = _const_alpha.y/val(fm.y,0,0,0);
      if (_const_alpha.y/val(fm.y,0,0,0) < amin) amin = _const_alpha.y/val(fm.y,0,0,0);

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dmin,double,MPI_MIN,1);mpi_all_reduce_array(&amax,double,MPI_MAX,1);mpi_all_reduce_array(&amin,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 55
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(min:dmin) reduction(max:amax)reduction(min:amin)){
#line 45
foreach_face_generic (){is_face_x(){
    if (_const_fm.x > 0.) {
      if (_const_alpha.x/_const_fm.x > amax) amax = _const_alpha.x/_const_fm.x;
      if (_const_alpha.x/_const_fm.x < amin) amin = _const_alpha.x/_const_fm.x;

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_x()
#line 45
is_face_y(){
    if (_const_fm.y > 0.) {
      if (_const_alpha.y/_const_fm.y > amax) amax = _const_alpha.y/_const_fm.y;
      if (_const_alpha.y/_const_fm.y < amin) amin = _const_alpha.y/_const_fm.y;

          if (Delta < dmin) dmin = Delta;




    }}end_is_face_y()}end_foreach_face_generic();mpi_all_reduce_array(&dmin,double,MPI_MIN,1);mpi_all_reduce_array(&amax,double,MPI_MAX,1);mpi_all_reduce_array(&amin,double,MPI_MIN,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 55
}
  double rhom = (1./amin + 1./amax)/2.;





  double sigma = 0.;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){
    sigma += _attribute[c.i].sigma;}}
  if (sigma) {
    double dt = sqrt (rhom*cube(dmin)/(3.14159265358979*sigma));
    if (dt < dtmax)
      dtmax = dt;
  }
}{end_tracing("stability_1","././my-tension.h",70);return 0;}end_tracing("stability_1","././my-tension.h",70);}







static int acceleration_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int acceleration_1(const int i,const double t,Event *_ev){tracing("acceleration_1","././my-tension.h",78);
{




  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].sigma) {





      scalar phi = _attribute[f.i].phi;
      if (phi.i)

   curvature ((struct Curvature){f_height, phi, _attribute[f.i].sigma, .add = true});
      else {
 phi = new_scalar("phi");

  curvature ((struct Curvature){f_height, phi, _attribute[f.i].sigma, .add = false});
 _attribute[f.i].phi = phi;
      }
    }}}
}{end_tracing("acceleration_1","././my-tension.h",102);return 0;}end_tracing("acceleration_1","././my-tension.h",102);}
#line 26 "template01.c"
#line 1 "./reduced.h"
#line 1 "././reduced.h"
#line 19 "././reduced.h"
coord G = {0.,0.,0.}, Z = {0.,0.,0.};
#line 36 "././reduced.h"
static int acceleration_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int acceleration_2(const int i,const double t,Event *_ev){tracing("acceleration_2","././reduced.h",36);
{
  scalar phi = _attribute[ff.i].phi;
  coord G1;
  
    G1.x = (Trhog - Trhol)*G.x;
    
#line 41
G1.y = (Trhog - Trhol)*G.y;

  if (phi.i)
    position ((struct Position){ff, phi, G1, Z, .add = true});
  else {
    phi = new_scalar("phi");
    position ((struct Position){ff, phi, G1, Z, .add = false});
    _attribute[ff.i].phi = phi;
  }
}{end_tracing("acceleration_2","././reduced.h",50);return 0;}end_tracing("acceleration_2","././reduced.h",50);}
#line 27 "template01.c"
#line 1 "./poisson-ps-usf2-2.h"
#line 1 "././poisson-ps-usf2-2.h"
extern scalar ff;
extern int globali;
extern int minl;


extern scalar res_ps;
extern scalar topo_mask_s;

extern bool flag_topos_advect_uf;
extern scalar intersect_true;
struct Linear_ps {
  vector alpha_temp;
  scalar ps;
  vector usf;
  scalar topo_mask;
  scalar source;
  int level_interface;
  double dt;
};

void poisson_ps_usf1 (struct Linear_ps q) {



     vector alpha_temp = q.alpha_temp;
     scalar ps = q.ps;
     vector usf = q.usf;
     scalar topo_mask = q.topo_mask;
     scalar source = q.source;
     int level_interface = q.level_interface;
     double dt = q.dt;
#line 50 "././poisson-ps-usf2-2.h"
     vector  Alef=new_vector("Alef"), Arigh=new_vector("Arigh");
     scalar  A3=new_scalar("A3"), A4=new_scalar("A4");
     foreach_stencil(){
        {
           _stencil_val_a(Alef.x,0,0,0);
           _stencil_val_a(Arigh.x,0,0,0);
        }
#line 53
{
           _stencil_val_a(Alef.y,0,0,0);
           _stencil_val_a(Arigh.y,0,0,0);
        }
        _stencil_val_a(A3,0,0,0);
        _stencil_val_a(A4,0,0,0);
     }end_foreach_stencil();
     {
#line 52
foreach(){
        {
           val(Alef.x,0,0,0)=0.0;
           val(Arigh.x,0,0,0)=0.0;
        }
#line 53
{
           val(Alef.y,0,0,0)=0.0;
           val(Arigh.y,0,0,0)=0.0;
        }
        val(A3,0,0,0)=0.0;
        val(A4,0,0,0)=0.0;
     }end_foreach();}
#line 90 "././poisson-ps-usf2-2.h"
     int numbercells=0;

     double Delta_interface = HUGE;
     scalar  numbercells3=new_scalar("numbercells3");
     foreach_stencil(){
        _stencil_val_a(numbercells3,0,0,0);
     }end_foreach_stencil();
     {
#line 94
foreach(){
        val(numbercells3,0,0,0)=0;
     }end_foreach();}
     foreach_stencil(){

_stencil_val(cs,0,0,0);{   
      
       _stencil_val(topo_mask,0,0,0);
{{
                       
                       _stencil_val_a(numbercells3,0,0,0);
                       bool lefedge= true;
                       bool righedge= true;
                       {


                          if(lefedge){
                              _stencil_val_a(Alef.x,0,0,0);_stencil_val(alpha_temp.x,0,0,0); 
                          }
                          if(righedge){
                              _stencil_val_a(Arigh.x,0,0,0);_stencil_val(alpha_temp.x,1,0,0); 
                          } 
_stencil_val(Alef.x,0,0,0);_stencil_val(Arigh.x,0,0,0); 
                             
                       
#line 117
}
#line 107
{


                          if(lefedge){
                              _stencil_val_a(Alef.y,0,0,0);_stencil_val(alpha_temp.y,0,0,0); 
                          }
                          if(righedge){
                              _stencil_val_a(Arigh.y,0,0,0);_stencil_val(alpha_temp.y,0,1,0); 
                          } 
_stencil_val(Alef.y,0,0,0);_stencil_val(Arigh.y,0,0,0); 
                             
                       
#line 117
}
                       _stencil_val_a(A3,0,0,0);  


                 _stencil_val_a(A4,0,0,0); 
             }{{
                      
                      _stencil_val_a(numbercells3,0,0,0);
                      { 
                            _stencil_val(topo_mask,-1,0,0); 
                            _stencil_val(topo_mask,1,0,0);    
                            
                            
{

                                                   _stencil_val_a(Alef.x,0,0,0);_stencil_val(alpha_temp.x,0,0,0); 
                              }
{

                                                   _stencil_val_a(Arigh.x,0,0,0);_stencil_val(alpha_temp.x,1,0,0); 
                              }
                                  
                                   
#line 138
_stencil_val(Alef.x,0,0,0);_stencil_val(Arigh.x,0,0,0);
                             
                      
#line 139
}
#line 125
{ 
                            _stencil_val(topo_mask,0,-1,0); 
                            _stencil_val(topo_mask,0,1,0);    
                            
                            
{

                                                   _stencil_val_a(Alef.y,0,0,0);_stencil_val(alpha_temp.y,0,0,0); 
                              }
{

                                                   _stencil_val_a(Arigh.y,0,0,0);_stencil_val(alpha_temp.y,0,1,0); 
                              }
                                  
                                   
#line 138
_stencil_val(Alef.y,0,0,0);_stencil_val(Arigh.y,0,0,0);
                             
                      
#line 139
}
                      _stencil_val_a(A3,0,0,0);  

                  if(!flag_topos_advect_uf){
                     _stencil_val_a(A4,0,0,0);_stencil_val(source,0,0,0); 
                  }else{
_stencil_val(topo_mask_s,0,0,0);_stencil_val(intersect_true,0,0,0);{{

                        _stencil_val_a(A4,0,0,0); 
                     }{
                        _stencil_val_a(A4,0,0,0);_stencil_val(source,0,0,0); 
                     }}
                       
                  
#line 151
}
             }{

                {
                     _stencil_val_a(Alef.x,0,0,0);
                     _stencil_val_a(Arigh.x,0,0,0);
                }
#line 154
{
                     _stencil_val_a(Alef.y,0,0,0);
                     _stencil_val_a(Arigh.y,0,0,0);
                }
                _stencil_val_a(A3,0,0,0);
                _stencil_val_a(A4,0,0,0);
            }}}
             




        
#line 165
}

              

     
#line 167
}end_foreach_stencil();
     
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:numbercells)){
#line 97
foreach(){

          if(level == level_interface && (val(cs,0,0,0)>0)){
      double temp_A3=0.0;
      int current = val(topo_mask,0,0,0);
          if(current==-1 || current==-2){
                       numbercells+=1;
                       val(numbercells3,0,0,0)=1;
                       bool lefedge= true;
                       bool righedge= true;
                       {


                          if(lefedge){
                              val(Alef.x,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.x,0,0,0);
                          }
                          if(righedge){
                              val(Arigh.x,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.x,1,0,0);
                          }
                             temp_A3 += val(Alef.x,0,0,0)+val(Arigh.x,0,0,0);
                       }
#line 107
{


                          if(lefedge){
                              val(Alef.y,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.y,0,0,0);
                          }
                          if(righedge){
                              val(Arigh.y,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.y,0,1,0);
                          }
                             temp_A3 += val(Alef.y,0,0,0)+val(Arigh.y,0,0,0);
                       }
                       val(A3,0,0,0) = temp_A3;


                 val(A4,0,0,0)= 0.0;
             }else if(current==0){
                      numbercells+=1;
                      val(numbercells3,0,0,0)=1;
                      {
                            int lef=val(topo_mask,-1,0,0);
                            int righ=val(topo_mask,1,0,0);
                            bool lefedge= true;
                            bool righedge= true;
                              if((lef==0 || lef==-1) && lefedge){

                                                   val(Alef.x,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.x,0,0,0);
                              }
                              if((righ==0 || righ==-1) && righedge){

                                                   val(Arigh.x,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.x,1,0,0);
                              }
                            temp_A3 += val(Alef.x,0,0,0)+val(Arigh.x,0,0,0);
                      }
#line 125
{
                            int lef=val(topo_mask,0,-1,0);
                            int righ=val(topo_mask,0,1,0);
                            bool lefedge= true;
                            bool righedge= true;
                              if((lef==0 || lef==-1) && lefedge){

                                                   val(Alef.y,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.y,0,0,0);
                              }
                              if((righ==0 || righ==-1) && righedge){

                                                   val(Arigh.y,0,0,0)= dt/(Delta*Delta)*val(alpha_temp.y,0,1,0);
                              }
                            temp_A3 += val(Alef.y,0,0,0)+val(Arigh.y,0,0,0);
                      }
                      val(A3,0,0,0) = temp_A3;

                  if(!flag_topos_advect_uf){
                     val(A4,0,0,0)= -val(source,0,0,0);
                  }else{
                     if(val(topo_mask_s,0,0,0)==0 && (val(intersect_true,0,0,0)==0)){

                        val(A4,0,0,0)= 0;
                     }else{
                        val(A4,0,0,0)= -val(source,0,0,0);
                     }
                  }
             }else{

                {
                     val(Alef.x,0,0,0)=0.0;
                     val(Arigh.x,0,0,0)=0.0;
                }
#line 154
{
                     val(Alef.y,0,0,0)=0.0;
                     val(Arigh.y,0,0,0)=0.0;
                }
                val(A3,0,0,0)=1.0;
                val(A4,0,0,0)=0.0;
            }




        }

     }end_foreach();mpi_all_reduce_array(&numbercells,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}




     
#line 172
int maxitt=2000,beta1=1.2;


    double ps_tolerance = 1e-4;
     foreach_stencil(){
        _stencil_val_a(ps,0,0,0);  
     }end_foreach_stencil();
     {
#line 176
foreach(){
        val(ps,0,0,0) = 0.0;
     }end_foreach();}
     foreach_face_stencil(){_stencil_is_face_x(){{
        _stencil_val_a(usf.x,0,0,0);  
     }}end__stencil_is_face_x()
#line 179
_stencil_is_face_y(){{
        _stencil_val_a(usf.y,0,0,0);  
     }}end__stencil_is_face_y()}end_foreach_face_stencil();
     {
#line 179
foreach_face_generic(){is_face_x(){{
        val(usf.x,0,0,0) = 0.0;
     }}end_is_face_x()
#line 179
is_face_y(){{
        val(usf.y,0,0,0) = 0.0;
     }}end_is_face_y()}end_foreach_face_generic();}
     boundary_internal ((scalar *)((scalar[]){ps,usf.x,usf.y,{-1}}), "././poisson-ps-usf2-2.h", 182);
#line 191 "././poisson-ps-usf2-2.h"
     int itt;



     for(itt=1;itt<=maxitt;itt++){





         foreach_stencil(){ 
             
_stencil_val(topo_mask,0,0,0);

{
                _stencil_val_a(ps,0,0,0);
            } 
            

               

         
#line 209
}end_foreach_stencil();





         {
#line 201
foreach(){
            int temp3;
            temp3 = val(topo_mask,0,0,0);

            if( temp3>=1 || temp3==-3){
                val(ps,0,0,0)=0.0;
            }

         }end_foreach();}
#line 224 "././poisson-ps-usf2-2.h"
         boundary_internal ((scalar *)((scalar[]){ps,{-1}}), "././poisson-ps-usf2-2.h", 224);

         foreach_stencil(){
_stencil_val(numbercells3,0,0,0);{  
               
               
               {
_stencil_val(A3,0,0,0);_stencil_val(Alef.x,0,0,0);_stencil_val(ps,-1,0,0); _stencil_val(Arigh.x,0,0,0);_stencil_val(ps,1,0,0); 
                         
               
#line 232
}
#line 230
{
_stencil_val(A3,0,0,0);_stencil_val(Alef.y,0,0,0);_stencil_val(ps,0,-1,0); _stencil_val(Arigh.y,0,0,0);_stencil_val(ps,0,1,0); 
                         
               
#line 232
}
_stencil_val(ps,0,0,0);_stencil_val(A3,0,0,0);_stencil_val(A4,0,0,0);
                   
               
#line 234
_stencil_val_a(ps,0,0,0);  
            }
              
          
#line 236
}end_foreach_stencil();

         {
#line 226
foreach(){
            if((level==level_interface) && (val(numbercells3,0,0,0)==1)){
               double part1=0.0;
               double part2;
               {
                     part1 = part1 + (beta1/val(A3,0,0,0))*(val(Alef.x,0,0,0)*val(ps,-1,0,0) + val(Arigh.x,0,0,0)*val(ps,1,0,0));
               }
#line 230
{
                     part1 = part1 + (beta1/val(A3,0,0,0))*(val(Alef.y,0,0,0)*val(ps,0,-1,0) + val(Arigh.y,0,0,0)*val(ps,0,1,0));
               }
               part2=(1.0-beta1)*val(ps,0,0,0) + part1 + (beta1/val(A3,0,0,0))*val(A4,0,0,0);
               val(ps,0,0,0) = part2;
            }
          }end_foreach();}
          boundary_internal ((scalar *)((scalar[]){ps,{-1}}), "././poisson-ps-usf2-2.h", 237);



         double T_res2=0.0;
         int numbercells2=0;
         double maxres_ps=0.0;
         foreach_stencil(){
            _stencil_val_a(res_ps,0,0,0);
_stencil_val(numbercells3,0,0,0);{ 
              
              

              { 
_stencil_val(Alef.x,0,0,0);_stencil_val(ps,-1,0,0); _stencil_val(Arigh.x,0,0,0);_stencil_val(ps,1,0,0); 
                     
              
#line 252
}
#line 250
{ 
_stencil_val(Alef.y,0,0,0);_stencil_val(ps,0,-1,0); _stencil_val(Arigh.y,0,0,0);_stencil_val(ps,0,1,0); 
                     
              
#line 252
}
_stencil_val(ps,0,0,0);_stencil_val(A3,0,0,0); _stencil_val(A4,0,0,0);
                  
              
              
#line 255
_stencil_val_a(res_ps,0,0,0); 
                   
                
              

            }  
                
         
#line 261
}end_foreach_stencil();
         
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(max:maxres_ps) reduction(+:numbercells2)reduction(+:T_res2)){
#line 244
foreach(){
            val(res_ps,0,0,0) = 0.0;
            if((level == level_interface) && (val(numbercells3,0,0,0)==1)){
              numbercells2+=1;
              double temp_res2=0.0;

              {
                  temp_res2 = temp_res2 + val(Alef.x,0,0,0)*val(ps,-1,0,0) + val(Arigh.x,0,0,0)*val(ps,1,0,0);
              }
#line 250
{
                  temp_res2 = temp_res2 + val(Alef.y,0,0,0)*val(ps,0,-1,0) + val(Arigh.y,0,0,0)*val(ps,0,1,0);
              }
              temp_res2 = temp_res2 -val(ps,0,0,0)*val(A3,0,0,0) + val(A4,0,0,0);
              T_res2=T_res2+pow(temp_res2,2.0);
              val(res_ps,0,0,0) = temp_res2/dt;
              if(fabs(temp_res2)>maxres_ps){
                  maxres_ps = fabs(temp_res2);
              }

            }
         }end_foreach();mpi_all_reduce_array(&maxres_ps,double,MPI_MAX,1);mpi_all_reduce_array(&numbercells2,int,MPI_SUM,1);mpi_all_reduce_array(&T_res2,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}





      
#line 267
if(numbercells2<=0){
            printf("numbercell2=%d numbercells=%d\n",numbercells2,numbercells);
      }
      T_res2 = T_res2/numbercells2;

         int diverged=0;
         foreach_stencil(){
{
             {
_stencil_val(Alef.x,0,0,0); _stencil_val(Alef.x,0,0,0);
_stencil_val(Arigh.x,0,0,0); _stencil_val(Arigh.x,0,0,0);
                    
                 
                    
                  
             
#line 280
}
#line 275
{
_stencil_val(Alef.y,0,0,0); _stencil_val(Alef.y,0,0,0);
_stencil_val(Arigh.y,0,0,0); _stencil_val(Arigh.y,0,0,0);
                    
                 
                    
                  
             
#line 280
}
_stencil_val(ps,0,0,0);_stencil_val(ps,0,0,0);{
#line 294 "././poisson-ps-usf2-2.h"
             }
               
            
#line 295
}
              

         
#line 297
}end_foreach_stencil();
         
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:diverged)){
#line 273
foreach(){
            if(level == level_interface){
             {
                if( (val(Alef.x,0,0,0) != val(Alef.x,0,0,0)) ||
                  (val(Arigh.x,0,0,0) != val(Arigh.x,0,0,0))) {
                    diverged=1;
                }
             }
#line 275
{
                if( (val(Alef.y,0,0,0) != val(Alef.y,0,0,0)) ||
                  (val(Arigh.y,0,0,0) != val(Arigh.y,0,0,0))) {
                    diverged=1;
                }
             }
             if((diverged==1) || (val(ps,0,0,0)!=val(ps,0,0,0))){
#line 294 "././poisson-ps-usf2-2.h"
             }
            }

         }end_foreach();mpi_all_reduce_array(&diverged,int,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}



          
#line 301
if(diverged==1){
            printf("diverged for ps; pid=%d\n",pid());
              exit(1);
           }


      if ((T_res2*numbercells2) > (1e16) ) {





            fprintf (ferr, "Poisson solver diverged after %d iterations \n",itt);
#line 328 "././poisson-ps-usf2-2.h"
       }

         double tres2=sqrt(T_res2);
#line 339 "././poisson-ps-usf2-2.h"
   if (tres2<ps_tolerance){
        break;
   }
#line 363 "././poisson-ps-usf2-2.h"
      boundary_internal ((scalar *)((scalar[]){ps,{-1}}), "././poisson-ps-usf2-2.h", 363);





     }
fprintf(ferr,"temperature itt=%d\n",itt);







   foreach_face_stencil(){_stencil_is_face_x(){{
{

_stencil_val(fs.x,0,0,0);{
_stencil_val(topo_mask,0,0,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,-1,0,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,-1,0,0); _stencil_val(topo_mask,-1,0,0);{
                    _stencil_val_a(usf.x,0,0,0);_stencil_val(alpha_temp.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, ps, 0);_stencil_val(ps,0,0,0); _stencil_val(ps,0 -1,0,0);            
            }
               
                    
                
        
#line 387
}

         
      
#line 388
}
        
   
#line 389
}}end__stencil_is_face_x()
#line 378
_stencil_is_face_y(){{
{

_stencil_val(fs.y,0,0,0);{
_stencil_val(topo_mask,0,0,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,0,-1,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,0,-1,0); _stencil_val(topo_mask,0,-1,0);{
                    _stencil_val_a(usf.y,0,0,0);_stencil_val(alpha_temp.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, ps, 0);_stencil_val(ps,0,0,0); _stencil_val(ps,0,0 -1,0);            
            }
               
                    
                
        
#line 387
}

         
      
#line 388
}
        
   
#line 389
}}end__stencil_is_face_y()}end_foreach_face_stencil();







   {
#line 378
foreach_face_generic(){is_face_x(){{
      if(level == level_interface){

         if(val(fs.x,0,0,0)>0){
            if(val(topo_mask,0,0,0)==-1 ||
                (val(topo_mask,0,0,0)==-2 && val(topo_mask,-1,0,0)==-1 ) ||
                (val(topo_mask,0,0,0)==0 && ( val(topo_mask,-1,0,0)==0 || val(topo_mask,-1,0,0)==-1))){
                    val(usf.x,0,0,0) = -dt*val(alpha_temp.x,0,0,0)*(_attribute[ps.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, ps, 0) : (val(ps,0,0,0) - val(ps,0 -1,0,0))/Delta);
            }
        }
      }
   }}end_is_face_x()
#line 378
is_face_y(){{
      if(level == level_interface){

         if(val(fs.y,0,0,0)>0){
            if(val(topo_mask,0,0,0)==-1 ||
                (val(topo_mask,0,0,0)==-2 && val(topo_mask,0,-1,0)==-1 ) ||
                (val(topo_mask,0,0,0)==0 && ( val(topo_mask,0,-1,0)==0 || val(topo_mask,0,-1,0)==-1))){
                    val(usf.y,0,0,0) = -dt*val(alpha_temp.y,0,0,0)*(_attribute[ps.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, ps, 0) : (val(ps,0,0,0) - val(ps,0,0 -1,0))/Delta);
            }
        }
      }
   }}end_is_face_y()}end_foreach_face_generic();}
   foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fs.x,0,0,0);{
          _stencil_val_a(usf.x,0,0,0);  
      }
      
   
#line 394
}}end__stencil_is_face_x()
#line 390
_stencil_is_face_y(){{
_stencil_val(fs.y,0,0,0);{
          _stencil_val_a(usf.y,0,0,0);  
      }
      
   
#line 394
}}end__stencil_is_face_y()}end_foreach_face_stencil();
   {
#line 390
foreach_face_generic(){is_face_x(){{
      if(val(fs.x,0,0,0)==0.0){
          val(usf.x,0,0,0) = 0.0;
      }
   }}end_is_face_x()
#line 390
is_face_y(){{
      if(val(fs.y,0,0,0)==0.0){
          val(usf.y,0,0,0) = 0.0;
      }
   }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){numbercells3,A4,A3,Arigh.x,Arigh.y,Alef.x,Alef.y,{-1}}));
}



struct Topo_m2 {
    scalar topo_mask;
};
void get_topomask(struct Topo_m2 q) {
     scalar topo_mask = q.topo_mask;

     foreach_stencil(){       
        _stencil_val(ff,0,0,0);
 _stencil_val_a(topo_mask,0,0,0);

_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);{

   _stencil_val_a(topo_mask,0,0,0);  
        }  

            
     
#line 413
}end_foreach_stencil();

     {
#line 405
foreach(){
        int phase_sign = (val(ff,0,0,0)>=0.5-0.0) ? 1 : -1;
 val(topo_mask,0,0,0) = 3*phase_sign;

         if(val(ff,0,0,0)<1.0-0.0 && val(ff,0,0,0)>0.0 && (val(css_test3_n,0,0,0)>0.0)){

   val(topo_mask,0,0,0) = 0;
        }
     }end_foreach();}
     boundary_internal ((scalar *)((scalar[]){topo_mask,{-1}}), "././poisson-ps-usf2-2.h", 414);
     foreach_stencil(){


{  
            
            { 
               _stencil_val(topo_mask,1,0,0); 
               _stencil_val(topo_mask,-1,0,0); 
                
               
              
            }
#line 420
{ 
               _stencil_val(topo_mask,0,1,0); 
               _stencil_val(topo_mask,0,-1,0); 
                
               
              
            } 
            _stencil_val(topo_mask,0,0,0);
{

{{
           _stencil_val_a(topo_mask,0,0,0);  
       } {_stencil_val(topo_mask,0,0,0);{
           _stencil_val_a(topo_mask,0,0,0);  
       }}}

       
            
#line 435
}
               
        
#line 436
}


         

     
#line 438
}end_foreach_stencil();
     {
#line 415
foreach(){


         if(level==level_interface){
            bool is1= false;
            {
               int temp1=val(topo_mask,1,0,0);
               int temp2=val(topo_mask,-1,0,0);
            if(temp1==0 || temp2==0){
               is1 = true;
               }
            }
#line 420
{
               int temp1=val(topo_mask,0,1,0);
               int temp2=val(topo_mask,0,-1,0);
            if(temp1==0 || temp2==0){
               is1 = true;
               }
            }
            int temp3=val(topo_mask,0,0,0);
            if (is1 && temp3!=0){

       if(temp3==3){
           val(topo_mask,0,0,0) = 1;
       }else if(val(topo_mask,0,0,0)==-3){
           val(topo_mask,0,0,0) = -1;
       }
            }
        }

     }end_foreach();}
  for(int phase=0;phase<=1;phase++){
     foreach_stencil(){


{      
                _stencil_val(ff,0,0,0);  
            
               { 
                  _stencil_val(topo_mask,1,0,0); 
                  _stencil_val(topo_mask,-1,0,0); 
                   
                  
                  
               }
#line 446
{ 
                  _stencil_val(topo_mask,0,1,0); 
                  _stencil_val(topo_mask,0,-1,0); 
                   
                  
                  
               }  
                _stencil_val(topo_mask,0,0,0);
{
                  _stencil_val_a(topo_mask,0,0,0);   
               }
                  
         
#line 457
}


          
     
#line 458
}end_foreach_stencil();
     {
#line 440
foreach(){


         if(level==level_interface ){
               int phase_sign = val(ff,0,0,0)>=0.5-0.0 ? 1 : -1;
            bool is1= false;
               {
                  int temp1=val(topo_mask,1,0,0);
                  int temp2=val(topo_mask,-1,0,0);
               if( temp1==(2*phase-1) || temp2==(2*phase-1)){
                  is1 = true;
                  }
               }
#line 446
{
                  int temp1=val(topo_mask,0,1,0);
                  int temp2=val(topo_mask,0,-1,0);
               if( temp1==(2*phase-1) || temp2==(2*phase-1)){
                  is1 = true;
                  }
               }
               int temp3 = val(topo_mask,0,0,0);
               if (is1 && temp3==3*phase_sign){
                  val(topo_mask,0,0,0) = 2*(2*phase-1) ;
               }
         }
     }end_foreach();}
  }



}
#line 28 "template01.c"
#line 1 "./poisson-ps-usf2g.h"
#line 1 "././poisson-ps-usf2g.h"
extern scalar ff;
extern int globali;
extern int minl;
struct Linear_psg {
  vector alpha_temp;
  scalar ps;
  vector usf;
  scalar topo_mask;
  int level_interface;
  double dt;
};

void poisson_ps_usf1g (struct Linear_psg q) {



     vector alpha_temp = q.alpha_temp;
     scalar ps = q.ps;
     vector usf = q.usf;
     scalar topo_mask = q.topo_mask;
     int level_interface = q.level_interface;
     double dt = q.dt;
#line 36 "././poisson-ps-usf2g.h"
     vector  facemask=new_face_vector("facemask");

     foreach_face_stencil(){_stencil_is_face_x(){{
        _stencil_val_a(facemask.x,0,0,0);
     }}end__stencil_is_face_x()
#line 38
_stencil_is_face_y(){{
        _stencil_val_a(facemask.y,0,0,0);
     }}end__stencil_is_face_y()}end_foreach_face_stencil();

     {
#line 38
foreach_face_generic(){is_face_x(){{
        val(facemask.x,0,0,0)=1;
     }}end_is_face_x()
#line 38
is_face_y(){{
        val(facemask.y,0,0,0)=1;
     }}end_is_face_y()}end_foreach_face_generic();}




      {foreach_level(level_interface){
         {
           Point neil = neighborp(-1,0,0);
            if((neighbor(-1,0,0).pid < 0)){
                val(facemask.x,0,0,0) = 0.0;
            }
            Point neir = neighborp(1,0,0);
            if((neighbor(1,0,0).pid < 0)){
                {foreach_neighbor(1){
                     if(point.i==neir.i && point.j==neir.j){
                          val(facemask.x,0,0,0) = 0.0;
                     }

                }end_foreach_neighbor()}
            }
         }
#line 46
{
           Point neil = neighborp(0,-1,0);
            if((neighbor(0,-1,0).pid < 0)){
                val(facemask.y,0,0,0) = 0.0;
            }
            Point neir = neighborp(0,1,0);
            if((neighbor(0,1,0).pid < 0)){
                {foreach_neighbor(1){
                     if(point.i==neir.i && point.j==neir.j){
                          val(facemask.y,0,0,0) = 0.0;
                     }

                }end_foreach_neighbor()}
            }
         }
     }end_foreach_level();}

    {foreach_level(level_interface){
         {
            Point neil = neighborp(-1,0,0);
            if((neighbor(-1,0,0).pid < 0)){
                 val(facemask.x,0,0,0) = 0.0;

            }

         }
#line 64
{
            Point neil = neighborp(0,-1,0);
            if((neighbor(0,-1,0).pid < 0)){
                 val(facemask.y,0,0,0) = 0.0;

            }

         }

    }end_foreach_level();}


     vector  Alef=new_vector("Alef"), Arigh=new_vector("Arigh");
     scalar  A3=new_scalar("A3"), A4=new_scalar("A4");
     foreach_stencil(){
        {
           _stencil_val_a(Alef.x,0,0,0);
           _stencil_val_a(Arigh.x,0,0,0);
        }
#line 79
{
           _stencil_val_a(Alef.y,0,0,0);
           _stencil_val_a(Arigh.y,0,0,0);
        }
        _stencil_val_a(A3,0,0,0);
        _stencil_val_a(A4,0,0,0);
     }end_foreach_stencil();
     {
#line 78
foreach(){
        {
           val(Alef.x,0,0,0)=0.0;
           val(Arigh.x,0,0,0)=0.0;
        }
#line 79
{
           val(Alef.y,0,0,0)=0.0;
           val(Arigh.y,0,0,0)=0.0;
        }
        val(A3,0,0,0)=0.0;
        val(A4,0,0,0)=0.0;
     }end_foreach();}
#line 116 "././poisson-ps-usf2g.h"
     int numbercells=0;
     bool get_delta_interface=false;
     double Delta_interface = HUGE;
     scalar  numbercells3=new_scalar("numbercells3");
     foreach_stencil(){
        _stencil_val_a(numbercells3,0,0,0);
     }end_foreach_stencil();
     {
#line 120
foreach(){
        val(numbercells3,0,0,0)=0;
     }end_foreach();}
     foreach_stencil(){
{   
      
       _stencil_val(topo_mask,0,0,0);
{{
                       
                       _stencil_val_a(numbercells3,0,0,0);
                       {


                              _stencil_val_a(Alef.x,0,0,0); _stencil_val(facemask.x,0,0,0);_stencil_val(alpha_temp.x,0,0,0);
                              _stencil_val_a(Arigh.x,0,0,0); _stencil_val(facemask.x,1,0,0);_stencil_val(alpha_temp.x,1,0,0); 
_stencil_val(Alef.x,0,0,0);_stencil_val(Arigh.x,0,0,0); 
                             
                       
#line 136
}
#line 130
{


                              _stencil_val_a(Alef.y,0,0,0); _stencil_val(facemask.y,0,0,0);_stencil_val(alpha_temp.y,0,0,0);
                              _stencil_val_a(Arigh.y,0,0,0); _stencil_val(facemask.y,0,1,0);_stencil_val(alpha_temp.y,0,1,0); 
_stencil_val(Alef.y,0,0,0);_stencil_val(Arigh.y,0,0,0); 
                             
                       
#line 136
}
                       _stencil_val_a(A3,0,0,0);  
                _stencil_val_a(A4,0,0,0);_stencil_val(source_pc,0,0,0);_stencil_val(cm,0,0,0); 

             }{{
                      
                      _stencil_val_a(numbercells3,0,0,0);
                      { 
                            _stencil_val(topo_mask,-1,0,0); 
                            _stencil_val(topo_mask,1,0,0);
{

                                                   _stencil_val_a(Alef.x,0,0,0); _stencil_val(facemask.x,0,0,0);_stencil_val(alpha_temp.x,0,0,0);
                              }
{

                                                   _stencil_val_a(Arigh.x,0,0,0); _stencil_val(facemask.x,1,0,0);_stencil_val(alpha_temp.x,1,0,0);
                              }
                                
                                 
#line 154
_stencil_val(Alef.x,0,0,0);_stencil_val(Arigh.x,0,0,0);
                             
                      
#line 155
}
#line 143
{ 
                            _stencil_val(topo_mask,0,-1,0); 
                            _stencil_val(topo_mask,0,1,0);
{

                                                   _stencil_val_a(Alef.y,0,0,0); _stencil_val(facemask.y,0,0,0);_stencil_val(alpha_temp.y,0,0,0);
                              }
{

                                                   _stencil_val_a(Arigh.y,0,0,0); _stencil_val(facemask.y,0,1,0);_stencil_val(alpha_temp.y,0,1,0);
                              }
                                
                                 
#line 154
_stencil_val(Alef.y,0,0,0);_stencil_val(Arigh.y,0,0,0);
                             
                      
#line 155
}
                      _stencil_val_a(A3,0,0,0);  
               _stencil_val_a(A4,0,0,0);_stencil_val(source_pc,0,0,0);_stencil_val(cm,0,0,0); 
             }{

                {
                     _stencil_val_a(Alef.x,0,0,0);
                     _stencil_val_a(Arigh.x,0,0,0);
                }
#line 160
{
                     _stencil_val_a(Alef.y,0,0,0);
                     _stencil_val_a(Arigh.y,0,0,0);
                }
                _stencil_val_a(A3,0,0,0);
                _stencil_val_a(A4,0,0,0);
            }}}
             




        
#line 171
}
          

     
#line 173
}end_foreach_stencil();
     
#line 123
if(!is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:numbercells)){
#line 123
foreach(){
        if(level == level_interface){
      double temp_A3=0.0;
      int current = val(topo_mask,0,0,0);
          if(current==-1 || current==-2){
                       numbercells+=1;
                       val(numbercells3,0,0,0)=1;
                       {


                              val(Alef.x,0,0,0)= val(facemask.x,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,0,0,0);
                              val(Arigh.x,0,0,0)= val(facemask.x,1,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,1,0,0);
                             temp_A3 += val(Alef.x,0,0,0)+val(Arigh.x,0,0,0);
                       }
#line 130
{


                              val(Alef.y,0,0,0)= val(facemask.y,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,0,0);
                              val(Arigh.y,0,0,0)= val(facemask.y,0,1,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,1,0);
                             temp_A3 += val(Alef.y,0,0,0)+val(Arigh.y,0,0,0);
                       }
                       val(A3,0,0,0) = temp_A3;
                val(A4,0,0,0)= -val(source_pc,0,0,0)*val(cm,0,0,0);

             }else if(current==0){
                      numbercells+=1;
                      val(numbercells3,0,0,0)=1;
                      {
                            int lef=val(topo_mask,-1,0,0);
                            int righ=val(topo_mask,1,0,0);
                              if(lef==0 || lef==-1){

                                                   val(Alef.x,0,0,0)= val(facemask.x,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,0,0,0);
                              }
                              if(righ==0 || righ==-1){

                                                   val(Arigh.x,0,0,0)= val(facemask.x,1,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,1,0,0);
                              }
                            temp_A3 += val(Alef.x,0,0,0)+val(Arigh.x,0,0,0);
                      }
#line 143
{
                            int lef=val(topo_mask,0,-1,0);
                            int righ=val(topo_mask,0,1,0);
                              if(lef==0 || lef==-1){

                                                   val(Alef.y,0,0,0)= val(facemask.y,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,0,0);
                              }
                              if(righ==0 || righ==-1){

                                                   val(Arigh.y,0,0,0)= val(facemask.y,0,1,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,1,0);
                              }
                            temp_A3 += val(Alef.y,0,0,0)+val(Arigh.y,0,0,0);
                      }
                      val(A3,0,0,0) = temp_A3;
               val(A4,0,0,0)= -val(source_pc,0,0,0)*val(cm,0,0,0);
             }else{

                {
                     val(Alef.x,0,0,0)=0.0;
                     val(Arigh.x,0,0,0)=0.0;
                }
#line 160
{
                     val(Alef.y,0,0,0)=0.0;
                     val(Arigh.y,0,0,0)=0.0;
                }
                val(A3,0,0,0)=1.0;
                val(A4,0,0,0)=0.0;
            }




        }

     }end_foreach();mpi_all_reduce_array(&numbercells,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 173
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
     
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:numbercells)){
#line 123
foreach(){
        if(level == level_interface){
      double temp_A3=0.0;
      int current = val(topo_mask,0,0,0);
          if(current==-1 || current==-2){
                       numbercells+=1;
                       val(numbercells3,0,0,0)=1;
                       {


                              val(Alef.x,0,0,0)= val(facemask.x,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,0,0,0);
                              val(Arigh.x,0,0,0)= val(facemask.x,1,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,1,0,0);
                             temp_A3 += val(Alef.x,0,0,0)+val(Arigh.x,0,0,0);
                       }
#line 130
{


                              val(Alef.y,0,0,0)= val(facemask.y,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,0,0);
                              val(Arigh.y,0,0,0)= val(facemask.y,0,1,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,1,0);
                             temp_A3 += val(Alef.y,0,0,0)+val(Arigh.y,0,0,0);
                       }
                       val(A3,0,0,0) = temp_A3;
                val(A4,0,0,0)= -val(source_pc,0,0,0)*_const_cm;

             }else if(current==0){
                      numbercells+=1;
                      val(numbercells3,0,0,0)=1;
                      {
                            int lef=val(topo_mask,-1,0,0);
                            int righ=val(topo_mask,1,0,0);
                              if(lef==0 || lef==-1){

                                                   val(Alef.x,0,0,0)= val(facemask.x,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,0,0,0);
                              }
                              if(righ==0 || righ==-1){

                                                   val(Arigh.x,0,0,0)= val(facemask.x,1,0,0)*dt/(Delta*Delta)*val(alpha_temp.x,1,0,0);
                              }
                            temp_A3 += val(Alef.x,0,0,0)+val(Arigh.x,0,0,0);
                      }
#line 143
{
                            int lef=val(topo_mask,0,-1,0);
                            int righ=val(topo_mask,0,1,0);
                              if(lef==0 || lef==-1){

                                                   val(Alef.y,0,0,0)= val(facemask.y,0,0,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,0,0);
                              }
                              if(righ==0 || righ==-1){

                                                   val(Arigh.y,0,0,0)= val(facemask.y,0,1,0)*dt/(Delta*Delta)*val(alpha_temp.y,0,1,0);
                              }
                            temp_A3 += val(Alef.y,0,0,0)+val(Arigh.y,0,0,0);
                      }
                      val(A3,0,0,0) = temp_A3;
               val(A4,0,0,0)= -val(source_pc,0,0,0)*_const_cm;
             }else{

                {
                     val(Alef.x,0,0,0)=0.0;
                     val(Arigh.x,0,0,0)=0.0;
                }
#line 160
{
                     val(Alef.y,0,0,0)=0.0;
                     val(Arigh.y,0,0,0)=0.0;
                }
                val(A3,0,0,0)=1.0;
                val(A4,0,0,0)=0.0;
            }




        }

     }end_foreach();mpi_all_reduce_array(&numbercells,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 173
}




     int maxitt=2000,beta1=1.2;


    double ps_tolerance = 0.00000001;
     foreach_stencil(){
        _stencil_val_a(ps,0,0,0);  
     }end_foreach_stencil();
     {
#line 182
foreach(){
        val(ps,0,0,0) = 0.0;
     }end_foreach();}
     foreach_face_stencil(){_stencil_is_face_x(){{
        _stencil_val_a(usf.x,0,0,0);  
     }}end__stencil_is_face_x()
#line 185
_stencil_is_face_y(){{
        _stencil_val_a(usf.y,0,0,0);  
     }}end__stencil_is_face_y()}end_foreach_face_stencil();
     {
#line 185
foreach_face_generic(){is_face_x(){{
        val(usf.x,0,0,0) = 0.0;
     }}end_is_face_x()
#line 185
is_face_y(){{
        val(usf.y,0,0,0) = 0.0;
     }}end_is_face_y()}end_foreach_face_generic();}
     boundary_internal ((scalar *)((scalar[]){ps,usf.x,usf.y,{-1}}), "././poisson-ps-usf2g.h", 188);
#line 197 "././poisson-ps-usf2g.h"
     int itt;



     for(itt=1;itt<=maxitt;itt++){





         foreach_stencil(){ 
             
_stencil_val(topo_mask,0,0,0);

{
                _stencil_val_a(ps,0,0,0);
            } 
            

               

         
#line 215
}end_foreach_stencil();





         {
#line 207
foreach(){
            int temp3;
            temp3 = val(topo_mask,0,0,0);

            if( temp3>=1 || temp3==-3){
                val(ps,0,0,0)=0.0;
            }

         }end_foreach();}
#line 229 "././poisson-ps-usf2g.h"
         boundary_internal ((scalar *)((scalar[]){ps,{-1}}), "././poisson-ps-usf2g.h", 229);
         foreach_stencil(){
_stencil_val(numbercells3,0,0,0);{ 
               
               {
_stencil_val(A3,0,0,0);_stencil_val(Alef.x,0,0,0);_stencil_val(ps,-1,0,0); _stencil_val(Arigh.x,0,0,0);_stencil_val(ps,1,0,0); 
                         
               
#line 235
}
#line 233
{
_stencil_val(A3,0,0,0);_stencil_val(Alef.y,0,0,0);_stencil_val(ps,0,-1,0); _stencil_val(Arigh.y,0,0,0);_stencil_val(ps,0,1,0); 
                         
               
#line 235
}
               _stencil_val_a(ps,0,0,0);_stencil_val(ps,0,0,0);_stencil_val(A3,0,0,0);_stencil_val(A4,0,0,0);    
            }
              
          
#line 238
}end_foreach_stencil();
         {
#line 230
foreach(){
            if((level==level_interface) && (val(numbercells3,0,0,0)==1)){
               double part1=0.0;
               {
                     part1 = part1 + (beta1/val(A3,0,0,0))*(val(Alef.x,0,0,0)*val(ps,-1,0,0) + val(Arigh.x,0,0,0)*val(ps,1,0,0));
               }
#line 233
{
                     part1 = part1 + (beta1/val(A3,0,0,0))*(val(Alef.y,0,0,0)*val(ps,0,-1,0) + val(Arigh.y,0,0,0)*val(ps,0,1,0));
               }
               val(ps,0,0,0)=(1.0-beta1)*val(ps,0,0,0) + part1 + (beta1/val(A3,0,0,0))*val(A4,0,0,0);
            }
          }end_foreach();}
          boundary_internal ((scalar *)((scalar[]){ps,{-1}}), "././poisson-ps-usf2g.h", 239);


         double T_res2=0.0;
         int numbercells2=0;
         foreach_stencil(){
_stencil_val(numbercells3,0,0,0);{ 
              
              

              { 
_stencil_val(Alef.x,0,0,0);_stencil_val(ps,-1,0,0); _stencil_val(Arigh.x,0,0,0);_stencil_val(ps,1,0,0); 
                     
              
#line 251
}
#line 249
{ 
_stencil_val(Alef.y,0,0,0);_stencil_val(ps,0,-1,0); _stencil_val(Arigh.y,0,0,0);_stencil_val(ps,0,1,0); 
                     
              
#line 251
}
_stencil_val(ps,0,0,0);_stencil_val(A3,0,0,0); _stencil_val(A4,0,0,0);
                  
              
            
#line 254
}
                
         
#line 255
}end_foreach_stencil();
         
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(+:numbercells2)reduction(+:T_res2)){
#line 244
foreach(){
            if((level == level_interface) && (val(numbercells3,0,0,0)==1)){
              numbercells2+=1;
              double temp_res2=0.0;

              {
                  temp_res2 = temp_res2 + val(Alef.x,0,0,0)*val(ps,-1,0,0) + val(Arigh.x,0,0,0)*val(ps,1,0,0);
              }
#line 249
{
                  temp_res2 = temp_res2 + val(Alef.y,0,0,0)*val(ps,0,-1,0) + val(Arigh.y,0,0,0)*val(ps,0,1,0);
              }
              temp_res2 = temp_res2 -val(ps,0,0,0)*val(A3,0,0,0) + val(A4,0,0,0);
              T_res2=T_res2+pow(temp_res2,2.0);
            }
         }end_foreach();mpi_all_reduce_array(&numbercells2,int,MPI_SUM,1);mpi_all_reduce_array(&T_res2,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}





      
#line 261
T_res2 = T_res2/numbercells2;

         int diverged=0;
         foreach_stencil(){
{
             {
_stencil_val(Alef.x,0,0,0); _stencil_val(Alef.x,0,0,0);
_stencil_val(Arigh.x,0,0,0); _stencil_val(Arigh.x,0,0,0);
                    
                 
                    
                  
             
#line 271
}
#line 266
{
_stencil_val(Alef.y,0,0,0); _stencil_val(Alef.y,0,0,0);
_stencil_val(Arigh.y,0,0,0); _stencil_val(Arigh.y,0,0,0);
                    
                 
                    
                  
             
#line 271
}
_stencil_val(T,0,0,0);_stencil_val(T,0,0,0);  
             
#line 283 "././poisson-ps-usf2g.h"
                 

             
            }
              

         
#line 288
}end_foreach_stencil();
         
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:diverged)){
#line 264
foreach(){
            if(level == level_interface){
             {
                if( (val(Alef.x,0,0,0) != val(Alef.x,0,0,0)) ||
                  (val(Arigh.x,0,0,0) != val(Arigh.x,0,0,0))) {
                    diverged=1;
                }
             }
#line 266
{
                if( (val(Alef.y,0,0,0) != val(Alef.y,0,0,0)) ||
                  (val(Arigh.y,0,0,0) != val(Arigh.y,0,0,0))) {
                    diverged=1;
                }
             }
             if((diverged==1) || (val(T,0,0,0)!=val(T,0,0,0))){
#line 283 "././poisson-ps-usf2g.h"
                 fprintf(ferr,"ps_poisson_error\n");

             }
            }

         }end_foreach();mpi_all_reduce_array(&diverged,int,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}



          
#line 292
if(diverged==1){
            printf("diverged for ps; pid=%d\n",pid());
              exit(1);
           }


      if ((T_res2*numbercells2) > (1e16) ) {





            fprintf (ferr, "Poisson solver diverged after %d iterations \n",itt);
#line 319 "././poisson-ps-usf2g.h"
       }

         double tres2=sqrt(T_res2);
#line 330 "././poisson-ps-usf2g.h"
   if (tres2<ps_tolerance){
        break;
   }


      boundary_internal ((scalar *)((scalar[]){ps,{-1}}), "././poisson-ps-usf2g.h", 335);


     }
fprintf(ferr,"temperature itt=%d\n",itt);







   foreach_face_stencil(){_stencil_is_face_x(){{
{
_stencil_val(facemask.x,0,0,0);{
_stencil_val(topo_mask,0,0,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,-1,0,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,-1,0,0); _stencil_val(topo_mask,-1,0,0);{
                    _stencil_val_a(usf.x,0,0,0);_stencil_val(alpha_temp.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, ps, 0);_stencil_val(ps,0,0,0); _stencil_val(ps,0 -1,0,0);            
            }
               
                    
                
        
#line 355
}
        
      
#line 356
}
        
   
#line 357
}}end__stencil_is_face_x()
#line 347
_stencil_is_face_y(){{
{
_stencil_val(facemask.y,0,0,0);{
_stencil_val(topo_mask,0,0,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,0,-1,0);
_stencil_val(topo_mask,0,0,0); _stencil_val(topo_mask,0,-1,0); _stencil_val(topo_mask,0,-1,0);{
                    _stencil_val_a(usf.y,0,0,0);_stencil_val(alpha_temp.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, ps, 0);_stencil_val(ps,0,0,0); _stencil_val(ps,0,0 -1,0);            
            }
               
                    
                
        
#line 355
}
        
      
#line 356
}
        
   
#line 357
}}end__stencil_is_face_y()}end_foreach_face_stencil();







   {
#line 347
foreach_face_generic(){is_face_x(){{
      if(level == level_interface){
        if(val(facemask.x,0,0,0)==1){
            if(val(topo_mask,0,0,0)==-1 ||
                (val(topo_mask,0,0,0)==-2 && val(topo_mask,-1,0,0)==-1 ) ||
                (val(topo_mask,0,0,0)==0 && ( val(topo_mask,-1,0,0)==0 || val(topo_mask,-1,0,0)==-1))){
                    val(usf.x,0,0,0) = -dt*val(alpha_temp.x,0,0,0)*(_attribute[ps.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, ps, 0) : (val(ps,0,0,0) - val(ps,0 -1,0,0))/Delta);
            }
        }
      }
   }}end_is_face_x()
#line 347
is_face_y(){{
      if(level == level_interface){
        if(val(facemask.y,0,0,0)==1){
            if(val(topo_mask,0,0,0)==-1 ||
                (val(topo_mask,0,0,0)==-2 && val(topo_mask,0,-1,0)==-1 ) ||
                (val(topo_mask,0,0,0)==0 && ( val(topo_mask,0,-1,0)==0 || val(topo_mask,0,-1,0)==-1))){
                    val(usf.y,0,0,0) = -dt*val(alpha_temp.y,0,0,0)*(_attribute[ps.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, ps, 0) : (val(ps,0,0,0) - val(ps,0,0 -1,0))/Delta);
            }
        }
      }
   }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){numbercells3,A4,A3,Arigh.x,Arigh.y,Alef.x,Alef.y,facemask.x,facemask.y,{-1}}));





}
#line 29 "template01.c"

#line 1 "./my-contact-embed-triple.h"
#line 1 "././my-contact-embed-triple.h"
#line 12 "././my-contact-embed-triple.h"
extern scalar intersect_true;
extern int level_interface;

extern scalar corner_ff;

        scalar contact_angle;
#line 130 "././my-contact-embed-triple.h"
static inline coord normal_contact (coord ns, coord nf, double angle)
{
  coord nc;

  if (- ns.x*nf.y + ns.y*nf.x > 0) {


    nc.x = - ns.x*cos(angle) + ns.y*sin(angle);
    nc.y = - ns.x*sin(angle) - ns.y*cos(angle);
  }
  else {
    nc.x = - ns.x*cos(angle) - ns.y*sin(angle);
    nc.y = + ns.x*sin(angle) - ns.y*cos(angle);
  }
#line 199 "././my-contact-embed-triple.h"
  return nc;
}






void reconstruction_contact (scalar f, vector n, scalar alpha, scalar intersect_true)
{





scalar  f_middle=new_scalar("f_middle");
 foreach_stencil(){
    _stencil_val_a(f_middle,0,0,0); _stencil_val(f,0,0,0); 
 }end_foreach_stencil();
 {
#line 215
foreach(){
    val(f_middle,0,0,0) = val(f,0,0,0);
 }end_foreach();}
 foreach_stencil(){
_stencil_val(cs,0,0,0);{
       _stencil_val_a(f,0,0,0); _stencil_val(f_height,0,0,0); 
    }
    
 
#line 222
}end_foreach_stencil();
 {
#line 218
foreach(){
    if(val(cs,0,0,0)<=0.0){
       val(f,0,0,0) = val(f_height,0,0,0);
    }
 }end_foreach();}






 if(1==0){
  reconstruction4 (f, n, alpha);
 }else{
  reconstruction (f, n, alpha);
 }

 foreach_stencil(){
   _stencil_val_a(f,0,0,0); _stencil_val(f_middle,0,0,0); 
 }end_foreach_stencil();

 {
#line 235
foreach(){
   val(f,0,0,0) = val(f_middle,0,0,0);
 }end_foreach();}





  foreach_stencil(){

_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(f,0,0,0); _stencil_val(f,0,0,0); {









_stencil_val(intersect_true,0,0,0);{  
                 _stencil_facet_normal (point, cs, fs); 
                
                
                    { _stencil_val(n.x,0,0,0); }
                    
#line 259
{ _stencil_val(n.y,0,0,0); }      

                
                 _stencil_val(contact_angle,0,0,0);
                
                  {_stencil_val_a(n.x,0,0,0);  }
                  
#line 264
{_stencil_val_a(n.y,0,0,0);  }


                _stencil_val_a(alpha,0,0,0);_stencil_val(f,0,0,0);    
        }
#line 255 "././my-contact-embed-triple.h"
          
    
#line 269
}     

                
    
  
#line 271
}end_foreach_stencil();





  
#line 243
if(!is_constant(contact_angle)){{foreach(){

    if (val(cs,0,0,0) < 1. && val(cs,0,0,0) > 0. && val(f,0,0,0) < 1. && val(f,0,0,0) > 0.) {
#line 255 "././my-contact-embed-triple.h"
          if(val(intersect_true,0,0,0)==1){
                coord ns = facet_normal (point, cs, fs);
                coord nf;
                
                    nf.x = val(n.x,0,0,0);
                    
#line 259
nf.y = val(n.y,0,0,0);

                normalize (&ns);
                coord nc = normal_contact (ns, nf, val(contact_angle,0,0,0));
                
                  val(n.x,0,0,0) = nc.x;
                  
#line 264
val(n.y,0,0,0) = nc.y;


                val(alpha,0,0,0) = line_alpha (val(f,0,0,0), nc);
        }
    }
    boundary_internal ((scalar *)((scalar[]){n.x,n.y, alpha,{-1}}), "././my-contact-embed-triple.h", 270);
  }end_foreach();}}else {double _const_contact_angle=_constant[contact_angle.i-_NVARMAX];NOT_UNUSED(_const_contact_angle);





  {
#line 243
foreach(){

    if (val(cs,0,0,0) < 1. && val(cs,0,0,0) > 0. && val(f,0,0,0) < 1. && val(f,0,0,0) > 0.) {
#line 255 "././my-contact-embed-triple.h"
          if(val(intersect_true,0,0,0)==1){
                coord ns = facet_normal (point, cs, fs);
                coord nf;
                
                    nf.x = val(n.x,0,0,0);
                    
#line 259
nf.y = val(n.y,0,0,0);

                normalize (&ns);
                coord nc = normal_contact (ns, nf, _const_contact_angle);
                
                  val(n.x,0,0,0) = nc.x;
                  
#line 264
val(n.y,0,0,0) = nc.y;


                val(alpha,0,0,0) = line_alpha (val(f,0,0,0), nc);
        }
    }
    boundary_internal ((scalar *)((scalar[]){n.x,n.y, alpha,{-1}}), "././my-contact-embed-triple.h", 270);
  }end_foreach();}}delete((scalar*)((scalar[]){f_middle,{-1}}));
}

typedef struct {
    int id;
    double x, y, alpha, n_x, n_y, c1,c2,sn_x,sn_y;
    double triplex,tripley;
} CellInfo;





bool is_intersection_within_unit_square(double a1, double b1, double c1, double a2, double b2, double c2, double* xx, double* yy) {
    double det = a1 * b2 - a2 * b1;



    if (fabs(det) > 1e-9) {
        double intersect_x,intersect_y;
        intersect_x = (b1 * c2 - b2 * c1) / det;
        intersect_y = (a2 * c1 - a1 * c2) / det;


        if (0 <= intersect_x && intersect_x <= 1 && 0 <= intersect_y && intersect_y <= 1) {
            *xx = intersect_x;
            *yy = intersect_y;
            return true;
        }
    }
    return false;
}




static int contact_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int contact(const int i,const double t,Event *_ev){tracing("contact","././my-contact-embed-triple.h",307);
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha");





  reconstruction4 (ff, n, alpha);
  scalar  cs_neg=new_scalar("cs_neg");
  foreach_stencil(){
    _stencil_val_a(cs_neg,0,0,0);_stencil_val(cs,0,0,0);  
  }end_foreach_stencil();
  {
#line 318
foreach(){
    val(cs_neg,0,0,0) = 1.0-val(cs,0,0,0);
  }end_foreach();}
  scalar  solid_neg_alpha=new_scalar("solid_neg_alpha");
  vector  solid_n=new_vector("solid_n");
  reconstruction (cs_neg, solid_n, solid_neg_alpha);

  vector  triple_coord=new_vector("triple_coord");
  int total_number_triple=0;

  scalar  intersect_true_temp=new_scalar("intersect_true_temp");

  foreach_stencil(){
    _stencil_val_a(intersect_true_temp,0,0,0); _stencil_val(intersect_true,0,0,0); 
  }end_foreach_stencil();

  {
#line 330
foreach(){
    val(intersect_true_temp,0,0,0) = val(intersect_true,0,0,0);
  }end_foreach();}

  foreach_stencil(){
        _stencil_val_a(intersect_true,0,0,0);  
        _stencil_val_a(f_height,0,0,0); _stencil_val(ff,0,0,0); 
        {
          _stencil_val_a(triple_coord.x,0,0,0);  

        }
#line 337
{
          _stencil_val_a(triple_coord.y,0,0,0);  

        }

_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); {   
            _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);  
             _stencil_val(solid_neg_alpha,0,0,0);   
            _stencil_val(n.y,0,0,0);_stencil_val(n.x,0,0,0); 
            _stencil_val(alpha,0,0,0);    
              
             
             
            
            
{
                _stencil_val_a(intersect_true,0,0,0);  
                
                _stencil_val_a(triple_coord.x,0,0,0);  
                _stencil_val_a(triple_coord.y,0,0,0);  
            }
            
        
#line 358
}

                    
  
#line 359
}end_foreach_stencil();

  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 334
foreach(){
        val(intersect_true,0,0,0) = 0;
        val(f_height,0,0,0) = val(ff,0,0,0);
        {
          val(triple_coord.x,0,0,0) = 0;

        }
#line 337
{
          val(triple_coord.y,0,0,0) = 0;

        }

        if (val(cs,0,0,0) < 1. && val(cs,0,0,0) > 0. && val(ff,0,0,0) < 1. && val(ff,0,0,0) > 0.) {
            coord nsf = (coord){val(solid_n.x,0,0,0),val(solid_n.y,0,0,0)};
            double alphasf = val(solid_neg_alpha,0,0,0);
            coord nlg = (coord){val(n.x,0,0,0),val(n.y,0,0,0)};
            double alphalg=val(alpha,0,0,0);
            double a1,b1,c1,a2,b2,c2;
            a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
            a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
            double xx=0,yy=0;
            bool intersect_flag= is_intersection_within_unit_square(a1,b1,c1,a2,b2,c2,&xx,&yy);
            if(intersect_flag){
                val(intersect_true,0,0,0) = 1;
                total_number_triple+=1;
                val(triple_coord.x,0,0,0) = (xx-0.5)*Delta+x;
                val(triple_coord.y,0,0,0) = (yy-0.5)*Delta+y;
            }
        }
  }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}

  
#line 361
bool flag33=false;
  int method=0;
  if(total_number_triple==0 && 1==0){
      flag33=true;
      foreach_stencil(){
_stencil_val(intersect_true_temp,0,0,0);{
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(intersect_true,0,0,0);{
                  _stencil_val_a(intersect_true,0,0,0);
                  
              }
                  
         
#line 371
}
           
      
#line 372
}end_foreach_stencil();
      
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 365
foreach(){
         if(val(intersect_true_temp,0,0,0)==1 && level==level_interface){
              if(val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0 && val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && val(intersect_true,0,0,0)==0){
                  val(intersect_true,0,0,0)=1;
                  total_number_triple+=1;
              }
         }
      }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
      
#line 373
if(total_number_triple>=1){
            method=1;
      }
      if(total_number_triple==0){
            foreach_stencil(){
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{   
                  
                  {foreach_neighbor(1){
_stencil_val(intersect_true_temp,0,0,0); 
                           
                      
                      
                  
#line 384
}end_foreach_neighbor()} 
_stencil_val(intersect_true,0,0,0);{
                     _stencil_val_a(intersect_true,0,0,0);
                      
                  }
                   
                
#line 389
}
                     
            
#line 390
}end_foreach_stencil();
            
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 377
foreach(){
                if(val(cs,0,0,0)>0.0 && val(cs,0,0,0)<1.0 && val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0 && level==level_interface){
                  bool flag1 = false;
                  {foreach_neighbor(1){
                      if(val(intersect_true_temp,0,0,0)==1){
                          flag1 = true;
                      }
                  }end_foreach_neighbor()}
                  if(flag1 && val(intersect_true,0,0,0)==0){
                     val(intersect_true,0,0,0)=1;
                      total_number_triple+=1;
                  }
                }
            }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
            
#line 391
if(total_number_triple>=1){
                  method=2;
            }
      }
#line 415 "././my-contact-embed-triple.h"
  }
 if(total_number_triple<=0){
                    method=-1;
  }

bool flag34=false;
if(!flag33 && 1==0){
  flag34=true;
  scalar  intersect_true_temp2=new_scalar("intersect_true_temp2");
  foreach_stencil(){
    _stencil_val_a(intersect_true_temp2,0,0,0); 
_stencil_val(intersect_true_temp,0,0,0); _stencil_val(intersect_true,0,0,0);{ 
        
        {foreach_neighbor(1){
_stencil_val(intersect_true,0,0,0);
              
           
           
        
#line 432
}end_foreach_neighbor()} 
_stencil_val(intersect_true,0,0,0);{
            _stencil_val_a(intersect_true_temp2,0,0,0); 

        }
         
     
#line 437
}
       
  
#line 438
}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 424
foreach(){
    val(intersect_true_temp2,0,0,0)=0;
     if(level==level_interface && val(intersect_true_temp,0,0,0)==1 && val(intersect_true,0,0,0)==0){
        bool flag=false;
        {foreach_neighbor(1){
           if(val(intersect_true,0,0,0)==1){
              flag=true;
           }
        }end_foreach_neighbor()}
        if((!flag) && val(intersect_true,0,0,0)==0){
            val(intersect_true_temp2,0,0,0) =2;

        }
     }
  }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
  
#line 439
foreach_stencil(){ 
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(intersect_true,0,0,0);{  
         
         
         {foreach_neighbor(1){
{
_stencil_val(intersect_true_temp2,0,0,0);
                  
              
              
            
#line 448
}
              
         
#line 449
}end_foreach_neighbor()} 
_stencil_val(intersect_true,0,0,0);{
            _stencil_val_a(intersect_true,0,0,0);
            
         }
          
      
#line 454
}
           
  
#line 455
}end_foreach_stencil();
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 439
foreach(){
      if(level==level_interface && val(cs,0,0,0)>0.0 && val(cs,0,0,0)<1.0 && val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0 && val(intersect_true,0,0,0)==0){
         bool flag=false;
         Point me;
         {foreach_neighbor(1){
            if(!(me.i==point.i && me.j==point.j)){
              if(val(intersect_true_temp2,0,0,0)==2){
                  flag=true;
              }
            }
         }end_foreach_neighbor()}
         if(flag && val(intersect_true,0,0,0)==0){
            val(intersect_true,0,0,0)=2;
            total_number_triple+=1;
         }
      }
  }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 455
delete((scalar*)((scalar[]){intersect_true_temp2,{-1}}));
}

if(1==1){
    foreach_stencil(){
_stencil_val(intersect_true,0,0,0); _stencil_val(intersect_true,0,0,0);{   
          
           _stencil_val(css_test,0,0,0);
          {foreach_neighbor(2){
_stencil_val(intersect_true,0,0,0); _stencil_val(intersect_true,0,0,0);{
_stencil_val(css_test,0,0,0);
                
              
              
            
#line 468
}
             
          
#line 469
}end_foreach_neighbor()}
{
                _stencil_val_a(intersect_true,0,0,0);   
                
           }
           
      
#line 474
}
       
    
#line 475
}end_foreach_stencil();
    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 459
foreach(){
      if(val(intersect_true,0,0,0)==1 || val(intersect_true,0,0,0)==2){
          bool flag=false;
          double value = val(css_test,0,0,0);
          {foreach_neighbor(2){
            if(val(intersect_true,0,0,0)==1 || val(intersect_true,0,0,0)==2){
              if(value<val(css_test,0,0,0)){
                flag=true;
              }
            }
          }end_foreach_neighbor()}
           if(flag){
                val(intersect_true,0,0,0) = 0;
                total_number_triple -=1;
           }
      }
    }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}

#line 476
}else{
    scalar  mindist=new_scalar("mindist");
    foreach_stencil(){
_stencil_val(intersect_true,0,0,0);{   
          
          
           
            
          {foreach_neighbor(2){ 
            
_stencil_val(topo_mask_s,0,0,0); _stencil_val(ff,0,0,0);      
                  
                
               
                     
              
            
             
          
#line 493
}end_foreach_neighbor()}
          _stencil_val_a(mindist,0,0,0);  
      }
      
    
#line 496
}end_foreach_stencil();
    {
#line 478
foreach(){
      if(val(intersect_true,0,0,0)==1){
          bool flag=false;
          double mindist_local=HUGE;
          coord current;
          current.x = x, current.y=y;
          {foreach_neighbor(2){
            coord here;
            if(val(topo_mask_s,0,0,0)==0 && val(ff,0,0,0)<=0){
              here.x = x, here.y = y;
              double distance = sqrt(sq(current.x-here.x) + sq(current.y-here.y));
              if(distance < mindist_local){
                    mindist_local = distance;
              }
            }
          }end_foreach_neighbor()}
          val(mindist,0,0,0) = mindist_local;
      }
    }end_foreach();}

   foreach_stencil() {
_stencil_val(intersect_true,0,0,0);{   
            
             _stencil_val(mindist,0,0,0);
            {foreach_neighbor(2){
_stencil_val(intersect_true,0,0,0);{
_stencil_val(mindist,0,0,0);
                  
                
                
              
#line 507
}
              
            
#line 508
}end_foreach_neighbor()}
{
                _stencil_val_a(intersect_true,0,0,0);   
                
            }
            
        
#line 513
}
        
    
#line 514
}end_foreach_stencil();

   
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:total_number_triple)){
#line 498
foreach() {
        if(val(intersect_true,0,0,0)==1){
            bool flag=false;
            double value = val(mindist,0,0,0);
            {foreach_neighbor(2){
              if(val(intersect_true,0,0,0)==1){
                if(value<val(mindist,0,0,0)){
                  flag=true;
                }
              }
            }end_foreach_neighbor()}
            if(flag){
                val(intersect_true,0,0,0) = 0;
                total_number_triple -=1;
            }
        }
    }end_foreach();mpi_all_reduce_array(&total_number_triple,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 514
delete((scalar*)((scalar[]){mindist,{-1}}));
}







  if(flag33 && total_number_triple>=1){
      foreach_stencil(){

_stencil_val(intersect_true,0,0,0); {   
            _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);  
             _stencil_val(solid_neg_alpha,0,0,0);   

            _stencil_val(solid_n.x,0,0,0);_stencil_val(solid_n.y,0,0,0);  
            _stencil_val(solid_n.x,0,0,0);_stencil_val(n.y,0,0,0);_stencil_val(solid_n.y,0,0,0);_stencil_val(n.x,0,0,0);    
            
                
                      
                
            

            _stencil_val(ff,0,0,0);    
              
             
             
            
            
{{
                _stencil_val_a(intersect_true,0,0,0);  
                _stencil_val_a(triple_coord.x,0,0,0);  
                _stencil_val_a(triple_coord.y,0,0,0);  
            }{
                _stencil_val_a(intersect_true,0,0,0);  
            }}
            
        
#line 551
}

         
      
#line 552
}end_foreach_stencil();
      {
#line 524
foreach(){

        if (val(intersect_true,0,0,0)==1) {
            coord nsf = (coord){val(solid_n.x,0,0,0),val(solid_n.y,0,0,0)};
            double alphasf = val(solid_neg_alpha,0,0,0);

            coord nlg = (coord){-val(solid_n.y,0,0,0),val(solid_n.x,0,0,0)};
            bool same_direction= (val(n.x,0,0,0)*(-val(solid_n.y,0,0,0))+val(n.y,0,0,0)*val(solid_n.x,0,0,0))>0;
            if(!same_direction){
                {
                   nlg.x = - nlg.x;
                }
#line 533
{
                   nlg.y = - nlg.y;
                }
            }

            double alphalg =line_alpha (val(ff,0,0,0), nlg);
            double a1,b1,c1,a2,b2,c2;
            a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
            a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
            double xx=0,yy=0;
            bool intersect_flag= is_intersection_within_unit_square(a1,b1,c1,a2,b2,c2,&xx,&yy);
            if(intersect_flag){
                val(intersect_true,0,0,0) = 1;
                val(triple_coord.x,0,0,0) = (xx-0.5)*Delta+x;
                val(triple_coord.y,0,0,0) = (yy-0.5)*Delta+y;
            }else{
                val(intersect_true,0,0,0) = 0;
            }
        }
      }end_foreach();}

  }else if(flag34 && total_number_triple>=1){
      foreach_stencil(){

_stencil_val(intersect_true,0,0,0); {   
            _stencil_val(solid_n.y,0,0,0);_stencil_val(solid_n.x,0,0,0);  
             _stencil_val(solid_neg_alpha,0,0,0);   

            _stencil_val(solid_n.x,0,0,0);_stencil_val(solid_n.y,0,0,0);  
            _stencil_val(solid_n.x,0,0,0);_stencil_val(n.y,0,0,0);_stencil_val(solid_n.y,0,0,0);_stencil_val(n.x,0,0,0);    
            
                
                      
                
            

            _stencil_val(ff,0,0,0);    
              
             
             
            
            
{{
                _stencil_val_a(intersect_true,0,0,0);  
                _stencil_val_a(triple_coord.x,0,0,0);  
                _stencil_val_a(triple_coord.y,0,0,0);  
            }{
                _stencil_val_a(intersect_true,0,0,0);  
            }}
            
        
#line 582
}

         
      
#line 583
}end_foreach_stencil();
      {
#line 555
foreach(){

        if (val(intersect_true,0,0,0)==2) {
            coord nsf = (coord){val(solid_n.x,0,0,0),val(solid_n.y,0,0,0)};
            double alphasf = val(solid_neg_alpha,0,0,0);

            coord nlg = (coord){-val(solid_n.y,0,0,0),val(solid_n.x,0,0,0)};
            bool same_direction= (val(n.x,0,0,0)*(-val(solid_n.y,0,0,0))+val(n.y,0,0,0)*val(solid_n.x,0,0,0))>0;
            if(!same_direction){
                {
                   nlg.x = - nlg.x;
                }
#line 564
{
                   nlg.y = - nlg.y;
                }
            }

            double alphalg =line_alpha (val(ff,0,0,0), nlg);
            double a1,b1,c1,a2,b2,c2;
            a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
            a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;
            double xx=0,yy=0;
            bool intersect_flag= is_intersection_within_unit_square(a1,b1,c1,a2,b2,c2,&xx,&yy);
            if(intersect_flag){
                val(intersect_true,0,0,0) = 1;
                val(triple_coord.x,0,0,0) = (xx-0.5)*Delta+x;
                val(triple_coord.y,0,0,0) = (yy-0.5)*Delta+y;
            }else{
                val(intersect_true,0,0,0) = 0;
            }
        }
      }end_foreach();}
  }


reconstruction_contact (ff, n, alpha, intersect_true);

int number = 0;
foreach_stencil () {
_stencil_val(intersect_true,0,0,0);
        

     
       

#line 595
}end_foreach_stencil();

#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(+:number)){
#line 590
foreach () {
    if (val(intersect_true,0,0,0) == 1) {
        number++;

    }
}end_foreach();mpi_all_reduce_array(&number,int,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}


#line 597
if(number==0 && pid()==0){
    printf("number of triple point ==0\n");
}

int selectedCount = 0;

foreach_stencil () {

_stencil_val(intersect_true,0,0,0);   
        
            
         
     

       

#line 610
}end_foreach_stencil();


#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 603
foreach () {

    if (val(intersect_true,0,0,0) == 1) {
        if (selectedCount < number) {
            selectedCount++;
        }
    }
}end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif


#line 611
int number_local = selectedCount;

CellInfo* selectedCells = (CellInfo*)pmalloc(number_local * sizeof(CellInfo),__func__,__FILE__,__LINE__);
int globalCount;
MPI_Allreduce(&selectedCount, &globalCount, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
int offset;
MPI_Scan(&selectedCount, &offset, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
offset -= selectedCount;
int local_number = 0;
foreach_stencil () {
_stencil_val(intersect_true,0,0,0); { 
{     
             
             

              
               
_stencil_val(alpha,0,0,0);
              _stencil_val(n.x,0,0,0);
              _stencil_val(n.y,0,0,0);
              _stencil_val(cs,0,0,0);
              _stencil_val(ff,0,0,0);
              _stencil_val(solid_n.x,0,0,0);
              _stencil_val(solid_n.y,0,0,0);
              _stencil_val(triple_coord.x,0,0,0);
              _stencil_val(triple_coord.y,0,0,0);
             
            

        
#line 639
}
           
    
#line 640
}
       

#line 641
}end_foreach_stencil();

#if _OPENMP
  #undef OMP
  #define OMP(x)
#endif
{
#line 620
foreach () {
    if (val(intersect_true,0,0,0) == 1) {
        if (local_number < selectedCount) {
            int globalID = offset + local_number;
            selectedCells[local_number].id = globalID;

            selectedCells[local_number].x = x;
            selectedCells[local_number].y = y;
            selectedCells[local_number].alpha = val(alpha,0,0,0);
            selectedCells[local_number].n_x = val(n.x,0,0,0);
            selectedCells[local_number].n_y = val(n.y,0,0,0);
            selectedCells[local_number].c1 = val(cs,0,0,0);
            selectedCells[local_number].c2 = val(ff,0,0,0);
            selectedCells[local_number].sn_x = val(solid_n.x,0,0,0);
            selectedCells[local_number].sn_y = val(solid_n.y,0,0,0);
            selectedCells[local_number].triplex = val(triple_coord.x,0,0,0);
            selectedCells[local_number].tripley = val(triple_coord.y,0,0,0);
            local_number++;

        }
    }
}end_foreach();}
#if _OPENMP
  #undef OMP
  #define OMP(x) _Pragma(#x)
#endif


        
#line 643
int *allCounts = NULL;
        if (pid() == 0) {
            allCounts = (int*)pmalloc(npe() * sizeof(int),__func__,__FILE__,__LINE__);
        }
        MPI_Gather(&selectedCount, 1, MPI_INT, allCounts, 1, MPI_INT, 0, MPI_COMM_WORLD);


        CellInfo *allSelectedCells = NULL;
        int totalSelectedCount = 0;
        int *displs = NULL;
        if (pid() == 0) {
            for (int i = 0; i < npe(); i++) {
                totalSelectedCount += allCounts[i];
            }
            allSelectedCells = (CellInfo*)pmalloc(totalSelectedCount * sizeof(CellInfo),__func__,__FILE__,__LINE__);
            displs = (int*)pmalloc(npe() * sizeof(int),__func__,__FILE__,__LINE__);
            displs[0] = 0;
            for (int i = 1; i < npe(); i++) {
                displs[i] = displs[i - 1] + allCounts[i - 1];
            }
        }


        MPI_Datatype cellInfoType;


        MPI_Type_contiguous(12, MPI_DOUBLE, &cellInfoType);
        MPI_Type_commit(&cellInfoType);


        MPI_Gatherv(selectedCells, selectedCount, cellInfoType,
                    allSelectedCells, allCounts, displs, cellInfoType,
                    0, MPI_COMM_WORLD);


        MPI_Bcast(&totalSelectedCount, 1, MPI_INT, 0, MPI_COMM_WORLD);
        if (pid() != 0) {
            allSelectedCells = (CellInfo*)pmalloc(totalSelectedCount * sizeof(CellInfo),__func__,__FILE__,__LINE__);
        }
        MPI_Bcast(allSelectedCells, totalSelectedCount, cellInfoType, 0, MPI_COMM_WORLD);
#line 698 "././my-contact-embed-triple.h"
scalar  corner_ff_temp=new_scalar("corner_ff_temp");
if(1==0){
    foreach_stencil(){
        _stencil_val_a(corner_ff_temp,0,0,0);
        _stencil_val_a(corner_ff,0,0,0);
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);{ 
            
            Point me = point;
            {foreach_neighbor(1){
                if(!(me.i==point.i && me.j==point.j)){
_stencil_val(cs,0,0,0);
                        
                    
                    
                
#line 711
}
            }end_foreach_neighbor()}
{
                _stencil_val_a(corner_ff_temp,0,0,0); 
            }
            
        
#line 716
}
           

    
#line 718
}end_foreach_stencil();
    {
#line 700
foreach(){
        val(corner_ff_temp,0,0,0)=0;
        val(corner_ff,0,0,0)=0;
        if(val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && level==level_interface){
            int number=0;
            Point me = point;
            {foreach_neighbor(1){
                if(!(me.i==point.i && me.j==point.j)){
                    if(val(cs,0,0,0)>=1){
                        number+=1;
                    }
                }
            }end_foreach_neighbor()}
            if(number>=5){
                val(corner_ff_temp,0,0,0) =1;
            }
        }

    }end_foreach();}
    foreach_stencil(){
      _stencil_val_a(corner_ff,0,0,0);
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);{ 
          
          {foreach_neighbor(2){
_stencil_val(corner_ff_temp,0,0,0);
                    
                
                
          
#line 727
}end_foreach_neighbor()}
{
              _stencil_val_a(corner_ff,0,0,0);  
          }
          
      
#line 731
}
       
    
#line 732
}end_foreach_stencil();
    {
#line 719
foreach(){
      val(corner_ff,0,0,0)=0;
      if(val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0){
          bool flag=false;
          {foreach_neighbor(2){
                if(val(corner_ff_temp,0,0,0)==1){
                    flag=true;
                }
          }end_foreach_neighbor()}
          if(flag){
              val(corner_ff,0,0,0) = 1;
          }
      }
    }end_foreach();}
    foreach_stencil(){
      _stencil_val_a(corner_ff_temp,0,0,0);_stencil_val(corner_ff,0,0,0);
    }end_foreach_stencil();
    {
#line 733
foreach(){
      val(corner_ff_temp,0,0,0)=val(corner_ff,0,0,0);
    }end_foreach();}
    foreach_stencil(){
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(corner_ff,0,0,0);{ 
          
          {foreach_neighbor(2){
_stencil_val(corner_ff_temp,0,0,0);
                    
                
                
          
#line 743
}end_foreach_neighbor()}
{
              _stencil_val_a(corner_ff,0,0,0);  
          }
          
      
#line 747
}
        
    
#line 748
}end_foreach_stencil();
    {
#line 736
foreach(){
      if(val(cs,0,0,0)<1.0 && val(cs,0,0,0)>0.0 && val(corner_ff,0,0,0)==0){
          bool flag=false;
          {foreach_neighbor(2){
                if(val(corner_ff_temp,0,0,0)==1){
                    flag=true;
                }
          }end_foreach_neighbor()}
          if(flag){
              val(corner_ff,0,0,0) = 1;
          }
      }
    }end_foreach();}
}else{
    foreach_stencil(){ 
_stencil_val(topo_mask_s,0,0,0);{
          _stencil_val_a(corner_ff,0,0,0);
      }
       
    
#line 754
}end_foreach_stencil();
    {
#line 750
foreach(){
      if(level==level_interface && val(topo_mask_s,0,0,0)==0){
          val(corner_ff,0,0,0)=1;
      }
    }end_foreach();}
}


foreach_stencil(){

  _stencil_val_a(f_height,0,0,0); _stencil_val(ff,0,0,0);  
  
_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0);_stencil_val(cs,0,0,0);_stencil_val(cs,0,0,0); 
        
_stencil_val(cs,0,0,0); _stencil_val(corner_ff,0,0,0); {           
      
      
      for(int ii=0;ii<totalSelectedCount;ii++){          
        
        
          
           
           
            
           
           

          
          
{{ 

_stencil_val(intersect_true,0,0,0);{        
                        
                       
                       
                      
                        
                       
                       




                      
                      
                        
                      
                      
                       
                           
                      
                      
                       
                           
                      
                       
                         
                           
                        
                           
                      
                      _stencil_val_a(f_height,0,0,0);    
                  }

                       
           
#line 813
}{        

                  
                    
                   
                   
                  
                                         
                  


                    
                     
                     
                  
                  
                    
                      
                    
                    
                     
                       
                    
                    
                     
                       
                    
                   
                       
                         
                      
                       
                  
                   
                   
                              

                       
                   
                     
                  
                     
                     
                      
                     
                      
                     
_stencil_val(cs,0,0,0);  
                           
                           
                    
                          
                    
                  
                    

          
#line 868
}}
               
      
#line 869
}
{
       _stencil_val_a(f_height,0,0,0);
_stencil_val(cs,0,0,0);{
            _stencil_val_a(ff,0,0,0);  
        }  
        
      
#line 875
}
         
   
#line 876
}

         

#line 877
}end_foreach_stencil();


{
#line 758
foreach(){

  val(f_height,0,0,0) = val(ff,0,0,0);
  bool flag=false;
  flag = (val(cs,0,0,0)>0.0 && val(cs,0,0,0)<1e-6) || ((val(cs,0,0,0)<1.0) && (val(cs,0,0,0)>1.0-1e-6));

   if (val(cs,0,0,0)<1.0 && (!flag) && (level==level_interface) && val(corner_ff,0,0,0)==0) {
      double fc = 0., sfc = 0.;
      coord o = {x, y, z};
      for(int ii=0;ii<totalSelectedCount;ii++){
        double fc_temp=0.0;
        bool insolid_flag=false;
        coord solidn;
          solidn.x = allSelectedCells[ii].sn_x;
          solidn.y = allSelectedCells[ii].sn_y;
          coord a;
          a.x = allSelectedCells[ii].x;
          a.y = allSelectedCells[ii].y;

          double distance1 = fabs(a.x-x)/Delta;
          double distance2 = fabs(a.y-y)/Delta;
          if(distance1<0.2 && distance2<0.2){

                    if(1==0 && val(intersect_true,0,0,0) == 1){
                      coord nf;
                      nf.x = allSelectedCells[ii].n_x;
                      nf.y = allSelectedCells[ii].n_y;
                      double alpha1 = allSelectedCells[ii].alpha;
                      coord triple_location;
                      triple_location.x = allSelectedCells[ii].triplex;
                      triple_location.y = allSelectedCells[ii].tripley;




                      double nf_abs=0.0;
                      {
                        nf_abs+=fabs(nf.x);
                      }
#line 794
{
                        nf_abs+=fabs(nf.y);
                      }
                      coord nf_scale;
                      {
                          nf_scale.x = nf.x/nf_abs;
                      }
#line 798
{
                          nf_scale.y = nf.y/nf_abs;
                      }
                      double alpha_scale=0.0;
                      {
                          alpha_scale += (nf_scale.x*(triple_location.x-a.x)/Delta);
                      }
#line 802
{
                          alpha_scale += (nf_scale.y*(triple_location.y-a.y)/Delta);
                      }
                      if(1==1){
                        {
                          nf.x = nf_scale.x;
                        }
#line 806
{
                          nf.y = nf_scale.y;
                        }
                          alpha1 = alpha_scale;
                      }
                      val(f_height,0,0,0) = line_area(nf.x, nf.y, alpha1);
                  }
           }else if(distance1<=4 && distance2<=4){

                  coord direction;
                  coord triple_location;
                  triple_location.x = allSelectedCells[ii].triplex;
                  triple_location.y = allSelectedCells[ii].tripley;
                  double c1 = allSelectedCells[ii].c1;
                  double c2 = allSelectedCells[ii].c2;
                  double coef = c1*(1. - c1)*c2*(1. - c2);


                  coord nf;
                    nf.x = allSelectedCells[ii].n_x;
                    nf.y = allSelectedCells[ii].n_y;
                  double alpha1 = allSelectedCells[ii].alpha;
                  double nf_abs=0.0;
                    {
                      nf_abs+=fabs(nf.x);
                    }
#line 829
{
                      nf_abs+=fabs(nf.y);
                    }
                    coord nf_scale;
                    {
                      nf_scale.x = nf.x/nf_abs;
                    }
#line 833
{
                      nf_scale.y = nf.y/nf_abs;
                    }
                    double alpha_scale=0.0;
                    {
                      alpha_scale += (nf_scale.x*(triple_location.x-a.x)/Delta);
                    }
#line 837
{
                      alpha_scale += (nf_scale.y*(triple_location.y-a.y)/Delta);
                    }
                  if(1==1){
                      {
                        nf.x = nf_scale.x;
                      }
#line 841
{
                        nf.y = nf_scale.y;
                      }
                      alpha1 = alpha_scale;
                  }
                  coord b;
                  
                    a.x = (o.x - a.x)/Delta - 0.5, b.x = a.x + 1.;
                    
#line 848
a.y = (o.y - a.y)/Delta - 0.5, b.y = a.y + 1.;

                  fc_temp = rectangle_fraction (nf, alpha1, a, b);
                  double alpha_temp;
                  alpha_temp = line_alpha (fc_temp, nf);
                  coord p_temp;
                  double area1 = line_length_center (nf, alpha_temp, &p_temp);
                  p_temp.x = x + Delta*p_temp.x;
                  p_temp.y = y + Delta*p_temp.y;
                  direction.x = p_temp.x - triple_location.x;
                  direction.y = p_temp.y - triple_location.y;
                  insolid_flag = ((direction.x*solidn.x+direction.y*solidn.y)<0.0 && !(fabs(area1)<1e-8));
                  if(val(cs,0,0,0)==0){
                        insolid_flag = true;
                    }
                    if(insolid_flag){
                          fc += coef*fc_temp;
                          sfc += coef;
                    }

          }
      }
      if (sfc > 0.){
       val(f_height,0,0,0) = fc/sfc;
        if(val(cs,0,0,0)==0){
            val(ff,0,0,0) = fc/sfc;
        }
      }
   }
}end_foreach();}
 boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "././my-contact-embed-triple.h", 878);

      pfree(selectedCells,__func__,__FILE__,__LINE__);

        if (pid() == 0) {
            pfree(allCounts,__func__,__FILE__,__LINE__);
            pfree(displs,__func__,__FILE__,__LINE__);
        }
        pfree(allSelectedCells,__func__,__FILE__,__LINE__);
        MPI_Type_free(&cellInfoType);delete((scalar*)((scalar[]){corner_ff_temp,intersect_true_temp,triple_coord.x,triple_coord.y,solid_n.x,solid_n.y,solid_neg_alpha,cs_neg,alpha,n.x,n.y,{-1}}));
}{end_tracing("contact","././my-contact-embed-triple.h",888);return 0;}end_tracing("contact","././my-contact-embed-triple.h",888);}
#line 31 "template01.c"
#line 1 "./axi-css_test.h"
#line 1 "././axi-css_test.h"




scalar  cm_css_test={19};
vector  fm_fss_test={{20},{21}};


static void refine_cm_css_test_axi (Point point, scalar cm_css_test)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  if (val(css_test,0,0,0) > 0. && val(css_test,0,0,0) < 1.) {
    coord n = mycs (point, css_test);


    {foreach_child() {
      if (val(css_test,0,0,0) > 0. && val(css_test,0,0,0) < 1.) {
 coord p;
     double alpha = line_alpha (val(css_test,0,0,0), n);
 line_center(n,alpha,val(css_test,0,0,0),&p);
 val(cm_css_test,0,0,0) = (y + Delta*p.y)*val(css_test,0,0,0);
      }
      else
 val(cm_css_test,0,0,0) = y*val(css_test,0,0,0);
    }end_foreach_child()}
  }
  else
    {foreach_child()
      val(cm_css_test,0,0,0) = y*val(css_test,0,0,0);end_foreach_child()}

}

static void refine_face_fss_test_x_axi (Point point, scalar fm_fss_test)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
#line 50 "././axi-css_test.h"
  double sig = 0., ff = 0.;
  if (val(css_test,0,0,0) > 0. && val(css_test,0,0,0) < 1.) {
    coord n = facet_normal (point, css_test, fss_test);
    sig = sign(n.y)*Delta/4.;
  }
  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0)) {
    ff = fine(fss_test.x,0,0,0);
    fine(fm_fss_test,0,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
    ff = fine(fss_test.x,0,1,0);
    fine(fm_fss_test,0,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors) {
    ff = fine(fss_test.x,2,0,0);
    fine(fm_fss_test,2,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
    ff = fine(fss_test.x,2,1,0);
    fine(fm_fss_test,2,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;
  }
  ff = fine(fss_test.x,1,0,0);
  fine(fm_fss_test,1,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
  ff = fine(fss_test.x,1,1,0);
  fine(fm_fss_test,1,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;

}

static void refine_face_fss_test_y_axi (Point point, scalar fm_fss_test)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;







  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0)) {
    fine(fm_fss_test,0,0,0) = (max(y - Delta/2., 1e-20))*fine(fss_test.y,0,0,0) ;
    fine(fm_fss_test,1,0,0) = (max(y - Delta/2., 1e-20))*fine(fss_test.y,1,0,0);
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors) {
    fine(fm_fss_test,0,2,0) = (y + Delta/2.)*fine(fss_test.y,0,2,0);
    fine(fm_fss_test,1,2,0) = (y + Delta/2.)*fine(fss_test.y,1,2,0);
  }
  fine(fm_fss_test,0,1,0) = y*fine(fss_test.y,0,1,0);
  fine(fm_fss_test,1,1,0) = y*fine(fss_test.y,1,1,0);

}static double _boundary13(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 119
dirichlet(y*val(css_test,0,0,0)));}}static double _boundary13_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary14(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(css_test,0,0,0)));}}static double _boundary14_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}
#line 107 "././axi-css_test.h"
void cm_css_test_update (scalar cm_css_test, scalar css_test, vector fss_test)
{
  foreach_stencil() {
_stencil_val(css_test,0,0,0); _stencil_val(css_test,0,0,0);{ {   
       _stencil_facet_normal (point, css_test, fss_test);     
      _stencil_val(css_test,0,0,0);
_stencil_val(css_test,0,0,0);
      
      
#line 114
_stencil_val_a(cm_css_test,0,0,0);_stencil_val(css_test,0,0,0);    
    }
      
{_stencil_val_a(cm_css_test,0,0,0);_stencil_val(css_test,0,0,0);  }}
          
    
  
#line 118
}end_foreach_stencil();
  {
#line 109
foreach() {
    if (val(css_test,0,0,0) > 0. && val(css_test,0,0,0) < 1.) {
      coord p, n = facet_normal (point, css_test, fss_test);
      double alpha = line_alpha (val(css_test,0,0,0), n);
      line_center(n,alpha,val(css_test,0,0,0),&p);
      val(cm_css_test,0,0,0) = (y + Delta*p.y)*val(css_test,0,0,0);
    }
    else
      val(cm_css_test,0,0,0) = y*val(css_test,0,0,0);
  }end_foreach();}
_attribute[cm_css_test.i].dirty=1,_attribute[cm_css_test.i].boundary[top]=_boundary13,_attribute[cm_css_test.i].boundary_homogeneous[top]=_boundary13_homogeneous;
_attribute[cm_css_test.i].dirty=1,_attribute[cm_css_test.i].boundary[bottom]=_boundary14,_attribute[cm_css_test.i].boundary_homogeneous[bottom]=_boundary14_homogeneous;
}static double _boundary15(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 135
dirichlet(y*val(fss_test.x,0,0,0)));}}static double _boundary15_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary16(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(fss_test.x,0,0,0)));}}static double _boundary16_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}


#line 123
void fm_fss_test_update (vector fm_fss_test, scalar css_test, vector fss_test)
{
  foreach_face_stencil()_stencil_is_face_x(){ {   
    
_stencil_val(css_test,0,0,0); _stencil_val(css_test,0,0,0); {  
       _stencil_facet_normal (point, css_test, fss_test); 
       
    }
          
    
#line 131
_stencil_val_a(fm_fss_test.x,0,0,0); _stencil_val(fss_test.x,0,0,0);_stencil_val(fss_test.x,0,0,0);     
  }}end__stencil_is_face_x()end_foreach_face_stencil();
  {
#line 125
foreach_face_generic()is_face_x(){ {
    double sig = 0.;
    if (val(css_test,0,0,0) > 0. && val(css_test,0,0,0) < 1.) {
      coord n = facet_normal (point, css_test, fss_test);
      sig = sign(n.y)*Delta/2.;
    }
    val(fm_fss_test.x,0,0,0) = (y - sig*(1. - val(fss_test.x,0,0,0)))*val(fss_test.x,0,0,0);
  }}end_is_face_x()end_foreach_face_generic();}
  foreach_face_stencil()_stencil_is_face_y(){
    {_stencil_val_a(fm_fss_test.y,0,0,0);_stencil_val(fss_test.y,0,0,0);   }}end__stencil_is_face_y()end_foreach_face_stencil();
  {
#line 133
foreach_face_generic()is_face_y(){
    val(fm_fss_test.y,0,0,0) = max(y, 1e-20)*val(fss_test.y,0,0,0);}end_is_face_y()end_foreach_face_generic();}
_attribute[fm_fss_test.y.i].dirty=1,_attribute[fm_fss_test.y.i].boundary[top]=_boundary15,_attribute[fm_fss_test.y.i].boundary_homogeneous[top]=_boundary15_homogeneous;
_attribute[fm_fss_test.y.i].dirty=1,_attribute[fm_fss_test.y.i].boundary[bottom]=_boundary16,_attribute[fm_fss_test.y.i].boundary_homogeneous[bottom]=_boundary16_homogeneous;
}static double _boundary17(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 150
dirichlet(y));}}static double _boundary17_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary18(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary18_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary19(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 162
dirichlet(y));}}static double _boundary19_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary20(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary20_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}




#line 141
void metric_css_test(){





  scalar cm_css_testv = cm_css_test;
  foreach_stencil()
    {_stencil_val_a(cm_css_testv,0,0,0);  }end_foreach_stencil();
  {
#line 148
foreach()
    val(cm_css_testv,0,0,0) = y;end_foreach();}
_attribute[cm_css_test.i].dirty=1,_attribute[cm_css_test.i].boundary[top]=_boundary17,_attribute[cm_css_test.i].boundary_homogeneous[top]=_boundary17_homogeneous;
_attribute[cm_css_test.i].dirty=1,_attribute[cm_css_test.i].boundary[bottom]=_boundary18,_attribute[cm_css_test.i].boundary_homogeneous[bottom]=_boundary18_homogeneous;







  vector fm_fss_testv = fm_fss_test;
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(fm_fss_testv.x,0,0,0);   }}end__stencil_is_face_x()
#line 160
_stencil_is_face_y(){
    {_stencil_val_a(fm_fss_testv.y,0,0,0);   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  {
#line 160
foreach_face_generic(){is_face_x(){
    val(fm_fss_testv.x,0,0,0) = max(y, 1e-20);}end_is_face_x()
#line 160
is_face_y(){
    val(fm_fss_testv.y,0,0,0) = max(y, 1e-20);}end_is_face_y()}end_foreach_face_generic();}
_attribute[fm_fss_test.y.i].dirty=1,_attribute[fm_fss_test.y.i].boundary[top]=_boundary19,_attribute[fm_fss_test.y.i].boundary_homogeneous[top]=_boundary19_homogeneous;
_attribute[fm_fss_test.y.i].dirty=1,_attribute[fm_fss_test.y.i].boundary[bottom]=_boundary20,_attribute[fm_fss_test.y.i].boundary_homogeneous[bottom]=_boundary20_homogeneous;





  _attribute[cm_css_test.i].refine = _attribute[cm_css_test.i].prolongation = refine_cm_css_test_axi;
  _attribute[fm_fss_test.x.i].prolongation = refine_face_fss_test_x_axi;
  _attribute[fm_fss_test.y.i].prolongation = refine_face_y_axi;

}
#line 32 "template01.c"
#line 1 "./axi-css_test2.h"
#line 1 "././axi-css_test2.h"




scalar  cm_css_test2={22};
vector  fm_fss_test2={{23},{24}};


static void refine_cm_css_test2_axi (Point point, scalar cm_css_test2)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  if (val(css_test2,0,0,0) > 0. && val(css_test2,0,0,0) < 1.) {
    coord n = mycs (point, css_test2);


    {foreach_child() {
      if (val(css_test2,0,0,0) > 0. && val(css_test2,0,0,0) < 1.) {
 coord p;
     double alpha = line_alpha (val(css_test2,0,0,0), n);
 line_center(n,alpha,val(css_test2,0,0,0),&p);
 val(cm_css_test2,0,0,0) = (y + Delta*p.y)*val(css_test2,0,0,0);
      }
      else
 val(cm_css_test2,0,0,0) = y*val(css_test2,0,0,0);
    }end_foreach_child()}
  }
  else
    {foreach_child()
      val(cm_css_test2,0,0,0) = y*val(css_test2,0,0,0);end_foreach_child()}

}

static void refine_face_fss_test2_x_axi (Point point, scalar fm_fss_test2)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
#line 50 "././axi-css_test2.h"
  double sig = 0., ff = 0.;
  if (val(css_test2,0,0,0) > 0. && val(css_test2,0,0,0) < 1.) {
    coord n = facet_normal (point, css_test2, fss_test2);
    sig = sign(n.y)*Delta/4.;
  }
  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0)) {
    ff = fine(fss_test2.x,0,0,0);
    fine(fm_fss_test2,0,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
    ff = fine(fss_test2.x,0,1,0);
    fine(fm_fss_test2,0,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors) {
    ff = fine(fss_test2.x,2,0,0);
    fine(fm_fss_test2,2,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
    ff = fine(fss_test2.x,2,1,0);
    fine(fm_fss_test2,2,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;
  }
  ff = fine(fss_test2.x,1,0,0);
  fine(fm_fss_test2,1,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
  ff = fine(fss_test2.x,1,1,0);
  fine(fm_fss_test2,1,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;

}

static void refine_face_fss_test2_y_axi (Point point, scalar fm_fss_test2)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;







  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0)) {
    fine(fm_fss_test2,0,0,0) = (max(y - Delta/2., 1e-20))*fine(fss_test2.y,0,0,0) ;
    fine(fm_fss_test2,1,0,0) = (max(y - Delta/2., 1e-20))*fine(fss_test2.y,1,0,0);
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors) {
    fine(fm_fss_test2,0,2,0) = (y + Delta/2.)*fine(fss_test2.y,0,2,0);
    fine(fm_fss_test2,1,2,0) = (y + Delta/2.)*fine(fss_test2.y,1,2,0);
  }
  fine(fm_fss_test2,0,1,0) = y*fine(fss_test2.y,0,1,0);
  fine(fm_fss_test2,1,1,0) = y*fine(fss_test2.y,1,1,0);

}static double _boundary21(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 119
dirichlet(y*val(css_test2,0,0,0)));}}static double _boundary21_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary22(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(css_test2,0,0,0)));}}static double _boundary22_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}
#line 107 "././axi-css_test2.h"
void cm_css_test2_update (scalar cm_css_test2, scalar css_test2, vector fss_test2)
{
  foreach_stencil() {
_stencil_val(css_test2,0,0,0); _stencil_val(css_test2,0,0,0);{ {   
       _stencil_facet_normal (point, css_test2, fss_test2);     
      _stencil_val(css_test2,0,0,0);
_stencil_val(css_test2,0,0,0);
      
      
#line 114
_stencil_val_a(cm_css_test2,0,0,0);_stencil_val(css_test2,0,0,0);    
    }
      
{_stencil_val_a(cm_css_test2,0,0,0);_stencil_val(css_test2,0,0,0);  }}
          
    
  
#line 118
}end_foreach_stencil();
  {
#line 109
foreach() {
    if (val(css_test2,0,0,0) > 0. && val(css_test2,0,0,0) < 1.) {
      coord p, n = facet_normal (point, css_test2, fss_test2);
      double alpha = line_alpha (val(css_test2,0,0,0), n);
      line_center(n,alpha,val(css_test2,0,0,0),&p);
      val(cm_css_test2,0,0,0) = (y + Delta*p.y)*val(css_test2,0,0,0);
    }
    else
      val(cm_css_test2,0,0,0) = y*val(css_test2,0,0,0);
  }end_foreach();}
_attribute[cm_css_test2.i].dirty=1,_attribute[cm_css_test2.i].boundary[top]=_boundary21,_attribute[cm_css_test2.i].boundary_homogeneous[top]=_boundary21_homogeneous;
_attribute[cm_css_test2.i].dirty=1,_attribute[cm_css_test2.i].boundary[bottom]=_boundary22,_attribute[cm_css_test2.i].boundary_homogeneous[bottom]=_boundary22_homogeneous;
}static double _boundary23(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 135
dirichlet(y*val(fss_test2.x,0,0,0)));}}static double _boundary23_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary24(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(fss_test2.x,0,0,0)));}}static double _boundary24_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}


#line 123
void fm_fss_test2_update (vector fm_fss_test2, scalar css_test2, vector fss_test2)
{
  foreach_face_stencil()_stencil_is_face_x(){ {   
    
_stencil_val(css_test2,0,0,0); _stencil_val(css_test2,0,0,0); {  
       _stencil_facet_normal (point, css_test2, fss_test2); 
       
    }
          
    
#line 131
_stencil_val_a(fm_fss_test2.x,0,0,0); _stencil_val(fss_test2.x,0,0,0);_stencil_val(fss_test2.x,0,0,0);     
  }}end__stencil_is_face_x()end_foreach_face_stencil();
  {
#line 125
foreach_face_generic()is_face_x(){ {
    double sig = 0.;
    if (val(css_test2,0,0,0) > 0. && val(css_test2,0,0,0) < 1.) {
      coord n = facet_normal (point, css_test2, fss_test2);
      sig = sign(n.y)*Delta/2.;
    }
    val(fm_fss_test2.x,0,0,0) = (y - sig*(1. - val(fss_test2.x,0,0,0)))*val(fss_test2.x,0,0,0);
  }}end_is_face_x()end_foreach_face_generic();}
  foreach_face_stencil()_stencil_is_face_y(){
    {_stencil_val_a(fm_fss_test2.y,0,0,0);_stencil_val(fss_test2.y,0,0,0);   }}end__stencil_is_face_y()end_foreach_face_stencil();
  {
#line 133
foreach_face_generic()is_face_y(){
    val(fm_fss_test2.y,0,0,0) = max(y, 1e-20)*val(fss_test2.y,0,0,0);}end_is_face_y()end_foreach_face_generic();}
_attribute[fm_fss_test2.y.i].dirty=1,_attribute[fm_fss_test2.y.i].boundary[top]=_boundary23,_attribute[fm_fss_test2.y.i].boundary_homogeneous[top]=_boundary23_homogeneous;
_attribute[fm_fss_test2.y.i].dirty=1,_attribute[fm_fss_test2.y.i].boundary[bottom]=_boundary24,_attribute[fm_fss_test2.y.i].boundary_homogeneous[bottom]=_boundary24_homogeneous;
}static double _boundary25(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 150
dirichlet(y));}}static double _boundary25_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary26(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary26_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary27(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 162
dirichlet(y));}}static double _boundary27_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary28(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary28_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}




#line 141
void metric_css_test2(){





  scalar cm_css_test2v = cm_css_test2;
  foreach_stencil()
    {_stencil_val_a(cm_css_test2v,0,0,0);  }end_foreach_stencil();
  {
#line 148
foreach()
    val(cm_css_test2v,0,0,0) = y;end_foreach();}
_attribute[cm_css_test2.i].dirty=1,_attribute[cm_css_test2.i].boundary[top]=_boundary25,_attribute[cm_css_test2.i].boundary_homogeneous[top]=_boundary25_homogeneous;
_attribute[cm_css_test2.i].dirty=1,_attribute[cm_css_test2.i].boundary[bottom]=_boundary26,_attribute[cm_css_test2.i].boundary_homogeneous[bottom]=_boundary26_homogeneous;







  vector fm_fss_test2v = fm_fss_test2;
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(fm_fss_test2v.x,0,0,0);   }}end__stencil_is_face_x()
#line 160
_stencil_is_face_y(){
    {_stencil_val_a(fm_fss_test2v.y,0,0,0);   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  {
#line 160
foreach_face_generic(){is_face_x(){
    val(fm_fss_test2v.x,0,0,0) = max(y, 1e-20);}end_is_face_x()
#line 160
is_face_y(){
    val(fm_fss_test2v.y,0,0,0) = max(y, 1e-20);}end_is_face_y()}end_foreach_face_generic();}
_attribute[fm_fss_test2.y.i].dirty=1,_attribute[fm_fss_test2.y.i].boundary[top]=_boundary27,_attribute[fm_fss_test2.y.i].boundary_homogeneous[top]=_boundary27_homogeneous;
_attribute[fm_fss_test2.y.i].dirty=1,_attribute[fm_fss_test2.y.i].boundary[bottom]=_boundary28,_attribute[fm_fss_test2.y.i].boundary_homogeneous[bottom]=_boundary28_homogeneous;





  _attribute[cm_css_test2.i].refine = _attribute[cm_css_test2.i].prolongation = refine_cm_css_test2_axi;
  _attribute[fm_fss_test2.x.i].prolongation = refine_face_fss_test2_x_axi;
  _attribute[fm_fss_test2.y.i].prolongation = refine_face_y_axi;

}
#line 33 "template01.c"
#line 1 "./axi-css_test3.h"
#line 1 "././axi-css_test3.h"




scalar  cm_css_test3={25};
vector  fm_fss_test3={{26},{27}};


static void refine_cm_css_test3_axi (Point point, scalar cm_css_test3)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;




  if (val(css_test3,0,0,0) > 0. && val(css_test3,0,0,0) < 1.) {
    coord n = mycs (point, css_test3);


    {foreach_child() {
      if (val(css_test3,0,0,0) > 0. && val(css_test3,0,0,0) < 1.) {
 coord p;
     double alpha = line_alpha (val(css_test3,0,0,0), n);
 line_center(n,alpha,val(css_test3,0,0,0),&p);
 val(cm_css_test3,0,0,0) = (y + Delta*p.y)*val(css_test3,0,0,0);
      }
      else
 val(cm_css_test3,0,0,0) = y*val(css_test3,0,0,0);
    }end_foreach_child()}
  }
  else
    {foreach_child()
      val(cm_css_test3,0,0,0) = y*val(css_test3,0,0,0);end_foreach_child()}

}

static void refine_face_fss_test3_x_axi (Point point, scalar fm_fss_test3)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
#line 50 "././axi-css_test3.h"
  double sig = 0., ff = 0.;
  if (val(css_test3,0,0,0) > 0. && val(css_test3,0,0,0) < 1.) {
    coord n = facet_normal (point, css_test3, fss_test3);
    sig = sign(n.y)*Delta/4.;
  }
  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0)) {
    ff = fine(fss_test3.x,0,0,0);
    fine(fm_fss_test3,0,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
    ff = fine(fss_test3.x,0,1,0);
    fine(fm_fss_test3,0,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors) {
    ff = fine(fss_test3.x,2,0,0);
    fine(fm_fss_test3,2,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
    ff = fine(fss_test3.x,2,1,0);
    fine(fm_fss_test3,2,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;
  }
  ff = fine(fss_test3.x,1,0,0);
  fine(fm_fss_test3,1,0,0) = (y - Delta/4. - sig*(1. - ff))*ff;
  ff = fine(fss_test3.x,1,1,0);
  fine(fm_fss_test3,1,1,0) = (y + Delta/4. - sig*(1. - ff))*ff;

}

static void refine_face_fss_test3_y_axi (Point point, scalar fm_fss_test3)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;







  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0)) {
    fine(fm_fss_test3,0,0,0) = (max(y - Delta/2., 1e-20))*fine(fss_test3.y,0,0,0) ;
    fine(fm_fss_test3,1,0,0) = (max(y - Delta/2., 1e-20))*fine(fss_test3.y,1,0,0);
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors) {
    fine(fm_fss_test3,0,2,0) = (y + Delta/2.)*fine(fss_test3.y,0,2,0);
    fine(fm_fss_test3,1,2,0) = (y + Delta/2.)*fine(fss_test3.y,1,2,0);
  }
  fine(fm_fss_test3,0,1,0) = y*fine(fss_test3.y,0,1,0);
  fine(fm_fss_test3,1,1,0) = y*fine(fss_test3.y,1,1,0);

}static double _boundary29(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 119
dirichlet(y*val(css_test3,0,0,0)));}}static double _boundary29_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary30(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(css_test3,0,0,0)));}}static double _boundary30_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}
#line 107 "././axi-css_test3.h"
void cm_css_test3_update (scalar cm_css_test3, scalar css_test3, vector fss_test3)
{
  foreach_stencil() {
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ {   
       _stencil_facet_normal (point, css_test3, fss_test3);     
      _stencil_val(css_test3,0,0,0);
_stencil_val(css_test3,0,0,0);
      
      
#line 114
_stencil_val_a(cm_css_test3,0,0,0);_stencil_val(css_test3,0,0,0);    
    }
      
{_stencil_val_a(cm_css_test3,0,0,0);_stencil_val(css_test3,0,0,0);  }}
          
    
  
#line 118
}end_foreach_stencil();
  {
#line 109
foreach() {
    if (val(css_test3,0,0,0) > 0. && val(css_test3,0,0,0) < 1.) {
      coord p, n = facet_normal (point, css_test3, fss_test3);
      double alpha = line_alpha (val(css_test3,0,0,0), n);
      line_center(n,alpha,val(css_test3,0,0,0),&p);
      val(cm_css_test3,0,0,0) = (y + Delta*p.y)*val(css_test3,0,0,0);
    }
    else
      val(cm_css_test3,0,0,0) = y*val(css_test3,0,0,0);
  }end_foreach();}
_attribute[cm_css_test3.i].dirty=1,_attribute[cm_css_test3.i].boundary[top]=_boundary29,_attribute[cm_css_test3.i].boundary_homogeneous[top]=_boundary29_homogeneous;
_attribute[cm_css_test3.i].dirty=1,_attribute[cm_css_test3.i].boundary[bottom]=_boundary30,_attribute[cm_css_test3.i].boundary_homogeneous[bottom]=_boundary30_homogeneous;
}static double _boundary31(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 135
dirichlet(y*val(fss_test3.x,0,0,0)));}}static double _boundary31_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary32(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y*val(fss_test3.x,0,0,0)));}}static double _boundary32_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}


#line 123
void fm_fss_test3_update (vector fm_fss_test3, scalar css_test3, vector fss_test3)
{
  foreach_face_stencil()_stencil_is_face_x(){ {   
    
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0); {  
       _stencil_facet_normal (point, css_test3, fss_test3); 
       
    }
          
    
#line 131
_stencil_val_a(fm_fss_test3.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);_stencil_val(fss_test3.x,0,0,0);     
  }}end__stencil_is_face_x()end_foreach_face_stencil();
  {
#line 125
foreach_face_generic()is_face_x(){ {
    double sig = 0.;
    if (val(css_test3,0,0,0) > 0. && val(css_test3,0,0,0) < 1.) {
      coord n = facet_normal (point, css_test3, fss_test3);
      sig = sign(n.y)*Delta/2.;
    }
    val(fm_fss_test3.x,0,0,0) = (y - sig*(1. - val(fss_test3.x,0,0,0)))*val(fss_test3.x,0,0,0);
  }}end_is_face_x()end_foreach_face_generic();}
  foreach_face_stencil()_stencil_is_face_y(){
    {_stencil_val_a(fm_fss_test3.y,0,0,0);_stencil_val(fss_test3.y,0,0,0);   }}end__stencil_is_face_y()end_foreach_face_stencil();
  {
#line 133
foreach_face_generic()is_face_y(){
    val(fm_fss_test3.y,0,0,0) = max(y, 1e-20)*val(fss_test3.y,0,0,0);}end_is_face_y()end_foreach_face_generic();}
_attribute[fm_fss_test3.y.i].dirty=1,_attribute[fm_fss_test3.y.i].boundary[top]=_boundary31,_attribute[fm_fss_test3.y.i].boundary_homogeneous[top]=_boundary31_homogeneous;
_attribute[fm_fss_test3.y.i].dirty=1,_attribute[fm_fss_test3.y.i].boundary[bottom]=_boundary32,_attribute[fm_fss_test3.y.i].boundary_homogeneous[bottom]=_boundary32_homogeneous;
}static double _boundary33(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 150
dirichlet(y));}}static double _boundary33_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary34(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary34_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary35(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
#line 162
dirichlet(y));}}static double _boundary35_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}static double _boundary36(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( 
dirichlet(y));}}static double _boundary36_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}




#line 141
void metric_css_test3(){





  scalar cm_css_test3v = cm_css_test3;
  foreach_stencil()
    {_stencil_val_a(cm_css_test3v,0,0,0);  }end_foreach_stencil();
  {
#line 148
foreach()
    val(cm_css_test3v,0,0,0) = y;end_foreach();}
_attribute[cm_css_test3.i].dirty=1,_attribute[cm_css_test3.i].boundary[top]=_boundary33,_attribute[cm_css_test3.i].boundary_homogeneous[top]=_boundary33_homogeneous;
_attribute[cm_css_test3.i].dirty=1,_attribute[cm_css_test3.i].boundary[bottom]=_boundary34,_attribute[cm_css_test3.i].boundary_homogeneous[bottom]=_boundary34_homogeneous;







  vector fm_fss_test3v = fm_fss_test3;
  foreach_face_stencil(){_stencil_is_face_x(){
    {_stencil_val_a(fm_fss_test3v.x,0,0,0);   }}end__stencil_is_face_x()
#line 160
_stencil_is_face_y(){
    {_stencil_val_a(fm_fss_test3v.y,0,0,0);   }}end__stencil_is_face_y()}end_foreach_face_stencil();
  {
#line 160
foreach_face_generic(){is_face_x(){
    val(fm_fss_test3v.x,0,0,0) = max(y, 1e-20);}end_is_face_x()
#line 160
is_face_y(){
    val(fm_fss_test3v.y,0,0,0) = max(y, 1e-20);}end_is_face_y()}end_foreach_face_generic();}
_attribute[fm_fss_test3.y.i].dirty=1,_attribute[fm_fss_test3.y.i].boundary[top]=_boundary35,_attribute[fm_fss_test3.y.i].boundary_homogeneous[top]=_boundary35_homogeneous;
_attribute[fm_fss_test3.y.i].dirty=1,_attribute[fm_fss_test3.y.i].boundary[bottom]=_boundary36,_attribute[fm_fss_test3.y.i].boundary_homogeneous[bottom]=_boundary36_homogeneous;





  _attribute[cm_css_test3.i].refine = _attribute[cm_css_test3.i].prolongation = refine_cm_css_test3_axi;
  _attribute[fm_fss_test3.x.i].prolongation = refine_face_fss_test3_x_axi;
  _attribute[fm_fss_test3.y.i].prolongation = refine_face_y_axi;

}
#line 34 "template01.c"
#line 1 "./getsolid.h"
#line 1 "././getsolid.h"
#line 16 "././getsolid.h"
extern scalar merge_to_me_s_c,merge_to_me_s_energy;
extern vector merge_to_me_s_position;

extern scalar merge_to_me_l_c,merge_to_me_l_energy;
extern vector merge_to_me_l_position;

extern scalar merge_to_me_g_c,merge_to_me_g_energy;
extern vector merge_to_me_g_position;
extern scalar intersect_ture;
extern scalar T;

extern bool Rcc_flag_l, Rcc_flag_g;
extern scalar aiml_s,aimg_s;
extern double Rcc;
extern double delta_min;



extern vector modphase0,modphase1,modphase_s_0;
bool structure_normal_flag = true;
struct Topo_m3 {
    scalar topo_mask;
    scalar ff;
    int level_interface;
};

void get_topomask_soilid(struct Topo_m3 q) {
     scalar topo_mask = q.topo_mask;
     scalar ff=q.ff;
     int level_interface=q.level_interface;

     foreach_stencil(){       
        _stencil_val(ff,0,0,0);
 _stencil_val_a(topo_mask,0,0,0);

_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
   _stencil_val_a(topo_mask,0,0,0);  
        }  

          
     
#line 54
}end_foreach_stencil();

     {
#line 47
foreach(){
        int phase_sign = (val(ff,0,0,0)>=0.5-0.0) ? 1 : -1;
 val(topo_mask,0,0,0) = 3*phase_sign;

         if(val(ff,0,0,0)<1.0-0.0 && val(ff,0,0,0)>0.0){
   val(topo_mask,0,0,0) = 0;
        }
     }end_foreach();}
     boundary_internal ((scalar *)((scalar[]){topo_mask,{-1}}), "././getsolid.h", 55);
     foreach_stencil(){

{  
            
            { 
               _stencil_val(topo_mask,1,0,0); 
               _stencil_val(topo_mask,-1,0,0); 
                
               
              
            }
#line 60
{ 
               _stencil_val(topo_mask,0,1,0); 
               _stencil_val(topo_mask,0,-1,0); 
                
               
              
            } 
            _stencil_val(topo_mask,0,0,0);
{

{{
           _stencil_val_a(topo_mask,0,0,0);  
       } {_stencil_val(topo_mask,0,0,0);{
           _stencil_val_a(topo_mask,0,0,0);  
       }}}

       
            
#line 75
}
               
        
#line 76
}

          

     
#line 78
}end_foreach_stencil();
     {
#line 56
foreach(){

         if(level==level_interface ){
            bool is1= false;
            {
               int temp1=val(topo_mask,1,0,0);
               int temp2=val(topo_mask,-1,0,0);
            if(temp1==0 || temp2==0){
               is1 = true;
               }
            }
#line 60
{
               int temp1=val(topo_mask,0,1,0);
               int temp2=val(topo_mask,0,-1,0);
            if(temp1==0 || temp2==0){
               is1 = true;
               }
            }
            int temp3=val(topo_mask,0,0,0);
            if (is1 && temp3!=0){

       if(temp3==3){
           val(topo_mask,0,0,0) = 1;
       }else if(val(topo_mask,0,0,0)==-3){
           val(topo_mask,0,0,0) = -1;
       }
            }
        }

     }end_foreach();}
  for(int phase=0;phase<=1;phase++){
     foreach_stencil(){

{      
                _stencil_val(ff,0,0,0);  
            
               { 
                  _stencil_val(topo_mask,1,0,0); 
                  _stencil_val(topo_mask,-1,0,0); 
                   
                  
                  
               }
#line 85
{ 
                  _stencil_val(topo_mask,0,1,0); 
                  _stencil_val(topo_mask,0,-1,0); 
                   
                  
                  
               }  
                _stencil_val(topo_mask,0,0,0);
{
                  _stencil_val_a(topo_mask,0,0,0);   
               }
                  
         
#line 96
}

           
     
#line 97
}end_foreach_stencil();
     {
#line 80
foreach(){

          if(level==level_interface ){
               int phase_sign = val(ff,0,0,0)>=0.5-0.0 ? 1 : -1;
            bool is1= false;
               {
                  int temp1=val(topo_mask,1,0,0);
                  int temp2=val(topo_mask,-1,0,0);
               if( temp1==(2*phase-1) || temp2==(2*phase-1)){
                  is1 = true;
                  }
               }
#line 85
{
                  int temp1=val(topo_mask,0,1,0);
                  int temp2=val(topo_mask,0,-1,0);
               if( temp1==(2*phase-1) || temp2==(2*phase-1)){
                  is1 = true;
                  }
               }
               int temp3 = val(topo_mask,0,0,0);
               if (is1 && temp3==3*phase_sign){
                  val(topo_mask,0,0,0) = 2*(2*phase-1) ;
               }
         }
     }end_foreach();}
  }



}

void gradient_s (scalar * f, vector * g, scalar c, scalar topo_mask, bool inverse)
{


  if (!(list_len(f) == vectors_len(g))) qassert ("././getsolid.h", 108, "list_len(f) == vectors_len(g)");
  double cmin = 0.5;
  foreach_stencil() {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
         {
            _stencil_val_a(v.x,0,0,0);        
             _stencil_val(c,1,0,0); _stencil_val(c,0,0,0); _stencil_val(c,-1,0,0); 
            
                                      
_stencil_val(topo_mask,0,0,0);{
{ {
{{
                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0);  
                    }{

                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0); _stencil_val(s,0,0,0);   
                    }}
                       
                
#line 126
}
                    {_stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,-1,0,0);   }}
                       
             
#line 128
}
              
        
#line 129
} 
#line 113
{
            _stencil_val_a(v.y,0,0,0);        
             _stencil_val(c,0,1,0); _stencil_val(c,0,0,0); _stencil_val(c,0,-1,0); 
            
                                      
_stencil_val(topo_mask,0,0,0);{
{ {
{{
                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0);  
                    }{

                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0); _stencil_val(s,0,0,0);   
                    }}
                       
                
#line 126
}
                    {_stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,-1,0);   }}
                       
             
#line 128
}
              
        
#line 129
}
    }}}
  }end_foreach_stencil();
  {
#line 110
foreach() {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
         {
            val(v.x,0,0,0) = 0.0;
            double cl = val(c,-1,0,0), cc = val(c,0,0,0), cr = val(c,1,0,0);
            if (inverse)
                        cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
            if(fabs(val(topo_mask,0,0,0))<3 && cc>=0.5){
                if (cr >= cmin) {
                    if (cl >= cmin){
                        val(v.x,0,0,0) =(val(s,1,0,0) - val(s,-1,0,0))/(2.0*Delta);
                    }else{

                        val(v.x,0,0,0) = (val(s,1,0,0) - val(s,0,0,0))/Delta;
                    }
                }else if (cl >= cmin)
                    val(v.x,0,0,0) = (val(s,0,0,0) - val(s,-1,0,0))/Delta;
             }
        } 
#line 113
{
            val(v.y,0,0,0) = 0.0;
            double cl = val(c,0,-1,0), cc = val(c,0,0,0), cr = val(c,0,1,0);
            if (inverse)
                        cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
            if(fabs(val(topo_mask,0,0,0))<3 && cc>=0.5){
                if (cr >= cmin) {
                    if (cl >= cmin){
                        val(v.y,0,0,0) =(val(s,0,1,0) - val(s,0,-1,0))/(2.0*Delta);
                    }else{

                        val(v.y,0,0,0) = (val(s,0,1,0) - val(s,0,0,0))/Delta;
                    }
                }else if (cl >= cmin)
                    val(v.y,0,0,0) = (val(s,0,0,0) - val(s,0,-1,0))/Delta;
             }
        }
    }}}
  }end_foreach();}
}
extern double Tsat00;

static double gradient_distacew(double T1, double T2, double T3, double a, double b) {
    double F = (T2 - T1) / a;
    double B = (T3 - T2) / b;

    double dT_dx = F + ((B - F) * 2 / (a + b) * a / 2);

    return dT_dx;
}


static double gradient_quadratic(double T1, double T2, double T3, double a, double b) {
    double A = ((b*T1) - (a*T3) + ((a+b)*T2)) / (a*b*(a+b));
    double B = ((T3-T2)/b - (T2-T1)/a) / (b-a);

    double dT_dx = 2*A*0 + B;

    return dT_dx;
}

void gradient_ff (scalar * f, vector * g, scalar c, scalar c2, scalar topo_mask, scalar topo_mask_s, bool inverse)
{



  if (!(list_len(f) == vectors_len(g))) qassert ("././getsolid.h", 159, "list_len(f) == vectors_len(g)");
  double cmin = 0.5;
  foreach_stencil() {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
         {
            _stencil_val_a(v.x,0,0,0);        
             _stencil_val(c,1,0,0); _stencil_val(c,0,0,0); _stencil_val(c,-1,0,0); 
            _stencil_val(c2,-1,0,0); 
            _stencil_val(c2,0,0,0); 
            _stencil_val(c2,1,0,0);


{
{{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{
                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0);  
                            }{ 
                              
                              if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                    
                              
#line 183
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                     
                              
#line 185
}
                              
                                  
                              
                                _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,1,0,0);   
                            }}
                               
                        
#line 191
}{{ 
                           
                              if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                    
                              
#line 195
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                     
                              
#line 197
}
                              
                                  
                              
                            _stencil_val_a(v.x,0,0,0);_stencil_val(s,-1,0,0);_stencil_val(s,0,0,0);   
                        }{

                        }}}
                               
                    
#line 205
}

                            
                
#line 206
}{{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{

                                            _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0);_stencil_val(s,0,0,0);  
                                }{ 
                                    
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                            
                                    
#line 217
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                             
                                    
#line 219
} 
                                     
_stencil_val(modphase_s_0.x,0,0,0);
{{
                                        
                                            
                                        

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,1,0,0);   
                                    }{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0);_stencil_val(s,0,0,0);  
                                    }} 
                                    
                                    
                                
#line 232
}}
                                   
                        
#line 233
}{{ 
                                 
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                            
                                    
#line 237
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                             
                                    
#line 239
}
{{
                                         
                                             
                                        

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                 }{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0);_stencil_val(s,0,0,0);  
                                 }}
                                   
                        
#line 250
}{ 
                                  
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                            
                                    
#line 254
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                             
                                    
#line 256
} 
                                     
_stencil_val(modphase_s_0.x,0,0,0);  
                                    
                                  
                                    
#line 260
if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                            
                                    
#line 262
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                             
                                    
#line 264
}    
                                    

                                








{{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);   
                                }{{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,1,0,0);   
                                }{{

                                       _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                }{

                                       _stencil_val_a(v.x,0,0,0);_stencil_val(s,1,0,0);_stencil_val(s,0,0,0);  
                                }}}} 
                                   
                                  
                                 
                                     
                                
                                 
                                     
                                
                                        
                        
#line 289
}}}
                                    
                      
#line 290
}

                              
                
#line 291
}{{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{

                                     _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,-1,0,0);  
                                }{ 
                                     
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                            
                                    
#line 302
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                             
                                    
#line 304
}
{{
                                             
                                                 
                                            

                                            _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                    }{

                                            _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,-1,0,0);  
                                    }}
                                      

                                
#line 316
}}
                                   
                        
#line 317
}{{ 
                                 
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                            
                                    
#line 321
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                             
                                    
#line 323
}   
                                     
_stencil_val(modphase_s_0.x,1,0,0);
{{
                                         
                                             
                                        

                                         _stencil_val_a(v.x,0,0,0);_stencil_val(s,-1,0,0);_stencil_val(s,0,0,0);   
                                    }{

                                         _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,-1,0,0);  
                                    }} 
                                    
                                      
                        
#line 336
}{ 
                                
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                            
                                    
#line 340
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                             
                                    
#line 342
}  
                                    

                                  
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                            
                                    
#line 348
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                             
                                    
#line 350
}   
                                     
_stencil_val(modphase_s_0.x,1,0,0);  
                                    
                                    







{{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);   
                                }{{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                }{{

                                       _stencil_val_a(v.x,0,0,0);_stencil_val(s,-1,0,0);_stencil_val(s,0,0,0);   
                                }{

                                       _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,-1,0,0);  
                                }}}} 
                                   
                                  
                                 
                                     
                                
                                 
                                     
                                
                                        
                        
#line 375
}}}
                                    
                      
#line 376
}

                              

                
#line 378
}{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{


                                }{ 
                                    
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                            
                                    
#line 389
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                             
                                    
#line 391
} 
                                     
_stencil_val(modphase_s_0.x,0,0,0);
{{
                                            
                                                
                                            

                                            _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                    }{


                                    }} 
                                    
                                    
                                
#line 404
}}
                                   
                        
#line 405
}{{ 
                                  
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                            
                                    
#line 409
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                             
                                    
#line 411
}   
                                     
_stencil_val(modphase_s_0.x,1,0,0);
{{
{

                                             _stencil_val_a(v.x,0,0,0); _stencil_val(s,0,0,0);   
                                        }
                                        
                                
#line 419
}{


                                }} 
                                    
                                
                        
#line 423
}{ 
                                 
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.x,0,0,0); 
                                            
                                    
#line 427
}else{ 
_stencil_val(modphase0.x,0,0,0);
                                             
                                    
#line 429
} 
                                     
_stencil_val(modphase_s_0.x,0,0,0);  
                                    
                                     
                                    
#line 433
if(phase_flag3==1){ 
_stencil_val(modphase1.x,1,0,0); 
                                            
                                    
#line 435
}else{ 
_stencil_val(modphase0.x,1,0,0);
                                             
                                    
#line 437
}   
                                     
_stencil_val(modphase_s_0.x,1,0,0);  
                                    
                                    







{{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);   
                                }{{

                                        _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                }{{

                                       _stencil_val_a(v.x,0,0,0);_stencil_val(s,0,0,0);  
                                }{


                                }}}} 
                                   
                                  
                                 
                                     
                                
                                 
                                     
                                
                                         
                        
#line 462
}}}
                                    
                      
#line 463
}

                             

                
#line 465
}}}}
                            
            
#line 466
} 
            
                                      
            
        
#line 467
} 
#line 164
{
            _stencil_val_a(v.y,0,0,0);        
             _stencil_val(c,0,1,0); _stencil_val(c,0,0,0); _stencil_val(c,0,-1,0); 
            _stencil_val(c2,0,-1,0); 
            _stencil_val(c2,0,0,0); 
            _stencil_val(c2,0,1,0);


{
{{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{
                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0);  
                            }{ 
                              
                              if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                    
                              
#line 183
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                     
                              
#line 185
}
                              
                                  
                              
                                _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,1,0);   
                            }}
                               
                        
#line 191
}{{ 
                           
                              if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                    
                              
#line 195
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                     
                              
#line 197
}
                              
                                  
                              
                            _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,-1,0);_stencil_val(s,0,0,0);   
                        }{

                        }}}
                               
                    
#line 205
}

                            
                
#line 206
}{{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{

                                            _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0);_stencil_val(s,0,0,0);  
                                }{ 
                                    
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                            
                                    
#line 217
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                             
                                    
#line 219
} 
                                     
_stencil_val(modphase_s_0.y,0,0,0);
{{
                                        
                                            
                                        

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,1,0);   
                                    }{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0);_stencil_val(s,0,0,0);  
                                    }} 
                                    
                                    
                                
#line 232
}}
                                   
                        
#line 233
}{{ 
                                 
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                            
                                    
#line 237
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                             
                                    
#line 239
}
{{
                                         
                                             
                                        

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                 }{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0);_stencil_val(s,0,0,0);  
                                 }}
                                   
                        
#line 250
}{ 
                                  
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                            
                                    
#line 254
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                             
                                    
#line 256
} 
                                     
_stencil_val(modphase_s_0.y,0,0,0);  
                                    
                                  
                                    
#line 260
if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                            
                                    
#line 262
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                             
                                    
#line 264
}    
                                    

                                








{{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);   
                                }{{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,1,0);   
                                }{{

                                       _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                }{

                                       _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,1,0);_stencil_val(s,0,0,0);  
                                }}}} 
                                   
                                  
                                 
                                     
                                
                                 
                                     
                                
                                        
                        
#line 289
}}}
                                    
                      
#line 290
}

                              
                
#line 291
}{{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{

                                     _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,-1,0);  
                                }{ 
                                     
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                            
                                    
#line 302
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                             
                                    
#line 304
}
{{
                                             
                                                 
                                            

                                            _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                    }{

                                            _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,-1,0);  
                                    }}
                                      

                                
#line 316
}}
                                   
                        
#line 317
}{{ 
                                 
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                            
                                    
#line 321
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                             
                                    
#line 323
}   
                                     
_stencil_val(modphase_s_0.y,0,1,0);
{{
                                         
                                             
                                        

                                         _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,-1,0);_stencil_val(s,0,0,0);   
                                    }{

                                         _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,-1,0);  
                                    }} 
                                    
                                      
                        
#line 336
}{ 
                                
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                            
                                    
#line 340
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                             
                                    
#line 342
}  
                                    

                                  
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                            
                                    
#line 348
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                             
                                    
#line 350
}   
                                     
_stencil_val(modphase_s_0.y,0,1,0);  
                                    
                                    







{{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);   
                                }{{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                }{{

                                       _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,-1,0);_stencil_val(s,0,0,0);   
                                }{

                                       _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);_stencil_val(s,0,-1,0);  
                                }}}} 
                                   
                                  
                                 
                                     
                                
                                 
                                     
                                
                                        
                        
#line 375
}}}
                                    
                      
#line 376
}

                              

                
#line 378
}{

_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask_s,0,0,0);{
{ {
{{


                                }{ 
                                    
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                            
                                    
#line 389
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                             
                                    
#line 391
} 
                                     
_stencil_val(modphase_s_0.y,0,0,0);
{{
                                            
                                                
                                            

                                            _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                    }{


                                    }} 
                                    
                                    
                                
#line 404
}}
                                   
                        
#line 405
}{{ 
                                  
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                            
                                    
#line 409
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                             
                                    
#line 411
}   
                                     
_stencil_val(modphase_s_0.y,0,1,0);
{{
{

                                             _stencil_val_a(v.y,0,0,0); _stencil_val(s,0,0,0);   
                                        }
                                        
                                
#line 419
}{


                                }} 
                                    
                                
                        
#line 423
}{ 
                                 
                                    if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,0,0); 
                                            
                                    
#line 427
}else{ 
_stencil_val(modphase0.y,0,0,0);
                                             
                                    
#line 429
} 
                                     
_stencil_val(modphase_s_0.y,0,0,0);  
                                    
                                     
                                    
#line 433
if(phase_flag3==1){ 
_stencil_val(modphase1.y,0,1,0); 
                                            
                                    
#line 435
}else{ 
_stencil_val(modphase0.y,0,1,0);
                                             
                                    
#line 437
}   
                                     
_stencil_val(modphase_s_0.y,0,1,0);  
                                    
                                    







{{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);   
                                }{{

                                        _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                }{{

                                       _stencil_val_a(v.y,0,0,0);_stencil_val(s,0,0,0);  
                                }{


                                }}}} 
                                   
                                  
                                 
                                     
                                
                                 
                                     
                                
                                         
                        
#line 462
}}}
                                    
                      
#line 463
}

                             

                
#line 465
}}}}
                            
            
#line 466
} 
            
                                      
            
        
#line 467
}
    }}}
  }end_foreach_stencil();
  {
#line 161
foreach() {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
         {
            val(v.x,0,0,0) = 0.0;
            double cl = val(c,-1,0,0), cc = val(c,0,0,0), cr = val(c,1,0,0);
            bool is_solid_l=val(c2,-1,0,0)>0.5;
            bool is_solid_c=val(c2,0,0,0)>0.5;
            bool is_solid_r=val(c2,1,0,0)>0.5;
            if (inverse)
                        cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
            if(!is_solid_c){
                 if((!is_solid_l) && (!is_solid_r)){

                      if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                        if (cr >= cmin) {
                            if (cl >= cmin){
                                        val(v.x,0,0,0) =(val(s,1,0,0) - val(s,-1,0,0))/(2.0*Delta);
                            }else{
                              double leftd=1.0;
                              if(phase_flag3==1){
                                    leftd = val(modphase1.x,0,0,0);
                              }else{
                                    leftd = val(modphase0.x,0,0,0);
                              }
                              if(leftd<1e-2){
                                  leftd=1e-2;
                              }
                                val(v.x,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),val(s,1,0,0),leftd,1)/Delta;
                            }
                        }else if (cl >= cmin){
                           double rightd=1.0;
                              if(phase_flag3==1){
                                    rightd = val(modphase1.x,1,0,0);
                              }else{
                                    rightd = val(modphase0.x,1,0,0);
                              }
                              if(rightd<1e-2){
                                  rightd=1e-2;
                              }
                            val(v.x,0,0,0) = gradient_distacew (val(s,-1,0,0),val(s,0,0,0),Tsat00,1,rightd)/Delta;
                        }else{

                        }
                    }
                }else if(is_solid_l && (!is_solid_r)){

                        if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                             if (cr >= cmin) {
                                if (cl >= cmin){

                                            val(v.x,0,0,0) = (val(s,1,0,0)-val(s,0,0,0))/Delta;
                                }else{
                                    double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.x,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.x,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.x,0,0,0);
                                    if(leftd_f<leftd_s){
                                        if(leftd_f<1e-2){
                                            leftd_f=1e-2;
                                        }

                                        val(v.x,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),val(s,1,0,0),leftd_f,1)/Delta;
                                    }else{

                                        val(v.x,0,0,0) = (val(s,1,0,0)-val(s,0,0,0))/Delta;
                                    }
                                }
                        }else if (cl >= cmin){
                                 double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.x,1,0,0);
                                    }else{
                                            rightd_f = val(modphase0.x,1,0,0);
                                    }
                                 if(rightd_f < 1.0){
                                        if(rightd_f<1e-2){
                                            rightd_f = 1e-2;
                                        }

                                        val(v.x,0,0,0) = (Tsat00-val(s,0,0,0))/(rightd_f*Delta);
                                 }else{

                                        val(v.x,0,0,0) = (val(s,1,0,0)-val(s,0,0,0))/Delta;
                                 }
                        }else{
                                  double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.x,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.x,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.x,0,0,0);
                                  double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.x,1,0,0);
                                    }else{
                                            rightd_f = val(modphase0.x,1,0,0);
                                    }
                                    double rightd_s = 1.0;

                                bool left_flag,right_flag;
                                left_flag = leftd_f < leftd_s;
                                right_flag=rightd_f < rightd_s;
                                if(leftd_f<1e-2){
                                    leftd_f = 1e-2;
                                }
                                if(rightd_f<1e-2){
                                    rightd_f = 1e-2;
                                }
                                if(left_flag && right_flag){

                                        val(v.x,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),Tsat00,leftd_f,rightd_f)/Delta;
                                }else if(left_flag && (!right_flag)){

                                        val(v.x,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),val(s,1,0,0),leftd_f,1)/Delta;
                                }else if((!left_flag) && right_flag){

                                       val(v.x,0,0,0) = (Tsat00-val(s,0,0,0))/(rightd_f*Delta);
                                }else{

                                       val(v.x,0,0,0) = (val(s,1,0,0)-val(s,0,0,0))/Delta;
                                }
                        }
                      }
                }else if((!is_solid_l) && (is_solid_r)){

                        if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                             if (cr >= cmin) {
                                if (cl >= cmin){

                                     val(v.x,0,0,0) = (val(s,0,0,0)-val(s,-1,0,0))/Delta;
                                }else{
                                     double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.x,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.x,0,0,0);
                                    }
                                    if(leftd_f < 1.0){
                                            if(leftd_f<1e-2){
                                                leftd_f = 1e-2;
                                            }

                                            val(v.x,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                    }else{

                                            val(v.x,0,0,0) = (val(s,0,0,0)-val(s,-1,0,0))/Delta;
                                    }

                                }
                        }else if (cl >= cmin){
                                 double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.x,1,0,0);
                                    }else{
                                            rightd_f = val(modphase0.x,1,0,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.x,1,0,0);
                                    if(rightd_f < rightd_s){
                                        if(rightd_f<1e-2){
                                            rightd_f = 1e-2;
                                        }

                                         val(v.x,0,0,0) = gradient_distacew (val(s,-1,0,0),val(s,0,0,0),Tsat00,1,rightd_f)/Delta;
                                    }else{

                                         val(v.x,0,0,0) = (val(s,0,0,0)-val(s,-1,0,0))/Delta;
                                    }
                        }else{
                                double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.x,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.x,0,0,0);
                                    }
                                    double leftd_s=1.0;

                                  double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.x,1,0,0);
                                    }else{
                                            rightd_f = val(modphase0.x,1,0,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.x,1,0,0);
                                    bool left_flag,right_flag;
                                left_flag = leftd_f < leftd_s;
                                right_flag=rightd_f < rightd_s;
                                if(leftd_f<1e-2){
                                    leftd_f = 1e-2;
                                }
                                if(rightd_f<1e-2){
                                    rightd_f = 1e-2;
                                }
                                if(left_flag && right_flag){

                                        val(v.x,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),Tsat00,leftd_f,rightd_f)/Delta;
                                }else if(left_flag && (!right_flag)){

                                        val(v.x,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                }else if((!left_flag) && right_flag){

                                       val(v.x,0,0,0) = gradient_distacew (val(s,-1,0,0),val(s,0,0,0),Tsat00,1,rightd_f)/Delta;
                                }else{

                                       val(v.x,0,0,0) = (val(s,0,0,0)-val(s,-1,0,0))/Delta;
                                }
                        }
                      }

                }else if(is_solid_l && is_solid_r){

                       if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                             if (cr >= cmin) {
                                if (cl >= cmin){


                                }else{
                                    double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.x,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.x,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.x,0,0,0);
                                    if(leftd_f<leftd_s){
                                            if(leftd_f<1e-2){
                                                leftd_f=1e-2;
                                            }

                                            val(v.x,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                    }else{


                                    }
                                }
                        }else if (cl >= cmin){
                                  double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.x,1,0,0);
                                    }else{
                                            rightd_f = val(modphase0.x,1,0,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.x,1,0,0);
                                if(rightd_f<rightd_s){
                                        if(rightd_f<1e-2){

                                             val(v.x,0,0,0) = (Tsat00 - val(s,0,0,0))/(rightd_f*Delta);
                                        }
                                }else{


                                }
                        }else{
                                 double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.x,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.x,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.x,0,0,0);
                                     double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.x,1,0,0);
                                    }else{
                                            rightd_f = val(modphase0.x,1,0,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.x,1,0,0);
                                    bool left_flag,right_flag;
                                left_flag = leftd_f < leftd_s;
                                right_flag=rightd_f < rightd_s;
                                if(leftd_f<1e-2){
                                    leftd_f = 1e-2;
                                }
                                if(rightd_f<1e-2){
                                    rightd_f = 1e-2;
                                }
                                 if(left_flag && right_flag){

                                        val(v.x,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),Tsat00,leftd_f,rightd_f)/Delta;
                                }else if(left_flag && (!right_flag)){

                                        val(v.x,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                }else if((!left_flag) && right_flag){

                                       val(v.x,0,0,0) = (Tsat00-val(s,0,0,0))/(rightd_f*Delta);
                                }else{


                                }
                        }
                      }

                }
            }
        } 
#line 164
{
            val(v.y,0,0,0) = 0.0;
            double cl = val(c,0,-1,0), cc = val(c,0,0,0), cr = val(c,0,1,0);
            bool is_solid_l=val(c2,0,-1,0)>0.5;
            bool is_solid_c=val(c2,0,0,0)>0.5;
            bool is_solid_r=val(c2,0,1,0)>0.5;
            if (inverse)
                        cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
            if(!is_solid_c){
                 if((!is_solid_l) && (!is_solid_r)){

                      if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                        if (cr >= cmin) {
                            if (cl >= cmin){
                                        val(v.y,0,0,0) =(val(s,0,1,0) - val(s,0,-1,0))/(2.0*Delta);
                            }else{
                              double leftd=1.0;
                              if(phase_flag3==1){
                                    leftd = val(modphase1.y,0,0,0);
                              }else{
                                    leftd = val(modphase0.y,0,0,0);
                              }
                              if(leftd<1e-2){
                                  leftd=1e-2;
                              }
                                val(v.y,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),val(s,0,1,0),leftd,1)/Delta;
                            }
                        }else if (cl >= cmin){
                           double rightd=1.0;
                              if(phase_flag3==1){
                                    rightd = val(modphase1.y,0,1,0);
                              }else{
                                    rightd = val(modphase0.y,0,1,0);
                              }
                              if(rightd<1e-2){
                                  rightd=1e-2;
                              }
                            val(v.y,0,0,0) = gradient_distacew (val(s,0,-1,0),val(s,0,0,0),Tsat00,1,rightd)/Delta;
                        }else{

                        }
                    }
                }else if(is_solid_l && (!is_solid_r)){

                        if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                             if (cr >= cmin) {
                                if (cl >= cmin){

                                            val(v.y,0,0,0) = (val(s,0,1,0)-val(s,0,0,0))/Delta;
                                }else{
                                    double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.y,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.y,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.y,0,0,0);
                                    if(leftd_f<leftd_s){
                                        if(leftd_f<1e-2){
                                            leftd_f=1e-2;
                                        }

                                        val(v.y,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),val(s,0,1,0),leftd_f,1)/Delta;
                                    }else{

                                        val(v.y,0,0,0) = (val(s,0,1,0)-val(s,0,0,0))/Delta;
                                    }
                                }
                        }else if (cl >= cmin){
                                 double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.y,0,1,0);
                                    }else{
                                            rightd_f = val(modphase0.y,0,1,0);
                                    }
                                 if(rightd_f < 1.0){
                                        if(rightd_f<1e-2){
                                            rightd_f = 1e-2;
                                        }

                                        val(v.y,0,0,0) = (Tsat00-val(s,0,0,0))/(rightd_f*Delta);
                                 }else{

                                        val(v.y,0,0,0) = (val(s,0,1,0)-val(s,0,0,0))/Delta;
                                 }
                        }else{
                                  double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.y,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.y,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.y,0,0,0);
                                  double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.y,0,1,0);
                                    }else{
                                            rightd_f = val(modphase0.y,0,1,0);
                                    }
                                    double rightd_s = 1.0;

                                bool left_flag,right_flag;
                                left_flag = leftd_f < leftd_s;
                                right_flag=rightd_f < rightd_s;
                                if(leftd_f<1e-2){
                                    leftd_f = 1e-2;
                                }
                                if(rightd_f<1e-2){
                                    rightd_f = 1e-2;
                                }
                                if(left_flag && right_flag){

                                        val(v.y,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),Tsat00,leftd_f,rightd_f)/Delta;
                                }else if(left_flag && (!right_flag)){

                                        val(v.y,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),val(s,0,1,0),leftd_f,1)/Delta;
                                }else if((!left_flag) && right_flag){

                                       val(v.y,0,0,0) = (Tsat00-val(s,0,0,0))/(rightd_f*Delta);
                                }else{

                                       val(v.y,0,0,0) = (val(s,0,1,0)-val(s,0,0,0))/Delta;
                                }
                        }
                      }
                }else if((!is_solid_l) && (is_solid_r)){

                        if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                             if (cr >= cmin) {
                                if (cl >= cmin){

                                     val(v.y,0,0,0) = (val(s,0,0,0)-val(s,0,-1,0))/Delta;
                                }else{
                                     double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.y,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.y,0,0,0);
                                    }
                                    if(leftd_f < 1.0){
                                            if(leftd_f<1e-2){
                                                leftd_f = 1e-2;
                                            }

                                            val(v.y,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                    }else{

                                            val(v.y,0,0,0) = (val(s,0,0,0)-val(s,0,-1,0))/Delta;
                                    }

                                }
                        }else if (cl >= cmin){
                                 double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.y,0,1,0);
                                    }else{
                                            rightd_f = val(modphase0.y,0,1,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.y,0,1,0);
                                    if(rightd_f < rightd_s){
                                        if(rightd_f<1e-2){
                                            rightd_f = 1e-2;
                                        }

                                         val(v.y,0,0,0) = gradient_distacew (val(s,0,-1,0),val(s,0,0,0),Tsat00,1,rightd_f)/Delta;
                                    }else{

                                         val(v.y,0,0,0) = (val(s,0,0,0)-val(s,0,-1,0))/Delta;
                                    }
                        }else{
                                double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.y,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.y,0,0,0);
                                    }
                                    double leftd_s=1.0;

                                  double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.y,0,1,0);
                                    }else{
                                            rightd_f = val(modphase0.y,0,1,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.y,0,1,0);
                                    bool left_flag,right_flag;
                                left_flag = leftd_f < leftd_s;
                                right_flag=rightd_f < rightd_s;
                                if(leftd_f<1e-2){
                                    leftd_f = 1e-2;
                                }
                                if(rightd_f<1e-2){
                                    rightd_f = 1e-2;
                                }
                                if(left_flag && right_flag){

                                        val(v.y,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),Tsat00,leftd_f,rightd_f)/Delta;
                                }else if(left_flag && (!right_flag)){

                                        val(v.y,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                }else if((!left_flag) && right_flag){

                                       val(v.y,0,0,0) = gradient_distacew (val(s,0,-1,0),val(s,0,0,0),Tsat00,1,rightd_f)/Delta;
                                }else{

                                       val(v.y,0,0,0) = (val(s,0,0,0)-val(s,0,-1,0))/Delta;
                                }
                        }
                      }

                }else if(is_solid_l && is_solid_r){

                       if(((fabs(val(topo_mask,0,0,0))<3) || (val(topo_mask_s,0,0,0)<=0 && level==level_interface)) && cc>=0.5){
                             if (cr >= cmin) {
                                if (cl >= cmin){


                                }else{
                                    double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.y,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.y,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.y,0,0,0);
                                    if(leftd_f<leftd_s){
                                            if(leftd_f<1e-2){
                                                leftd_f=1e-2;
                                            }

                                            val(v.y,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                    }else{


                                    }
                                }
                        }else if (cl >= cmin){
                                  double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.y,0,1,0);
                                    }else{
                                            rightd_f = val(modphase0.y,0,1,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.y,0,1,0);
                                if(rightd_f<rightd_s){
                                        if(rightd_f<1e-2){

                                             val(v.y,0,0,0) = (Tsat00 - val(s,0,0,0))/(rightd_f*Delta);
                                        }
                                }else{


                                }
                        }else{
                                 double leftd_f=1.0;
                                    if(phase_flag3==1){
                                            leftd_f = val(modphase1.y,0,0,0);
                                    }else{
                                            leftd_f = val(modphase0.y,0,0,0);
                                    }
                                    double leftd_s=1.0;
                                    leftd_s = val(modphase_s_0.y,0,0,0);
                                     double rightd_f=1.0;
                                    if(phase_flag3==1){
                                            rightd_f = val(modphase1.y,0,1,0);
                                    }else{
                                            rightd_f = val(modphase0.y,0,1,0);
                                    }
                                    double rightd_s = 1.0;
                                    rightd_s = val(modphase_s_0.y,0,1,0);
                                    bool left_flag,right_flag;
                                left_flag = leftd_f < leftd_s;
                                right_flag=rightd_f < rightd_s;
                                if(leftd_f<1e-2){
                                    leftd_f = 1e-2;
                                }
                                if(rightd_f<1e-2){
                                    rightd_f = 1e-2;
                                }
                                 if(left_flag && right_flag){

                                        val(v.y,0,0,0) = gradient_distacew (Tsat00,val(s,0,0,0),Tsat00,leftd_f,rightd_f)/Delta;
                                }else if(left_flag && (!right_flag)){

                                        val(v.y,0,0,0) = (val(s,0,0,0)-Tsat00)/(leftd_f*Delta);
                                }else if((!left_flag) && right_flag){

                                       val(v.y,0,0,0) = (Tsat00-val(s,0,0,0))/(rightd_f*Delta);
                                }else{


                                }
                        }
                      }

                }
            }
        }
    }}}
  }end_foreach();}
}
#line 497 "././getsolid.h"
void direction_ff(vector T_g, scalar f, scalar f2, scalar topo_mask, scalar topo_mask_s, vector direction,bool flag4){
    foreach_stencil(){
        {
            _stencil_val_a(direction.x,0,0,0);  
        }
#line 499
{
            _stencil_val_a(direction.y,0,0,0);  
        }
    }end_foreach_stencil();
    {
#line 498
foreach(){
        {
            val(direction.x,0,0,0) = 0.0;
        }
#line 499
{
            val(direction.y,0,0,0) = 0.0;
        }
    }end_foreach();}

    foreach_stencil(){
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);_stencil_val(topo_mask_s,0,0,0); _stencil_val(topo_mask_s,0,0,0);
_stencil_val(topo_mask,0,0,0);_stencil_val(topo_mask,0,0,0);{ 
             
_stencil_val(T_g.x,0,0,0); 
             _stencil_val(T_g.y,0,0,0);  
             
             
             
            {
                
                _stencil_val_a(direction.x,0,0,0);  
                _stencil_val_a(direction.y,0,0,0);  
                
            }
{       
                
                
                
                
                 
                 
                  
                {foreach_neighbor(2){
_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f2,0,0,0);{    
                         
                         
                          
                        
{ 
                             
_stencil_val(T_g.x,0,0,0); 
                             _stencil_val(T_g.y,0,0,0);   
                             
                            
                              
                                  
                                   
                                   
                                    
                                  
                            
                        
#line 545
}
                        
                    
#line 546
}
                                         
                
#line 547
}end_foreach_neighbor()}
{
                    _stencil_val_a(direction.x,0,0,0);  
                    _stencil_val_a(direction.y,0,0,0);  
                }
                
            
#line 552
}
            
            
        
#line 553
}
                   
           
    
#line 554
}end_foreach_stencil();

    {
#line 504
foreach(){
        if((val(f,0,0,0)>0.0 && val(f,0,0,0)<1.0) || ((val(topo_mask_s,0,0,0)<=0 && val(topo_mask_s,0,0,0)>=-2) &&
         ((val(topo_mask,0,0,0)>=0 && (!flag4)) || (val(topo_mask,0,0,0)<=0 && (flag4)) ) )){
            coord nn;
            nn.x = val(T_g.x,0,0,0);
            nn.y = val(T_g.y,0,0,0);
            double value;
            value = sqrt(sq(nn.x)+sq(nn.y));
            bool flag=false;
            if(fabs(value)>1e-20){
                normalize(&nn);
                val(direction.x,0,0,0) = nn.x;
                val(direction.y,0,0,0) = nn.y;
                flag=true;
            }
            if(!flag){
                Point me = point;
                bool flag2=false;
                double distance1=HUGE;
                coord direction_temp;
                coord temp1;
                temp1.x = x;
                temp1.y = y;
                {foreach_neighbor(2){
                    if( (!(me.i == point.i && me.j == point.j)) && (!(cell.pid < 0)) && (((!flag4) && (val(f,0,0,0)>=0.5)) || ((flag4) && (val(f,0,0,0)<0.5))) && (val(f2,0,0,0)<0.5)){
                        coord temp2;
                        temp2.x = x;
                        temp2.y = y;
                        double value2 = sqrt(sq(temp1.x-temp2.x)+sq(temp1.y-temp2.y));
                        if(value2<distance1){
                            coord temp3;
                            temp3.x = val(T_g.x,0,0,0);
                            temp3.y = val(T_g.y,0,0,0);
                            double value3 = sqrt(sq(temp3.x)+sq(temp3.y));
                            if(value3>1e-20){
                                  normalize(&temp3);
                                  distance1 = value2;
                                  direction_temp.x = temp3.x;
                                  direction_temp.y = temp3.y;
                                  flag2=true;
                            }
                        }
                    }
                }end_foreach_neighbor()}
                if(flag2){
                    val(direction.x,0,0,0) = direction_temp.x;
                    val(direction.y,0,0,0) = direction_temp.y;
                }
            }
        }
    }end_foreach();}
}

void direction_s(vector T_g, scalar f, vector direction,bool flag4){
    foreach_stencil(){
        {
            _stencil_val_a(direction.x,0,0,0);  
        }
#line 559
{
            _stencil_val_a(direction.y,0,0,0);  
        }
    }end_foreach_stencil();
    {
#line 558
foreach(){
        {
            val(direction.x,0,0,0) = 0.0;
        }
#line 559
{
            val(direction.y,0,0,0) = 0.0;
        }
    }end_foreach();}

    foreach_stencil(){
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{ 
             
_stencil_val(T_g.x,0,0,0); 
             _stencil_val(T_g.y,0,0,0);  
             
             
             
            {
                
                _stencil_val_a(direction.x,0,0,0);  
                _stencil_val_a(direction.y,0,0,0);  
                
            }
{       
                
                
                
                
                 
                 
                  
                {foreach_neighbor(2){
_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);{    
                         
                         
                          
                        
{ 
                             
_stencil_val(T_g.x,0,0,0); 
                             _stencil_val(T_g.y,0,0,0);   
                             
                            
                              
                                  
                                   
                                   
                                    
                                  
                            
                        
#line 604
}
                        
                    
#line 605
}
                                  
                
#line 606
}end_foreach_neighbor()}
{
                    _stencil_val_a(direction.x,0,0,0);  
                    _stencil_val_a(direction.y,0,0,0);  
                }
                
            
#line 611
}
            
            
        
#line 612
}
         
    
#line 613
}end_foreach_stencil();

    {
#line 564
foreach(){
        if(val(f,0,0,0)>0.0 && val(f,0,0,0)<1.0){
            coord nn;
            nn.x = val(T_g.x,0,0,0);
            nn.y = val(T_g.y,0,0,0);
            double value;
            value = sqrt(sq(nn.x)+sq(nn.y));
            bool flag=false;
            if(fabs(value)>1e-20){
                normalize(&nn);
                val(direction.x,0,0,0) = nn.x;
                val(direction.y,0,0,0) = nn.y;
                flag=true;
            }
            if(!flag){
                Point me = point;
                bool flag2=false;
                double distance1=HUGE;
                coord direction_temp;
                coord temp1;
                temp1.x = x;
                temp1.y = y;
                {foreach_neighbor(2){
                    if((!(me.i==point.i && me.j==point.j)) && (!(cell.pid < 0)) && (((!flag4) && (val(f,0,0,0)>=0.5)) || ((flag4) && (val(f,0,0,0)<0.5)))){
                        coord temp2;
                        temp2.x = x;
                        temp2.y = y;
                        double value2 = sqrt(sq(temp1.x-temp2.x)+sq(temp1.y-temp2.y));
                        if(value2<distance1){
                            coord temp3;
                            temp3.x = val(T_g.x,0,0,0);
                            temp3.y = val(T_g.y,0,0,0);
                            double value3 = sqrt(sq(temp3.x)+sq(temp3.y));
                            if(value3>1e-20){
                                  normalize(&temp3);
                                  distance1 = value2;
                                  direction_temp.x = temp3.x;
                                  direction_temp.y = temp3.y;
                                  flag2=true;
                            }
                        }
                    }
                }end_foreach_neighbor()}
                if(flag2){
                    val(direction.x,0,0,0) = direction_temp.x;
                    val(direction.y,0,0,0) = direction_temp.y;
                }
            }
        }
    }end_foreach();}
}
extern scalar topo_mask,topo_mask_s;
extern int level_interface;
extern vector Tlff_g,Tgff_g,T_solid_g;
extern scalar ff,css_test3,Tl,Tg,Ts;
extern scalar css_test,css_test2;
extern vector direction_Tfg, direction_Tfl, direction_Ts;
extern scalar aiml,aimg, T_modl,T_modg;
extern scalar flux_l,flux_g;
extern scalar areasg,areasl,arealg;


extern vector fss_test3, fss_test3_n;
extern scalar css_test3_n;





bool gradient_conjugates_x (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p,
         double * T1, double * T2, double *a, double* b, int* number, int* sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;






  
    n.x = - n.x;
    
#line 644
n.y = - n.y;
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  
    if (defined && !val(fss_test3.x,(n.x > 0.),0,0))
      defined = false;
    
#line 648
if (defined && !val(fss_test3.y,0,(n.y > 0.),0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(n.x);
      d[l] = (i - p.x)/n.x;
      *sign_flag = sign(n.x);
      double y1 = p.y + d[l]*n.y;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(fss_test3.x,i + (i < 0),j,0) && val(fss_test3.y,i,j,0) && val(fss_test3.y,i,j+1,0) &&
   val(css_test3,i,j-1,0) && val(css_test3,i,j,0) && val(css_test3,i,j+1,0)){
         v[l] = ((((val(s,i,j-1,0)))*((y1) - 1.) + ((val(s,i,j+1,0)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,0)))*((y1) - 1.)*((y1) + 1.));
      }
#line 685 "././getsolid.h"
      else{
         break;
      }
    }
  if (v[0] == HUGE) {

         if(1==1){
#line 700 "././getsolid.h"
        d[0] = max(1e-1,fabs(p.x*n.x + p.y*n.y));



          *T1=val(s,0,0,0);
          *a=fabs(d[0]);
          *number=1;
          return true;

      }else{
          return false;
      }
  }






  if (v[1] != HUGE){

         if(((!Rcc_flag_l) && (!inverse_flag)) || (inverse_flag)){






            *T1=v[1];
            *T2=v[0];
            *b=fabs(d[0]);
            *a=fabs(d[1]) - fabs(d[0]);
            *number=2;
        }else{
            *T1=v[0];
            *a=fabs(d[0]);
            *number=1;
        }
     return true;

  }


     *T1=v[0];
     *a=fabs(d[0]);
     *number=1;
     return true;


}

#line 633
bool gradient_conjugates_y (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p,
         double * T1, double * T2, double *a, double* b, int* number, int* sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;






  
    n.y = - n.y;
    
#line 644
n.x = - n.x;
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  
    if (defined && !val(fss_test3.y,0,(n.y > 0.),0))
      defined = false;
    
#line 648
if (defined && !val(fss_test3.x,(n.x > 0.),0,0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(n.y);
      d[l] = (i - p.y)/n.y;
      *sign_flag = sign(n.y);
      double y1 = p.x + d[l]*n.x;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(fss_test3.y,j,i + (i < 0),0) && val(fss_test3.x,j,i,0) && val(fss_test3.x,j+1,i,0) &&
   val(css_test3,j-1,i,0) && val(css_test3,j,i,0) && val(css_test3,j+1,i,0)){
         v[l] = ((((val(s,j-1,i,0)))*((y1) - 1.) + ((val(s,j+1,i,0)))*((y1) + 1.))*(y1)/2. - ((val(s,j,i,0)))*((y1) - 1.)*((y1) + 1.));
      }
#line 685 "././getsolid.h"
      else{
         break;
      }
    }
  if (v[0] == HUGE) {

         if(1==1){
#line 700 "././getsolid.h"
        d[0] = max(1e-1,fabs(p.y*n.y + p.x*n.x));



          *T1=val(s,0,0,0);
          *a=fabs(d[0]);
          *number=1;
          return true;

      }else{
          return false;
      }
  }






  if (v[1] != HUGE){

         if(((!Rcc_flag_l) && (!inverse_flag)) || (inverse_flag)){






            *T1=v[1];
            *T2=v[0];
            *b=fabs(d[0]);
            *a=fabs(d[1]) - fabs(d[0]);
            *number=2;
        }else{
            *T1=v[0];
            *a=fabs(d[0]);
            *number=1;
        }
     return true;

  }


     *T1=v[0];
     *a=fabs(d[0]);
     *number=1;
     return true;


}






#line 633
static void _stencil_gradient_conjugates_x (Point point, scalar s, scalar f, bool inverse_flag,
_stencil_undefined *
      
#line 634
n,_stencil_undefined * p,
_stencil_undefined 
         
#line 635
* T1,_stencil_undefined  * T2,_stencil_undefined  *a,_stencil_undefined * b,_stencil_undefined * number,_stencil_undefined * sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;       






  
       
  
  
  
    {_stencil_val(fss_test3.x,o_stencil,0,0  ); 
          }
    
#line 648
{_stencil_val(fss_test3.y,0,o_stencil,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
        
      
      
        

_stencil_val(fss_test3.x,    o_stencil,o_stencil,0); _stencil_val(fss_test3.y,o_stencil,o_stencil,0); _stencil_val(fss_test3.y,o_stencil,o_stencil,0);
   _stencil_val(css_test3,o_stencil,o_stencil,0); _stencil_val(css_test3,o_stencil,o_stencil,0); _stencil_val(css_test3,o_stencil,o_stencil,0);
#line 659
{
{
_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0); 
                      
      
#line 662
}
         
      
#line 687
}

            
#line 685 "././getsolid.h"
      
    

} 
{

         if(1==1){
#line 700 "././getsolid.h"
            



_stencil_val(s,0,0,0); 



          
          
          
          

      
#line 709
} 
          
      
  } 






            
            
            
              
            
            

         
            
            
            
        
     

  
   
     






     


     
     
     
     
#line 746
return ;


}

#line 633
static void _stencil_gradient_conjugates_y (Point point, scalar s, scalar f, bool inverse_flag,
_stencil_undefined *
      
#line 634
n,_stencil_undefined * p,
_stencil_undefined 
         
#line 635
* T1,_stencil_undefined  * T2,_stencil_undefined  *a,_stencil_undefined * b,_stencil_undefined * number,_stencil_undefined * sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;       






  
       
  
  
  
    {_stencil_val(fss_test3.y,0,o_stencil,0  ); 
          }
    
#line 648
{_stencil_val(fss_test3.x,o_stencil,0,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
        
      
      
        

_stencil_val(fss_test3.y,o_stencil,    o_stencil,0); _stencil_val(fss_test3.x,o_stencil,o_stencil,0); _stencil_val(fss_test3.x,o_stencil,o_stencil,0);
   _stencil_val(css_test3,o_stencil,o_stencil,0); _stencil_val(css_test3,o_stencil,o_stencil,0); _stencil_val(css_test3,o_stencil,o_stencil,0);
#line 659
{
{
_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0); 
                      
      
#line 662
}
         
      
#line 687
}

            
#line 685 "././getsolid.h"
      
    

} 
{

         if(1==1){
#line 700 "././getsolid.h"
            



_stencil_val(s,0,0,0); 



          
          
          
          

      
#line 709
} 
          
      
  } 






            
            
            
              
            
            

         
            
            
            
        
     

  
   
     






     


     
     
     
     
#line 746
return ;


}







bool gradient_conjugatef_x (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p, double * T3, double * T4, double *c, double* e,
         int* number, int* sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  bool consider_dirichlet_interface=true;
  
    n.x = - n.x;
    
#line 763
n.y = - n.y;
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  
    if (defined && !val(fss_test3_n.x,(n.x > 0.),0,0))
      defined = false;
    
#line 767
if (defined && !val(fss_test3_n.y,0,(n.y > 0.),0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(n.x);
      d[l] = (i - p.x)/n.x;
      *sign_flag = sign(n.x);
      double y1 = p.y + d[l]*n.y;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

         if(!consider_dirichlet_interface){
            bool flag_f1 = (((!inverse_flag) && val(f,i,j-1,0)>=0.5) || (inverse_flag && val(f,i,j-1,0)<0.5) );
            bool flag_f2 = (((!inverse_flag) && val(f,i,j,0)>=0.5) || (inverse_flag && val(f,i,j,0)<0.5) );
            bool flag_f3 = (((!inverse_flag) && val(f,i,j+1,0)>=0.5) || (inverse_flag && val(f,i,j+1,0)<0.5) );
            if (val(fss_test3_n.x,i + (i < 0),j,0) && val(fss_test3_n.y,i,j,0) && val(fss_test3_n.y,i,j+1,0) &&
          val(css_test3_n,i,j-1,0) && val(css_test3_n,i,j,0) && val(css_test3_n,i,j+1,0) && (flag_f1) && (flag_f2) && (flag_f3)){
                v[l] = ((((val(s,i,j-1,0)))*((y1) - 1.) + ((val(s,i,j+1,0)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,0)))*((y1) - 1.)*((y1) + 1.));
            }else{
                break;
            }
          }else{
            bool flag_f1 = (val(css_test3_n,i,j-1,0) && (((!inverse_flag) && val(f,i,j-1,0)>0.0) || (inverse_flag && val(f,i,j-1,0)<1)) );
            bool flag_f2 = (val(css_test3_n,i,j,0) && (((!inverse_flag) && val(f,i,j,0)>0) || (inverse_flag && val(f,i,j,0)<1)) );
            bool flag_f3 = (val(css_test3_n,i,j+1,0) && (((!inverse_flag) && val(f,i,j+1,0)>0) || (inverse_flag && val(f,i,j+1,0)<1)) );
            double value1;
            if(flag_f1){
                  if((!inverse_flag && val(f,i,j-1,0)<0.5) && (!inverse_flag && val(f,i,j-1,0)>0.5) ){
                      value1 = Tsat00;
                  }else{
                      value1 = val(s,i,j-1,0);
                  }
            }
            double value2;
            if(flag_f2){
                  if((!inverse_flag && val(f,i,j,0)<0.5) && (!inverse_flag && val(f,i,j,0)>0.5) ){
                      value2 = Tsat00;
                  }else{
                      value2 = val(s,i,j,0);
                  }
            }
            double value3;
            if(flag_f3){
                  if((!inverse_flag && val(f,i,j+1,0)<0.5) && (!inverse_flag && val(f,i,j+1,0)>0.5) ){
                      value3 = Tsat00;
                  }else{
                      value3 = val(s,i,j+1,0);
                  }
            }
            if (val(fss_test3_n.x,i + (i < 0),j,0) && val(fss_test3_n.y,i,j,0) && val(fss_test3_n.y,i,j+1,0) &&
          (flag_f1) && (flag_f2) && (flag_f3)){
                v[l] = ((((value1))*((y1) - 1.) + ((value3))*((y1) + 1.))*(y1)/2. - ((value2))*((y1) - 1.)*((y1) + 1.));
             }else{
                  break;
              }
          }
#line 848 "././getsolid.h"
    }
  if (v[0] == HUGE) {
     if(val(css_test3_n,0,0,0)>0.5){
        if(((!(inverse_flag)) && val(f,0,0,0)>=0.5) || (inverse_flag && val(f,0,0,0)<0.5)){







            d[0] = max(1e-2,fabs(p.x*n.x + p.y*n.y));




            *T3=val(s,0,0,0);
            *c=fabs(d[0]);
            *number=1;
#line 884 "././getsolid.h"
            return true;

        }else {
            if(1==0){
                    double d0=0.0;
                    if(val(f,0,0,0)<1.0 && val(f,0,0,0)>0.0){
                        coord n_f = mycs (point, f);
                        double alpha = line_alpha (val(f,0,0,0), n_f);
                        coord p_f;
                        double area = line_length_center(n_f,alpha,&p_f);
                        d0 = fabs((p_f.x-p.x)*n.x + (p_f.y-p.y)*n.y);
                    }
                    if(d0>1e-2){
                        *T3=Tsat00;
                        *c=d0;
                        *number=1;
                    }else{
                        *T3=Tsat00;
                        *c=1e-2;
                        *number=1;
                    }
            }else{
                 d[0] = max(1e-2,fabs(p.x*n.x + p.y*n.y));
                *T3=val(T,0,0,0);
                *c=fabs(d[0]);
                *number=1;
            }
         return true;

        }
     }else{
         return false;
     }


     bool flag_find=false;
#line 989 "././getsolid.h"
      if(flag_find){
          return true;
      }else{
        return false;
      }
  }






 if (v[1] != HUGE){

        if(((!Rcc_flag_l) && (!inverse_flag)) || (inverse_flag)){






            *T3=v[0];
            *T4=v[1];
            *c=fabs(d[0]);
            *e=fabs(d[1]) - fabs(d[0]);
            *number=2;
        }else{
            *T3=v[0];
            *c=fabs(d[0]);
            *number=1;
        }
     return true;

  }


     *T3=v[0];
     *c=fabs(d[0]);
     *number=1;

     return true;


}

#line 757
bool gradient_conjugatef_y (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p, double * T3, double * T4, double *c, double* e,
         int* number, int* sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  bool consider_dirichlet_interface=true;
  
    n.y = - n.y;
    
#line 763
n.x = - n.x;
  double d[2], v[2] = {HUGE,HUGE};
  bool defined = true;
  
    if (defined && !val(fss_test3_n.y,0,(n.y > 0.),0))
      defined = false;
    
#line 767
if (defined && !val(fss_test3_n.x,(n.x > 0.),0,0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*sign(n.y);
      d[l] = (i - p.y)/n.y;
      *sign_flag = sign(n.y);
      double y1 = p.x + d[l]*n.x;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

         if(!consider_dirichlet_interface){
            bool flag_f1 = (((!inverse_flag) && val(f,j-1,i,0)>=0.5) || (inverse_flag && val(f,j-1,i,0)<0.5) );
            bool flag_f2 = (((!inverse_flag) && val(f,j,i,0)>=0.5) || (inverse_flag && val(f,j,i,0)<0.5) );
            bool flag_f3 = (((!inverse_flag) && val(f,j+1,i,0)>=0.5) || (inverse_flag && val(f,j+1,i,0)<0.5) );
            if (val(fss_test3_n.y,j,i + (i < 0),0) && val(fss_test3_n.x,j,i,0) && val(fss_test3_n.x,j+1,i,0) &&
          val(css_test3_n,j-1,i,0) && val(css_test3_n,j,i,0) && val(css_test3_n,j+1,i,0) && (flag_f1) && (flag_f2) && (flag_f3)){
                v[l] = ((((val(s,j-1,i,0)))*((y1) - 1.) + ((val(s,j+1,i,0)))*((y1) + 1.))*(y1)/2. - ((val(s,j,i,0)))*((y1) - 1.)*((y1) + 1.));
            }else{
                break;
            }
          }else{
            bool flag_f1 = (val(css_test3_n,j-1,i,0) && (((!inverse_flag) && val(f,j-1,i,0)>0.0) || (inverse_flag && val(f,j-1,i,0)<1)) );
            bool flag_f2 = (val(css_test3_n,j,i,0) && (((!inverse_flag) && val(f,j,i,0)>0) || (inverse_flag && val(f,j,i,0)<1)) );
            bool flag_f3 = (val(css_test3_n,j+1,i,0) && (((!inverse_flag) && val(f,j+1,i,0)>0) || (inverse_flag && val(f,j+1,i,0)<1)) );
            double value1;
            if(flag_f1){
                  if((!inverse_flag && val(f,j-1,i,0)<0.5) && (!inverse_flag && val(f,j-1,i,0)>0.5) ){
                      value1 = Tsat00;
                  }else{
                      value1 = val(s,j-1,i,0);
                  }
            }
            double value2;
            if(flag_f2){
                  if((!inverse_flag && val(f,j,i,0)<0.5) && (!inverse_flag && val(f,j,i,0)>0.5) ){
                      value2 = Tsat00;
                  }else{
                      value2 = val(s,j,i,0);
                  }
            }
            double value3;
            if(flag_f3){
                  if((!inverse_flag && val(f,j+1,i,0)<0.5) && (!inverse_flag && val(f,j+1,i,0)>0.5) ){
                      value3 = Tsat00;
                  }else{
                      value3 = val(s,j+1,i,0);
                  }
            }
            if (val(fss_test3_n.y,j,i + (i < 0),0) && val(fss_test3_n.x,j,i,0) && val(fss_test3_n.x,j+1,i,0) &&
          (flag_f1) && (flag_f2) && (flag_f3)){
                v[l] = ((((value1))*((y1) - 1.) + ((value3))*((y1) + 1.))*(y1)/2. - ((value2))*((y1) - 1.)*((y1) + 1.));
             }else{
                  break;
              }
          }
#line 848 "././getsolid.h"
    }
  if (v[0] == HUGE) {
     if(val(css_test3_n,0,0,0)>0.5){
        if(((!(inverse_flag)) && val(f,0,0,0)>=0.5) || (inverse_flag && val(f,0,0,0)<0.5)){







            d[0] = max(1e-2,fabs(p.y*n.y + p.x*n.x));




            *T3=val(s,0,0,0);
            *c=fabs(d[0]);
            *number=1;
#line 884 "././getsolid.h"
            return true;

        }else {
            if(1==0){
                    double d0=0.0;
                    if(val(f,0,0,0)<1.0 && val(f,0,0,0)>0.0){
                        coord n_f = mycs (point, f);
                        double alpha = line_alpha (val(f,0,0,0), n_f);
                        coord p_f;
                        double area = line_length_center(n_f,alpha,&p_f);
                        d0 = fabs((p_f.y-p.y)*n.y + (p_f.x-p.x)*n.x);
                    }
                    if(d0>1e-2){
                        *T3=Tsat00;
                        *c=d0;
                        *number=1;
                    }else{
                        *T3=Tsat00;
                        *c=1e-2;
                        *number=1;
                    }
            }else{
                 d[0] = max(1e-2,fabs(p.y*n.y + p.x*n.x));
                *T3=val(T,0,0,0);
                *c=fabs(d[0]);
                *number=1;
            }
         return true;

        }
     }else{
         return false;
     }


     bool flag_find=false;
#line 989 "././getsolid.h"
      if(flag_find){
          return true;
      }else{
        return false;
      }
  }






 if (v[1] != HUGE){

        if(((!Rcc_flag_l) && (!inverse_flag)) || (inverse_flag)){






            *T3=v[0];
            *T4=v[1];
            *c=fabs(d[0]);
            *e=fabs(d[1]) - fabs(d[0]);
            *number=2;
        }else{
            *T3=v[0];
            *c=fabs(d[0]);
            *number=1;
        }
     return true;

  }


     *T3=v[0];
     *c=fabs(d[0]);
     *number=1;

     return true;


}








#line 757
static void _stencil_gradient_conjugatef_x (Point point, scalar s, scalar f, bool inverse_flag,
_stencil_undefined *
      
#line 758
n,_stencil_undefined * p,_stencil_undefined  * T3,_stencil_undefined  * T4,_stencil_undefined  *c,_stencil_undefined * e,
_stencil_undefined
         
#line 759
* number,_stencil_undefined * sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  bool consider_dirichlet_interface=true;       
  
       
  
  
  
    {_stencil_val(fss_test3_n.x,o_stencil,0,0  ); 
          }
    
#line 767
{_stencil_val(fss_test3_n.y,0,o_stencil,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
        
      
      
        

         if(!consider_dirichlet_interface){        
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);        
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);        
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);
_stencil_val(fss_test3_n.x,    o_stencil,o_stencil,0); _stencil_val(fss_test3_n.y,o_stencil,o_stencil,0); _stencil_val(fss_test3_n.y,o_stencil,o_stencil,0);
          _stencil_val(css_test3_n,o_stencil,o_stencil,0); _stencil_val(css_test3_n,o_stencil,o_stencil,0); _stencil_val(css_test3_n,o_stencil,o_stencil,0);
#line 782
{
{
_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0); 
                             
            
#line 785
}
                
            }
                        
          
#line 788
}else{          
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);_stencil_val(css_test3_n,o_stencil,o_stencil,0);          
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);_stencil_val(css_test3_n,o_stencil,o_stencil,0);          
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);_stencil_val(css_test3_n,o_stencil,o_stencil,0); 
            
{ 
_stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);{ 
                       
                  { 
_stencil_val(s,o_stencil,o_stencil,0);
                       
                  
#line 798
}}
                       
            
#line 799
} 
            
            { 
_stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);{ 
                       
                  { 
_stencil_val(s,o_stencil,o_stencil,0);
                       
                  
#line 806
}}
                       
            
#line 807
} 
            
            { 
_stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);{ 
                       
                  { 
_stencil_val(s,o_stencil,o_stencil,0);
                       
                  
#line 814
}}
                       
            
#line 815
}
            _stencil_val(fss_test3_n.x,    o_stencil,o_stencil,0); _stencil_val(fss_test3_n.y,o_stencil,o_stencil,0); _stencil_val(fss_test3_n.y,o_stencil,o_stencil,0);
                  
              
                              
             
               
               
          
#line 822
}
#line 848 "././getsolid.h"
    } 
{
_stencil_val(css_test3_n,0,0,0);{{ 
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{{







                




_stencil_val(s,0,0,0); 
#line 884 "././getsolid.h"
            

        } {
            if(1==0){ 
                    
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{  
                         _stencil_mycs (point, f);     
                        _stencil_val(f,0,0,0);    
                        
                         
                           
                    }
                        
                        
                        
                    
                     
                    
                        
                        
                        
                    
            
#line 905
}else{
                     
_stencil_val(T,0,0,0);
                
                
                
            
#line 910
} 
         

        }}
            
     
#line 914
} 
         
     } 
     


      
          
      
#line 989 "././getsolid.h"
       
        
      
  

} 






            
            
            
              
            
            

        
            
            
            
        
     

  
   
     






    


     
     
     

     
#line 1029
return ;


}

#line 757
static void _stencil_gradient_conjugatef_y (Point point, scalar s, scalar f, bool inverse_flag,
_stencil_undefined *
      
#line 758
n,_stencil_undefined * p,_stencil_undefined  * T3,_stencil_undefined  * T4,_stencil_undefined  *c,_stencil_undefined * e,
_stencil_undefined
         
#line 759
* number,_stencil_undefined * sign_flag)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  bool consider_dirichlet_interface=true;       
  
       
  
  
  
    {_stencil_val(fss_test3_n.y,0,o_stencil,0  ); 
          }
    
#line 767
{_stencil_val(fss_test3_n.x,o_stencil,0,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                         
       
         
        
      
      
        

         if(!consider_dirichlet_interface){        
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);        
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);        
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);
_stencil_val(fss_test3_n.y,o_stencil,    o_stencil,0); _stencil_val(fss_test3_n.x,o_stencil,o_stencil,0); _stencil_val(fss_test3_n.x,o_stencil,o_stencil,0);
          _stencil_val(css_test3_n,o_stencil,o_stencil,0); _stencil_val(css_test3_n,o_stencil,o_stencil,0); _stencil_val(css_test3_n,o_stencil,o_stencil,0);
#line 782
{
{
_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0); 
                             
            
#line 785
}
                
            }
                        
          
#line 788
}else{          
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);_stencil_val(css_test3_n,o_stencil,o_stencil,0);          
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);_stencil_val(css_test3_n,o_stencil,o_stencil,0);          
             _stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);_stencil_val(css_test3_n,o_stencil,o_stencil,0); 
            
{ 
_stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);{ 
                       
                  { 
_stencil_val(s,o_stencil,o_stencil,0);
                       
                  
#line 798
}}
                       
            
#line 799
} 
            
            { 
_stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);{ 
                       
                  { 
_stencil_val(s,o_stencil,o_stencil,0);
                       
                  
#line 806
}}
                       
            
#line 807
} 
            
            { 
_stencil_val(f,o_stencil,o_stencil,0); _stencil_val(f,o_stencil,o_stencil,0);{ 
                       
                  { 
_stencil_val(s,o_stencil,o_stencil,0);
                       
                  
#line 814
}}
                       
            
#line 815
}
            _stencil_val(fss_test3_n.y,o_stencil,    o_stencil,0); _stencil_val(fss_test3_n.x,o_stencil,o_stencil,0); _stencil_val(fss_test3_n.x,o_stencil,o_stencil,0);
                  
              
                              
             
               
               
          
#line 822
}
#line 848 "././getsolid.h"
    } 
{
_stencil_val(css_test3_n,0,0,0);{{ 
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{{







                




_stencil_val(s,0,0,0); 
#line 884 "././getsolid.h"
            

        } {
            if(1==0){ 
                    
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{  
                         _stencil_mycs (point, f);     
                        _stencil_val(f,0,0,0);    
                        
                         
                           
                    }
                        
                        
                        
                    
                     
                    
                        
                        
                        
                    
            
#line 905
}else{
                     
_stencil_val(T,0,0,0);
                
                
                
            
#line 910
} 
         

        }}
            
     
#line 914
} 
         
     } 
     


      
          
      
#line 989 "././getsolid.h"
       
        
      
  

} 






            
            
            
              
            
            

        
            
            
            
        
     

  
   
     






    


     
     
     

     
#line 1029
return ;


}


static inline double five_points(double T1,double T2,double T3,double T4
        ,double a,double b,double c,double d,double kl, double kr, double* flux_temp){
        double aT1,aT2,aTf,aT3,aT4;

        double Tf;
        aTf = (a+2*b)/(a+b)/b*kl + (d+2*c)/(d+c)/c*kr;
        aT1 = kl*(-(a+2*b)/(a+b)/a + 1.0/a);
        aT2 = kl*((a+2*b)/(a+b)*(1.0/a+1.0/b)-1.0/a);
        aT3 = kr*((d+2*c)/(d+c)*(1.0/d+1.0/c)-1.0/d);
        aT4 = kr*(-(d+2*c)/(d+c)/d + 1.0/d);
        if(fabs(aTf)>1e-12){
             Tf = (aT1*T1 + aT2*T2 + aT3*T3 + aT4*T4)/aTf;
             *flux_temp = kl*((T2-T1)/a + ((Tf-T2)/b-(T2-T1)/a)/(a+b)*(a+2*b));
        }else{
             Tf = -1;
        }
        return Tf;
}

static inline double one_two_points(double T1,double T3,double T4
        ,double a,double c,double d,double kl, double kr, double* flux_temp){
        double aT1,aTf,aT3,aT4;

        double Tf;
        aTf = 1.0/a*kl + (d+2*c)/(d+c)/c*kr;
        aT1 = kl*(1.0/a);
        aT3 = kr*((d+2*c)/(d+c)*(1.0/d+1.0/c)-1.0/d);
        aT4 = kr*(-(d+2*c)/(d+c)/d + 1.0/d);
        if(fabs(aTf)>1e-12){
             Tf = (aT1*T1 + aT3*T3 + aT4*T4)/aTf;
             *flux_temp = kl*((Tf-T1)/a);
        }else{
             Tf = -1;
        }
        return Tf;
}

static inline double two_one_points(double T1,double T2,double T3
        ,double a,double b,double c,double kl, double kr, double* flux_temp){
        double aT1,aT2,aTf,aT3;

        double Tf;
        aTf = (a+2*b)/(a+b)/b*kl + 1.0/c*kr;
        aT1 = kl*(-(a+2*b)/(a+b)/a + 1.0/a);
        aT2 = kl*((a+2*b)/(a+b)*(1.0/a+1.0/b)-1.0/a);
        aT3 = kr*(1.0/c);
        if(fabs(aTf)>1e-12){
             Tf = (aT1*T1 + aT2*T2 + aT3*T3)/aTf;
             *flux_temp = kr*((T3-Tf)/c);
        }else{
             Tf = -1;
        }
        return Tf;
}

static inline double one_one_points (double T1,double T3,
        double a,double c,double kl, double kr, double* flux_temp){
        double aT1,aTf,aT3;

        double Tf;
        aTf = 1.0/a*kl + 1.0/c*kr;
        aT1 = kl*1.0/a;
        aT3 = kr*1.0/c;
        if(fabs(aTf)>1e-12){
             Tf = (aT1*T1 + aT3*T3)/aTf;
             *flux_temp = kl*((Tf-T1)/a);
        }else{
             Tf = -1;
        }
        return Tf;
}
void one_one_points_Rcc (double T1,double T3,
        double a,double c,double kl, double kr, double* solid_temp){

        double Rs = a/kl, Rl = c/kr;
        double Rcc_v = Rcc/delta_min;
        double aTf = (Rs+Rl)*Rcc_v+Rcc_v*Rcc_v;


        if(fabs(aTf)>1e-12){
            solid_temp[0] = ((Rs+Rcc_v)*Rcc_v*T3+Rl*Rcc_v*T1)/aTf;
            solid_temp[1] = ((Rl+Rcc_v)*Rcc_v*T1+Rs*Rcc_v*T3)/aTf;
            solid_temp[2] = (solid_temp[0] - solid_temp[1])/Rcc_v;
        }else{
            solid_temp[0] = -1;
            solid_temp[1] = -1;
        }
#line 1138 "././getsolid.h"
}

double equal_of_flux(double* data_s, int number_s, double* data_f, int number_f, int * mod_temp, bool inverse_flag, double* flux_temp){
   double result=-1;
   double k1,k2;

   if(!inverse_flag){
      k1 = Tks;
      k2 = Tkl;
   }else{
      k1 = Tks;
      k2 = Tkg;
   }
   if((number_s==2) && (number_f==2)){
        double T1=data_s[0],T2=data_s[1],a=data_s[2];
        double b=data_s[3];
        double T3=data_f[0],T4=data_f[1],c=data_f[2];
        double d=data_f[3];
        *mod_temp=1;
        result=five_points(T1,T2,T3,T4,a,b,c,d,k1,k2,flux_temp);
   }else if((number_s==1) && (number_f==2)){
        double T1=data_s[0],a=data_s[1];
        double T3=data_f[0],T4=data_f[1],c=data_f[2];
        double d=data_f[3];
        *mod_temp=2;
        result=one_two_points(T1,T3,T4,a,c,d,k1,k2,flux_temp);
   }else if((number_s==2) && (number_f==1)){
        double T1=data_s[0],T2=data_s[1],a=data_s[2];
        double b=data_s[3];
        double T3=data_f[0], c=data_f[1];
        *mod_temp=3;
        result=two_one_points(T1,T2,T3,a,b,c,k1,k2,flux_temp);
   }else if((number_s==1) && (number_f==1)){
        double T1=data_s[0],a=data_s[1];
        double T3=data_f[0],c=data_f[1];
        *mod_temp=4;
        result=one_one_points(T1,T3,a,c,k1,k2,flux_temp);
   }else{


   }
      return result;
}

void equal_of_flux_Rcc(double* data_s, int number_s, double* data_f, int number_f, int * mod_temp,
                      bool inverse_flag, double* result){


   double k1,k2;

   if(!inverse_flag){
      k1 = Tks;
      k2 = Tkl;
   }else{
      k1 = Tks;
      k2 = Tkg;
   }

        if((number_s==1) && (number_f==1)){

                double T1=data_s[0],a=data_s[1];
                double T3=data_f[0],c=data_f[1];
                *mod_temp=4;
                one_one_points_Rcc(T1,T3,a,c,k1,k2,result);
        }else{


        }


}

bool max_colinearity_f (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p, double * T3, double * T4, double *c, double* e,
         int* number)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
    
    n.x = - n.x;
    
#line 1215
n.y = - n.y;
     bool flag_find=false;

            Point me = point;
            double distance1=HUGE;
            coord temp1;
            temp1.x=x;
            temp1.y=y;
            coord p_real;
            p_real.x=p.x*Delta+x;
            p_real.y=p.y*Delta+y;
            double colinearity=0.0;
            {foreach_neighbor(1){
                if(!(me.i==point.i && me.j==point.j)){
                      if(val(css_test3_n,0,0,0)>0.5 && (((!(inverse_flag)) && val(ff,0,0,0)>=0.5) || (inverse_flag && val(ff,0,0,0)<0.5))){
                          coord temp2;
                          temp2.x=x;
                          temp2.y=y;
                          double distance_temp=sqrt(sq(temp2.x-p_real.x) + sq(temp2.y-p_real.y));
                          coord temp2_dir;
                          temp2_dir.x = temp2.x/distance_temp;
                          temp2_dir.y = temp2.y/distance_temp;
                          double colinearity_temp = fabs(temp2_dir.x*n.x+temp2_dir.y*n.y);
                          if(colinearity_temp>colinearity){
                              colinearity=colinearity_temp;
                              distance1 = distance_temp;
                              *T3=val(s,0,0,0);
                              *c=distance1;
                              *number=1;
                              flag_find=true;
                          }
                      }
                }
            }end_foreach_neighbor()}

      if(flag_find){
          return true;
      }else{
        return false;
      }
}

bool min_distance_f (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p, double * T3, double * T4, double *c, double* e,
         int* number)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
      
        n.x = - n.x;
        
#line 1262
n.y = - n.y;
      bool flag_find=false;

           Point me = point;
                bool flag2=false;
                double distance1=HUGE;
                coord direction_temp;
                coord temp1;
                temp1.x = x;
                temp1.y = y;
                coord p_real;
                p_real.x=p.x*Delta+x;
                p_real.y=p.y*Delta+y;
                {foreach_neighbor(1){
                    if((!(me.i==point.i && me.j==point.j)) && (!(cell.pid < 0)) &&
                    (((!(inverse_flag)) && val(ff,0,0,0)>=0.5) || (inverse_flag && val(ff,0,0,0)<0.5)) &&
                        val(css_test3_n,0,0,0)>0.5){
                        coord temp2;
                        temp2.x = x;
                        temp2.y = y;
                        double value2 = sqrt(sq(p_real.x-temp2.x)+sq(p_real.y-temp2.y));
                        if(value2<distance1){
                            flag2 = true;
                            distance1 = value2;
                            *c = value2;
                            *T3 = val(s,0,0,0);
                            *number=1;
                        }
                    }
                }end_foreach_neighbor()}
                if(flag2){
                    flag_find=true;
                }

      if(flag_find){
          return true;
      }else{
        return false;
      }
}

bool max_colinearity_s (Point point, scalar s, scalar f, bool inverse_flag,
      coord n, coord p, double * T1, double * T2, double *a, double* b,
         int* number)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
    
    n.x = - n.x;
    
#line 1308
n.y = - n.y;
     bool flag_find=false;

            Point me = point;
            double distance1=HUGE;
            coord temp1;
            temp1.x=x;
            temp1.y=y;
            coord p_real;
            p_real.x=p.x*Delta+x;
            p_real.y=p.y*Delta+y;
            double colinearity=0.0;
            {foreach_neighbor(1){
                if(!(me.i==point.i && me.j==point.j)){
                      if((((!(inverse_flag)) && val(f,0,0,0)>=0.5) || (inverse_flag && val(f,0,0,0)<0.5))){
                          coord temp2;
                          temp2.x=x;
                          temp2.y=y;
                          double distance_temp=sqrt(sq(temp2.x-p_real.x) + sq(temp2.y-p_real.y));
                          coord temp2_dir;
                          temp2_dir.x = temp2.x/distance_temp;
                          temp2_dir.y = temp2.y/distance_temp;
                          double colinearity_temp = fabs(temp2_dir.x*n.x+temp2_dir.y*n.y);
                          if(colinearity_temp>colinearity){
                              colinearity=colinearity_temp;
                              distance1 = distance_temp;
                              *T1=val(s,0,0,0);
                              *a=distance1;
                              *number=1;
                              flag_find=true;
                          }
                      }
                }
            }end_foreach_neighbor()}

      if(flag_find){
          return true;
      }else{
        return false;
      }
}

double gradient_conjugate (Point point, scalar s, scalar ss,coord * nn1_temp, coord * nn2_temp, coord * p_temp,
             int* mod_temp, bool is_liquid, double* flux_temp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



bool inverse_flag;
inverse_flag=false;
coord nn1,nn2,p;
{
  nn1.x=nn1_temp->x;
  nn2.x=nn2_temp->x;
  p.x=p_temp->x;
}
#line 1359
{
  nn1.y=nn1_temp->y;
  nn2.y=nn2_temp->y;
  p.y=p_temp->y;
}
double result=0;

double T1, T2, a, b;

double T3,T4,c,d;
int sign_flag_s;
int sign_flag_f;
double data_s[4];
double data_f[4];

int number_s =0;
int number_f=0;
bool near_triple_flag=false;





if(!near_triple_flag){
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    }

    bool flag1=false;
    if(1==0){
        
            if (fabs(nn1.x) >= fabs(nn1.y) && (!flag1)){
            flag1 = gradient_conjugates_x (point, s, css_test3, inverse_flag, nn1, p,
                &T1,&T2,&a,&b, &number_s,&sign_flag_s);

            }
            
#line 1392
if (fabs(nn1.y) >= fabs(nn1.x) && (!flag1)){
            flag1 = gradient_conjugates_y (point, s, css_test3, inverse_flag, nn1, p,
                &T1,&T2,&a,&b, &number_s,&sign_flag_s);

            }
    }else{
        if(fabs(nn1.x) >= fabs(nn1.y)){
            flag1 = gradient_conjugates_x (point, s, css_test3, inverse_flag, nn1, p,
                &T1,&T2,&a,&b, &number_s,&sign_flag_s);

        }else{
            flag1 = gradient_conjugates_y (point, s, css_test3, inverse_flag, nn1, p,
                &T1,&T2,&a,&b, &number_s,&sign_flag_s);

        }
    }
#line 1433 "././getsolid.h"
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    }


    bool flag2=false;
    
        if (fabs(nn2.x) >= fabs(nn2.y) && (!flag2)){

        flag2 = gradient_conjugatef_x (point, ss, ff, inverse_flag, nn2, p,
            &T3,&T4,&c,&d, &number_f,&sign_flag_f);

        }
        
#line 1442
if (fabs(nn2.y) >= fabs(nn2.x) && (!flag2)){

        flag2 = gradient_conjugatef_y (point, ss, ff, inverse_flag, nn2, p,
            &T3,&T4,&c,&d, &number_f,&sign_flag_f);

        }
#line 1466 "././getsolid.h"
}else{
    if(val(css_test3,0,0,0)>=0.5){
        number_s = 1;
        T1 = val(s,0,0,0);

        a = max(1e-1,fabs(p.x*nn1.x + p.y*nn1.y));
        int ii,jj;
        if(is_liquid){
            ii = round(val(merge_to_me_l_position.x,0,0,0));
            jj = round(val(merge_to_me_l_position.y,0,0,0));
        }else{
            ii = round(val(merge_to_me_g_position.x,0,0,0));
            jj = round(val(merge_to_me_g_position.y,0,0,0));
        }
        number_f = 1;
        T3 = val(ss,ii,jj,0);
        c = max(1e-1,fabs((ii-p.x)*nn2.x + (jj-p.y)*nn2.y));
    }else{
        number_s = 1;
        int ii = round(val(merge_to_me_s_position.x,0,0,0));
        int jj = round(val(merge_to_me_s_position.y,0,0,0));
        T1 = val(s,ii,jj,0);
        a = max(1e-1,fabs((ii-p.x)*nn1.x + (jj-p.y)*nn1.y));
        number_f = 1;
        T3 = val(ss,0,0,0);

        c = max(1e-1,fabs(p.x*nn2.x + p.y*nn2.y));
    }
}
#line 1506 "././getsolid.h"
   if(number_s>=1 && number_f>=1){
        if(number_s==1){
              data_s[0]=T1;
              data_s[1]=a;

        }else if(number_s==2){
              data_s[0]=T1;
              data_s[1]=T2;
              data_s[2]=a;
              data_s[3]=b;

        }
        if(number_f==1){
              data_f[0]=T3;
              data_f[1]=c;

        }else if(number_f==2){
              data_f[0]=T3;
              data_f[1]=T4;
              data_f[2]=c;
              data_f[3]=d;

        }

        result = equal_of_flux(data_s, number_s, data_f, number_f, mod_temp, inverse_flag, flux_temp);

   }else{


   }







   return result;

}


#line 1350
static void _stencil_gradient_conjugate (Point point, scalar s, scalar ss,_stencil_undefined * nn1_temp,_stencil_undefined  * nn2_temp,_stencil_undefined  * p_temp,
_stencil_undefined
             
#line 1351
* mod_temp, bool is_liquid,_stencil_undefined * flux_temp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



bool inverse_flag;
inverse_flag=false;              


  
  
  













bool near_triple_flag=false;





if(!near_triple_flag){
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    } 

    
    if(1==0){
        
{ 
_stencil_gradient_conjugates_x (point, s, css_test3, inverse_flag,
NULL 
#line 1393
,
NULL 
#line 1393
,
NULL
                
#line 1394
,NULL,NULL,NULL,NULL ,NULL); 
            

            
#line 1396
}
#line 1392
{ 
_stencil_gradient_conjugates_y (point, s, css_test3, inverse_flag,
NULL 
#line 1393
,
NULL 
#line 1393
,
NULL
                
#line 1394
,NULL,NULL,NULL,NULL ,NULL); 
            

            
#line 1396
}
                 
    
#line 1397
}else{
{{ 
_stencil_gradient_conjugates_x (point, s, css_test3, inverse_flag,
NULL 
#line 1399
,
NULL 
#line 1399
,
NULL
                
#line 1400
,NULL,NULL,NULL,NULL ,NULL);
             

        
#line 1402
}{ 
_stencil_gradient_conjugates_y (point, s, css_test3, inverse_flag,
NULL 
#line 1403
,
NULL 
#line 1403
,
NULL
                
#line 1404
,NULL,NULL,NULL,NULL ,NULL);
             

        
#line 1406
}}
          
    
#line 1407
}
#line 1433 "././getsolid.h"
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    } 


    
    
{ 

_stencil_gradient_conjugatef_x (point, ss, ff, inverse_flag,
NULL 
#line 1444
,
NULL 
#line 1444
,
NULL
            
#line 1445
,NULL,NULL,NULL,NULL ,NULL); 

        

        
#line 1447
}
#line 1442
{ 

_stencil_gradient_conjugatef_y (point, ss, ff, inverse_flag,
NULL 
#line 1444
,
NULL 
#line 1444
,
NULL
            
#line 1445
,NULL,NULL,NULL,NULL ,NULL); 

        

        
#line 1447
}
             
#line 1466 "././getsolid.h"
}else{
_stencil_val(css_test3,0,0,0);{{
           
_stencil_val(s,0,0,0); 
         

            
        
        
#line 1473
if(is_liquid){
_stencil_val(merge_to_me_l_position.x,0,0,0); 
             _stencil_val(merge_to_me_l_position.y,0,0,0); 
             
        
#line 1476
}else{
_stencil_val(merge_to_me_g_position.x,0,0,0);
              _stencil_val(merge_to_me_g_position.y,0,0,0);
              
        
#line 1479
}
           
_stencil_val(ss,o_stencil,o_stencil,0);
         
            
    
#line 1483
}{   
          
        _stencil_val(merge_to_me_s_position.x,0,0,0);   
        _stencil_val(merge_to_me_s_position.y,0,0,0); 
_stencil_val(s,o_stencil,o_stencil,0);
         
            
           _stencil_val(ss,0,0,0);
         

            
    
#line 1493
}}
    

#line 1494
}
#line 1532
{


   }
#line 1506 "././getsolid.h"
      
              
              

        
              
              

        
         
              
              
              
              

        
         
              
              
              
              

        

               

   







   


return ;

}

void gradient_conjugate_Rcc (Point point, scalar s, scalar ss,coord * nn1_temp, coord * nn2_temp, coord * p_temp,
             int* mod_temp, bool is_liquid, double* result)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



bool inverse_flag;
inverse_flag=false;
coord nn1,nn2,p;
{
  nn1.x=nn1_temp->x;
  nn2.x=nn2_temp->x;
  p.x=p_temp->x;
}
#line 1556
{
  nn1.y=nn1_temp->y;
  nn2.y=nn2_temp->y;
  p.y=p_temp->y;
}


double T1, T2, a, b;

double T3,T4,c,d;
int sign_flag_s;
int sign_flag_f;
double data_s[4];
double data_f[4];

int number_s =0;
int number_f=0;
bool near_triple_flag=false;





if(!near_triple_flag){
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    }

    bool flag1=false;
    
        if (fabs(nn1.x) >= fabs(nn1.y) && (!flag1)){
        flag1 = gradient_conjugates_x (point, s, css_test3, inverse_flag, nn1, p,
            &T1,&T2,&a,&b, &number_s,&sign_flag_s);

        }
        
#line 1588
if (fabs(nn1.y) >= fabs(nn1.x) && (!flag1)){
        flag1 = gradient_conjugates_y (point, s, css_test3, inverse_flag, nn1, p,
            &T1,&T2,&a,&b, &number_s,&sign_flag_s);

        }
#line 1617 "././getsolid.h"
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    }


    bool flag2=false;
    
        if (fabs(nn2.x) >= fabs(nn2.y) && (!flag2)){

        flag2 = gradient_conjugatef_x (point, ss, ff, inverse_flag, nn2, p,
            &T3,&T4,&c,&d, &number_f,&sign_flag_f);

        }
        
#line 1626
if (fabs(nn2.y) >= fabs(nn2.x) && (!flag2)){

        flag2 = gradient_conjugatef_y (point, ss, ff, inverse_flag, nn2, p,
            &T3,&T4,&c,&d, &number_f,&sign_flag_f);

        }
#line 1650 "././getsolid.h"
}else{
    if(val(css_test3,0,0,0)>=0.5){
        number_s = 1;
        T1 = val(s,0,0,0);

        a = max(1e-1,fabs(p.x*nn1.x + p.y*nn1.y));
        int ii,jj;
        if(is_liquid){
            ii = round(val(merge_to_me_l_position.x,0,0,0));
            jj = round(val(merge_to_me_l_position.y,0,0,0));
        }else{
            ii = round(val(merge_to_me_g_position.x,0,0,0));
            jj = round(val(merge_to_me_g_position.y,0,0,0));
        }
        number_f = 1;
        T3 = val(ss,ii,jj,0);
        c = max(1e-1,fabs((ii-p.x)*nn2.x + (jj-p.y)*nn2.y));
    }else{
        number_s = 1;
        int ii = round(val(merge_to_me_s_position.x,0,0,0));
        int jj = round(val(merge_to_me_s_position.y,0,0,0));
        T1 = val(s,ii,jj,0);
        a = max(1e-1,fabs((ii-p.x)*nn1.x + (jj-p.y)*nn1.y));
        number_f = 1;
        T3 = val(ss,0,0,0);

        c = max(1e-1,fabs(p.x*nn2.x + p.y*nn2.y));
    }
}
#line 1691 "././getsolid.h"
   if(number_s==1 && number_f==1){
        if(number_s==1){
              data_s[0]=T1;
              data_s[1]=a;

        }
        if(number_f==1){
              data_f[0]=T3;
              data_f[1]=c;

        }
        equal_of_flux_Rcc(data_s, number_s, data_f, number_f, mod_temp, inverse_flag, result);
   }else{

   }






}


#line 1547
static void _stencil_gradient_conjugate_Rcc (Point point, scalar s, scalar ss,_stencil_undefined * nn1_temp,_stencil_undefined  * nn2_temp,_stencil_undefined  * p_temp,
_stencil_undefined
             
#line 1548
* mod_temp, bool is_liquid, double* result)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;



bool inverse_flag;
inverse_flag=false;             


  
  
  













bool near_triple_flag=false;





if(!near_triple_flag){
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    } 

    
    
{ 
_stencil_gradient_conjugates_x (point, s, css_test3, inverse_flag,
NULL 
#line 1589
,
NULL 
#line 1589
,
NULL
            
#line 1590
,NULL,NULL,NULL,NULL ,NULL); 
        

        
#line 1592
}
#line 1588
{ 
_stencil_gradient_conjugates_y (point, s, css_test3, inverse_flag,
NULL 
#line 1589
,
NULL 
#line 1589
,
NULL
            
#line 1590
,NULL,NULL,NULL,NULL ,NULL); 
        

        
#line 1592
}
             
#line 1617 "././getsolid.h"
    if(is_liquid){
    inverse_flag=false;
    }else{
    inverse_flag=true;
    } 


    
    
{ 

_stencil_gradient_conjugatef_x (point, ss, ff, inverse_flag,
NULL 
#line 1628
,
NULL 
#line 1628
,
NULL
            
#line 1629
,NULL,NULL,NULL,NULL ,NULL); 

        

        
#line 1631
}
#line 1626
{ 

_stencil_gradient_conjugatef_y (point, ss, ff, inverse_flag,
NULL 
#line 1628
,
NULL 
#line 1628
,
NULL
            
#line 1629
,NULL,NULL,NULL,NULL ,NULL); 

        

        
#line 1631
}
             
#line 1650 "././getsolid.h"
}else{
_stencil_val(css_test3,0,0,0);{{
           
_stencil_val(s,0,0,0); 
         

            
        
        
#line 1657
if(is_liquid){
_stencil_val(merge_to_me_l_position.x,0,0,0); 
             _stencil_val(merge_to_me_l_position.y,0,0,0); 
             
        
#line 1660
}else{
_stencil_val(merge_to_me_g_position.x,0,0,0);
              _stencil_val(merge_to_me_g_position.y,0,0,0);
              
        
#line 1663
}
           
_stencil_val(ss,o_stencil,o_stencil,0);
         
            
    
#line 1667
}{   
          
        _stencil_val(merge_to_me_s_position.x,0,0,0);   
        _stencil_val(merge_to_me_s_position.y,0,0,0); 
_stencil_val(s,o_stencil,o_stencil,0);
         
            
           _stencil_val(ss,0,0,0);
         

            
    
#line 1677
}}
    

#line 1678
}
#line 1703
{

   }
#line 1691 "././getsolid.h"
     
        
              
              

        
        
              
              

              
        
   








}


void gradient_conjugate_for_solid (Point point, scalar s, scalar ss, coord * nn1_temp, coord * p_temp,
                     int* mod_temp, bool is_liquid, double* flux_temp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;

int number_s =0;
bool inverse_flag;
inverse_flag=false;
coord nn1,p;
{
  nn1.x=nn1_temp->x;

  p.x=p_temp->x;
}
#line 1723
{
  nn1.y=nn1_temp->y;

  p.y=p_temp->y;
}
double result=0;

double T1, T2, a, b;
int sign_flag_s;

 bool flag1=false;
 if(1==0){
  
    if (fabs(nn1.x) >= fabs(nn1.y) && (!flag1)){
      flag1 = gradient_conjugates_x (point, s, css_test3, inverse_flag, nn1, p,
        &T1,&T2,&a,&b, &number_s,&sign_flag_s);

    }
    
#line 1736
if (fabs(nn1.y) >= fabs(nn1.x) && (!flag1)){
      flag1 = gradient_conjugates_y (point, s, css_test3, inverse_flag, nn1, p,
        &T1,&T2,&a,&b, &number_s,&sign_flag_s);

    }
 }else{
    if (fabs(nn1.x) >= fabs(nn1.y)){
      flag1 = gradient_conjugates_x (point, s, css_test3, inverse_flag, nn1, p,
        &T1,&T2,&a,&b, &number_s,&sign_flag_s);


    }else{
        flag1 = gradient_conjugates_y (point, s, css_test3, inverse_flag, nn1, p,
        &T1,&T2,&a,&b, &number_s,&sign_flag_s);

    }
 }
#line 1771 "././getsolid.h"
if(is_liquid){
  inverse_flag=false;
}else{
  inverse_flag=true;
}

   if(number_s>=1){
        if(number_s==1){



            *flux_temp = Tks*((val(ss,0,0,0) - T1)/a);
            *mod_temp = 6;
        }else if(number_s==2){





            *flux_temp = Tks*((T2-T1)/a + ((val(ss,0,0,0)-T2)/b-(T2-T1)/a)/(a+b)*(a+2*b));
            *mod_temp = 6;
        }else{
            printf("no gradient_conjugate_for_solid 2\n");
        }
   }else{
        printf("no gradient_conjugate_for_solid 2\n");
   }






}



#line 1715
static void _stencil_gradient_conjugate_for_solid (Point point, scalar s, scalar ss,_stencil_undefined  * nn1_temp,_stencil_undefined  * p_temp,
_stencil_undefined
                     
#line 1716
* mod_temp, bool is_liquid,_stencil_undefined * flux_temp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;  


bool inverse_flag;
inverse_flag=false;        


  

  






 
 if(1==0){
  
{ 
_stencil_gradient_conjugates_x (point, s, css_test3, inverse_flag,
NULL 
#line 1737
,
NULL 
#line 1737
,
NULL
        
#line 1738
,NULL,NULL,NULL,NULL ,NULL); 
      

    
#line 1740
}
#line 1736
{ 
_stencil_gradient_conjugates_y (point, s, css_test3, inverse_flag,
NULL 
#line 1737
,
NULL 
#line 1737
,
NULL
        
#line 1738
,NULL,NULL,NULL,NULL ,NULL); 
      

    
#line 1740
}
         
 
#line 1741
}else{
{{ 
_stencil_gradient_conjugates_x (point, s, css_test3, inverse_flag,
NULL 
#line 1743
,
NULL 
#line 1743
,
NULL
        
#line 1744
,NULL,NULL,NULL,NULL ,NULL);
       


    
#line 1747
}{ 
_stencil_gradient_conjugates_y (point, s, css_test3, inverse_flag,
NULL 
#line 1748
,
NULL 
#line 1748
,
NULL
        
#line 1749
,NULL,NULL,NULL,NULL ,NULL);
         

    
#line 1751
}}
       
 
#line 1752
}
#line 1771 "././getsolid.h"
if(is_liquid){
  inverse_flag=false;
}else{
  inverse_flag=true;
}

{
{{



_stencil_val(ss,0,0,0); 



                
             
        
#line 1784
}{





_stencil_val(ss,0,0,0); 





                
             
        
#line 1792
}}
         
            
        
   
#line 1795
}

   
        
   







#line 1804
}
#line 1834 "././getsolid.h"
void embed_flux_conjugate (scalar s, scalar ss, scalar sss, scalar aiml, scalar aimg, scalar T_modl, scalar T_modg, scalar flux_l, scalar flux_g)
{

foreach_stencil(){



        _stencil_val_a(T_modl,0,0,0);  
        _stencil_val_a(T_modg,0,0,0);  
        _stencil_val_a(aiml,0,0,0);
        _stencil_val_a(aimg,0,0,0);
        _stencil_val_a(flux_l,0,0,0);  
        _stencil_val_a(flux_g,0,0,0);
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{  






               _stencil_facet_normal (point, css_test3, fss_test3);      
              
              _stencil_val(css_test3,0,0,0);    
               
               
                  
#line 1870 "././getsolid.h"
                  




                  
                  if(!structure_normal_flag){ 
_stencil_val(direction_Ts.x,0,0,0); 
                     _stencil_val(direction_Ts.y,0,0,0);
                     
                  
#line 1879
}   
                      
                      
                  
                  



                  
                 if(!structure_normal_flag){ 
_stencil_val(direction_Tfl.x,0,0,0); 
                     _stencil_val(direction_Tfl.y,0,0,0);
                     
                 
#line 1891
}   
                      
                      
                 
                  


                  
                if(!structure_normal_flag){ 
_stencil_val(direction_Tfg.x,0,0,0); 
                     _stencil_val(direction_Tfg.y,0,0,0);
                     
                 
#line 1902
}   
                      
                      
                 
                  



                  
                  _stencil_val_a(T_modl,0,0,0);   
                  
                  _stencil_val_a(T_modg,0,0,0); 



_stencil_val(ff,0,0,0);{     


                         
                        
                              
                              
                        
                             
                        
                              
                              
                        

                        bool is_liquid=true; 
                        
                        
                          
                        

                        if(!Rcc_flag_l){  
                                
                                
_stencil_gradient_conjugate (point, s, ss,NULL ,NULL ,NULL ,NULL ,is_liquid,NULL);
                                
{
                                    _stencil_val_a(aiml,0,0,0);   
                                    _stencil_val_a(T_modl,0,0,0);  
                                    _stencil_val_a(flux_l,0,0,0);  
                                }

                                  
                        
#line 1947
}else{
                                double gradl[3];

                                gradl[2] = 0;
                 _stencil_gradient_conjugate_Rcc (point, s, ss,NULL ,NULL ,NULL ,NULL ,is_liquid,gradl);

{

{
                                        _stencil_val_a(aiml,0,0,0);   
                                        _stencil_val_a(aiml_s,0,0,0);   
                                        _stencil_val_a(T_modl,0,0,0);  
                                        _stencil_val_a(flux_l,0,0,0);   
                                    }

                                      

                                
#line 1962
}

                                
                        
#line 1963
}

                } 

_stencil_val(ff,0,0,0);{     
                        
                        
                              
                              
                        
                            
                        
                              
                              
                        

                        bool is_liquid=false; 
                        
                        
                          
                        

                        if(!Rcc_flag_g){  
                                
                                
_stencil_gradient_conjugate (point, s, sss,NULL ,NULL ,NULL ,NULL , is_liquid,NULL );
                                
{
                                    _stencil_val_a(aimg,0,0,0);   
                                    _stencil_val_a(T_modg,0,0,0);  
                                    _stencil_val_a(flux_g,0,0,0);  
                                }

                                  
                        
#line 1995
}else{
                                double gradg[3];

                                gradg[2]=0.0;
                                _stencil_gradient_conjugate_Rcc (point, s, sss,NULL ,NULL ,NULL ,NULL , is_liquid,gradg);


{
{
                                            _stencil_val_a(aimg,0,0,0);   
                                            _stencil_val_a(aimg_s,0,0,0);   
                                            _stencil_val_a(T_modg,0,0,0);  
                                            _stencil_val_a(flux_g,0,0,0);   
                                        }
                                          

                                
#line 2010
}


                                
                         
#line 2011
}

                }  



                   

                   
#line 2026 "././getsolid.h"
      } 
            

    
#line 2028
}end_foreach_stencil();

{
#line 1837
foreach(){



        val(T_modl,0,0,0) = 0;
        val(T_modg,0,0,0) = 0;
        val(aiml,0,0,0)=0;
        val(aimg,0,0,0)=0;
        val(flux_l,0,0,0) = 0.0;
        val(flux_g,0,0,0) =0.0;
      if (!(val(css_test3,0,0,0) >= 1. || val(css_test3,0,0,0) <= 0.)){






              coord n = facet_normal (point, css_test3, fss_test3);
              coord p;
              double alpha = line_alpha (val(css_test3,0,0,0), n);
              double area = line_length_center(n,alpha,&p);
              if (metric_embed_factor)
                  area *= metric_embed_factor (point, p);
#line 1870 "././getsolid.h"
                  normalize(&n);




                  coord nn1;
                  if(!structure_normal_flag){
                    nn1.x = val(direction_Ts.x,0,0,0);
                    nn1.y = val(direction_Ts.y,0,0,0);
                  }else{
                    nn1.x = n.x;
                    nn1.y = n.y;
                  }
                  double value_temp1= sqrt(sq(nn1.x)+sq(nn1.y));



                  coord nn2;
                 if(!structure_normal_flag){
                    nn2.x = val(direction_Tfl.x,0,0,0);
                    nn2.y = val(direction_Tfl.y,0,0,0);
                 }else{
                    nn2.x = -n.x;
                    nn2.y = -n.y;
                 }
                  double value_temp2= sqrt(sq(nn2.x)+sq(nn2.y));


                  coord nn3;
                if(!structure_normal_flag){
                    nn3.x = val(direction_Tfg.x,0,0,0);
                    nn3.y = val(direction_Tfg.y,0,0,0);
                 }else{
                    nn3.x = -n.x;
                    nn3.y = -n.y;
                 }
                  double value_temp3= sqrt(sq(nn3.x)+sq(nn3.y));



                  int mod_templ=-1;
                  val(T_modl,0,0,0) = mod_templ;
                  int mod_tempg=-1;
                  val(T_modg,0,0,0) = mod_tempg;



                if((value_temp1>1e-20) && (value_temp2>1e-20) && val(ff,0,0,0)>0.0){


                         double same_direction = n.x*nn1.x + n.y*nn1.y;
                        if(same_direction<0.0){
                            nn1.x = -nn1.x;
                            nn1.y = -nn1.y;
                        }
                         same_direction = (-n.x)*nn2.x + (-n.y)*nn2.y;
                        if(same_direction<0.0){
                            nn2.x = -nn2.x;
                            nn2.y = -nn2.y;
                        }

                        bool is_liquid=true;
                        coord pp;
                        {
                          pp.x=p.x;
                        }
#line 1933
{
                          pp.y=p.y;
                        }

                        if(!Rcc_flag_l){
                                double gradl;
                                double flux1=0.0;
                                gradl=gradient_conjugate (point, s, ss, &nn1, &nn2, &pp, &mod_templ,is_liquid,&flux1);

                                if(mod_templ!=-1 && fabs(gradl+1)>1e-20){
                                    val(aiml,0,0,0) = gradl ;
                                    val(T_modl,0,0,0) = mod_templ;
                                    val(flux_l,0,0,0) = flux1;
                                }
                        }else{
                                double gradl[3];;

                                gradl[2] = 0;
                 gradient_conjugate_Rcc (point, s, ss, &nn1, &nn2, &pp, &mod_templ,is_liquid,gradl);

                                if(gradl!=NULL){

                                    if(mod_templ!=-1 && (fabs(gradl[0]+1)>1e-20)){
                                        val(aiml,0,0,0) = gradl[0] ;
                                        val(aiml_s,0,0,0) = gradl[1] ;
                                        val(T_modl,0,0,0) = mod_templ;
                                        val(flux_l,0,0,0) = gradl[2] ;
                                    }

                                }
                        }

                }

                if((value_temp1>1e-20) && (value_temp3>1e-20) && val(ff,0,0,0)<1.0){
                        double same_direction = n.x*nn1.x + n.y*nn1.y;
                        if(same_direction<0.0){
                            nn1.x = -nn1.x;
                            nn1.y = -nn1.y;
                        }
                        same_direction = (-n.x)*nn3.x + (-n.y)*nn3.y;
                        if(same_direction<0.0){
                            nn3.x = -nn3.x;
                            nn3.y = -nn3.y;
                        }

                        bool is_liquid=false;
                        coord pp;
                        {
                          pp.x=p.x;
                        }
#line 1981
{
                          pp.y=p.y;
                        }

                        if(!Rcc_flag_g){
                                double gradg;
                                double flux1=0.0;
                                gradg=gradient_conjugate (point, s, sss, &nn1, &nn3, &pp, &mod_tempg, is_liquid, &flux1);

                                if(mod_tempg!=-1 && fabs(gradg+1)>1e-20){
                                    val(aimg,0,0,0) = gradg ;
                                    val(T_modg,0,0,0) = mod_tempg;
                                    val(flux_g,0,0,0) = flux1;
                                }
                        }else{
                                double gradg[3];

                                gradg[2]=0.0;
                                gradient_conjugate_Rcc (point, s, sss, &nn1, &nn3, &pp, &mod_tempg, is_liquid,gradg);


                                if(gradg!=NULL){
                                        if(mod_tempg!=-1 && fabs(gradg[0]+1)>1e-20){
                                            val(aimg,0,0,0) = gradg[0] ;
                                            val(aimg_s,0,0,0) = gradg[1] ;
                                            val(T_modg,0,0,0) = mod_tempg;
                                            val(flux_g,0,0,0) = gradg[2] ;
                                        }

                                }
                         }

                }
#line 2026 "././getsolid.h"
      }

    }end_foreach();}



    foreach_stencil(){
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);_stencil_val(intersect_true,0,0,0);{  
               _stencil_facet_normal (point, css_test3, fss_test3);      
              
              _stencil_val(css_test3,0,0,0);    
               
               
                  
               
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{  
                      _stencil_mycs (point, ff);      
                      
                      _stencil_val(ff,0,0,0);   
                       
                       
                             
                       
                }
                
                 
#line 2050
Point me = point;      
                 
                 

_stencil_val(T_modl,0,0,0);_stencil_val(ff,0,0,0);{  
                
                







                {foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

_stencil_val(T_modl,0,0,0);{{ 
                              
                                 
                             
_stencil_val(aiml,0,0,0); 
                             



                     
#line 2075
} {_stencil_val(intersect_true,0,0,0); 
                             
                                 
                              
                              

                        }}

                        
                    
#line 2082
}
                }end_foreach_neighbor()}
{
                    _stencil_val_a(aiml,0,0,0);  

                    _stencil_val_a(T_modl,0,0,0);
                }
                
          
#line 2089
}


_stencil_val(T_modg,0,0,0);_stencil_val(ff,0,0,0);{  
                
                






                {foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

_stencil_val(T_modg,0,0,0);{{ 
                              

                                 
                             
_stencil_val(aimg,0,0,0); 
                             


                         
#line 2112
} {_stencil_val(intersect_true,0,0,0); 
                             
                                 
                              
                              
                        }}

                        
                    
#line 2118
}
                }end_foreach_neighbor()}
{
                    _stencil_val_a(aimg,0,0,0);  

                    _stencil_val_a(T_modg,0,0,0);
                }
                 
          
#line 2125
}

            


            

      
#line 2127
}
               
    
#line 2128
}end_foreach_stencil();



    {
#line 2032
foreach(){
       if ((!(val(css_test3,0,0,0) >= 1. || val(css_test3,0,0,0) <= 0.)) && (val(intersect_true,0,0,0)==0)){
              coord n = facet_normal (point, css_test3, fss_test3);
              coord p;
              double alpha = line_alpha (val(css_test3,0,0,0), n);
              double area = line_length_center(n,alpha,&p);
              if (metric_embed_factor)
                  area *= metric_embed_factor (point, p);
               double distance=HUGE;
               if((val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0)){
                     coord nl = mycs (point, ff);
                      coord pl;
                      double alphal = line_alpha (val(ff,0,0,0), nl);
                      double area = line_length_center(nl,alphal,&pl);
                      if (metric_embed_factor)
                            area *= metric_embed_factor (point, pl);
                      distance = sqrt(sq(p.x-pl.x)+sq(p.y-pl.y));
                }
                 Point me = point;
                 double xx = p.x*Delta+x;
                 double yy = p.y*Delta+y;

          if(fabs(val(T_modl,0,0,0)+1)<1e-12 && (val(ff,0,0,0)>0.0)){
                double total=0.0;
                double weight=0.0;







                {foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

                        if(val(T_modl,0,0,0)>0.5){
                            double weight_local;
                            weight_local = 1.0/(sqrt(sq(x-xx) + sq(y - yy))/Delta);
                            weight += weight_local;
                            total += weight_local*val(aiml,0,0,0);



                     }else if((val(intersect_true,0,0,0)==1)){
                            double weight_local;
                            weight_local = 1.0/(sqrt(sq(x-xx) + sq(y - yy))/Delta);
                            weight += weight_local;
                            total += weight_local*Tsat00;

                        }
                    }
                }end_foreach_neighbor()}
                if(weight>1e-12){
                    val(aiml,0,0,0) = total/weight;

                    val(T_modl,0,0,0)=6;
                }
          }


          if(fabs(val(T_modg,0,0,0)+1)<1e-12 && (val(ff,0,0,0)<1.0)){
                double total=0.0;
                double weight=0.0;






                {foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

                        if(val(T_modg,0,0,0)>0.5){
                            double weight_local;

                            weight_local = 1.0/(sqrt(sq(x-xx) + sq(y - yy))/Delta);
                            weight += weight_local;
                            total += weight_local*val(aimg,0,0,0);


                         }else if((val(intersect_true,0,0,0)==1)){
                            double weight_local;
                            weight_local = 1.0/(sqrt(sq(x-xx) + sq(y - yy))/Delta);
                            weight += 1.0/weight_local;
                            total += weight_local*Tsat00;
                        }
                    }
                }end_foreach_neighbor()}
                 if(weight>1e-12){
                    val(aimg,0,0,0) = total/weight;

                    val(T_modg,0,0,0)=6;
                }
          }

      }
    }end_foreach();}


     foreach_stencil(){
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);_stencil_val(intersect_true,0,0,0);{  
               _stencil_facet_normal (point, css_test3, fss_test3);      
              
              _stencil_val(css_test3,0,0,0);    
               
               
                  
               
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{  
                      _stencil_mycs (point, ff);      
                      
                      _stencil_val(ff,0,0,0);   
                       
                       
                             
                       
                }
                
                 
#line 2149
Point me = point;      
                 
                 

_stencil_val(T_modl,0,0,0);_stencil_val(ff,0,0,0);{  
                
                
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);  
                     
                     

                 
                  


                {
#line 2163
foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

_stencil_val(T_modl,0,0,0);{ 
                             
                                 
                              
_stencil_val(aiml,0,0,0);
                              

                        
#line 2172
}

                        







                    
#line 2180
}
                }end_foreach_neighbor()}
{
                    _stencil_val_a(aiml,0,0,0);  

                    _stencil_val_a(T_modl,0,0,0);
                }
                
          
#line 2187
}


_stencil_val(T_modg,0,0,0);_stencil_val(ff,0,0,0);{  
                
                
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);  
                     
                     
                 
                  


                {
#line 2199
foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

_stencil_val(T_modg,0,0,0);{ 
                             

                                 
                              
_stencil_val(aimg,0,0,0);
                              
                        
#line 2208
}

                        






                    
#line 2215
}
                }end_foreach_neighbor()}
{
                    _stencil_val_a(aimg,0,0,0);  

                    _stencil_val_a(T_modg,0,0,0);
                }
                 
          
#line 2222
}

            


            

      
#line 2224
}
               
    
#line 2225
}end_foreach_stencil();


     {
#line 2131
foreach(){
       if ((!(val(css_test3,0,0,0) >= 1. || val(css_test3,0,0,0) <= 0.)) && (val(intersect_true,0,0,0)==1)){
              coord n = facet_normal (point, css_test3, fss_test3);
              coord p;
              double alpha = line_alpha (val(css_test3,0,0,0), n);
              double area = line_length_center(n,alpha,&p);
              if (metric_embed_factor)
                  area *= metric_embed_factor (point, p);
               double distance=HUGE;
               if((val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0)){
                     coord nl = mycs (point, ff);
                      coord pl;
                      double alphal = line_alpha (val(ff,0,0,0), nl);
                      double area = line_length_center(nl,alphal,&pl);
                      if (metric_embed_factor)
                            area *= metric_embed_factor (point, pl);
                      distance = sqrt(sq(p.x-pl.x)+sq(p.y-pl.y));
                }
                 Point me = point;
                 double xx = p.x*Delta+x;
                 double yy = p.y*Delta+y;

          if(fabs(val(T_modl,0,0,0)+1)<1e-12 && (val(ff,0,0,0)>0.0)){
                double total=0.0;
                double weight=0.0;
                 if((val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0)){
                    weight += 1.0/distance;
                    total += weight*Tsat00;

                 }


                {foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

                        if(val(T_modl,0,0,0)>0.5){
                            double weight_local;
                            weight_local = 1.0/(sqrt(sq(x-xx) + sq(y - yy))/Delta);
                            weight += weight_local;
                            total += weight_local*val(aiml,0,0,0);

                        }







                    }
                }end_foreach_neighbor()}
                if(weight>1e-12){
                    val(aiml,0,0,0) = total/weight;

                    val(T_modl,0,0,0)=6;
                }
          }


          if(fabs(val(T_modg,0,0,0)+1)<1e-12 && (val(ff,0,0,0)<1.0)){
                double total=0.0;
                double weight=0.0;
                 if((val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0)){
                    weight = 1.0/distance;
                    total = weight*Tsat00;
                 }


                {foreach_neighbor(2){
                    if(!(me.i==point.i && me.j==point.j)){

                        if(val(T_modg,0,0,0)>0.5){
                            double weight_local;

                            weight_local = 1.0/(sqrt(sq(x-xx) + sq(y - yy))/Delta);
                            weight += weight_local;
                            total += weight_local*val(aimg,0,0,0);
                        }






                    }
                }end_foreach_neighbor()}
                 if(weight>1e-12){
                    val(aimg,0,0,0) = total/weight;

                    val(T_modg,0,0,0)=6;
                }
          }

      }
    }end_foreach();}



if(1==0){
foreach_stencil(){

_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{  
               _stencil_facet_normal (point, css_test3, fss_test3);      
              
              _stencil_val(css_test3,0,0,0);    
               
               
                  

                  

                  
                  if(!structure_normal_flag){ 
_stencil_val(direction_Ts.x,0,0,0); 
                     _stencil_val(direction_Ts.y,0,0,0);
                     
                  
#line 2246
}   
                      
                      
                  
                  



                  
                  if(!structure_normal_flag){ 
_stencil_val(direction_Tfl.x,0,0,0); 
                     _stencil_val(direction_Tfl.y,0,0,0);
                     
                 
#line 2258
}   
                      
                      
                 
                  


                  
                  if(!structure_normal_flag){ 
_stencil_val(direction_Tfg.x,0,0,0); 
                     _stencil_val(direction_Tfg.y,0,0,0);
                     
                 
#line 2269
}  
                      
                      
                 
                  




_stencil_val(T_modl,0,0,0);_stencil_val(aiml,0,0,0);{     
                         
                        
                              
                              
                        
                             
                        
                              
                              
                        

                        bool is_liquid=true;   
                        
                        
                        
                          
                        
                        

                        _stencil_gradient_conjugate_for_solid (point, s, aiml,NULL ,NULL ,NULL ,is_liquid,NULL );
{
                            _stencil_val_a(flux_l,0,0,0);  
                            _stencil_val_a(T_modl,0,0,0);  
                        }
                        
                
#line 2303
}

_stencil_val(T_modg,0,0,0);_stencil_val(aimg,0,0,0);{     
                        
                        
                              
                              
                        
                            
                        
                              
                              
                        

                        bool is_liquid=false;   
                        
                        
                        
                          
                        
                         

                        _stencil_gradient_conjugate_for_solid (point, s, aimg,NULL ,NULL ,NULL ,is_liquid,NULL );
{
                            _stencil_val_a(flux_g,0,0,0);  
                            _stencil_val_a(T_modg,0,0,0);  
                         }
                         
                
#line 2330
}




                      

                      
      
#line 2331
}

            

    
#line 2333
}end_foreach_stencil();
{
#line 2230
foreach(){

      if (!(val(css_test3,0,0,0) >= 1. || val(css_test3,0,0,0) <= 0.)){
              coord n = facet_normal (point, css_test3, fss_test3);
              coord p;
              double alpha = line_alpha (val(css_test3,0,0,0), n);
              double area = line_length_center(n,alpha,&p);
              if (metric_embed_factor)
                  area *= metric_embed_factor (point, p);

                  normalize(&n);

                  coord nn1;
                  if(!structure_normal_flag){
                    nn1.x = val(direction_Ts.x,0,0,0);
                    nn1.y = val(direction_Ts.y,0,0,0);
                  }else{
                    nn1.x = n.x;
                    nn1.y = n.y;
                  }
                  double value_temp1= sqrt(sq(nn1.x)+sq(nn1.y));



                  coord nn2;
                  if(!structure_normal_flag){
                    nn2.x = val(direction_Tfl.x,0,0,0);
                    nn2.y = val(direction_Tfl.y,0,0,0);
                 }else{
                    nn2.x = -n.x;
                    nn2.y = -n.y;
                 }
                  double value_temp2= sqrt(sq(nn2.x)+sq(nn2.y));


                  coord nn3;
                  if(!structure_normal_flag){
                    nn3.x = val(direction_Tfg.x,0,0,0);
                    nn3.y = val(direction_Tfg.y,0,0,0);
                 }else{
                    nn3.x = -n.x;
                    nn3.y = -n.y;
                 }
                  double value_temp3= sqrt(sq(nn3.x)+sq(nn3.y));




                if((fabs(val(T_modl,0,0,0)+1)<1e-12 && fabs(val(aiml,0,0,0))>1e-12) && ((value_temp1>1e-20) && (value_temp2>1e-20))){
                         double same_direction = n.x*nn1.x + n.y*nn1.y;
                        if(same_direction<0.0){
                            nn1.x = -nn1.x;
                            nn1.y = -nn1.y;
                        }
                         same_direction = (-n.x)*nn2.x + (-n.y)*nn2.y;
                        if(same_direction<0.0){
                            nn2.x = -nn2.x;
                            nn2.y = -nn2.y;
                        }

                        bool is_liquid=true;
                        double flux1=0.0;
                        coord pp;
                        {
                          pp.x=p.x;
                        }
#line 2293
{
                          pp.y=p.y;
                        }
                        int mod_temp=-1;

                        gradient_conjugate_for_solid (point, s, aiml, &nn1, &pp, &mod_temp,is_liquid, &flux1);
                        if(mod_temp==6){
                            val(flux_l,0,0,0) = flux1;
                            val(T_modl,0,0,0) = mod_temp;
                        }
                }

                if((fabs(val(T_modg,0,0,0)+1)<1e-12 && fabs(val(aimg,0,0,0))>1e-12) && ((value_temp1>1e-20) && (value_temp3>1e-20))){
                        double same_direction = n.x*nn1.x + n.y*nn1.y;
                        if(same_direction<0.0){
                            nn1.x = -nn1.x;
                            nn1.y = -nn1.y;
                        }
                        same_direction = (-n.x)*nn3.x + (-n.y)*nn3.y;
                        if(same_direction<0.0){
                            nn3.x = -nn3.x;
                            nn3.y = -nn3.y;
                        }

                        bool is_liquid=false;
                        double flux1=0.0;
                        coord pp;
                        {
                          pp.x=p.x;
                        }
#line 2320
{
                          pp.y=p.y;
                        }
                         int mod_temp=-1;

                        gradient_conjugate_for_solid (point, s, aimg, &nn1, &pp, &mod_temp,is_liquid, &flux1);
                         if(mod_temp==6){
                            val(flux_g,0,0,0) = flux1;
                            val(T_modg,0,0,0) = 6;
                         }
                }
      }

    }end_foreach();}
}

}



 void get_solidsurfaceT(){

    get_topomask_soilid((struct Topo_m3){topo_mask_s,css_test3,level_interface});


    bool flag;
    flag=false;
    gradient_ff(((scalar[]){Tl,{-1}}),((vector[]){Tlff_g,{{-1},{-1}}}),ff,css_test3,topo_mask,topo_mask_s,flag);
    flag=true;
    gradient_ff(((scalar[]){Tg,{-1}}),((vector[]){Tgff_g,{{-1},{-1}}}),ff,css_test3,topo_mask,topo_mask_s,flag);
    flag=false;
    gradient_s(((scalar[]){Ts,{-1}}),((vector[]){T_solid_g,{{-1},{-1}}}),css_test3,topo_mask_s,flag);

        bool flag4;
        flag4=true;
        direction_ff(Tgff_g,ff,css_test3,topo_mask,topo_mask_s,direction_Tfg,flag4);
        flag4=false;
        direction_ff(Tlff_g,ff,css_test3,topo_mask,topo_mask_s,direction_Tfl,flag4);
        flag4=false;
        direction_s(T_solid_g,css_test3,direction_Ts,flag4);

     embed_flux_conjugate(Ts, Tl, Tg, aiml, aimg, T_modl,T_modg, flux_l, flux_g);
}
#line 2382 "././getsolid.h"
bool is_f_small_part(double f_value) {
    if ( (f_value > 0.0 && f_value < 0.5)) {
        return true;
    }
    return false;
}

bool is_f_big_part(double f_value) {
    if ((f_value >= 0.5 && f_value<=1.0)) {
        return true;
    }
    return false;
}

void merge_get_c_position(bool inverse, scalar ff5, scalar merge_c,vector merge_position){
        foreach_stencil(){
            _stencil_val_a(merge_c,0,0,0);  
            _stencil_val_a(merge_position.x,0,0,0);
            _stencil_val_a(merge_position.y,0,0,0);

_stencil_val(ff5,0,0,0);{   
                
                

               _stencil_mycs (point,ff5);      
              
              _stencil_val(ff5,0,0,0);     
               
               
                   
                 
                  
              

                
                
                {foreach_neighbor(1){
_stencil_val(ff5,0,0,0);     
                             
                               
                                
                            
                             
                             
                               
                                 
                                 
                                 
                            

                            
                     
                        
                    
                    
                     
                                   
                        
                    
                   
                
#line 2441
}end_foreach_neighbor()}
{
                    _stencil_val_a(merge_position.x,0,0,0);  
                    _stencil_val_a(merge_position.y,0,0,0);  

                    _stencil_val_a(merge_c,0,0,0); _stencil_val(ff5,0,0,0); 
                }
                

            
#line 2449
}

                  
    
#line 2450
}end_foreach_stencil();
        {
#line 2397
foreach(){
            val(merge_c,0,0,0) = 0;
            val(merge_position.x,0,0,0)=0;
            val(merge_position.y,0,0,0)=0;

                if(level==level_interface && (is_f_small_part(val(ff5,0,0,0)))){
                coord mixed;
                mixed.x=x,mixed.y=y;

              coord nn = mycs (point,ff5);
              coord pp;
              double alpha2 = line_alpha (val(ff5,0,0,0), nn);
              double area = line_length_center(nn,alpha2,&pp);
              if (metric_embed_factor)
                  area *= metric_embed_factor (point, pp);
              pp.x = pp.x*Delta + mixed.x;
              pp.y = pp.y*Delta + mixed.y;
              normalize(&nn);

                int pppx,pppy;
                double colinearity=0.0;
                {foreach_neighbor(1){
                 if(level==level_interface && (is_f_big_part(val(ff5,0,0,0)))){
                    coord pure;
                    pure.x = x, pure.y = y;
                    int ii=round((pure.x-mixed.x)/Delta);
                    int jj=round((pure.y-mixed.y)/Delta);
                    bool flag2;
                    flag2 = ((ii==0 && jj==-1) || (ii==1 && jj==0) || (ii==0 && jj==1) || (ii==-1 && jj==0));
                        if(flag2){
                            coord puretomixed;
                            puretomixed.x = pure.x - pp.x;
                            puretomixed.y = pure.y - pp.y;
                            double leng1 = sqrt(sq(puretomixed.x)+sq(puretomixed.y));
                            double colinearity_temp;
                            colinearity_temp = fabs(nn.x*puretomixed.x/leng1+nn.y*puretomixed.y/leng1);
                            if(colinearity<colinearity_temp){
                                colinearity = colinearity_temp;
                                pppx = ii;
                                pppy = jj;
                            }

                        }
                    }
                }end_foreach_neighbor()}
                if(colinearity>0){
                    val(merge_position.x,0,0,0) = pppx;
                    val(merge_position.y,0,0,0) = pppy;

                    val(merge_c,0,0,0) = val(ff5,0,0,0);
                }

            }
    }end_foreach();}

}






#line 1 "././poissonsolver.h"
#line 1 "./././poissonsolver.h"
extern scalar flux_lg_l,flux_lg_g;
extern scalar phase0Tgrad,phase1Tgrad;
extern scalar resl,resg,ress;




extern scalar T_modl,T_modg,aiml,aimg;
extern int maxl;

void get_flux_lg(scalar flux_lg_l1, scalar flux_lg_g1, scalar phase0Tgrad, scalar phase1Tgrad){
     foreach_stencil(){
        _stencil_val_a(flux_lg_l1,0,0,0);
        _stencil_val_a(flux_lg_g1,0,0,0);
{
_stencil_val(css_test3,0,0,0);{
_stencil_val(css_test,0,0,0); _stencil_val(css_test,0,0,0);{    

                            
                            
                            
                        if(1==1){      
                            
                             { 

_stencil_val(fss_test.x,0,0,0); _stencil_val(fss_test.x,1,0,0); 

                             
                            
#line 27
} 
#line 24
{ 

_stencil_val(fss_test.y,0,0,0); _stencil_val(fss_test.y,0,1,0); 

                             
                            
#line 27
}  
                             _stencil_mycs (point, css_test);     
                            _stencil_val(css_test,0,0,0);   
                              
                             
                             
                                    
                             _stencil_val(phase1Tgrad,0,0,0);     
                              
                             

                               
                             

                            
                             
                             
                             _stencil_val(css_test,0,0,0);
_stencil_val(css_test,0,0,0);{{  
                                 _stencil_val(merge_to_me_l_position.x,0,0,0);  
                                 _stencil_val(merge_to_me_l_position.y,0,0,0);
{ 
_stencil_val(css_test,o_stencil,o_stencil,0);
                                     
                                
#line 50
}
                                  
                            
#line 51
}{

                                {foreach_neighbor(1){    
                                     
                                        
                                    
                                    
                                    _stencil_val(merge_to_me_l_position.x,0,0,0); 
                                    _stencil_val(merge_to_me_l_position.y,0,0,0);
{
_stencil_val(css_test,0,0,0);
                                        
                                    
#line 62
}
                                          
                                
#line 63
}end_foreach_neighbor()}
                            }}
_stencil_val(Tl,0,0,0); 
                            
                             {{
                                _stencil_val_a(flux_lg_l1,0,0,0);  
                            }{
                                _stencil_val_a(flux_lg_l1,0,0,0);  
                            }}

                              
                        
#line 72
} 

                        
                        if(1==1){      
                            
                             { 

_stencil_val(fss_test2.x,0,0,0); _stencil_val(fss_test2.x,1,0,0); 

                                 
                            
#line 80
} 
#line 77
{ 

_stencil_val(fss_test2.y,0,0,0); _stencil_val(fss_test2.y,0,1,0); 

                                 
                            
#line 80
}  

                             _stencil_mycs (point, css_test2);      
                            
                            _stencil_val(css_test2,0,0,0);     
                             
                             
                                    

                            _stencil_val(phase0Tgrad,0,0,0);     
                               
                            

                               
                         

                        
                             
                             
                              _stencil_val(css_test2,0,0,0);
_stencil_val(css_test2,0,0,0);{{  
                                 _stencil_val(merge_to_me_g_position.x,0,0,0);  
                                 _stencil_val(merge_to_me_g_position.y,0,0,0);
{ 
_stencil_val(css_test2,o_stencil,o_stencil,0);
                                     
                                
#line 105
}
                                  
                            
#line 106
}{
                                {foreach_neighbor(1){    
                                     
                                        
                                    
                                    
                                    _stencil_val(merge_to_me_g_position.x,0,0,0); 
                                    _stencil_val(merge_to_me_g_position.y,0,0,0);
{
_stencil_val(css_test2,0,0,0);
                                        
                                    
#line 116
}
                                          
                                
#line 117
}end_foreach_neighbor()}
                            }}

_stencil_val(Tg,0,0,0); 
                            

                              
#line 121
{{
                                _stencil_val_a(flux_lg_g1,0,0,0);  
                            }{
                                _stencil_val_a(flux_lg_g1,0,0,0);  
                            }}
                               
                        
#line 126
}

                }
                     
        
#line 129
}
            
        
#line 130
}
        
    
#line 131
}end_foreach_stencil();
     {
#line 12
foreach(){
        val(flux_lg_l1,0,0,0)=0.0;
        val(flux_lg_g1,0,0,0)=0.0;
        if(level==level_interface){
            if(val(css_test3,0,0,0)<1.0){
                    if(val(css_test,0,0,0)>0 && val(css_test,0,0,0)<1.0){

                            double c1, e=0.0;
                            double c1_2,e_2=0.0;
                            double arealg=0.0;
                        if(1==1){
                            double mua = 0., fa = 0.;
                             {

                            fa += val(fss_test.x,0,0,0) + val(fss_test.x,1,0,0);
                            } 
#line 24
{

                            fa += val(fss_test.y,0,0,0) + val(fss_test.y,0,1,0);
                            }
                            coord nl = mycs (point, css_test);
                            double alphal = line_alpha (val(css_test,0,0,0), nl);
                            coord ppp;
                            arealg = line_length_center(nl,alphal,&ppp);
                            if (metric_embed_factor)
                                    arealg *= metric_embed_factor (point, ppp);
                            double gradl2 = val(phase1Tgrad,0,0,0);
                            mua = Tkl;
                            fa =1.0;

                            c1 = mua/(fa + 1e-30)*gradl2*arealg/Delta;
                            e = 0.0;

                            double limit;
                             coord coord_pa;
                             coord_pa.x=x,coord_pa.y=y;
                             double merge_plus_self_volume=val(css_test,0,0,0);
                            if(val(css_test,0,0,0)<0.5){
                                int ii = val(merge_to_me_l_position.x,0,0,0);
                                int jj = val(merge_to_me_l_position.y,0,0,0);
                                if(!(ii==0 && jj==0)){
                                    merge_plus_self_volume += val(css_test,ii,jj,0);
                                }
                            }else{

                                {foreach_neighbor(1){
                                    coord coord_child;
                                    coord_child.x = x, coord_child.y = y;
                                    int ii_real=round((coord_pa.x-coord_child.x)/Delta);
                                    int jj_real=round((coord_pa.y-coord_child.y)/Delta);
                                    int ii_aim=val(merge_to_me_l_position.x,0,0,0);
                                    int jj_aim=val(merge_to_me_l_position.y,0,0,0);
                                    if((!(ii_aim==0 && jj_aim==0)) && (ii_real==ii_aim && jj_real==jj_aim)){
                                        merge_plus_self_volume+=val(css_test,0,0,0);
                                    }
                                }end_foreach_neighbor()}
                            }
                            limit = Trhol*Tcpl*(Tsat00-val(Tl,0,0,0))*merge_plus_self_volume*max(1e-20,y)/dt;

                            if(sign(c1)==sign(limit) && true){
                                val(flux_lg_l1,0,0,0) = fabs(c1)<fabs(limit)?c1:limit;
                            }else{
                                val(flux_lg_l1,0,0,0) = c1;
                            }
                        }

                        double arealg2=0.0;
                        if(1==1){
                            double mua = 0., fa = 0.;
                             {

                                fa += val(fss_test2.x,0,0,0) + val(fss_test2.x,1,0,0);
                            } 
#line 77
{

                                fa += val(fss_test2.y,0,0,0) + val(fss_test2.y,0,1,0);
                            }

                            coord ng = mycs (point, css_test2);
                            coord ppp2;
                            double alphag = line_alpha (val(css_test2,0,0,0), ng);
                            arealg2 = line_length_center(ng,alphag,&ppp2);
                            if (metric_embed_factor)
                                    arealg2 *= metric_embed_factor (point, ppp2);

                            double gradg2 = -val(phase0Tgrad,0,0,0);
                            mua = Tkg;
                            fa= 1.0;

                            c1_2 = mua/(fa + 1e-30)*gradg2*arealg2/Delta;
                        e_2 = 0.0;

                        double limit;
                             coord coord_pa;
                             coord_pa.x=x,coord_pa.y=y;
                              double merge_plus_self_volume=val(css_test2,0,0,0);
                            if(val(css_test2,0,0,0)<0.5){
                                int ii = val(merge_to_me_g_position.x,0,0,0);
                                int jj = val(merge_to_me_g_position.y,0,0,0);
                                if(!(ii==0 && jj==0)){
                                    merge_plus_self_volume += val(css_test2,ii,jj,0);
                                }
                            }else{
                                {foreach_neighbor(1){
                                    coord coord_child;
                                    coord_child.x = x, coord_child.y = y;
                                    int ii_real=round((coord_pa.x-coord_child.x)/Delta);
                                    int jj_real=round((coord_pa.y-coord_child.y)/Delta);
                                    int ii_aim=val(merge_to_me_g_position.x,0,0,0);
                                    int jj_aim=val(merge_to_me_g_position.y,0,0,0);
                                    if((!(ii_aim==0 && jj_aim==0)) && (ii_real==ii_aim && jj_real==jj_aim)){
                                        merge_plus_self_volume+=val(css_test2,0,0,0);
                                    }
                                }end_foreach_neighbor()}
                            }

                             limit = Trhog*Tcpg*(Tsat00-val(Tg,0,0,0))*merge_plus_self_volume*max(1e-20,y)/dt;
                             if(sign(c1_2)==sign(limit) && true){
                                val(flux_lg_g1,0,0,0) = fabs(c1_2)<fabs(limit)?c1_2:limit;
                            }else{
                                val(flux_lg_g1,0,0,0) = c1_2;
                            }
                        }

                }
        }
        }
    }end_foreach();}
}


double max_function(double x, double y, double z) {
    if (x > y) {
        if (x > z) {
            return x;
        } else {
            return z;
        }
    } else {
        if (y > z) {
            return y;
        } else {
            return z;
        }
    }
}

void poisson_solver(scalar poisson_s, double percent_s,double percent_l,double percent_g){

int maxitt=2000,beta1=1.2;
int itt;
double T_tolerance = 1e-6;



if(maxl==11){
    T_tolerance = 1e-4;
}
get_solidsurfaceT();
Tgrad_leon((struct Tgradleon){ff,phase0Tgrad,phase1Tgrad,aiml,aimg});
get_flux_lg(flux_lg_l, flux_lg_g, phase0Tgrad, phase1Tgrad);


scalar  flux_s_6=new_scalar("flux_s_6"), flux_l_6=new_scalar("flux_l_6"), flux_g_6=new_scalar("flux_g_6");
foreach_stencil(){
    _stencil_val_a(flux_s_6,0,0,0);  
    _stencil_val_a(flux_l_6,0,0,0);  
    _stencil_val_a(flux_g_6,0,0,0);  
}end_foreach_stencil();
{
#line 168
foreach(){
    val(flux_s_6,0,0,0) = 0.0;
    val(flux_l_6,0,0,0) = 0.0;
    val(flux_g_6,0,0,0) = 0.0;
}end_foreach();}

foreach_stencil(){
_stencil_val(T_modl,0,0,0);{   

        _stencil_val(Ts,0,0,0);_stencil_val(aiml,0,0,0); 

        
_stencil_val(aiml,0,0,0); _stencil_val(Ts,0,0,0);_stencil_val(areasl,0,0,0); 
           
        
#line 181
_stencil_val_r(flux_s_6,0,0,0);      


         _stencil_val(Tl,0,0,0);_stencil_val(aiml,0,0,0); 

        
_stencil_val(aiml,0,0,0); _stencil_val(Tl,0,0,0);_stencil_val(areasl,0,0,0); 
          
        
#line 188
_stencil_val_r(flux_l_6,0,0,0);  
    }
_stencil_val(T_modg,0,0,0);{   

        _stencil_val(Ts,0,0,0);_stencil_val(aimg,0,0,0); 

        
_stencil_val(aimg,0,0,0); _stencil_val(Ts,0,0,0);_stencil_val(areasg,0,0,0); 
           
        
#line 196
_stencil_val_r(flux_s_6,0,0,0);      


         _stencil_val(Tg,0,0,0);_stencil_val(aimg,0,0,0); 

        
_stencil_val(aimg,0,0,0); _stencil_val(Tg,0,0,0);_stencil_val(areasg,0,0,0); 
         
        
#line 203
_stencil_val_r(flux_g_6,0,0,0);  
    }
    
    


#line 206
}end_foreach_stencil();

{
#line 174
foreach(){
    if(val(T_modl,0,0,0)==6){

        double limit_s = Trhos*Tcps*(val(aiml,0,0,0)-val(Ts,0,0,0))*1.0*max(1e-20,y)/dt;

        double value_s=0.0;
        value_s = (val(aiml,0,0,0) - val(Ts,0,0,0))/Delta*val(areasl,0,0,0)/Delta ;
        val(flux_s_6,0,0,0) += (fabs(value_s)<fabs(limit_s)?value_s:limit_s) ;


         double limit_l = Trhol*Tcpl*(val(aiml,0,0,0)-val(Tl,0,0,0))*1.0*max(1e-20,y)/dt;

        double value_l=0.0;
        value_l = (val(aiml,0,0,0) - val(Tl,0,0,0))/Delta*val(areasl,0,0,0)/Delta;
        val(flux_l_6,0,0,0) += (fabs(value_l)<fabs(limit_l)?value_l:limit_l);
    }
    if(val(T_modg,0,0,0)==6){

        double limit_s = Trhos*Tcps*(val(aimg,0,0,0)-val(Ts,0,0,0))*1.0*max(1e-20,y)/dt;

        double value_s=0.0;
        value_s = (val(aimg,0,0,0) - val(Ts,0,0,0))/Delta*val(areasg,0,0,0)/Delta ;
        val(flux_s_6,0,0,0) += (fabs(value_s)<fabs(limit_s)?value_s:limit_s) ;


         double limit_g = Trhog*Tcpg*(val(aimg,0,0,0)-val(Tg,0,0,0))*1.0*max(1e-20,y)/dt;

        double value_g=0.0;
        value_g =(val(aimg,0,0,0) - val(Tg,0,0,0))/Delta*val(areasg,0,0,0)/Delta;
        val(flux_g_6,0,0,0) += (fabs(value_g)<fabs(limit_g)?value_g:limit_g);
    }

}end_foreach();}

scalar  Ts_old=new_scalar("Ts_old"), Tl_old=new_scalar("Tl_old"), Tg_old=new_scalar("Tg_old");




foreach_stencil(){
    _stencil_val_a(Ts_old,0,0,0); _stencil_val(Ts,0,0,0); 
    _stencil_val_a(Tl_old,0,0,0); _stencil_val(Tl,0,0,0); 
    _stencil_val_a(Tg_old,0,0,0); _stencil_val(Tg,0,0,0); 
}end_foreach_stencil();




{
#line 213
foreach(){
    val(Ts_old,0,0,0) = val(Ts,0,0,0);
    val(Tl_old,0,0,0) = val(Tl,0,0,0);
    val(Tg_old,0,0,0) = val(Tg,0,0,0);
}end_foreach();}
_attribute[Ts_old.i].ff6 = css_test3;
_attribute[Ts_old.i].restriction = restriction_zero;
_attribute[Tl_old.i].ff6 = css_test;
_attribute[Tl_old.i].restriction = restriction_zero;
_attribute[Tg_old.i].ff6 = css_test2;
_attribute[Tg_old.i].restriction = restriction_zero;

_attribute[Ts_old.i].refine = _attribute[Ts_old.i].prolongation = refine_embed_linear_css_test3;
_attribute[Tl_old.i].refine = _attribute[Tl_old.i].prolongation = refine_embed_linear_css_test;
_attribute[Tg_old.i].refine = _attribute[Tg_old.i].prolongation = refine_embed_linear_css_test2;
boundary_internal ((scalar *)((scalar[]){Ts_old,Tl_old,Tg_old,{-1}}), "./././poissonsolver.h", 228);
restriction(((scalar[]){Ts_old,Tl_old,Tg_old,{-1}}));
for(itt=1;itt<=maxitt;itt++){

    foreach_stencil(){






_stencil_val(css_test3,0,0,0);{  

            _stencil_val(poisson_s,0,0,0); 
            _stencil_val(cm_css_test3,0,0,0); 
            _stencil_val(cm_css_test3,0,0,0);
{{
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
                     

_stencil_val(flux_l,0,0,0);_stencil_val(areasl,0,0,0); _stencil_val(flux_g,0,0,0);_stencil_val(areasg,0,0,0); _stencil_val(flux_s_6,0,0,0); 

                      
                      
                
#line 250
}

_stencil_val(css_test3,-1,0,0);{{ 
                            
_stencil_val(fm_fss_test3.x,0,0,0); 
                             _stencil_val(Ts,-1,0,0);
                              
                              
                        
#line 257
} {_stencil_val(css_test3,-1,0,0);{

_stencil_val(merge_to_me_s_c,-1,0,0);{  
                                 _stencil_val(merge_to_me_s_position.x,-1,0,0);  
                                 _stencil_val(merge_to_me_s_position.y,-1,0,0);
{ 

                                     
_stencil_val(flux_l,-1,0,0);_stencil_val(areasl,-1,0,0); _stencil_val(flux_g,-1,0,0);_stencil_val(areasg,-1,0,0);_stencil_val(poisson_s,-1,0,0); _stencil_val(flux_s_6,-1,0,0); 
                                        
                                      _stencil_val(cm_css_test3,-1,0,0);
                                      _stencil_val(cm_css_test3,-1,0,0);
                                      
                                
#line 269
}
                                  
                            
#line 270
}

                            
                        
#line 271
}}}


_stencil_val(css_test3,1,0,0);{{ 
                            
_stencil_val(fm_fss_test3.x,1,0,0); 
                             _stencil_val(Ts,1,0,0);
                              
                              
                        
#line 279
} {_stencil_val(css_test3,1,0,0);{

_stencil_val(merge_to_me_s_c,1,0,0);{  
                                 _stencil_val(merge_to_me_s_position.x,1,0,0);  
                                 _stencil_val(merge_to_me_s_position.y,1,0,0);
{ 

                                     
_stencil_val(flux_l,1,0,0);_stencil_val(areasl,1,0,0); _stencil_val(flux_g,1,0,0);_stencil_val(areasg,1,0,0);_stencil_val(poisson_s,1,0,0);_stencil_val(flux_s_6,1,0,0); 
                                       
                                      _stencil_val(cm_css_test3,1,0,0);
                                      _stencil_val(cm_css_test3,1,0,0);
                                      
                                
#line 291
}
                                  
                            
#line 292
}

                            
                        
#line 293
}}}


_stencil_val(css_test3,0,-1,0);{{ 
                            
_stencil_val(fm_fss_test3.y,0,0,0); 
                             _stencil_val(Ts,0,-1,0);
                              
                              
                        
#line 301
} {_stencil_val(css_test3,0,-1,0);{

_stencil_val(merge_to_me_s_c,0,-1,0);{  
                                 _stencil_val(merge_to_me_s_position.x,0,-1,0);  
                                 _stencil_val(merge_to_me_s_position.y,0,-1,0);
{ 

                                     
_stencil_val(flux_l,0,-1,0);_stencil_val(areasl,0,-1,0); _stencil_val(flux_g,0,-1,0);_stencil_val(areasg,0,-1,0);_stencil_val(poisson_s,0,-1,0); _stencil_val(flux_s_6,0,-1,0); 
                                        
                                      _stencil_val(cm_css_test3,0,-1,0);
                                      _stencil_val(cm_css_test3,0,-1,0);
                                      
                                
#line 313
}
                                  
                            
#line 314
}

                            
                        
#line 315
}}}


_stencil_val(css_test3,0,1,0);{{ 
                            
_stencil_val(fm_fss_test3.y,0,1,0); 
                             _stencil_val(Ts,0,1,0);
                              
                              
                        
#line 323
} {_stencil_val(css_test3,0,1,0);{

_stencil_val(merge_to_me_s_c,0,1,0);{  
                                 _stencil_val(merge_to_me_s_position.x,0,1,0);  
                                 _stencil_val(merge_to_me_s_position.y,0,1,0);
{ 

                                     
_stencil_val(flux_l,0,1,0);_stencil_val(areasl,0,1,0); _stencil_val(flux_g,0,1,0);_stencil_val(areasg,0,1,0);_stencil_val(poisson_s,0,1,0); _stencil_val(flux_s_6,0,1,0); 
                                       
                                      _stencil_val(cm_css_test3,0,1,0);
                                      _stencil_val(cm_css_test3,0,1,0);
                                      
                                
#line 335
}
                                  
                            
#line 336
}

                            
                        
#line 337
}}}
                 

                        


                        


                        


                        

            
#line 339
}{
_stencil_val(css_test3,0,0,0);{

                    {
_stencil_val(css_test3,-1,0,0);{ 
                           
_stencil_val(fm_fss_test3.x,0,0,0); 
                             _stencil_val(Ts,-1,0,0);
                              
                              
                        
#line 348
}

_stencil_val(css_test3,1,0,0);{ 
                            
_stencil_val(fm_fss_test3.x,1,0,0); 
                             _stencil_val(Ts,1,0,0);
                              
                              
                        
#line 355
}
                        

                        
                    
#line 356
}
#line 342
{
_stencil_val(css_test3,0,-1,0);{ 
                           
_stencil_val(fm_fss_test3.y,0,0,0); 
                             _stencil_val(Ts,0,-1,0);
                              
                              
                        
#line 348
}

_stencil_val(css_test3,0,1,0);{ 
                            
_stencil_val(fm_fss_test3.y,0,1,0); 
                             _stencil_val(Ts,0,1,0);
                              
                              
                        
#line 355
}
                        

                        
                    
#line 356
}
                }
                
            
#line 358
}}
            
            
#line 359
_stencil_val_a(Ts,0,0,0);_stencil_val(Ts_old,0,0,0);_stencil_val(Ts,0,0,0);    
        }






_stencil_val(css_test3,0,0,0); _stencil_val(css_test,0,0,0);{  
            _stencil_val(poisson_s,0,0,0); 
            _stencil_val(cm_css_test,0,0,0); 
            _stencil_val(cm_css_test,0,0,0);
{{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
                    

_stencil_val(flux_l,0,0,0);_stencil_val(areasl,0,0,0); _stencil_val(flux_l_6,0,0,0); 

                      
                      
                
#line 378
}

_stencil_val(css_test3,0,0,0);{
_stencil_val(css_test,0,0,0); _stencil_val(css_test,0,0,0);{ 


_stencil_val(flux_lg_l,0,0,0);


                         
                    
#line 385
}
                     
                
#line 386
}

_stencil_val(css_test3,-1,0,0);{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test,-1,0,0);{{ 
                                    
_stencil_val(fm_fss_test.x,0,0,0); 
                                     _stencil_val(Tl,-1,0,0);
                                      
                                      
                        
#line 394
}{

_stencil_val(merge_to_me_l_c,-1,0,0);{  
                                  _stencil_val(merge_to_me_l_position.x,-1,0,0);  
                                  _stencil_val(merge_to_me_l_position.y,-1,0,0);
{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test3,-1,0,0);{ 

                                            
_stencil_val(flux_l,-1,0,0);_stencil_val(areasl,-1,0,0);_stencil_val(poisson_s,-1,0,0); _stencil_val(flux_l_6,-1,0,0); 
                                                
                                              
                                        
#line 405
}

_stencil_val(css_test,-1,0,0); _stencil_val(css_test,-1,0,0);{ 

_stencil_val(flux_lg_l,-1,0,0);

                                                 
                                        
#line 410
}
_stencil_val(cm_css_test,-1,0,0);
                                         

                                         
                                          
#line 412
_stencil_val(cm_css_test,-1,0,0);
                                          
                                 
#line 413
}
                                   
                            
#line 414
}

                            
                        
#line 415
}}
                         
                    
#line 416
}


_stencil_val(css_test3,1,0,0);{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test,1,0,0);{{ 
                                    
_stencil_val(fm_fss_test.x,1,0,0); 
                                     _stencil_val(Tl,1,0,0);
                                      
                                      
                        
#line 425
}{

_stencil_val(merge_to_me_l_c,1,0,0);{  
                                  _stencil_val(merge_to_me_l_position.x,1,0,0);  
                                  _stencil_val(merge_to_me_l_position.y,1,0,0);
{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test3,1,0,0);{ 

                                            
_stencil_val(flux_l,1,0,0);_stencil_val(areasl,1,0,0);_stencil_val(poisson_s,1,0,0); _stencil_val(flux_l_6,1,0,0); 
                                               
                                              
                                        
#line 436
}

_stencil_val(css_test,1,0,0); _stencil_val(css_test,1,0,0);{ 

_stencil_val(flux_lg_l,1,0,0);

                                                 
                                        
#line 441
}
_stencil_val(cm_css_test,1,0,0);
                                         

                                         
                                          
#line 443
_stencil_val(cm_css_test,1,0,0);
                                          
                                 
#line 444
}
                                   
                            
#line 445
}

                            
                        
#line 446
}}
                         
                    
#line 447
}


_stencil_val(css_test3,0,-1,0);{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test,0,-1,0);{{ 
                                    
_stencil_val(fm_fss_test.y,0,0,0); 
                                     _stencil_val(Tl,0,-1,0);
                                      
                                      
                        
#line 456
}{

_stencil_val(merge_to_me_l_c,0,-1,0);{  
                                  _stencil_val(merge_to_me_l_position.x,0,-1,0);  
                                  _stencil_val(merge_to_me_l_position.y,0,-1,0);
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test3,0,-1,0);{ 

                                            
_stencil_val(flux_l,0,-1,0);_stencil_val(areasl,0,-1,0);_stencil_val(poisson_s,0,-1,0); _stencil_val(flux_l_6,0,-1,0); 
                                               
                                              
                                        
#line 467
}

_stencil_val(css_test,0,-1,0); _stencil_val(css_test,0,-1,0);{ 

_stencil_val(flux_lg_l,0,-1,0);

                                                 
                                        
#line 472
}
_stencil_val(cm_css_test,0,-1,0);
                                         

                                         
                                          
#line 474
_stencil_val(cm_css_test,0,-1,0);
                                          
                                 
#line 475
}
                                   
                            
#line 476
}

                            
                        
#line 477
}}
                         
                    
#line 478
}


_stencil_val(css_test3,0,1,0);{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test,0,1,0);{{ 
                                    
_stencil_val(fm_fss_test.y,0,1,0); 
                                     _stencil_val(Tl,0,1,0);
                                      
                                      
                        
#line 487
}{

_stencil_val(merge_to_me_l_c,0,1,0);{  
                                  _stencil_val(merge_to_me_l_position.x,0,1,0);  
                                  _stencil_val(merge_to_me_l_position.y,0,1,0);
{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test3,0,1,0);{ 

                                            
_stencil_val(flux_l,0,1,0);_stencil_val(areasl,0,1,0);_stencil_val(poisson_s,0,1,0); _stencil_val(flux_l_6,0,1,0); 
                                               
                                              
                                        
#line 498
}

_stencil_val(css_test,0,1,0); _stencil_val(css_test,0,1,0);{ 

_stencil_val(flux_lg_l,0,1,0);

                                                 
                                        
#line 503
}
_stencil_val(cm_css_test,0,1,0);
                                         

                                         
                                          
#line 505
_stencil_val(cm_css_test,0,1,0);
                                          
                                 
#line 506
}
                                   
                            
#line 507
}

                            
                        
#line 508
}}
                         
                    
#line 509
}

                 

                

                    


                   


                   


                   

            
#line 511
}{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test,0,0,0);{

                    {
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test,-1,0,0);{ 
                           
_stencil_val(fm_fss_test.x,0,0,0); 
                             _stencil_val(Tl,-1,0,0);
                              
                              
                        
#line 521
}

_stencil_val(css_test3,1,0,0); _stencil_val(css_test,1,0,0);{ 
                            
_stencil_val(fm_fss_test.x,1,0,0); 
                             _stencil_val(Tl,1,0,0);
                              
                              
                        
#line 528
}
                         

                         
                    
#line 529
}
#line 515
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test,0,-1,0);{ 
                           
_stencil_val(fm_fss_test.y,0,0,0); 
                             _stencil_val(Tl,0,-1,0);
                              
                              
                        
#line 521
}

_stencil_val(css_test3,0,1,0); _stencil_val(css_test,0,1,0);{ 
                            
_stencil_val(fm_fss_test.y,0,1,0); 
                             _stencil_val(Tl,0,1,0);
                              
                              
                        
#line 528
}
                         

                         
                    
#line 529
}
                }

                 
            
#line 531
}}
            
            
#line 532
_stencil_val_a(Tl,0,0,0);_stencil_val(Tl_old,0,0,0);_stencil_val(Tl,0,0,0);    
    }





_stencil_val(css_test3,0,0,0); _stencil_val(css_test2,0,0,0);{ 
            _stencil_val(poisson_s,0,0,0); 
            _stencil_val(cm_css_test2,0,0,0); 
            _stencil_val(cm_css_test2,0,0,0);
{{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
                    

_stencil_val(flux_g,0,0,0);_stencil_val(areasg,0,0,0); _stencil_val(flux_g_6,0,0,0); 

                      
                      
                
#line 550
}

_stencil_val(css_test3,0,0,0);{
_stencil_val(css_test2,0,0,0); _stencil_val(css_test2,0,0,0);{ 

_stencil_val(flux_lg_g,0,0,0);

                         
                    
#line 556
}
                     
                
#line 557
}

_stencil_val(css_test3,-1,0,0);{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test2,-1,0,0);{{ 
                                    
_stencil_val(fm_fss_test2.x,0,0,0); 
                                     _stencil_val(Tg,-1,0,0);
                                      
                                      
                        
#line 565
}{

_stencil_val(merge_to_me_g_c,-1,0,0);{  
                                  _stencil_val(merge_to_me_g_position.x,-1,0,0);  
                                  _stencil_val(merge_to_me_g_position.y,-1,0,0);
{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test3,-1,0,0);{ 

                                            
_stencil_val(flux_g,-1,0,0);_stencil_val(areasg,-1,0,0);_stencil_val(poisson_s,-1,0,0); _stencil_val(flux_g_6,-1,0,0); 
                                               
                                              
                                        
#line 576
}

_stencil_val(css_test2,-1,0,0); _stencil_val(css_test2,-1,0,0);{ 

_stencil_val(flux_lg_g,-1,0,0);

                                                 
                                        
#line 581
}
_stencil_val(cm_css_test2,-1,0,0);
                                         

                                         
                                          
#line 583
_stencil_val(cm_css_test2,-1,0,0);
                                          
                                 
#line 584
}
                                   
                            
#line 585
}

                            
                        
#line 586
}}
                         
                    
#line 587
}


_stencil_val(css_test3,1,0,0);{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test2,1,0,0);{{ 
                                    
_stencil_val(fm_fss_test2.x,1,0,0); 
                                     _stencil_val(Tg,1,0,0);
                                      
                                      
                        
#line 596
}{

_stencil_val(merge_to_me_g_c,1,0,0);{  
                                  _stencil_val(merge_to_me_g_position.x,1,0,0);  
                                  _stencil_val(merge_to_me_g_position.y,1,0,0);
{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test3,1,0,0);{ 

                                            
_stencil_val(flux_g,1,0,0);_stencil_val(areasg,1,0,0);_stencil_val(poisson_s,1,0,0); _stencil_val(flux_g_6,1,0,0); 
                                               
                                              
                                        
#line 607
}

_stencil_val(css_test2,1,0,0); _stencil_val(css_test2,1,0,0);{ 

_stencil_val(flux_lg_g,1,0,0);

                                                 
                                        
#line 612
}
_stencil_val(cm_css_test2,1,0,0);
                                         

                                         
                                           
#line 614
_stencil_val(cm_css_test2,1,0,0);
                                           
                                 
#line 615
}
                                   
                            
#line 616
}

                            
                        
#line 617
}}
                         
                    
#line 618
}


_stencil_val(css_test3,0,-1,0);{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test2,0,-1,0);{{ 
                                    
_stencil_val(fm_fss_test2.y,0,0,0); 
                                     _stencil_val(Tg,0,-1,0);
                                      
                                      
                        
#line 627
}{

_stencil_val(merge_to_me_g_c,0,-1,0);{  
                                  _stencil_val(merge_to_me_g_position.x,0,-1,0);  
                                  _stencil_val(merge_to_me_g_position.y,0,-1,0);
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test3,0,-1,0);{ 

                                            
_stencil_val(flux_g,0,-1,0);_stencil_val(areasg,0,-1,0);_stencil_val(poisson_s,0,-1,0); _stencil_val(flux_g_6,0,-1,0); 
                                               
                                              
                                        
#line 638
}

_stencil_val(css_test2,0,-1,0); _stencil_val(css_test2,0,-1,0);{ 

_stencil_val(flux_lg_g,0,-1,0);

                                                 
                                        
#line 643
}
_stencil_val(cm_css_test2,0,-1,0);
                                         

                                         
                                           
#line 645
_stencil_val(cm_css_test2,0,-1,0);
                                           
                                 
#line 646
}
                                   
                            
#line 647
}

                            
                        
#line 648
}}
                         
                    
#line 649
}


_stencil_val(css_test3,0,1,0);{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test2,0,1,0);{{ 
                                    
_stencil_val(fm_fss_test2.y,0,1,0); 
                                     _stencil_val(Tg,0,1,0);
                                      
                                      
                        
#line 658
}{

_stencil_val(merge_to_me_g_c,0,1,0);{  
                                  _stencil_val(merge_to_me_g_position.x,0,1,0);  
                                  _stencil_val(merge_to_me_g_position.y,0,1,0);
{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test3,0,1,0);{ 

                                            
_stencil_val(flux_g,0,1,0);_stencil_val(areasg,0,1,0);_stencil_val(poisson_s,0,1,0); _stencil_val(flux_g_6,0,1,0); 
                                               
                                              
                                        
#line 669
}

_stencil_val(css_test2,0,1,0); _stencil_val(css_test2,0,1,0);{ 

_stencil_val(flux_lg_g,0,1,0);

                                                 
                                        
#line 674
}
_stencil_val(cm_css_test2,0,1,0);
                                         

                                         
                                          
#line 676
_stencil_val(cm_css_test2,0,1,0);
                                          
                                 
#line 677
}
                                   
                            
#line 678
}

                            
                        
#line 679
}}
                         
                    
#line 680
}

                 

                

                    


                   


                   


                   

            
#line 682
}{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test2,0,0,0);{

                    {
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test2,-1,0,0);{ 
                           
_stencil_val(fm_fss_test2.x,0,0,0); 
                             _stencil_val(Tg,-1,0,0);
                              
                              
                        
#line 692
}

_stencil_val(css_test3,1,0,0); _stencil_val(css_test2,1,0,0);{ 
                            
_stencil_val(fm_fss_test2.x,1,0,0); 
                             _stencil_val(Tg,1,0,0);
                              
                              
                        
#line 699
}
                         

                         
                    
#line 700
}
#line 686
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test2,0,-1,0);{ 
                           
_stencil_val(fm_fss_test2.y,0,0,0); 
                             _stencil_val(Tg,0,-1,0);
                              
                              
                        
#line 692
}

_stencil_val(css_test3,0,1,0); _stencil_val(css_test2,0,1,0);{ 
                            
_stencil_val(fm_fss_test2.y,0,1,0); 
                             _stencil_val(Tg,0,1,0);
                              
                              
                        
#line 699
}
                         

                         
                    
#line 700
}
                }

                 
            
#line 702
}}
            
            
#line 703
_stencil_val_a(Tg,0,0,0);_stencil_val(Tg_old,0,0,0);_stencil_val(Tg,0,0,0);    
      }






        






        





        


#line 706
}end_foreach_stencil();

    {
#line 232
foreach(){






        if(val(css_test3,0,0,0)>=0.5){

            double total= percent_s*val(poisson_s,0,0,0);
            double A3=Trhos*Tcps/dt*val(cm_css_test3,0,0,0);
            double A4=Trhos*Tcps/dt*val(cm_css_test3,0,0,0);
            if(level==level_interface){
                if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                    double flux_i=0.0;

                    flux_i = val(flux_l,0,0,0)/Delta*val(areasl,0,0,0)/Delta + val(flux_g,0,0,0)/Delta*val(areasg,0,0,0)/Delta + val(flux_s_6,0,0,0);
                    total += flux_i;
                }

                        if(val(css_test3,-1,0,0)>=0.5){
                            double Al;
                            Al = Tks*val(fm_fss_test3.x,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,-1,0,0);
                            A3 += Al;
                        }else if(val(css_test3,-1,0,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,-1,0,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,-1,0,0);
                                int jj = val(merge_to_me_s_position.y,-1,0,0);
                                if((ii==1) && (jj==0)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,-1,0,0)/Delta*val(areasl,-1,0,0)/Delta + val(flux_g,-1,0,0)/Delta*val(areasg,-1,0,0)/Delta + percent_s*val(poisson_s,-1,0,0) + val(flux_s_6,-1,0,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,-1,0,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,-1,0,0);
                                }
                            }
                        }


                        if(val(css_test3,1,0,0)>=0.5){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.x,1,0,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,1,0,0);
                            A3 += Ar;
                        }else if(val(css_test3,1,0,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,1,0,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,1,0,0);
                                int jj = val(merge_to_me_s_position.y,1,0,0);
                                if((ii==-1) && (jj==0)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,1,0,0)/Delta*val(areasl,1,0,0)/Delta + val(flux_g,1,0,0)/Delta*val(areasg,1,0,0)/Delta + percent_s*val(poisson_s,1,0,0)+val(flux_s_6,1,0,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,1,0,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,1,0,0);
                                }
                            }
                        }


                        if(val(css_test3,0,-1,0)>=0.5){
                            double Al;
                            Al = Tks*val(fm_fss_test3.y,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,0,-1,0);
                            A3 += Al;
                        }else if(val(css_test3,0,-1,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,0,-1,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,0,-1,0);
                                int jj = val(merge_to_me_s_position.y,0,-1,0);
                                if((ii==0) && (jj==1)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,0,-1,0)/Delta*val(areasl,0,-1,0)/Delta + val(flux_g,0,-1,0)/Delta*val(areasg,0,-1,0)/Delta + percent_s*val(poisson_s,0,-1,0) + val(flux_s_6,0,-1,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,0,-1,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,0,-1,0);
                                }
                            }
                        }


                        if(val(css_test3,0,1,0)>=0.5){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.y,0,1,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,0,1,0);
                            A3 += Ar;
                        }else if(val(css_test3,0,1,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,0,1,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,0,1,0);
                                int jj = val(merge_to_me_s_position.y,0,1,0);
                                if((ii==0) && (jj==-1)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,0,1,0)/Delta*val(areasl,0,1,0)/Delta + val(flux_g,0,1,0)/Delta*val(areasg,0,1,0)/Delta + percent_s*val(poisson_s,0,1,0)+ val(flux_s_6,0,1,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,0,1,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,0,1,0);
                                }
                            }
                        }

            }else{
                if(val(css_test3,0,0,0)>=0.5){

                    {
                        if(val(css_test3,-1,0,0)>0.0){
                           double Al;
                            Al = Tks*val(fm_fss_test3.x,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,-1,0,0);
                            A3 += Al;
                        }

                        if(val(css_test3,1,0,0)>0.0){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.x,1,0,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,1,0,0);
                            A3 += Ar;
                        }
                    }
#line 342
{
                        if(val(css_test3,0,-1,0)>0.0){
                           double Al;
                            Al = Tks*val(fm_fss_test3.y,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,0,-1,0);
                            A3 += Al;
                        }

                        if(val(css_test3,0,1,0)>0.0){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.y,0,1,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,0,1,0);
                            A3 += Ar;
                        }
                    }
                }
            }
            val(Ts,0,0,0) = (total+A4*val(Ts_old,0,0,0))*beta1/A3 + (1.0-beta1)*val(Ts,0,0,0);
        }






       if(val(css_test3,0,0,0)<0.5 && val(css_test,0,0,0)>=0.5){
            double total_l= percent_l*val(poisson_s,0,0,0);
            double A3_l=Trhol*Tcpl/dt*val(cm_css_test,0,0,0);
            double A4_l=Trhol*Tcpl/dt*val(cm_css_test,0,0,0);
            if(level==level_interface){

                if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                    double flux_i=0.0;

                    flux_i = (-val(flux_l,0,0,0))/Delta*val(areasl,0,0,0)/Delta + val(flux_l_6,0,0,0);
                    total_l += flux_i;
                }

                if(val(css_test3,0,0,0)<1.0){
                    if(val(css_test,0,0,0)>0 && val(css_test,0,0,0)<1.0){


                        total_l += val(flux_lg_l,0,0,0);
                    }
                }

                    if(val(css_test3,-1,0,0)<1.0){
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test,-1,0,0)>=0.5){
                                    double Al;
                                    Al = Tkl*val(fm_fss_test.x,0,0,0)*1.0/(Delta*Delta);
                                    total_l += Al*val(Tl,-1,0,0);
                                    A3_l += Al;
                        }else{

                            if(fabs(val(merge_to_me_l_c,-1,0,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,-1,0,0);
                                 int jj = val(merge_to_me_l_position.y,-1,0,0);
                                 if((ii==1) && (jj==0)){
                                        if(val(css_test3,-1,0,0)<1.0 && val(css_test3,-1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,-1,0,0))/Delta*val(areasl,-1,0,0)/Delta + percent_l*val(poisson_s,-1,0,0) + val(flux_l_6,-1,0,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,-1,0,0)>0.0 && val(css_test,-1,0,0)<0.5){

                                                total_l += val(flux_lg_l,-1,0,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,-1,0,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,-1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,1,0,0)<1.0){
                        if(val(css_test3,1,0,0)<0.5 && val(css_test,1,0,0)>=0.5){
                                    double Ar;
                                    Ar = Tkl*val(fm_fss_test.x,1,0,0)*1.0/(Delta*Delta);
                                    total_l += Ar*val(Tl,1,0,0);
                                    A3_l += Ar;
                        }else{

                            if(fabs(val(merge_to_me_l_c,1,0,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,1,0,0);
                                 int jj = val(merge_to_me_l_position.y,1,0,0);
                                 if((ii==-1) && (jj==0)){
                                        if(val(css_test3,1,0,0)<1.0 && val(css_test3,1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,1,0,0))/Delta*val(areasl,1,0,0)/Delta + percent_l*val(poisson_s,1,0,0)+ val(flux_l_6,1,0,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,1,0,0)>0.0 && val(css_test,1,0,0)<0.5){

                                                total_l += val(flux_lg_l,1,0,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,1,0,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,-1,0)<1.0){
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test,0,-1,0)>=0.5){
                                    double Al;
                                    Al = Tkl*val(fm_fss_test.y,0,0,0)*1.0/(Delta*Delta);
                                    total_l += Al*val(Tl,0,-1,0);
                                    A3_l += Al;
                        }else{

                            if(fabs(val(merge_to_me_l_c,0,-1,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,0,-1,0);
                                 int jj = val(merge_to_me_l_position.y,0,-1,0);
                                 if((ii==0) && (jj==1)){
                                        if(val(css_test3,0,-1,0)<1.0 && val(css_test3,0,-1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,0,-1,0))/Delta*val(areasl,0,-1,0)/Delta + percent_l*val(poisson_s,0,-1,0)+ val(flux_l_6,0,-1,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,0,-1,0)>0.0 && val(css_test,0,-1,0)<0.5){

                                                total_l += val(flux_lg_l,0,-1,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,0,-1,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,0,-1,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,1,0)<1.0){
                        if(val(css_test3,0,1,0)<0.5 && val(css_test,0,1,0)>=0.5){
                                    double Ar;
                                    Ar = Tkl*val(fm_fss_test.y,0,1,0)*1.0/(Delta*Delta);
                                    total_l += Ar*val(Tl,0,1,0);
                                    A3_l += Ar;
                        }else{

                            if(fabs(val(merge_to_me_l_c,0,1,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,0,1,0);
                                 int jj = val(merge_to_me_l_position.y,0,1,0);
                                 if((ii==0) && (jj==-1)){
                                        if(val(css_test3,0,1,0)<1.0 && val(css_test3,0,1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,0,1,0))/Delta*val(areasl,0,1,0)/Delta + percent_l*val(poisson_s,0,1,0)+ val(flux_l_6,0,1,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,0,1,0)>0.0 && val(css_test,0,1,0)<0.5){

                                                total_l += val(flux_lg_l,0,1,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,0,1,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,0,1,0);
                                 }
                            }
                        }
                    }

            }else{

                if(val(css_test3,0,0,0)<0.5 && val(css_test,0,0,0)>=0.5){

                    {
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test,-1,0,0)>0.0){
                           double Al;
                            Al = Tkl*val(fm_fss_test.x,0,0,0)*1.0/(Delta*Delta);
                            total_l += Al*val(Tl,-1,0,0);
                            A3_l += Al;
                        }

                        if(val(css_test3,1,0,0)<0.5 && val(css_test,1,0,0)>0.0){
                            double Ar;
                            Ar = Tkl*val(fm_fss_test.x,1,0,0)*1.0/(Delta*Delta);
                            total_l += Ar*val(Tl,1,0,0);
                            A3_l += Ar;
                        }
                    }
#line 515
{
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test,0,-1,0)>0.0){
                           double Al;
                            Al = Tkl*val(fm_fss_test.y,0,0,0)*1.0/(Delta*Delta);
                            total_l += Al*val(Tl,0,-1,0);
                            A3_l += Al;
                        }

                        if(val(css_test3,0,1,0)<0.5 && val(css_test,0,1,0)>0.0){
                            double Ar;
                            Ar = Tkl*val(fm_fss_test.y,0,1,0)*1.0/(Delta*Delta);
                            total_l += Ar*val(Tl,0,1,0);
                            A3_l += Ar;
                        }
                    }
                }
            }
            val(Tl,0,0,0) = (total_l+A4_l*val(Tl_old,0,0,0))*beta1/A3_l + (1.0-beta1)*val(Tl,0,0,0);
    }





       if(val(css_test3,0,0,0)<0.5 && val(css_test2,0,0,0)>=0.5){
            double total_g=percent_g*val(poisson_s,0,0,0);
            double A3_g=Trhog*Tcpg/dt*val(cm_css_test2,0,0,0);
            double A4_g=Trhog*Tcpg/dt*val(cm_css_test2,0,0,0);
            if(level==level_interface){

                if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                    double flux_i=0.0;

                    flux_i = (-val(flux_g,0,0,0))/Delta*val(areasg,0,0,0)/Delta + val(flux_g_6,0,0,0);
                    total_g += flux_i;
                }

                if(val(css_test3,0,0,0)<1.0){
                    if(val(css_test2,0,0,0)>0 && val(css_test2,0,0,0)<1.0){

                        total_g += val(flux_lg_g,0,0,0);
                    }
                }

                    if(val(css_test3,-1,0,0)<1.0){
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test2,-1,0,0)>=0.5){
                                    double Al;
                                    Al = Tkg*val(fm_fss_test2.x,0,0,0)*1.0/(Delta*Delta);
                                    total_g += Al*val(Tg,-1,0,0);
                                    A3_g += Al;
                        }else{

                            if(fabs(val(merge_to_me_g_c,-1,0,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,-1,0,0);
                                 int jj = val(merge_to_me_g_position.y,-1,0,0);
                                 if((ii==1) && (jj==0)){
                                        if(val(css_test3,-1,0,0)<1.0 && val(css_test3,-1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,-1,0,0))/Delta*val(areasg,-1,0,0)/Delta + percent_g*val(poisson_s,-1,0,0)+ val(flux_g_6,-1,0,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,-1,0,0)>0.0 && val(css_test2,-1,0,0)<0.5){

                                                total_g += val(flux_lg_g,-1,0,0);
                                        }
                                        A3_g += Trhog*Tcpg/dt*val(cm_css_test2,-1,0,0);
                                        A4_g += Trhog*Tcpg/dt*val(cm_css_test2,-1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,1,0,0)<1.0){
                        if(val(css_test3,1,0,0)<0.5 && val(css_test2,1,0,0)>=0.5){
                                    double Ar;
                                    Ar = Tkg*val(fm_fss_test2.x,1,0,0)*1.0/(Delta*Delta);
                                    total_g += Ar*val(Tg,1,0,0);
                                    A3_g += Ar;
                        }else{

                            if(fabs(val(merge_to_me_g_c,1,0,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,1,0,0);
                                 int jj = val(merge_to_me_g_position.y,1,0,0);
                                 if((ii==-1) && (jj==0)){
                                        if(val(css_test3,1,0,0)<1.0 && val(css_test3,1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,1,0,0))/Delta*val(areasg,1,0,0)/Delta + percent_g*val(poisson_s,1,0,0)+ val(flux_g_6,1,0,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,1,0,0)>0.0 && val(css_test2,1,0,0)<0.5){

                                                total_g += val(flux_lg_g,1,0,0);
                                        }
                                         A3_g += Trhog*Tcpg/dt*val(cm_css_test2,1,0,0);
                                         A4_g += Trhog*Tcpg/dt*val(cm_css_test2,1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,-1,0)<1.0){
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test2,0,-1,0)>=0.5){
                                    double Al;
                                    Al = Tkg*val(fm_fss_test2.y,0,0,0)*1.0/(Delta*Delta);
                                    total_g += Al*val(Tg,0,-1,0);
                                    A3_g += Al;
                        }else{

                            if(fabs(val(merge_to_me_g_c,0,-1,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,0,-1,0);
                                 int jj = val(merge_to_me_g_position.y,0,-1,0);
                                 if((ii==0) && (jj==1)){
                                        if(val(css_test3,0,-1,0)<1.0 && val(css_test3,0,-1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,0,-1,0))/Delta*val(areasg,0,-1,0)/Delta + percent_g*val(poisson_s,0,-1,0)+ val(flux_g_6,0,-1,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,0,-1,0)>0.0 && val(css_test2,0,-1,0)<0.5){

                                                total_g += val(flux_lg_g,0,-1,0);
                                        }
                                         A3_g += Trhog*Tcpg/dt*val(cm_css_test2,0,-1,0);
                                         A4_g += Trhog*Tcpg/dt*val(cm_css_test2,0,-1,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,1,0)<1.0){
                        if(val(css_test3,0,1,0)<0.5 && val(css_test2,0,1,0)>=0.5){
                                    double Ar;
                                    Ar = Tkg*val(fm_fss_test2.y,0,1,0)*1.0/(Delta*Delta);
                                    total_g += Ar*val(Tg,0,1,0);
                                    A3_g += Ar;
                        }else{

                            if(fabs(val(merge_to_me_g_c,0,1,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,0,1,0);
                                 int jj = val(merge_to_me_g_position.y,0,1,0);
                                 if((ii==0) && (jj==-1)){
                                        if(val(css_test3,0,1,0)<1.0 && val(css_test3,0,1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,0,1,0))/Delta*val(areasg,0,1,0)/Delta + percent_g*val(poisson_s,0,1,0)+ val(flux_g_6,0,1,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,0,1,0)>0.0 && val(css_test2,0,1,0)<0.5){

                                                total_g += val(flux_lg_g,0,1,0);
                                        }
                                        A3_g += Trhog*Tcpg/dt*val(cm_css_test2,0,1,0);
                                        A4_g += Trhog*Tcpg/dt*val(cm_css_test2,0,1,0);
                                 }
                            }
                        }
                    }

            }else{

                if(val(css_test3,0,0,0)<0.5 && val(css_test2,0,0,0)>=0.5){

                    {
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test2,-1,0,0)>0.0){
                           double Al;
                            Al = Tkg*val(fm_fss_test2.x,0,0,0)*1.0/(Delta*Delta);
                            total_g += Al*val(Tg,-1,0,0);
                            A3_g += Al;
                        }

                        if(val(css_test3,1,0,0)<0.5 && val(css_test2,1,0,0)>0.0){
                            double Ar;
                            Ar = Tkg*val(fm_fss_test2.x,1,0,0)*1.0/(Delta*Delta);
                            total_g += Ar*val(Tg,1,0,0);
                            A3_g += Ar;
                        }
                    }
#line 686
{
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test2,0,-1,0)>0.0){
                           double Al;
                            Al = Tkg*val(fm_fss_test2.y,0,0,0)*1.0/(Delta*Delta);
                            total_g += Al*val(Tg,0,-1,0);
                            A3_g += Al;
                        }

                        if(val(css_test3,0,1,0)<0.5 && val(css_test2,0,1,0)>0.0){
                            double Ar;
                            Ar = Tkg*val(fm_fss_test2.y,0,1,0)*1.0/(Delta*Delta);
                            total_g += Ar*val(Tg,0,1,0);
                            A3_g += Ar;
                        }
                    }
                }
            }
            val(Tg,0,0,0) = (total_g+A4_g*val(Tg_old,0,0,0))*beta1/A3_g + (1.0-beta1)*val(Tg,0,0,0);
      }

}end_foreach();}

boundary_internal ((scalar *)((scalar[]){Tg,Tl,Ts,{-1}}), "./././poissonsolver.h", 708);
restriction(((scalar[]){Tg,Tl,Ts,{-1}}));



if(itt%1==0){
    double maxres_total=0.0;
    foreach_stencil(){   
        
        
        
_stencil_val(css_test3,0,0,0);{  

            _stencil_val(poisson_s,0,0,0); 
            _stencil_val(cm_css_test3,0,0,0); 
            _stencil_val(cm_css_test3,0,0,0);
{{
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
                     

_stencil_val(flux_l,0,0,0);_stencil_val(areasl,0,0,0); _stencil_val(flux_g,0,0,0);_stencil_val(areasg,0,0,0); _stencil_val(flux_s_6,0,0,0); 

                      
                      
                
#line 730
}

_stencil_val(css_test3,-1,0,0);{{ 
                            
_stencil_val(fm_fss_test3.x,0,0,0); 
                             _stencil_val(Ts,-1,0,0);
                              
                              
                        
#line 737
} {_stencil_val(css_test3,-1,0,0);{

_stencil_val(merge_to_me_s_c,-1,0,0);{  
                                 _stencil_val(merge_to_me_s_position.x,-1,0,0);  
                                 _stencil_val(merge_to_me_s_position.y,-1,0,0);
{ 

                                     
_stencil_val(flux_l,-1,0,0);_stencil_val(areasl,-1,0,0); _stencil_val(flux_g,-1,0,0);_stencil_val(areasg,-1,0,0);_stencil_val(poisson_s,-1,0,0); _stencil_val(flux_s_6,-1,0,0); 
                                       
                                      _stencil_val(cm_css_test3,-1,0,0);
                                      _stencil_val(cm_css_test3,-1,0,0);
                                      
                                
#line 749
}
                                  

                            
#line 751
}

                            
                        
#line 752
}}}


_stencil_val(css_test3,1,0,0);{{ 
                            
_stencil_val(fm_fss_test3.x,1,0,0); 
                             _stencil_val(Ts,1,0,0);
                              
                              
                        
#line 760
} {_stencil_val(css_test3,1,0,0);{

_stencil_val(merge_to_me_s_c,1,0,0);{  
                                 _stencil_val(merge_to_me_s_position.x,1,0,0);  
                                 _stencil_val(merge_to_me_s_position.y,1,0,0);
{ 

                                     
_stencil_val(flux_l,1,0,0);_stencil_val(areasl,1,0,0); _stencil_val(flux_g,1,0,0);_stencil_val(areasg,1,0,0);_stencil_val(poisson_s,1,0,0); _stencil_val(flux_s_6,1,0,0); 
                                       
                                      _stencil_val(cm_css_test3,1,0,0);
                                      _stencil_val(cm_css_test3,1,0,0);
                                      
                                
#line 772
}
                                  
                            
#line 773
}

                            
                        
#line 774
}}}


_stencil_val(css_test3,0,-1,0);{{ 
                            
_stencil_val(fm_fss_test3.y,0,0,0); 
                             _stencil_val(Ts,0,-1,0);
                              
                              
                        
#line 782
} {_stencil_val(css_test3,0,-1,0);{

_stencil_val(merge_to_me_s_c,0,-1,0);{  
                                 _stencil_val(merge_to_me_s_position.x,0,-1,0);  
                                 _stencil_val(merge_to_me_s_position.y,0,-1,0);
{ 

                                     
_stencil_val(flux_l,0,-1,0);_stencil_val(areasl,0,-1,0); _stencil_val(flux_g,0,-1,0);_stencil_val(areasg,0,-1,0);_stencil_val(poisson_s,0,-1,0); _stencil_val(flux_s_6,0,-1,0); 
                                        
                                      _stencil_val(cm_css_test3,0,-1,0);
                                      _stencil_val(cm_css_test3,0,-1,0);
                                      
                                
#line 794
}
                                  
                            
#line 795
}

                            
                        
#line 796
}}}


_stencil_val(css_test3,0,1,0);{{ 
                            
_stencil_val(fm_fss_test3.y,0,1,0); 
                             _stencil_val(Ts,0,1,0);
                              
                              
                        
#line 804
} {_stencil_val(css_test3,0,1,0);{

_stencil_val(merge_to_me_s_c,0,1,0);{  
                                 _stencil_val(merge_to_me_s_position.x,0,1,0);  
                                 _stencil_val(merge_to_me_s_position.y,0,1,0);
{ 

                                     
_stencil_val(flux_l,0,1,0);_stencil_val(areasl,0,1,0); _stencil_val(flux_g,0,1,0);_stencil_val(areasg,0,1,0);_stencil_val(poisson_s,0,1,0); _stencil_val(flux_s_6,0,1,0); 
                                       
                                      _stencil_val(cm_css_test3,0,1,0);
                                       _stencil_val(cm_css_test3,0,1,0);
                                       
                                
#line 816
}
                                  
                            
#line 817
}

                            
                        
#line 818
}}}
                 

                        


                        


                        


                        

            
#line 820
}{
_stencil_val(css_test3,0,0,0);{

                    {
_stencil_val(css_test3,-1,0,0);{ 
                           
_stencil_val(fm_fss_test3.x,0,0,0); 
                             _stencil_val(Ts,-1,0,0);
                              
                              
                        
#line 829
}

_stencil_val(css_test3,1,0,0);{ 
                            
_stencil_val(fm_fss_test3.x,1,0,0); 
                             _stencil_val(Ts,1,0,0);
                              
                              
                        
#line 836
}
                        

                        
                    
#line 837
}
#line 823
{
_stencil_val(css_test3,0,-1,0);{ 
                           
_stencil_val(fm_fss_test3.y,0,0,0); 
                             _stencil_val(Ts,0,-1,0);
                              
                              
                        
#line 829
}

_stencil_val(css_test3,0,1,0);{ 
                            
_stencil_val(fm_fss_test3.y,0,1,0); 
                             _stencil_val(Ts,0,1,0);
                              
                              
                        
#line 836
}
                        

                        
                    
#line 837
}
                }
                
            
#line 839
}}
            _stencil_val(Ts_old,0,0,0);_stencil_val(Ts,0,0,0); 
             
        
#line 841
}






_stencil_val(css_test3,0,0,0); _stencil_val(css_test,0,0,0);{  
            _stencil_val(poisson_s,0,0,0); 
            _stencil_val(cm_css_test,0,0,0); 
            _stencil_val(cm_css_test,0,0,0);
{{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
                    

_stencil_val(flux_l,0,0,0);_stencil_val(areasl,0,0,0); _stencil_val(flux_l_6,0,0,0); 

                      
                      
                
#line 859
}

_stencil_val(css_test3,0,0,0);{
_stencil_val(css_test,0,0,0); _stencil_val(css_test,0,0,0);{ 

_stencil_val(flux_lg_l,0,0,0);

                         
                    
#line 865
}
                     
                
#line 866
}

_stencil_val(css_test3,-1,0,0);{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test,-1,0,0);{{ 
                                    
_stencil_val(fm_fss_test.x,0,0,0); 
                                     _stencil_val(Tl,-1,0,0);
                                      
                                      
                        
#line 874
}{

_stencil_val(merge_to_me_l_c,-1,0,0);{  
                                  _stencil_val(merge_to_me_l_position.x,-1,0,0);  
                                  _stencil_val(merge_to_me_l_position.y,-1,0,0);
{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test3,-1,0,0);{ 

                                            
_stencil_val(flux_l,-1,0,0);_stencil_val(areasl,-1,0,0);_stencil_val(poisson_s,-1,0,0); _stencil_val(flux_l_6,-1,0,0); 
                                               
                                              
                                        
#line 885
}

_stencil_val(css_test,-1,0,0); _stencil_val(css_test,-1,0,0);{ 

_stencil_val(flux_lg_l,-1,0,0);

                                                 
                                        
#line 890
}
_stencil_val(cm_css_test,-1,0,0);
                                         

                                         
                                          
#line 892
_stencil_val(cm_css_test,-1,0,0);
                                          
                                 
#line 893
}
                                   
                            
#line 894
}

                            
                        
#line 895
}}
                         
                    
#line 896
}


_stencil_val(css_test3,1,0,0);{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test,1,0,0);{{ 
                                    
_stencil_val(fm_fss_test.x,1,0,0); 
                                     _stencil_val(Tl,1,0,0);
                                      
                                      
                        
#line 905
}{

_stencil_val(merge_to_me_l_c,1,0,0);{  
                                  _stencil_val(merge_to_me_l_position.x,1,0,0);  
                                  _stencil_val(merge_to_me_l_position.y,1,0,0);
{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test3,1,0,0);{ 

                                            
_stencil_val(flux_l,1,0,0);_stencil_val(areasl,1,0,0);_stencil_val(poisson_s,1,0,0); _stencil_val(flux_l_6,1,0,0); 
                                               
                                              
                                        
#line 916
}

_stencil_val(css_test,1,0,0); _stencil_val(css_test,1,0,0);{ 

_stencil_val(flux_lg_l,1,0,0);

                                                 
                                        
#line 921
}
_stencil_val(cm_css_test,1,0,0);
                                         

                                         
                                          
#line 923
_stencil_val(cm_css_test,1,0,0);
                                          

                                 
#line 925
}
                                   
                            
#line 926
}

                            
                        
#line 927
}}
                         
                    
#line 928
}


_stencil_val(css_test3,0,-1,0);{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test,0,-1,0);{{ 
                                    
_stencil_val(fm_fss_test.y,0,0,0); 
                                     _stencil_val(Tl,0,-1,0);
                                      
                                      
                        
#line 937
}{

_stencil_val(merge_to_me_l_c,0,-1,0);{  
                                  _stencil_val(merge_to_me_l_position.x,0,-1,0);  
                                  _stencil_val(merge_to_me_l_position.y,0,-1,0);
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test3,0,-1,0);{ 

                                            
_stencil_val(flux_l,0,-1,0);_stencil_val(areasl,0,-1,0);_stencil_val(poisson_s,0,-1,0); _stencil_val(flux_l_6,0,-1,0); 
                                               
                                              
                                        
#line 948
}

_stencil_val(css_test,0,-1,0); _stencil_val(css_test,0,-1,0);{ 

_stencil_val(flux_lg_l,0,-1,0);

                                                 
                                        
#line 953
}
_stencil_val(cm_css_test,0,-1,0);
                                         

                                         
                                          
#line 955
_stencil_val(cm_css_test,0,-1,0);
                                          
                                 
#line 956
}
                                   
                            
#line 957
}

                            
                        
#line 958
}}
                         
                    
#line 959
}


_stencil_val(css_test3,0,1,0);{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test,0,1,0);{{ 
                                    
_stencil_val(fm_fss_test.y,0,1,0); 
                                     _stencil_val(Tl,0,1,0);
                                      
                                      
                        
#line 968
}{

_stencil_val(merge_to_me_l_c,0,1,0);{  
                                  _stencil_val(merge_to_me_l_position.x,0,1,0);  
                                  _stencil_val(merge_to_me_l_position.y,0,1,0);
{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test3,0,1,0);{ 

                                            
_stencil_val(flux_l,0,1,0);_stencil_val(areasl,0,1,0);_stencil_val(poisson_s,0,1,0); _stencil_val(flux_l_6,0,1,0); 
                                               
                                              
                                        
#line 979
}

_stencil_val(css_test,0,1,0); _stencil_val(css_test,0,1,0);{ 

_stencil_val(flux_lg_l,0,1,0);

                                                 
                                        
#line 984
}
_stencil_val(cm_css_test,0,1,0);
                                         

                                         
                                           
#line 986
_stencil_val(cm_css_test,0,1,0);
                                           
                                 
#line 987
}
                                   
                            
#line 988
}

                            
                        
#line 989
}}
                         
                    
#line 990
}

                 

                

                    


                   


                   


                   

            
#line 992
}{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test,0,0,0);{

                    {
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test,-1,0,0);{ 
                           
_stencil_val(fm_fss_test.x,0,0,0); 
                             _stencil_val(Tl,-1,0,0);
                              
                              
                        
#line 1002
}

_stencil_val(css_test3,1,0,0); _stencil_val(css_test,1,0,0);{ 
                            
_stencil_val(fm_fss_test.x,1,0,0); 
                             _stencil_val(Tl,1,0,0);
                              
                              
                        
#line 1009
}
                         

                         
                    
#line 1010
}
#line 996
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test,0,-1,0);{ 
                           
_stencil_val(fm_fss_test.y,0,0,0); 
                             _stencil_val(Tl,0,-1,0);
                              
                              
                        
#line 1002
}

_stencil_val(css_test3,0,1,0); _stencil_val(css_test,0,1,0);{ 
                            
_stencil_val(fm_fss_test.y,0,1,0); 
                             _stencil_val(Tl,0,1,0);
                              
                              
                        
#line 1009
}
                         

                         
                    
#line 1010
}
                }

                 
            
#line 1012
}}
            
_stencil_val(Tl_old,0,0,0);_stencil_val(Tl,0,0,0); 

              
    
#line 1015
}





_stencil_val(css_test3,0,0,0); _stencil_val(css_test2,0,0,0);{  
            _stencil_val(poisson_s,0,0,0); 
            _stencil_val(cm_css_test2,0,0,0); 
            _stencil_val(cm_css_test2,0,0,0);
{{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{ 
                    

_stencil_val(flux_g,0,0,0);_stencil_val(areasg,0,0,0); _stencil_val(flux_g_6,0,0,0); 

                      
                      
                
#line 1032
}

_stencil_val(css_test3,0,0,0);{
_stencil_val(css_test2,0,0,0); _stencil_val(css_test2,0,0,0);{ 

_stencil_val(flux_lg_g,0,0,0);

                         
                    
#line 1038
}
                     
                
#line 1039
}

_stencil_val(css_test3,-1,0,0);{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test2,-1,0,0);{{ 
                                    
_stencil_val(fm_fss_test2.x,0,0,0); 
                                     _stencil_val(Tg,-1,0,0);
                                      
                                      
                        
#line 1047
}{

_stencil_val(merge_to_me_g_c,-1,0,0);{  
                                  _stencil_val(merge_to_me_g_position.x,-1,0,0);  
                                  _stencil_val(merge_to_me_g_position.y,-1,0,0);
{
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test3,-1,0,0);{ 

                                            
_stencil_val(flux_g,-1,0,0);_stencil_val(areasg,-1,0,0);_stencil_val(poisson_s,-1,0,0); _stencil_val(flux_g_6,-1,0,0); 
                                               
                                              
                                        
#line 1058
}

_stencil_val(css_test2,-1,0,0); _stencil_val(css_test2,-1,0,0);{ 

_stencil_val(flux_lg_g,-1,0,0);

                                                 
                                        
#line 1063
}
_stencil_val(cm_css_test2,-1,0,0);
                                         

                                         
                                          
#line 1065
_stencil_val(cm_css_test2,-1,0,0);
                                          
                                 
#line 1066
}
                                   
                            
#line 1067
}

                            
                        
#line 1068
}}
                         
                    
#line 1069
}


_stencil_val(css_test3,1,0,0);{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test2,1,0,0);{{ 
                                    
_stencil_val(fm_fss_test2.x,1,0,0); 
                                     _stencil_val(Tg,1,0,0);
                                      
                                      
                        
#line 1078
}{

_stencil_val(merge_to_me_g_c,1,0,0);{  
                                  _stencil_val(merge_to_me_g_position.x,1,0,0);  
                                  _stencil_val(merge_to_me_g_position.y,1,0,0);
{
_stencil_val(css_test3,1,0,0); _stencil_val(css_test3,1,0,0);{ 

                                            
_stencil_val(flux_g,1,0,0);_stencil_val(areasg,1,0,0);_stencil_val(poisson_s,1,0,0); _stencil_val(flux_g_6,1,0,0); 
                                               
                                              
                                        
#line 1089
}

_stencil_val(css_test2,1,0,0); _stencil_val(css_test2,1,0,0);{ 

_stencil_val(flux_lg_g,1,0,0);

                                                 
                                        
#line 1094
}
_stencil_val(cm_css_test2,1,0,0);
                                         

                                         
                                           
#line 1096
_stencil_val(cm_css_test2,1,0,0);
                                           
                                 
#line 1097
}
                                   
                            
#line 1098
}

                            
                        
#line 1099
}}
                         
                    
#line 1100
}


_stencil_val(css_test3,0,-1,0);{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test2,0,-1,0);{{ 
                                    
_stencil_val(fm_fss_test2.y,0,0,0); 
                                     _stencil_val(Tg,0,-1,0);
                                      
                                      
                        
#line 1109
}{

_stencil_val(merge_to_me_g_c,0,-1,0);{  
                                  _stencil_val(merge_to_me_g_position.x,0,-1,0);  
                                  _stencil_val(merge_to_me_g_position.y,0,-1,0);
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test3,0,-1,0);{ 

                                            
_stencil_val(flux_g,0,-1,0);_stencil_val(areasg,0,-1,0);_stencil_val(poisson_s,0,-1,0); _stencil_val(flux_g_6,0,-1,0); 
                                               
                                              
                                        
#line 1120
}

_stencil_val(css_test2,0,-1,0); _stencil_val(css_test2,0,-1,0);{ 

_stencil_val(flux_lg_g,0,-1,0);

                                                 
                                        
#line 1125
}
_stencil_val(cm_css_test2,0,-1,0);
                                         

                                         
                                          
#line 1127
_stencil_val(cm_css_test2,0,-1,0);
                                          
                                 
#line 1128
}
                                   
                            
#line 1129
}

                            
                        
#line 1130
}}
                         
                    
#line 1131
}


_stencil_val(css_test3,0,1,0);{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test2,0,1,0);{{ 
                                    
_stencil_val(fm_fss_test2.y,0,1,0); 
                                     _stencil_val(Tg,0,1,0);
                                      
                                      
                        
#line 1140
}{

_stencil_val(merge_to_me_g_c,0,1,0);{  
                                  _stencil_val(merge_to_me_g_position.x,0,1,0);  
                                  _stencil_val(merge_to_me_g_position.y,0,1,0);
{
_stencil_val(css_test3,0,1,0); _stencil_val(css_test3,0,1,0);{ 

                                            
_stencil_val(flux_g,0,1,0);_stencil_val(areasg,0,1,0);_stencil_val(poisson_s,0,1,0); _stencil_val(flux_g_6,0,1,0); 
                                               
                                              
                                        
#line 1151
}

_stencil_val(css_test2,0,1,0); _stencil_val(css_test2,0,1,0);{ 

_stencil_val(flux_lg_g,0,1,0);

                                                 
                                        
#line 1156
}
_stencil_val(cm_css_test2,0,1,0);
                                         

                                         
                                          
#line 1158
_stencil_val(cm_css_test2,0,1,0);
                                          
                                 
#line 1159
}
                                   
                            
#line 1160
}

                            
                        
#line 1161
}}
                         
                    
#line 1162
}

                 

                

                    


                   


                   


                   

            
#line 1164
}{

_stencil_val(css_test3,0,0,0); _stencil_val(css_test2,0,0,0);{

                    {
_stencil_val(css_test3,-1,0,0); _stencil_val(css_test2,-1,0,0);{ 
                           
_stencil_val(fm_fss_test2.x,0,0,0); 
                             _stencil_val(Tg,-1,0,0);
                              
                              
                        
#line 1174
}

_stencil_val(css_test3,1,0,0); _stencil_val(css_test2,1,0,0);{ 
                            
_stencil_val(fm_fss_test2.x,1,0,0); 
                             _stencil_val(Tg,1,0,0);
                              
                              
                        
#line 1181
}
                         

                         
                    
#line 1182
}
#line 1168
{
_stencil_val(css_test3,0,-1,0); _stencil_val(css_test2,0,-1,0);{ 
                           
_stencil_val(fm_fss_test2.y,0,0,0); 
                             _stencil_val(Tg,0,-1,0);
                              
                              
                        
#line 1174
}

_stencil_val(css_test3,0,1,0); _stencil_val(css_test2,0,1,0);{ 
                            
_stencil_val(fm_fss_test2.y,0,1,0); 
                             _stencil_val(Tg,0,1,0);
                              
                              
                        
#line 1181
}
                         

                         
                    
#line 1182
}
                }

                 
            
#line 1184
}}
            
_stencil_val(Tg_old,0,0,0);_stencil_val(Tg,0,0,0); 

              
        
#line 1187
}
        






        





        
        
#line 1188
_stencil_val_a(resl,0,0,0);  
        _stencil_val_a(resg,0,0,0);  
        _stencil_val_a(ress,0,0,0);   
         

    }end_foreach_stencil();
    
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxres_total)){
#line 715
foreach(){
        double maxres_s=0.0;
        double maxres_l=0.0;
        double maxres_g=0.0;
        if(val(css_test3,0,0,0)>=0.5){

            double total= percent_s*val(poisson_s,0,0,0);
            double A3=Trhos*Tcps/dt*val(cm_css_test3,0,0,0);
            double A4=Trhos*Tcps/dt*val(cm_css_test3,0,0,0);
            if(level==level_interface){
                if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                    double flux_i=0.0;

                    flux_i = val(flux_l,0,0,0)/Delta*val(areasl,0,0,0)/Delta + val(flux_g,0,0,0)/Delta*val(areasg,0,0,0)/Delta + val(flux_s_6,0,0,0);
                    total += flux_i;
                }

                        if(val(css_test3,-1,0,0)>=0.5){
                            double Al;
                            Al = Tks*val(fm_fss_test3.x,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,-1,0,0);
                            A3 += Al;
                        }else if(val(css_test3,-1,0,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,-1,0,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,-1,0,0);
                                int jj = val(merge_to_me_s_position.y,-1,0,0);
                                if((ii==1) && (jj==0)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,-1,0,0)/Delta*val(areasl,-1,0,0)/Delta + val(flux_g,-1,0,0)/Delta*val(areasg,-1,0,0)/Delta + percent_s*val(poisson_s,-1,0,0)+ val(flux_s_6,-1,0,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,-1,0,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,-1,0,0);
                                }

                            }
                        }


                        if(val(css_test3,1,0,0)>=0.5){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.x,1,0,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,1,0,0);
                            A3 += Ar;
                        }else if(val(css_test3,1,0,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,1,0,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,1,0,0);
                                int jj = val(merge_to_me_s_position.y,1,0,0);
                                if((ii==-1) && (jj==0)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,1,0,0)/Delta*val(areasl,1,0,0)/Delta + val(flux_g,1,0,0)/Delta*val(areasg,1,0,0)/Delta + percent_s*val(poisson_s,1,0,0)+ val(flux_s_6,1,0,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,1,0,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,1,0,0);
                                }
                            }
                        }


                        if(val(css_test3,0,-1,0)>=0.5){
                            double Al;
                            Al = Tks*val(fm_fss_test3.y,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,0,-1,0);
                            A3 += Al;
                        }else if(val(css_test3,0,-1,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,0,-1,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,0,-1,0);
                                int jj = val(merge_to_me_s_position.y,0,-1,0);
                                if((ii==0) && (jj==1)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,0,-1,0)/Delta*val(areasl,0,-1,0)/Delta + val(flux_g,0,-1,0)/Delta*val(areasg,0,-1,0)/Delta + percent_s*val(poisson_s,0,-1,0) + val(flux_s_6,0,-1,0);
                                    total += flux_i;
                                    A3 += Trhos*Tcps/dt*val(cm_css_test3,0,-1,0);
                                    A4 += Trhos*Tcps/dt*val(cm_css_test3,0,-1,0);
                                }
                            }
                        }


                        if(val(css_test3,0,1,0)>=0.5){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.y,0,1,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,0,1,0);
                            A3 += Ar;
                        }else if(val(css_test3,0,1,0)>0.0){

                            if(fabs(val(merge_to_me_s_c,0,1,0))>1e-12){
                                int ii = val(merge_to_me_s_position.x,0,1,0);
                                int jj = val(merge_to_me_s_position.y,0,1,0);
                                if((ii==0) && (jj==-1)){

                                    double flux_i=0.0;
                                    flux_i = val(flux_l,0,1,0)/Delta*val(areasl,0,1,0)/Delta + val(flux_g,0,1,0)/Delta*val(areasg,0,1,0)/Delta + percent_s*val(poisson_s,0,1,0)+ val(flux_s_6,0,1,0);
                                    total += flux_i;
                                     A3 += Trhos*Tcps/dt*val(cm_css_test3,0,1,0);
                                     A4 += Trhos*Tcps/dt*val(cm_css_test3,0,1,0);
                                }
                            }
                        }

            }else{
                if(val(css_test3,0,0,0)>=0.5){

                    {
                        if(val(css_test3,-1,0,0)>0.0){
                           double Al;
                            Al = Tks*val(fm_fss_test3.x,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,-1,0,0);
                            A3 += Al;
                        }

                        if(val(css_test3,1,0,0)>0.0){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.x,1,0,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,1,0,0);
                            A3 += Ar;
                        }
                    }
#line 823
{
                        if(val(css_test3,0,-1,0)>0.0){
                           double Al;
                            Al = Tks*val(fm_fss_test3.y,0,0,0)*1.0/(Delta*Delta);
                            total += Al*val(Ts,0,-1,0);
                            A3 += Al;
                        }

                        if(val(css_test3,0,1,0)>0.0){
                            double Ar;
                            Ar = Tks*val(fm_fss_test3.y,0,1,0)*1.0/(Delta*Delta);
                            total += Ar*val(Ts,0,1,0);
                            A3 += Ar;
                        }
                    }
                }
            }
            maxres_s = fabs(total+A4*val(Ts_old,0,0,0)-A3*val(Ts,0,0,0));
        }






       if(val(css_test3,0,0,0)<0.5 && val(css_test,0,0,0)>=0.5){
            double total_l= percent_l*val(poisson_s,0,0,0);
            double A3_l=Trhol*Tcpl/dt*val(cm_css_test,0,0,0);
            double A4_l=Trhol*Tcpl/dt*val(cm_css_test,0,0,0);
            if(level==level_interface){

                if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                    double flux_i=0.0;

                    flux_i = (-val(flux_l,0,0,0))/Delta*val(areasl,0,0,0)/Delta + val(flux_l_6,0,0,0);
                    total_l += flux_i;
                }

                if(val(css_test3,0,0,0)<1.0){
                    if(val(css_test,0,0,0)>0 && val(css_test,0,0,0)<1.0){

                        total_l += val(flux_lg_l,0,0,0);
                    }
                }

                    if(val(css_test3,-1,0,0)<1.0){
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test,-1,0,0)>=0.5){
                                    double Al;
                                    Al = Tkl*val(fm_fss_test.x,0,0,0)*1.0/(Delta*Delta);
                                    total_l += Al*val(Tl,-1,0,0);
                                    A3_l += Al;
                        }else{

                            if(fabs(val(merge_to_me_l_c,-1,0,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,-1,0,0);
                                 int jj = val(merge_to_me_l_position.y,-1,0,0);
                                 if((ii==1) && (jj==0)){
                                        if(val(css_test3,-1,0,0)<1.0 && val(css_test3,-1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,-1,0,0))/Delta*val(areasl,-1,0,0)/Delta + percent_l*val(poisson_s,-1,0,0)+ val(flux_l_6,-1,0,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,-1,0,0)>0.0 && val(css_test,-1,0,0)<0.5){

                                                total_l += val(flux_lg_l,-1,0,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,-1,0,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,-1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,1,0,0)<1.0){
                        if(val(css_test3,1,0,0)<0.5 && val(css_test,1,0,0)>=0.5){
                                    double Ar;
                                    Ar = Tkl*val(fm_fss_test.x,1,0,0)*1.0/(Delta*Delta);
                                    total_l += Ar*val(Tl,1,0,0);
                                    A3_l += Ar;
                        }else{

                            if(fabs(val(merge_to_me_l_c,1,0,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,1,0,0);
                                 int jj = val(merge_to_me_l_position.y,1,0,0);
                                 if((ii==-1) && (jj==0)){
                                        if(val(css_test3,1,0,0)<1.0 && val(css_test3,1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,1,0,0))/Delta*val(areasl,1,0,0)/Delta + percent_l*val(poisson_s,1,0,0)+ val(flux_l_6,1,0,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,1,0,0)>0.0 && val(css_test,1,0,0)<0.5){

                                                total_l += val(flux_lg_l,1,0,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,1,0,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,1,0,0);

                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,-1,0)<1.0){
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test,0,-1,0)>=0.5){
                                    double Al;
                                    Al = Tkl*val(fm_fss_test.y,0,0,0)*1.0/(Delta*Delta);
                                    total_l += Al*val(Tl,0,-1,0);
                                    A3_l += Al;
                        }else{

                            if(fabs(val(merge_to_me_l_c,0,-1,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,0,-1,0);
                                 int jj = val(merge_to_me_l_position.y,0,-1,0);
                                 if((ii==0) && (jj==1)){
                                        if(val(css_test3,0,-1,0)<1.0 && val(css_test3,0,-1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,0,-1,0))/Delta*val(areasl,0,-1,0)/Delta + percent_l*val(poisson_s,0,-1,0)+ val(flux_l_6,0,-1,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,0,-1,0)>0.0 && val(css_test,0,-1,0)<0.5){

                                                total_l += val(flux_lg_l,0,-1,0);
                                        }
                                        A3_l += Trhol*Tcpl/dt*val(cm_css_test,0,-1,0);
                                        A4_l += Trhol*Tcpl/dt*val(cm_css_test,0,-1,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,1,0)<1.0){
                        if(val(css_test3,0,1,0)<0.5 && val(css_test,0,1,0)>=0.5){
                                    double Ar;
                                    Ar = Tkl*val(fm_fss_test.y,0,1,0)*1.0/(Delta*Delta);
                                    total_l += Ar*val(Tl,0,1,0);
                                    A3_l += Ar;
                        }else{

                            if(fabs(val(merge_to_me_l_c,0,1,0))>1e-12){
                                 int ii = val(merge_to_me_l_position.x,0,1,0);
                                 int jj = val(merge_to_me_l_position.y,0,1,0);
                                 if((ii==0) && (jj==-1)){
                                        if(val(css_test3,0,1,0)<1.0 && val(css_test3,0,1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_l,0,1,0))/Delta*val(areasl,0,1,0)/Delta + percent_l*val(poisson_s,0,1,0)+ val(flux_l_6,0,1,0);
                                            total_l += flux_i;
                                        }

                                        if(val(css_test,0,1,0)>0.0 && val(css_test,0,1,0)<0.5){

                                                total_l += val(flux_lg_l,0,1,0);
                                        }
                                         A3_l += Trhol*Tcpl/dt*val(cm_css_test,0,1,0);
                                         A4_l += Trhol*Tcpl/dt*val(cm_css_test,0,1,0);
                                 }
                            }
                        }
                    }

            }else{

                if(val(css_test3,0,0,0)<0.5 && val(css_test,0,0,0)>=0.5){

                    {
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test,-1,0,0)>0.0){
                           double Al;
                            Al = Tkl*val(fm_fss_test.x,0,0,0)*1.0/(Delta*Delta);
                            total_l += Al*val(Tl,-1,0,0);
                            A3_l += Al;
                        }

                        if(val(css_test3,1,0,0)<0.5 && val(css_test,1,0,0)>0.0){
                            double Ar;
                            Ar = Tkl*val(fm_fss_test.x,1,0,0)*1.0/(Delta*Delta);
                            total_l += Ar*val(Tl,1,0,0);
                            A3_l += Ar;
                        }
                    }
#line 996
{
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test,0,-1,0)>0.0){
                           double Al;
                            Al = Tkl*val(fm_fss_test.y,0,0,0)*1.0/(Delta*Delta);
                            total_l += Al*val(Tl,0,-1,0);
                            A3_l += Al;
                        }

                        if(val(css_test3,0,1,0)<0.5 && val(css_test,0,1,0)>0.0){
                            double Ar;
                            Ar = Tkl*val(fm_fss_test.y,0,1,0)*1.0/(Delta*Delta);
                            total_l += Ar*val(Tl,0,1,0);
                            A3_l += Ar;
                        }
                    }
                }
            }

             maxres_l = fabs(total_l+A4_l*val(Tl_old,0,0,0)-A3_l*val(Tl,0,0,0));
    }





       if(val(css_test3,0,0,0)<0.5 && val(css_test2,0,0,0)>=0.5){
            double total_g= percent_g*val(poisson_s,0,0,0);
            double A3_g=Trhog*Tcpg/dt*val(cm_css_test2,0,0,0);
            double A4_g=Trhog*Tcpg/dt*val(cm_css_test2,0,0,0);
            if(level==level_interface){

                if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
                    double flux_i=0.0;

                    flux_i = (-val(flux_g,0,0,0))/Delta*val(areasg,0,0,0)/Delta + val(flux_g_6,0,0,0);
                    total_g += flux_i;
                }

                if(val(css_test3,0,0,0)<1.0){
                    if(val(css_test2,0,0,0)>0 && val(css_test2,0,0,0)<1.0){

                        total_g += val(flux_lg_g,0,0,0);
                    }
                }

                    if(val(css_test3,-1,0,0)<1.0){
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test2,-1,0,0)>=0.5){
                                    double Al;
                                    Al = Tkg*val(fm_fss_test2.x,0,0,0)*1.0/(Delta*Delta);
                                    total_g += Al*val(Tg,-1,0,0);
                                    A3_g += Al;
                        }else{

                            if(fabs(val(merge_to_me_g_c,-1,0,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,-1,0,0);
                                 int jj = val(merge_to_me_g_position.y,-1,0,0);
                                 if((ii==1) && (jj==0)){
                                        if(val(css_test3,-1,0,0)<1.0 && val(css_test3,-1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,-1,0,0))/Delta*val(areasg,-1,0,0)/Delta + percent_g*val(poisson_s,-1,0,0)+ val(flux_g_6,-1,0,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,-1,0,0)>0.0 && val(css_test2,-1,0,0)<0.5){

                                                total_g += val(flux_lg_g,-1,0,0);
                                        }
                                        A3_g += Trhog*Tcpg/dt*val(cm_css_test2,-1,0,0);
                                        A4_g += Trhog*Tcpg/dt*val(cm_css_test2,-1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,1,0,0)<1.0){
                        if(val(css_test3,1,0,0)<0.5 && val(css_test2,1,0,0)>=0.5){
                                    double Ar;
                                    Ar = Tkg*val(fm_fss_test2.x,1,0,0)*1.0/(Delta*Delta);
                                    total_g += Ar*val(Tg,1,0,0);
                                    A3_g += Ar;
                        }else{

                            if(fabs(val(merge_to_me_g_c,1,0,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,1,0,0);
                                 int jj = val(merge_to_me_g_position.y,1,0,0);
                                 if((ii==-1) && (jj==0)){
                                        if(val(css_test3,1,0,0)<1.0 && val(css_test3,1,0,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,1,0,0))/Delta*val(areasg,1,0,0)/Delta + percent_g*val(poisson_s,1,0,0)+ val(flux_g_6,1,0,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,1,0,0)>0.0 && val(css_test2,1,0,0)<0.5){

                                                total_g += val(flux_lg_g,1,0,0);
                                        }
                                         A3_g += Trhog*Tcpg/dt*val(cm_css_test2,1,0,0);
                                         A4_g += Trhog*Tcpg/dt*val(cm_css_test2,1,0,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,-1,0)<1.0){
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test2,0,-1,0)>=0.5){
                                    double Al;
                                    Al = Tkg*val(fm_fss_test2.y,0,0,0)*1.0/(Delta*Delta);
                                    total_g += Al*val(Tg,0,-1,0);
                                    A3_g += Al;
                        }else{

                            if(fabs(val(merge_to_me_g_c,0,-1,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,0,-1,0);
                                 int jj = val(merge_to_me_g_position.y,0,-1,0);
                                 if((ii==0) && (jj==1)){
                                        if(val(css_test3,0,-1,0)<1.0 && val(css_test3,0,-1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,0,-1,0))/Delta*val(areasg,0,-1,0)/Delta + percent_g*val(poisson_s,0,-1,0)+ val(flux_g_6,0,-1,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,0,-1,0)>0.0 && val(css_test2,0,-1,0)<0.5){

                                                total_g += val(flux_lg_g,0,-1,0);
                                        }
                                        A3_g += Trhog*Tcpg/dt*val(cm_css_test2,0,-1,0);
                                        A4_g += Trhog*Tcpg/dt*val(cm_css_test2,0,-1,0);
                                 }
                            }
                        }
                    }


                   if(val(css_test3,0,1,0)<1.0){
                        if(val(css_test3,0,1,0)<0.5 && val(css_test2,0,1,0)>=0.5){
                                    double Ar;
                                    Ar = Tkg*val(fm_fss_test2.y,0,1,0)*1.0/(Delta*Delta);
                                    total_g += Ar*val(Tg,0,1,0);
                                    A3_g += Ar;
                        }else{

                            if(fabs(val(merge_to_me_g_c,0,1,0))>1e-12){
                                 int ii = val(merge_to_me_g_position.x,0,1,0);
                                 int jj = val(merge_to_me_g_position.y,0,1,0);
                                 if((ii==0) && (jj==-1)){
                                        if(val(css_test3,0,1,0)<1.0 && val(css_test3,0,1,0)>0.5){

                                            double flux_i=0.0;
                                            flux_i = (-val(flux_g,0,1,0))/Delta*val(areasg,0,1,0)/Delta + percent_g*val(poisson_s,0,1,0)+ val(flux_g_6,0,1,0);
                                            total_g += flux_i;
                                        }

                                        if(val(css_test2,0,1,0)>0.0 && val(css_test2,0,1,0)<0.5){

                                                total_g += val(flux_lg_g,0,1,0);
                                        }
                                        A3_g += Trhog*Tcpg/dt*val(cm_css_test2,0,1,0);
                                        A4_g += Trhog*Tcpg/dt*val(cm_css_test2,0,1,0);
                                 }
                            }
                        }
                    }

            }else{

                if(val(css_test3,0,0,0)<0.5 && val(css_test2,0,0,0)>=0.5){

                    {
                        if(val(css_test3,-1,0,0)<0.5 && val(css_test2,-1,0,0)>0.0){
                           double Al;
                            Al = Tkg*val(fm_fss_test2.x,0,0,0)*1.0/(Delta*Delta);
                            total_g += Al*val(Tg,-1,0,0);
                            A3_g += Al;
                        }

                        if(val(css_test3,1,0,0)<0.5 && val(css_test2,1,0,0)>0.0){
                            double Ar;
                            Ar = Tkg*val(fm_fss_test2.x,1,0,0)*1.0/(Delta*Delta);
                            total_g += Ar*val(Tg,1,0,0);
                            A3_g += Ar;
                        }
                    }
#line 1168
{
                        if(val(css_test3,0,-1,0)<0.5 && val(css_test2,0,-1,0)>0.0){
                           double Al;
                            Al = Tkg*val(fm_fss_test2.y,0,0,0)*1.0/(Delta*Delta);
                            total_g += Al*val(Tg,0,-1,0);
                            A3_g += Al;
                        }

                        if(val(css_test3,0,1,0)<0.5 && val(css_test2,0,1,0)>0.0){
                            double Ar;
                            Ar = Tkg*val(fm_fss_test2.y,0,1,0)*1.0/(Delta*Delta);
                            total_g += Ar*val(Tg,0,1,0);
                            A3_g += Ar;
                        }
                    }
                }
            }

             maxres_g = fabs(total_g+A4_g*val(Tg_old,0,0,0)-A3_g*val(Tg,0,0,0));
        }
        val(resl,0,0,0) = maxres_l;
        val(resg,0,0,0) = maxres_g;
        val(ress,0,0,0) = maxres_s;
        maxres_total = max_function(maxres_s/(Trhos*Tcps),maxres_l/(Trhol*Tcpl),maxres_g/(Trhog*Tcpg));

    }end_foreach();mpi_all_reduce_array(&maxres_total,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}


#line 1195
if(poisson_check){
      if(pid()==0){
            char name93[80];
            sprintf(name93,"poisson_check.dat");
            FILE * fp93 = fopen(name93,"a");
            int num2=0;
              fprintf (fp93," %g\n", maxres_total);
            fclose(fp93);
      }
  }

   if (maxres_total<T_tolerance){
            if(pid()==0){
                printf("max_total=%g ,itt=%d step\n",maxres_total,itt);
            }
        break;
   }

      boundary_internal ((scalar *)((scalar[]){Ts,Tl,Tg,{-1}}), "./././poissonsolver.h", 1213);
}


    }
    if(pid()==0){
        printf("3T itt=%d step\n",itt);
    }

if(poisson_check){
      if(pid()==0){
            char name93[80];
            sprintf(name93,"poisson_check.dat");
            FILE * fp93 = fopen(name93,"a");
            int num2=0;
              fprintf (fp93," \n \n \n");
            fclose(fp93);
      }
  }delete((scalar*)((scalar[]){Tg_old,Tl_old,Ts_old,flux_g_6,flux_l_6,flux_s_6,{-1}}));

}
#line 2460 "././getsolid.h"

void solver_new(scalar poisson_s,double percent_s,double percent_l,double percent_g){


      bool flag=false;
      merge_get_c_position(flag, css_test3,merge_to_me_s_c,merge_to_me_s_position);
      merge_get_c_position(flag, css_test,merge_to_me_l_c,merge_to_me_l_position);

      merge_get_c_position(flag, css_test2,merge_to_me_g_c,merge_to_me_g_position);
#line 2492 "././getsolid.h"
foreach_stencil(){
_stencil_val(merge_to_me_s_c,0,0,0);{ 
        
_stencil_val(merge_to_me_s_position.x,0,0,0); 
        _stencil_val(merge_to_me_s_position.y,0,0,0); 
       
       
#line 2497
_stencil_val_a(Ts,0,0,0); _stencil_val(Ts,o_stencil,o_stencil,0); 
   }
   

#line 2499
}end_foreach_stencil();
#line 2492 "././getsolid.h"
{foreach(){
   if(fabs(val(merge_to_me_s_c,0,0,0))>1e-7){
       int ii,jj;
       ii = val(merge_to_me_s_position.x,0,0,0);
       jj = val(merge_to_me_s_position.y,0,0,0);
       val(Ts,0,0,0) = val(Ts,ii,jj,0);
   }
}end_foreach();}

foreach_stencil(){
_stencil_val(merge_to_me_l_c,0,0,0);{ 
        
_stencil_val(merge_to_me_l_position.x,0,0,0); 
        _stencil_val(merge_to_me_l_position.y,0,0,0); 
       
       
#line 2506
_stencil_val_a(Tl,0,0,0); _stencil_val(Tl,o_stencil,o_stencil,0); 
   }
   

#line 2508
}end_foreach_stencil();

{
#line 2501
foreach(){
   if(fabs(val(merge_to_me_l_c,0,0,0))>1e-7){
       int ii,jj;
       ii = val(merge_to_me_l_position.x,0,0,0);
       jj = val(merge_to_me_l_position.y,0,0,0);
       val(Tl,0,0,0) = val(Tl,ii,jj,0);
   }
}end_foreach();}

foreach_stencil(){
_stencil_val(merge_to_me_g_c,0,0,0);{ 
        
_stencil_val(merge_to_me_g_position.x,0,0,0); 
        _stencil_val(merge_to_me_g_position.y,0,0,0); 
       
       
#line 2515
_stencil_val_a(Tg,0,0,0); _stencil_val(Tg,o_stencil,o_stencil,0); 
   }
   

#line 2517
}end_foreach_stencil();

{
#line 2510
foreach(){
   if(fabs(val(merge_to_me_g_c,0,0,0))>1e-7){
       int ii,jj;
       ii = val(merge_to_me_g_position.x,0,0,0);
       jj = val(merge_to_me_g_position.y,0,0,0);
       val(Tg,0,0,0) = val(Tg,ii,jj,0);
   }
}end_foreach();}


_attribute[Ts.i].ff6 = css_test3;
_attribute[Ts.i].restriction = restriction_zero;
_attribute[Tl.i].ff6 = css_test;
_attribute[Tl.i].restriction = restriction_zero;
_attribute[Tg.i].ff6 = css_test2;
_attribute[Tg.i].restriction = restriction_zero;

_attribute[Ts.i].refine = _attribute[Ts.i].prolongation = refine_embed_linear_css_test3;
_attribute[Tl.i].refine = _attribute[Tl.i].prolongation = refine_embed_linear_css_test;
_attribute[Tg.i].refine = _attribute[Tg.i].prolongation = refine_embed_linear_css_test2;


restriction(((scalar[]){Ts,Tl,Tg,{-1}}));


poisson_solver(poisson_s,percent_s,percent_l,percent_g);

}
#line 2549 "././getsolid.h"
#line 1 "././line9-4-4-for-basilisk-css-test.h"
#line 1 "./././line9-4-4-for-basilisk-css-test.h"






#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdio.h"
#include <stdio.h>
#line 8 "./././line9-4-4-for-basilisk-css-test.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdlib.h"
#include <stdlib.h>
#line 9 "./././line9-4-4-for-basilisk-css-test.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/math.h"
#include <math.h>
#line 10 "./././line9-4-4-for-basilisk-css-test.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdbool.h"
#include <stdbool.h>
#line 11 "./././line9-4-4-for-basilisk-css-test.h"
#line 20 "./././line9-4-4-for-basilisk-css-test.h"
struct Pointt;
struct Edge;
struct Surface;
struct Line;
struct EdgeVector;


typedef struct Pointt {
    int number;
    double coordinates[2];
    struct Edge** edges;
    int edge_count;
    struct Surface** surfaces;
    int surface_count;
} Pointt;

typedef struct Edge {
    int number;
    Pointt* start_pointt;
    Pointt* end_pointt;
    double length;
    struct Surface** surfaces;
    int surface_count;
    int type;
} Edge;

typedef struct Surface {
    int number;
    Edge** edges;
    int edge_count;
    Pointt** pointts;
    int pointt_count;
    double area;
    int cut_count;
    int pointts_reordered;
    int type;
} Surface;


typedef struct {
    int number;
    double a;
    double b;
    double c;
    double normal[2];
} Line;

typedef struct {
    Edge** data;
    int size;
    int capacity;
} EdgeVector;

typedef struct {
    Surface** data;
    int size;
    int capacity;
} SurfaceVector;



typedef struct {
    Pointt* intersection_pointt;
    Edge* associated_edge;
} IntersectionInfo;


Pointt** all_pointts = NULL;
int pointt_count = 0;

Edge** all_edges = NULL;
int edge_count = 0;

Surface** all_surfaces = NULL;
int surface_count = 0;

Line** all_lines = NULL;
int line_count = 0;

double centroid[2];


int get_next_id(int* existing_ids, int count);
void add_edge_to_pointt(Pointt *pointt, Edge *edge);
void add_surface_to_list(Surface ***surfaces, int *count, Surface *surface);

Pointt* Pointt_create(double x, double y);
Edge* Edge_create(Pointt* start_pointt, Pointt* end_pointt);
Surface* Surface_create(Edge** edges, int edge_count, Pointt** pointts, int pointt_count, int ordered);
double Surface_calculate_area(Surface* surface);


const char* SurfaceType_to_string(int type);

void Pointt_print(Pointt* pointt);
void Edge_print(Edge* edge);
void Surface_print(Surface* surface);
void Pointt_belongs_to_print(Pointt* pointt);
void Edge_belongs_to_print(Edge* edge);

double polar_angle(Pointt* pointt, double centroid_x, double centroid_y);

int compare_pointts(const void* a, const void* b);
void Surface_reorder_pointts(Surface* surface);
EdgeVector* init_edge_vector(int initial_capacity);
void add_edge_to_vector(EdgeVector* vec, Edge* edge);
SurfaceVector* init_surface_vector(int initial_capacity);
void add_surface_to_vector(SurfaceVector* vec, Surface* surface);


Line* Line_create(int number, double a, double b, double c);
void Line_print(Line* line);
double Line_at(Line* line, double x, double y, int flag);


bool are_parallel(double a, double b, double x1, double y1, double x2, double y2);
Pointt** intersect(Line* line, Edge* edge);
void create_edges_from_pointts(Pointt** pointts, int pointts_length, EdgeVector* own_edges, EdgeVector* overlap_edges);
void cut_surface(Surface* original_surface, Line* cutting_line, SurfaceVector* new_surfaces);
void cut_surfaces(SurfaceVector* surfaces, Line* cutting_line, SurfaceVector* new_surfaces);
void SurfaceVector_print(SurfaceVector* surfaceVector);




int Pointt_above_line(double pointt_coordinates[2], Line* line);
void Surface_get_center(Surface* surface, double center_coordinates[2]);
void Surface_get_type(Surface* surface, Line* line1, Line* line2);
void Surface_get_type_3_cut(Surface* surface, Line* line1, Line* line2, Line* line3);


int Pointt_on_line(Pointt* pointt, Pointt* line_start, Pointt* line_end);

int Edge_on(Edge* edge1, Edge* edge2);
void Edge_get_type(Edge* edge, EdgeVector* square_edges, SurfaceVector* surfaces_input);



void free_all_pointts(Pointt** all_pointts, int pointt_count);
void free_all_edges(Edge** all_edges, int edge_count);
void free_all_surfaces(Surface** all_surfaces, int surface_count);
void free_all_lines(Line** all_lines, int line_count);
void free_all_resources();

void line_intersection_range(coord n1, double* c_min, double* c_max);




int cut_line_test_in_basilisk(coord n1,double c1,coord n2,double c2, double* data2) {
    double a1 = n1.x;
    double b1 = n1.y;
    double a2 = n2.x;
    double b2 = n2.y;





all_pointts = NULL;
pointt_count = 0;

all_edges = NULL;
edge_count = 0;

all_surfaces = NULL;
surface_count = 0;

all_lines = NULL;
line_count = 0;


double css_test2_value=0.0;
double css_test_value=0.0;
double arealg_value=0.0;
double areasl_value=0.0;
double areasg_value=0.0;
double fss_test_small_x=0.0;
double fss_test_small_y=0.0;
double fss_test_big_x=0.0;
double fss_test_big_y=0.0;
double fss_test2_small_x=0.0;
double fss_test2_small_y=0.0;
double fss_test2_big_x=0.0;
double fss_test2_big_y=0.0;

    Pointt* p1 = Pointt_create(0.0, 0.0);

    Pointt* p2 = Pointt_create(1.0, 0.0);

    Pointt* p3 = Pointt_create(0.0, 1.0);

    Pointt* p4 = Pointt_create(1.0, 1.0);
#line 224 "./././line9-4-4-for-basilisk-css-test.h"
    Edge* e1 = Edge_create(p1, p2);
    Edge* e2 = Edge_create(p2, p4);
    Edge* e3 = Edge_create(p4, p3);
    Edge* e4 = Edge_create(p3, p1);
#line 237 "./././line9-4-4-for-basilisk-css-test.h"
    Edge* edges[] = {e1, e2, e3, e4};
    Pointt* pointts[] = {p1, p2, p4, p3};

    Surface* s1 = Surface_create(edges, 4, pointts, 4, 0);
#line 251 "./././line9-4-4-for-basilisk-css-test.h"
    Line* line1 = Line_create(1, a1, b1, c1);





    if (false){
        EdgeVector* own_edges = init_edge_vector(10);
        EdgeVector* overlap_edges = init_edge_vector(10);;

        Pointt* pointts_test[3];
        pointts_test[0] = p2;
        pointts_test[1] = p4;
        pointts_test[2] = p3;
        create_edges_from_pointts(pointts_test, 3, own_edges, overlap_edges);




        pfree(own_edges->data,__func__,__FILE__,__LINE__);
        pfree(own_edges,__func__,__FILE__,__LINE__);
        pfree(overlap_edges->data,__func__,__FILE__,__LINE__);
        pfree(overlap_edges,__func__,__FILE__,__LINE__);
    }


   if(false){
        SurfaceVector* new_surfaces = init_surface_vector(2);
        cut_surface(s1, line1, new_surfaces);
#line 289 "./././line9-4-4-for-basilisk-css-test.h"
        for (int i = 0; i < new_surfaces->size; ++i) {

            Surface_print(new_surfaces->data[i]);
#line 302 "./././line9-4-4-for-basilisk-css-test.h"
         }




        pfree(new_surfaces->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces,__func__,__FILE__,__LINE__);
   }


   if(false){
        SurfaceVector* new_surfaces1 = init_surface_vector(2);
        cut_surface(s1, line1, new_surfaces1);
#line 342 "./././line9-4-4-for-basilisk-css-test.h"
        Line* line2 = Line_create(2, 1.0, 0, -0.4);

        SurfaceVector* new_surfaces2 = init_surface_vector(2);
        cut_surfaces(new_surfaces1, line2, new_surfaces2);




        Line* line3 = Line_create(3, 0, 1.0, -0.4);

        SurfaceVector* new_surfaces3 = init_surface_vector(2);
        cut_surfaces(new_surfaces2, line3, new_surfaces3);
#line 367 "./././line9-4-4-for-basilisk-css-test.h"
        pfree(new_surfaces1->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces1,__func__,__FILE__,__LINE__);
        pfree(new_surfaces2->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces2,__func__,__FILE__,__LINE__);
        pfree(new_surfaces3->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces3,__func__,__FILE__,__LINE__);
   }


    if(true){
        SurfaceVector* new_surfaces1 = init_surface_vector(2);
        cut_surface(s1, line1, new_surfaces1);


        Line* line2 = Line_create(2, a2, b2, c2);

        SurfaceVector* new_surfaces2 = init_surface_vector(2);
        cut_surfaces(new_surfaces1, line2, new_surfaces2);

        for(int i=0;i<new_surfaces2->size;++i){
            Surface_get_type(new_surfaces2->data[i], line1, line2);
        }

        EdgeVector* square_edges = init_edge_vector(4);
        add_edge_to_vector(square_edges,e4);
        add_edge_to_vector(square_edges,e2);
        add_edge_to_vector(square_edges,e1);
        add_edge_to_vector(square_edges,e3);

        for (int i=0;i<new_surfaces2->size;++i) {
            for (int ii=0;ii<new_surfaces2->data[i]->edge_count;++ii){
                Edge_get_type(new_surfaces2->data[i]->edges[ii], square_edges, new_surfaces2);

            }
        }
#line 410 "./././line9-4-4-for-basilisk-css-test.h"
        for (int i=0;i<new_surfaces2->size;++i) {
            int type_temp = new_surfaces2->data[i]->type;
            if(type_temp == 1){
                css_test2_value = new_surfaces2->data[i]->area;
            }else if(type_temp == 2){
                css_test_value = new_surfaces2->data[i]->area;
            }
        }
#line 442 "./././line9-4-4-for-basilisk-css-test.h"
         for (int i=0;i<new_surfaces2->size;++i) {
            for (int ii=0;ii<new_surfaces2->data[i]->edge_count;++ii){

                int type_temp = new_surfaces2->data[i]->edges[ii]->type;
                double length_temp = new_surfaces2->data[i]->edges[ii]->length;
                if(type_temp==1){
                    arealg_value = length_temp;
                }
                if(type_temp==2){
                    areasg_value = length_temp;
                }
                if(type_temp==5){
                    areasl_value = length_temp;
                }



                if(type_temp==7){
                    fss_test2_small_x = length_temp;
                }else if(type_temp==8){
                    fss_test2_big_x = length_temp;
                }else if(type_temp==9){
                    fss_test2_small_y = length_temp;
                }else if(type_temp==10){
                    fss_test2_big_y = length_temp;
                }


                if(type_temp==11){
                    fss_test_small_x = length_temp;
                }else if(type_temp==12){
                    fss_test_big_x = length_temp;
                }else if(type_temp==13){
                    fss_test_small_y = length_temp;
                }else if(type_temp==14){
                    fss_test_big_y = length_temp;
                }


            }
        }

    data2[0]=css_test2_value;
    data2[1]=css_test_value;
    data2[2]=arealg_value;
    data2[3]=areasl_value;
    data2[4]=areasg_value;
    data2[5]=fss_test_small_x;
    data2[6]=fss_test_small_y;
    data2[7]=fss_test_big_x;
    data2[8]=fss_test_big_y;
    data2[9]=fss_test2_small_x;
    data2[10]=fss_test2_small_y;
    data2[11]=fss_test2_big_x;
    data2[12]=fss_test2_big_y;

        pfree(new_surfaces1->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces1,__func__,__FILE__,__LINE__);
        pfree(new_surfaces2->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces2,__func__,__FILE__,__LINE__);
        pfree(square_edges->data,__func__,__FILE__,__LINE__);
        pfree(square_edges,__func__,__FILE__,__LINE__);

    }
#line 515 "./././line9-4-4-for-basilisk-css-test.h"
    free_all_resources();
    all_pointts = NULL;
    pointt_count = 0;

    all_edges = NULL;
    edge_count = 0;

    all_surfaces = NULL;
    surface_count = 0;

    all_lines = NULL;
    line_count = 0;
    return 0;
}





int cut_line_test_in_basilisk_3_times(coord n1 ,double c1,coord n2,double c2 ,
coord n3,double c3, double* moving_liquid,double* moving_gas ) {

    double a1 = n1.x;
    double b1 = n1.y;
    double a2 = n2.x;
    double b2 = n2.y;
    double a3 = n3.x;
    double b3 = n3.y;
*moving_liquid = 0.0;
*moving_gas = 0.0;





all_pointts = NULL;
pointt_count = 0;

all_edges = NULL;
edge_count = 0;

all_surfaces = NULL;
surface_count = 0;

all_lines = NULL;
line_count = 0;


double css_test2_value=0.0;
double css_test_value=0.0;
double arealg_value=0.0;
double areasl_value=0.0;
double areasg_value=0.0;
double fss_test_small_x=0.0;
double fss_test_small_y=0.0;
double fss_test_big_x=0.0;
double fss_test_big_y=0.0;
double fss_test2_small_x=0.0;
double fss_test2_small_y=0.0;
double fss_test2_big_x=0.0;
double fss_test2_big_y=0.0;

    Pointt* p1 = Pointt_create(0.0, 0.0);

    Pointt* p2 = Pointt_create(1.0, 0.0);

    Pointt* p3 = Pointt_create(0.0, 1.0);

    Pointt* p4 = Pointt_create(1.0, 1.0);
#line 595 "./././line9-4-4-for-basilisk-css-test.h"
    Edge* e1 = Edge_create(p1, p2);
    Edge* e2 = Edge_create(p2, p4);
    Edge* e3 = Edge_create(p4, p3);
    Edge* e4 = Edge_create(p3, p1);
#line 608 "./././line9-4-4-for-basilisk-css-test.h"
    Edge* edges[] = {e1, e2, e3, e4};
    Pointt* pointts[] = {p1, p2, p4, p3};

    Surface* s1 = Surface_create(edges, 4, pointts, 4, 0);
#line 622 "./././line9-4-4-for-basilisk-css-test.h"
    Line* line1 = Line_create(1, a1, b1, c1);




    if(true){
        SurfaceVector* new_surfaces1 = init_surface_vector(2);
        cut_surface(s1, line1, new_surfaces1);


        Line* line2 = Line_create(2, a2, b2, c2);

        Line* line3 = Line_create(3, a3, b3, c3);

        SurfaceVector* new_surfaces2 = init_surface_vector(2);
        cut_surfaces(new_surfaces1, line2, new_surfaces2);
        SurfaceVector* new_surfaces3 = init_surface_vector(2);
        cut_surfaces(new_surfaces2, line3, new_surfaces3);

        for(int i=0;i<new_surfaces3->size;++i){
            Surface_get_type_3_cut(new_surfaces3->data[i], line1, line2, line3);
        }





        double temp1=0.0;
        double temp2=0.0;
        for (int i=0;i<new_surfaces3->size;++i) {
            int type_temp = new_surfaces3->data[i]->type;
            if(type_temp == 1){
                temp1 = new_surfaces3->data[i]->area;
            }else if(type_temp == 2){
                temp2 = new_surfaces3->data[i]->area;
            }
        }
        *moving_gas = temp1;
        *moving_liquid = temp2;

        pfree(new_surfaces1->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces1,__func__,__FILE__,__LINE__);
        pfree(new_surfaces2->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces2,__func__,__FILE__,__LINE__);
        pfree(new_surfaces3->data,__func__,__FILE__,__LINE__);
        pfree(new_surfaces3,__func__,__FILE__,__LINE__);



    }
#line 683 "./././line9-4-4-for-basilisk-css-test.h"
    free_all_resources();
    all_pointts = NULL;
    pointt_count = 0;

    all_edges = NULL;
    edge_count = 0;

    all_surfaces = NULL;
    surface_count = 0;

    all_lines = NULL;
    line_count = 0;
    return 0;
}


int get_next_id(int* existing_ids, int count) {
    int id = 1;
    while (1) {
        int found = 0;
        for (int i = 0; i < count; ++i) {
            if (existing_ids[i] == id) {
                found = 1;
                break;
            }
        }
        if (!found) return id;
        id++;
    }
}

void add_edge_to_pointt(Pointt *pointt, Edge *edge) {

    for (int i = 0; i < pointt->edge_count; ++i) {
        if (pointt->edges[i] == edge) {
            return;
        }
    }


    pointt->edges = (Edge**)prealloc(pointt->edges, (pointt->edge_count + 1) * sizeof(Edge*),__func__,__FILE__,__LINE__);
    if (pointt->edges == NULL) {
        fprintf(ferr, "Memory allocation failed for edges\n");
        exit(1);
    }


    pointt->edges[pointt->edge_count] = edge;
    pointt->edge_count++;
}

void add_surface_to_list(Surface ***surfaces, int *count, Surface *surface) {

    for (int i = 0; i < *count; ++i) {
        if ((*surfaces)[i] == surface) {
            return;
        }
    }


    *surfaces = (Surface**)prealloc(*surfaces, (*count + 1) * sizeof(Surface*),__func__,__FILE__,__LINE__);
    if (*surfaces == NULL) {
        fprintf(ferr, "Memory allocation failed for surfaces\n");
        exit(1);
    }


    (*surfaces)[*count] = surface;
    (*count)++;
}



Pointt* Pointt_create(double x, double y) {




    for (int i = 0; i < pointt_count; ++i) {

        if (all_pointts[i]->coordinates[0] == x && all_pointts[i]->coordinates[1] == y) {
            return all_pointts[i];
        }
    }

    Pointt* new_pointt = (Pointt*)pmalloc(sizeof(Pointt),__func__,__FILE__,__LINE__);
    if (new_pointt == NULL) {


        printf("new_pointt == NULL\n");
        exit(1);
    }
    new_pointt->coordinates[0] = x;
    new_pointt->coordinates[1] = y;
    new_pointt->edges = NULL;
    new_pointt->edge_count = 0;
    new_pointt->surfaces = NULL;
    new_pointt->surface_count = 0;


    int existing_ids[pointt_count];
    for (int i = 0; i < pointt_count; ++i) {
        existing_ids[i] = all_pointts[i]->number;
    }
    new_pointt->number = get_next_id(existing_ids, pointt_count);


    all_pointts = (Pointt**)prealloc(all_pointts, (pointt_count + 1) * sizeof(Pointt*),__func__,__FILE__,__LINE__);
    all_pointts[pointt_count++] = new_pointt;

    return new_pointt;
}


Edge* Edge_create(Pointt* start_pointt, Pointt* end_pointt) {

    for (int i = 0; i < edge_count; ++i) {
        if ((all_edges[i]->start_pointt == start_pointt && all_edges[i]->end_pointt == end_pointt) ||
            (all_edges[i]->start_pointt == end_pointt && all_edges[i]->end_pointt == start_pointt)) {
            return all_edges[i];
        }
    }

    Edge* new_edge = (Edge*)pmalloc(sizeof(Edge),__func__,__FILE__,__LINE__);
    if (new_edge == NULL) {


        exit(1);
    }
    new_edge->start_pointt = start_pointt;
    new_edge->end_pointt = end_pointt;
    new_edge->surfaces = NULL;
    new_edge->surface_count = 0;

    double dx = start_pointt->coordinates[0] - end_pointt->coordinates[0];
    double dy = start_pointt->coordinates[1] - end_pointt->coordinates[1];
    new_edge->length = sqrt(dx * dx + dy * dy);


    int existing_ids[edge_count];
    for (int i = 0; i < edge_count; ++i) {
        existing_ids[i] = all_edges[i]->number;
    }
    new_edge->number = get_next_id(existing_ids, edge_count);


    all_edges = (Edge**)prealloc(all_edges, (edge_count + 1) * sizeof(Edge*),__func__,__FILE__,__LINE__);
    all_edges[edge_count++] = new_edge;

    new_edge->type = -1;


    add_edge_to_pointt(start_pointt, new_edge);
    add_edge_to_pointt(end_pointt, new_edge);

    return new_edge;
}


Surface* Surface_create(Edge** edges, int edge_count, Pointt** pointts, int pointt_count, int ordered) {


    for (int i = 0; i < surface_count; ++i) {
        Surface* existing_surface = all_surfaces[i];
        if (existing_surface->edge_count != edge_count) {
            continue;
        }


        int matched = 1;
        for (int j = 0; j < edge_count; ++j) {
            int edge_found = 0;
            for (int k = 0; k < edge_count; ++k) {
                if (edges[j]->number == existing_surface->edges[k]->number) {
                    edge_found = 1;
                    break;
                }
            }

            if (!edge_found) {
                matched = 0;
                break;
            }
        }

        if (matched) {
            return existing_surface;
        }
    }




    Surface* new_surface = (Surface*)pmalloc(sizeof(Surface),__func__,__FILE__,__LINE__);
    if (new_surface == NULL) {
        fprintf(ferr, "Memory allocation failed for Surface\n");
        exit(1);
    }

    new_surface->pointt_count = pointt_count;
    new_surface->pointts = (Pointt**)pmalloc(pointt_count * sizeof(Pointt*),__func__,__FILE__,__LINE__);
    if (new_surface->pointts == NULL) {
        fprintf(ferr, "Memory allocation failed for pointts in Surface\n");
        exit(1);
    }
    for (int i = 0; i < pointt_count; ++i) {
        new_surface->pointts[i] = pointts[i];
    }


    new_surface->edge_count = edge_count;
    new_surface->edges = (Edge**)pmalloc(edge_count * sizeof(Edge*),__func__,__FILE__,__LINE__);
    if (new_surface->edges == NULL) {
        fprintf(ferr, "Memory allocation failed for edges in Surface\n");
        exit(1);
    }
    for (int i = 0; i < edge_count; ++i) {
        new_surface->edges[i] = edges[i];
    }



    new_surface->pointts_reordered = ordered;

    if (!new_surface->pointts_reordered) {
        Surface_reorder_pointts(new_surface);
        new_surface->pointts_reordered = 1;

    }




    new_surface->area = Surface_calculate_area(new_surface);
    new_surface->cut_count = 0;
    new_surface->type = -1;

    int existing_ids[surface_count];
    for (int i = 0; i < surface_count; ++i) {
        existing_ids[i] = all_surfaces[i]->number;
    }
    new_surface->number = get_next_id(existing_ids, surface_count);


    all_surfaces = (Surface**)prealloc(all_surfaces, (surface_count + 1) * sizeof(Surface*),__func__,__FILE__,__LINE__);
    if (all_surfaces == NULL) {
        fprintf(ferr, "Memory reallocation failed for all_surfaces\n");
        exit(1);
    }
    all_surfaces[surface_count++] = new_surface;


    for (int i = 0; i < edge_count; ++i) {
        add_surface_to_list(&(edges[i]->surfaces), &(edges[i]->surface_count), new_surface);
    }


    for (int i = 0; i < pointt_count; ++i) {
        add_surface_to_list(&(pointts[i]->surfaces), &(pointts[i]->surface_count), new_surface);
    }


    return new_surface;
}

double Surface_calculate_area(Surface* surface) {

    double centroid_x = 0.0;
    double centroid_y = 0.0;

    int pointt_count = surface->pointt_count;
    for (int i = 0; i < pointt_count; ++i) {
        centroid_x += surface->pointts[i]->coordinates[0];
        centroid_y += surface->pointts[i]->coordinates[1];
    }
    centroid_x /= pointt_count;
    centroid_y /= pointt_count;


    double total_area = 0.0;
    for (int i = 0; i < pointt_count; ++i) {
        double x1 = surface->pointts[i]->coordinates[0];
        double y1 = surface->pointts[i]->coordinates[1];

        double x2 = surface->pointts[(i + 1) % pointt_count]->coordinates[0];
        double y2 = surface->pointts[(i + 1) % pointt_count]->coordinates[1];


        total_area += 0.5 * fabs(centroid_x * (y1 - y2) + x1 * (y2 - centroid_y) + x2 * (centroid_y - y1));
    }



    return total_area;
}
#line 988 "./././line9-4-4-for-basilisk-css-test.h"
int Pointt_on_line(Pointt* pointt, Pointt* line_start, Pointt* line_end) {
    double dx = line_end->coordinates[0] - line_start->coordinates[0];
    double dy = line_end->coordinates[1] - line_start->coordinates[1];




    if (fabs(dx)<1e-20) {
        int result= (pointt->coordinates[0] == line_start->coordinates[0] &&
                ((pointt->coordinates[1]-line_start->coordinates[1])*
                (pointt->coordinates[1]-line_end->coordinates[1])<=0) );

        return result;
    }


    if (fabs(dy)<1e-20) {
        int result= (pointt->coordinates[1] == line_start->coordinates[1] &&
                ((pointt->coordinates[0]-line_start->coordinates[0])*
                (pointt->coordinates[0]-line_end->coordinates[0])<=0) );

        return result;
    }

    double t = (pointt->coordinates[0] - line_start->coordinates[0]) / dx;


    if (t >= 0 && t <= 1) {

        int result = (pointt->coordinates[1] == line_start->coordinates[1] + t * dy);

        return result;
    }


    return 0;
}


int Edge_on(Edge* edge1, Edge* edge2) {

    return Pointt_on_line(edge1->start_pointt, edge2->start_pointt, edge2->end_pointt) &&
           Pointt_on_line(edge1->end_pointt, edge2->start_pointt, edge2->end_pointt);
}

void Edge_get_type(Edge* edge, EdgeVector* square_edges, SurfaceVector* surfaces_input) {

    int type_temp = -1;
    int ii_lim=edge->surface_count;
    for(int ii=0;ii<=ii_lim;ii++){
       if(ii==0){

       }else{
            if(ii==ii_lim){

            }else if(ii==ii_lim-1){

            }
       }
    }
    int number1=0,number2=1;
    int valid_count=edge->surface_count;
    if(1==1){
        valid_count=0;
        for(int jj=0;jj<edge->surface_count;jj++){
            int temp_jj=edge->surfaces[jj]->number;
            for(int ii=0;ii<surfaces_input->size;ii++){
                int temp_ii=surfaces_input->data[ii]->number;
                if(temp_jj==temp_ii){
                    valid_count++;
                    if(valid_count==1){
                        number1 = jj;
                    }else if(valid_count==2){
                        number2 = jj;
                    }else{
                        printf("Error edge belongs to more than 3 surfaces!!!!!\n");
                    }

                }
            }
        }
    }


    if (valid_count == 2) {


        int s1 = edge->surfaces[number1]->type;
        int s2 = edge->surfaces[number2]->type;


        if ((s1 == 1 && s2 == 2) || (s2 == 1 && s1 == 2)) type_temp=1;
        if ((s1 == 1 && s2 == 3) || (s2 == 1 && s1 == 3)) type_temp=2;
        if ((s1 == 1 && s2 == 4) || (s2 == 1 && s1 == 4)) type_temp=3;
        if ((s1 == 2 && s2 == 3) || (s2 == 2 && s1 == 3)) type_temp=4;
        if ((s1 == 2 && s2 == 4) || (s2 == 2 && s1 == 4)) type_temp=5;
        if ((s1 == 3 && s2 == 4) || (s2 == 3 && s1 == 4)) type_temp=6;
    }else if (valid_count == 1) {



        int s = edge->surfaces[number1]->type;

        int baseType;

        if (s == 1) baseType = 7;
        else if (s == 2) baseType = 11;
        else if (s == 3) baseType = 15;
        else if (s == 4) baseType = 19;





        for (int i = 1; i <= 4; ++i) {
            if (Edge_on(edge, square_edges->data[i-1])) {
                type_temp = baseType + (i-1);
            }
        }
    }

    edge->type = type_temp;
}



void Pointt_print(Pointt* pointt) {
    printf("Pointt %d: (%.2f, %.2f)\n", pointt->number, pointt->coordinates[0], pointt->coordinates[1]);
}

void Edge_print(Edge* edge) {
    printf("Edge %d: Pointts %d to %d\n", edge->number, edge->start_pointt->number, edge->end_pointt->number);
}

const char* SurfaceType_to_string(int type) {
    switch (type) {
        case 1: return "Not solid and gas";
        case 2: return "Not solid and liquid";
        case 3: return "Solid and gas";
        case 4: return "Solid and liquid";
        default: return "Unknown type";
    }
}

void Surface_print(Surface* surface) {
    char type_s[20];
    printf("Surface %d: Type: %d(%s), Area: %.2f, Edges [", surface->number, surface->type, SurfaceType_to_string(surface->type), surface->area);
    for (int i = 0; i < surface->edge_count; ++i) {
        printf("%d", surface->edges[i]->number);
        if (i < surface->edge_count - 1) {
            printf(", ");
        }
    }

    printf("], Pointts [");
    for (int i = 0; i < surface->pointt_count; ++i) {
        printf("%d", surface->pointts[i]->number);
        if (i < surface->pointt_count - 1) {
            printf(", ");
        }
    }
    printf("]\n");
}

void Pointt_belongs_to_print(Pointt* pointt) {
    printf("Pointt %d: belongs to Edge: [", pointt->number);
    for (int i=0;i<pointt->edge_count;i++) {
        if(i==0){
            printf("%d",pointt->edges[i]->number);
        }else{
            printf(", %d ",pointt->edges[i]->number);
        }

    }
    printf("]\n");
    printf("Pointt %d: belongs to surface: [", pointt->number);
    for (int i=0;i<pointt->surface_count;i++) {
        if(i==0){
            printf("%d",pointt->surfaces[i]->number);
        }else{
            printf(",%d",pointt->surfaces[i]->number);
        }
    }
    printf("]\n");
}

void Edge_belongs_to_print(Edge* edge) {
    printf("Edge %d: belongs to surface: [", edge->number);
    for (int i=0;i<edge->surface_count;i++) {
        if(i==0){
            printf("%d",edge->surfaces[i]->number);
        }else{
            printf(",%d",edge->surfaces[i]->number);
        }
    }
    printf("]\n");
}



double polar_angle(Pointt* pointt, double centroid_x, double centroid_y) {
    return atan2(pointt->coordinates[1] - centroid_y, pointt->coordinates[0] - centroid_x);
}




int compare_pointts(const void* a, const void* b) {
    Pointt* pointt_a = *(Pointt**)a;
    Pointt* pointt_b = *(Pointt**)b;
    double centroid_x = ((double*)centroid)[0];
    double centroid_y = ((double*)centroid)[1];

    double angle_a = polar_angle(pointt_a, centroid_x, centroid_y);
    double angle_b = polar_angle(pointt_b, centroid_x, centroid_y);

    if (angle_a < angle_b) return -1;
    if (angle_a > angle_b) return 1;
    return 0;
}


void Surface_reorder_pointts(Surface* surface) {

    double centroid_x = 0.0, centroid_y = 0.0;
    for (int i = 0; i < surface->pointt_count; ++i) {
        centroid_x += surface->pointts[i]->coordinates[0];
        centroid_y += surface->pointts[i]->coordinates[1];
    }
    centroid_x /= surface->pointt_count;
    centroid_y /= surface->pointt_count;



    centroid[0] = centroid_x;
    centroid[1] = centroid_y;

    qsort(surface->pointts, surface->pointt_count, sizeof(Pointt*), compare_pointts);
}


EdgeVector* init_edge_vector(int initial_capacity) {
    EdgeVector* vec = pmalloc(sizeof(EdgeVector),__func__,__FILE__,__LINE__);
    if (vec == NULL) {

        exit(1);
    }
    vec->data = pmalloc(initial_capacity * sizeof(Edge*),__func__,__FILE__,__LINE__);
    if (vec->data == NULL) {

        exit(1);
    }
    vec->size = 0;
    vec->capacity = initial_capacity;
    return vec;
}

void add_edge_to_vector(EdgeVector* vec, Edge* edge) {
    if (vec->size == vec->capacity) {
        vec->capacity *= 2;
        vec->data = prealloc(vec->data, vec->capacity * sizeof(Edge*),__func__,__FILE__,__LINE__);
        if (vec->data == NULL) {

            exit(1);
        }
    }
    vec->data[vec->size] = edge;
    vec->size++;
}


SurfaceVector* init_surface_vector(int initial_capacity) {
    SurfaceVector* vec = pmalloc(sizeof(SurfaceVector),__func__,__FILE__,__LINE__);
    if (vec == NULL) {

        exit(1);
    }
    vec->data = pmalloc(initial_capacity * sizeof(Surface*),__func__,__FILE__,__LINE__);
    if (vec->data == NULL) {

        exit(1);
    }
    vec->size = 0;
    vec->capacity = initial_capacity;
    return vec;
}

void add_surface_to_vector(SurfaceVector* vec, Surface* surface) {
    if (vec->size == vec->capacity) {
        vec->capacity *= 2;
        vec->data = prealloc(vec->data, vec->capacity * sizeof(Surface*),__func__,__FILE__,__LINE__);
        if (vec->data == NULL) {

            exit(1);
        }
    }
    vec->data[vec->size] = surface;
    vec->size++;
}



Line* Line_create(int number, double a, double b, double c) {
    Line* new_line = (Line*) pmalloc(sizeof(Line),__func__,__FILE__,__LINE__);
    if (new_line == NULL) {

        exit(1);
    }
    new_line->number = number;
    new_line->a = a;
    new_line->b = b;
    new_line->c = c;
    new_line->normal[0] = a;
    new_line->normal[1] = b;

    all_lines = (Line**)prealloc(all_lines, (line_count + 1) * sizeof(Line*),__func__,__FILE__,__LINE__);
    if (all_lines == NULL) {


        exit(1);
    }
    all_lines[line_count++] = new_line;


    return new_line;
}


void Line_print(Line* line) {
    printf("Line %d: %fx + %fy + %f = 0\n", line->number, line->a, line->b, line->c);
}


double Line_at(Line* line, double x, double y, int flag) {
    if (flag == 0 && line->b != 0) {

        return (-line->a * x - line->c) / line->b;
    } else if (flag == 1 && line->a != 0) {

        return (-line->b * y - line->c) / line->a;
    } else {

        printf("Invalid arguments or line parameters\n");
        exit(1);
    }
}


bool are_parallel(double a, double b, double x1, double y1, double x2, double y2) {

    double dx = x2 - x1;
    double dy = y2 - y1;


    if (a == 0.0 && dx == 0.0) {
        return true;
    }


    if ((a == 0.0 && dx != 0.0) || (a != 0.0 && dx == 0.0)) {
        return false;
    }


    double ratio_a = a / dx;
    double ratio_b = b / dy;


    return fabs(ratio_a - ratio_b) < 1e-9;
}


Pointt** intersect(Line* line, Edge* edge) {



    double a = line->a;
    double b = line->b;
    double c = line->c;

    double x1 = edge->start_pointt->coordinates[0];
    double y1 = edge->start_pointt->coordinates[1];
    double x2 = edge->end_pointt->coordinates[0];
    double y2 = edge->end_pointt->coordinates[1];

    double det = a * (x2 - x1) + b * (y2 - y1);


    if (fabs(det) < 1e-9) {
            Pointt** pointts = (Pointt**)pmalloc(2 * sizeof(Pointt*),__func__,__FILE__,__LINE__);
            if (fabs(a * x1 + b * y1 + c) < 1e-9) {
                pointts[0] = edge->start_pointt;
                pointts[1] = edge->end_pointt;
            } else {
                pointts[0] = NULL;
                pointts[1] = NULL;
            }
            return pointts;
        }

        double t = -(a * x1 + b * y1 + c) / det;


        if (0 <= t && t <= 1) {
            double x = x1 + t * (x2 - x1);
            double y = y1 + t * (y2 - y1);

            Pointt** pointts = (Pointt**)pmalloc(2 * sizeof(Pointt*),__func__,__FILE__,__LINE__);
            pointts[0] = Pointt_create(x, y);
            pointts[1] = NULL;
            return pointts;
        }
        return NULL;
}



void create_edges_from_pointts(Pointt** pointts, int pointts_length, EdgeVector* own_edges, EdgeVector* overlap_edges){
    int initial_total_edges = edge_count;

    for (int i = 0; i < pointts_length; ++i) {
        int next_i = (i + 1) % pointts_length;

        Pointt* start_pointt = pointts[i];
        Pointt* end_pointt = pointts[next_i];


        Edge* edge = Edge_create(start_pointt, end_pointt);


        if (edge_count > initial_total_edges) {

            add_edge_to_vector(own_edges, edge);
            initial_total_edges=edge_count;
        } else {

            add_edge_to_vector(overlap_edges, edge);
        }
    }
}




void cut_surface(Surface* original_surface, Line* cutting_line, SurfaceVector* new_surfaces) {

    IntersectionInfo* intersections = NULL;
    int intersection_count = 0;


    for (int i = 0; i < original_surface->edge_count; ++i) {
        Edge* edge = original_surface->edges[i];


        Pointt** result = intersect(cutting_line, edge);

        if (result) {
            for (int j = 0; result[j] != NULL; ++j) {
                bool already_exists = false;


                for (int k = 0; k < intersection_count; ++k) {
                    if (intersections[k].intersection_pointt == result[j]) {
                        already_exists = true;
                        break;
                    }
                }


                if (!already_exists) {
                    intersections = prealloc(intersections, (intersection_count + 1) * sizeof(IntersectionInfo),__func__,__FILE__,__LINE__);
                    intersections[intersection_count].intersection_pointt = result[j];
                    intersections[intersection_count].associated_edge = edge;
                    intersection_count++;
                }
            }

            pfree(result,__func__,__FILE__,__LINE__);
        }
    }





    if (intersection_count != 2) {

        add_surface_to_vector(new_surfaces, original_surface);
    }
    else {

        Pointt** original_pointts = pmalloc(original_surface->pointt_count * sizeof(Pointt*),__func__,__FILE__,__LINE__);
        for (int i = 0; i < original_surface->pointt_count; ++i) {
            original_pointts[i] = original_surface->pointts[i];
        }
        int original_pointt_count = original_surface->pointt_count;


        for (int i = 0; i < intersection_count; ++i) {
            Pointt* intersection_pointt = intersections[i].intersection_pointt;
            Edge* intersected_edge = intersections[i].associated_edge;

            int insert_index1 = -1;
            int insert_index2 = -1;

            for (int j = 0; j < original_pointt_count; ++j) {
                if (original_pointts[j] == intersected_edge->start_pointt) {
                    insert_index1 = j;
                }
                if (original_pointts[j] == intersected_edge->end_pointt) {
                    insert_index2 = j;
                }
            }

            int position = -1;
            if (abs(insert_index1 - insert_index2) == 1) {
                position = (insert_index1 > insert_index2) ? insert_index1 : insert_index2;
            } else if ((insert_index1 == 0 && insert_index2 == original_pointt_count - 1) ||
                    (insert_index2 == 0 && insert_index1 == original_pointt_count - 1)) {
                position = original_pointt_count;
            }

            if (position != -1) {
                original_pointt_count++;
                original_pointts = prealloc(original_pointts, original_pointt_count * sizeof(Pointt*),__func__,__FILE__,__LINE__);
                for (int j = original_pointt_count - 1; j > position; --j) {
                    original_pointts[j] = original_pointts[j - 1];
                }
                original_pointts[position] = intersection_pointt;
            }
        }


        int index1 = -1;
        int index2 = -1;
        for (int i = 0; i < original_pointt_count; ++i) {
            if (original_pointts[i] == intersections[0].intersection_pointt) {
                index1 = i;
            }
            if (original_pointts[i] == intersections[1].intersection_pointt) {
                index2 = i;
            }
        }


        Pointt** new_surface1_pointts = NULL;
        Pointt** new_surface2_pointts = NULL;
        int count1 = 0, count2 = 0;

        if (index1 < index2) {

            count1 = index2 - index1 + 1;
            count2 = original_pointt_count - index2 + index1 + 1;


            new_surface1_pointts = pmalloc(count1 * sizeof(Pointt*),__func__,__FILE__,__LINE__);
            new_surface2_pointts = pmalloc(count2 * sizeof(Pointt*),__func__,__FILE__,__LINE__);


            for (int i = 0; i < count1; ++i) {
                new_surface1_pointts[i] = original_pointts[index1 + i];
            }


            for (int i = 0; i < original_pointt_count - index2; ++i) {
                new_surface2_pointts[i] = original_pointts[index2 + i];
            }
            for (int i = 0; i < index1 + 1; ++i) {
                new_surface2_pointts[original_pointt_count - index2 + i] = original_pointts[i];
            }
        } else {

            count1 = original_pointt_count - index1 + index2 + 1;
            count2 = index1 - index2 + 1;


            new_surface1_pointts = pmalloc(count1 * sizeof(Pointt*),__func__,__FILE__,__LINE__);
            new_surface2_pointts = pmalloc(count2 * sizeof(Pointt*),__func__,__FILE__,__LINE__);


            for (int i = 0; i < original_pointt_count - index1; ++i) {
                new_surface1_pointts[i] = original_pointts[index1 + i];
            }
            for (int i = 0; i < index2 + 1; ++i) {
                new_surface1_pointts[original_pointt_count - index1 + i] = original_pointts[i];
            }


            for (int i = 0; i < count2; ++i) {
                new_surface2_pointts[i] = original_pointts[index2 + i];
            }
        }





            EdgeVector* new_surface1_edges = init_edge_vector(10);
            EdgeVector* overlaps1 = init_edge_vector(10);


            create_edges_from_pointts(new_surface1_pointts, count1, new_surface1_edges, overlaps1);


            EdgeVector* new_surface2_edges = init_edge_vector(10);
            EdgeVector* overlaps2 = init_edge_vector(10);


            create_edges_from_pointts(new_surface2_pointts, count2, new_surface2_edges, overlaps2);







            int totalEdgeCount1 = new_surface1_edges->size + overlaps1->size;
            Edge** allEdges1 = pmalloc(totalEdgeCount1 * sizeof(Edge*),__func__,__FILE__,__LINE__);


            for (int i = 0; i < new_surface1_edges->size; ++i) {
                allEdges1[i] = new_surface1_edges->data[i];
            }


            for (int i = 0; i < overlaps1->size; ++i) {
                allEdges1[new_surface1_edges->size + i] = overlaps1->data[i];
            }
#line 1626 "./././line9-4-4-for-basilisk-css-test.h"
            Surface* new_surface1 = Surface_create(allEdges1, totalEdgeCount1, new_surface1_pointts, count1, 1);
#line 1637 "./././line9-4-4-for-basilisk-css-test.h"
            pfree(allEdges1,__func__,__FILE__,__LINE__);


            int totalEdgeCount2 = new_surface2_edges->size + overlaps2->size;
            Edge** allEdges2 = pmalloc(totalEdgeCount2 * sizeof(Edge*),__func__,__FILE__,__LINE__);


            for (int i = 0; i < new_surface2_edges->size; ++i) {
                allEdges2[i] = new_surface2_edges->data[i];
            }


            for (int i = 0; i < overlaps2->size; ++i) {
                allEdges2[new_surface2_edges->size + i] = overlaps2->data[i];
            }


            Surface* new_surface2 = Surface_create(allEdges2, totalEdgeCount2, new_surface2_pointts, count2, 1);
#line 1668 "./././line9-4-4-for-basilisk-css-test.h"
            pfree(allEdges2,__func__,__FILE__,__LINE__);
#line 1691 "./././line9-4-4-for-basilisk-css-test.h"
            add_surface_to_vector(new_surfaces, new_surface1);
            add_surface_to_vector(new_surfaces, new_surface2);

            if (new_surfaces == NULL || new_surfaces->data == NULL) {
                printf("Null pointter encountered.\n");
                return;
            }
#line 1709 "./././line9-4-4-for-basilisk-css-test.h"
            pfree(new_surface1_pointts,__func__,__FILE__,__LINE__);
            pfree(new_surface2_pointts,__func__,__FILE__,__LINE__);
            pfree(new_surface1_edges->data,__func__,__FILE__,__LINE__);
            pfree(new_surface1_edges,__func__,__FILE__,__LINE__);
            pfree(overlaps1->data,__func__,__FILE__,__LINE__);
            pfree(overlaps1,__func__,__FILE__,__LINE__);
            pfree(new_surface2_edges->data,__func__,__FILE__,__LINE__);
            pfree(new_surface2_edges,__func__,__FILE__,__LINE__);
            pfree(overlaps2->data,__func__,__FILE__,__LINE__);
            pfree(overlaps2,__func__,__FILE__,__LINE__);


        pfree(original_pointts,__func__,__FILE__,__LINE__);

    }


    if (intersections) {
        pfree(intersections,__func__,__FILE__,__LINE__);
    }


}


void cut_surfaces(SurfaceVector* surfaces, Line* cutting_line, SurfaceVector* new_surfaces) {
    for (int i = 0; i < surfaces->size; ++i) {
        Surface* current_surface = surfaces->data[i];
        SurfaceVector* cut_result = init_surface_vector(2);
        cut_surface(current_surface, cutting_line, cut_result);
        for (int j = 0; j < cut_result->size; ++j) {
            add_surface_to_vector(new_surfaces, cut_result->data[j]);
        }


        pfree(cut_result->data,__func__,__FILE__,__LINE__);
        pfree(cut_result,__func__,__FILE__,__LINE__);
    }
}



void SurfaceVector_print(SurfaceVector* surfaceVector) {
    if (surfaceVector == NULL) {
        printf("SurfaceVector is NULL.\n");
        return;
    }
    printf("SurfaceVector size: %d, capacity: %d\n", surfaceVector->size, surfaceVector->capacity);
    for (int i = 0; i < surfaceVector->size; ++i) {

        Surface_print(surfaceVector->data[i]);
    }
}


int Pointt_above_line(double pointt_coordinates[2], Line* line) {
    double result = line->a * pointt_coordinates[0] + line->b * pointt_coordinates[1] + line->c;
    if (result > 0) return 1;
    if (result == 0) return 0;
    return -1;
}


void Surface_get_center(Surface* surface, double center_coordinates[2]) {
    double x_sum = 0;
    double y_sum = 0;
    for (int i = 0; i < surface->pointt_count; ++i) {
        x_sum += surface->pointts[i]->coordinates[0];
        y_sum += surface->pointts[i]->coordinates[1];
    }
    center_coordinates[0] = x_sum / surface->pointt_count;
    center_coordinates[1] = y_sum / surface->pointt_count;
}




void Surface_get_type(Surface* surface, Line* line1, Line* line2) {
    double center[2];
    Surface_get_center(surface, center);





    int above_line1 = Pointt_above_line(center, line1);
    int above_line2 = Pointt_above_line(center, line2);

    int type_temp=-1;

    if (above_line1 == 1 && above_line2 == 1) {
        type_temp = 1;
    }
    else if (above_line1 == 1 && above_line2 == -1) {
        type_temp = 2;
    }
    else if (above_line1 == -1 && above_line2 == 1) {
        type_temp = 3;
    }
    else if (above_line1 == -1 && above_line2 == -1) {
        type_temp = 4;
    }

    surface->type = type_temp;
}


void Surface_get_type_3_cut(Surface* surface, Line* line1, Line* line2, Line* line3) {
    double center[2];
    Surface_get_center(surface, center);






    int above_line1 = Pointt_above_line(center, line1);
    int above_line2 = Pointt_above_line(center, line2);
    int above_line3 = Pointt_above_line(center, line3);

    int type_temp=-1;

    if (above_line1 == 1 && above_line2 == 1 && above_line3==1) {
        type_temp = 1;
    }
    else if (above_line1 == 1 && above_line2 == -1 && above_line3==1) {
        type_temp = 2;
    }
    else if (above_line1 == -1 && above_line2 == 1 && above_line3==1) {
        type_temp = 3;
    }
    else if (above_line1 == -1 && above_line2 == -1 && above_line3==1) {
        type_temp = 4;
    }
    else if (above_line1 == 1 && above_line2 == 1 && above_line3==-1) {
        type_temp = 5;
    }
    else if (above_line1 == 1 && above_line2 == -1 && above_line3==-1) {
        type_temp = 6;
    }
    else if (above_line1 == -1 && above_line2 == 1 && above_line3==-1) {
        type_temp = 7;
    }
    else if (above_line1 == -1 && above_line2 == -1 && above_line3==-1) {
        type_temp = 8;
    }

    surface->type = type_temp;
}





void free_pointt(Pointt* pointt) {

    if (pointt->edges != NULL) {
        pfree(pointt->edges,__func__,__FILE__,__LINE__);
    }


    if (pointt->surfaces != NULL) {
        pfree(pointt->surfaces,__func__,__FILE__,__LINE__);
    }


    pfree(pointt,__func__,__FILE__,__LINE__);
}

void free_surface(Surface* surface) {

    if (surface->edges != NULL) {
        pfree(surface->edges,__func__,__FILE__,__LINE__);
    }


    if (surface->pointts != NULL) {
        pfree(surface->pointts,__func__,__FILE__,__LINE__);
    }


    pfree(surface,__func__,__FILE__,__LINE__);
}

void free_edge(Edge* edge) {

    if (edge->surfaces != NULL) {
        pfree(edge->surfaces,__func__,__FILE__,__LINE__);
    }


    pfree(edge,__func__,__FILE__,__LINE__);
}



void free_all_pointts(Pointt** all_pointts, int pointt_count) {
    for (int i = 0; i < pointt_count; ++i) {
        free_pointt(all_pointts[i]);
    }

}

void free_all_edges(Edge** all_edges, int edge_count) {
    for (int i = 0; i < edge_count; ++i) {
        free_edge(all_edges[i]);
    }

}

void free_all_surfaces(Surface** all_surfaces, int surface_count) {
    for (int i = 0; i < surface_count; ++i) {
        free_surface(all_surfaces[i]);
    }

}

void free_all_lines(Line** all_lines, int line_count) {
    for (int i = 0; i < line_count; ++i) {
        pfree(all_lines[i],__func__,__FILE__,__LINE__);
    }

}

void free_all_resources() {
    free_all_pointts(all_pointts, pointt_count);
    free_all_edges(all_edges, edge_count);
    free_all_surfaces(all_surfaces, surface_count);
    free_all_lines(all_lines, line_count);
}



void line_intersection_range(coord n1, double* c_min, double* c_max) {

    double a = n1.x;
    double b = n1.y;
    double vertices[4][2] = {{0,0}, {1,0}, {0,1}, {1,1}};


    *c_min = 1.0e10;
    *c_max = -1.0e10;


    if (a == 0 && b == 0) {

        *c_min = *c_max = 0;
        return;
    }


    for(int i=0; i<4; i++) {
        double x = vertices[i][0];
        double y = vertices[i][1];
        double c = -a*x - b*y;
        if (c < *c_min) *c_min = c;
        if (c > *c_max) *c_max = c;
    }
}
#line 2550 "././getsolid.h"

 extern scalar temp27;
  extern scalar temp28;
  extern scalar temp211;
   extern scalar temp212;

   extern scalar temp25;
   extern scalar temp26;
    extern scalar temp29;
    extern scalar temp210;
void get_css_fss_areaslg_triple_point(){
#line 2570 "././getsolid.h"
    foreach_stencil(){
        _stencil_val_a(areasl,0,0,0);
        _stencil_val_a(areasg,0,0,0);
        _stencil_val_a(arealg,0,0,0);        

        
        
        
        

        
        
        
        
    }end_foreach_stencil();
#line 2570 "././getsolid.h"
    {foreach(){
        val(areasl,0,0,0)=0.0;
        val(areasg,0,0,0)=0.0;
        val(arealg,0,0,0)=0.0;

        scalar  temp27=new_scalar("temp27");
        scalar  temp28=new_scalar("temp28");
        scalar  temp211=new_scalar("temp211");
        scalar  temp212=new_scalar("temp212");

        scalar  temp25=new_scalar("temp25");
        scalar  temp26=new_scalar("temp26");
        scalar  temp29=new_scalar("temp29");
        scalar  temp210=new_scalar("temp210");delete((scalar*)((scalar[]){temp210,temp29,temp26,temp25,temp212,temp211,temp28,temp27,{-1}}));
    }end_foreach();}

    foreach_stencil(){

_stencil_val(css_test3,0,0,0);{
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{  
                 _stencil_mycs (point, ff);     
                _stencil_val(ff,0,0,0);    
                
                 
                 
                    
                _stencil_val_a(arealg,0,0,0);  
            }
             
        
#line 2598
}
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0);{  
             _stencil_mycs (point, css_test3);     
            _stencil_val(css_test3,0,0,0);    
            
             
             
                


_stencil_val(ff,0,0,0);{
                _stencil_val_a(areasl,0,0,0);  
            }
_stencil_val(ff,0,0,0);{
                    _stencil_val_a(areasg,0,0,0);  
            }


            
            
        
#line 2614
}

        
         
    
#line 2615
}end_foreach_stencil();

    {
#line 2586
foreach(){

        if(val(css_test3,0,0,0)<1.0){
            if(val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0){
                coord nlg = mycs (point, ff);
                double alphalg = line_alpha (val(ff,0,0,0), nlg);
                coord plg;
                double arealg_temp = line_length_center(nlg,alphalg,&plg);
                if (metric_embed_factor)
                    arealg_temp *= metric_embed_factor (point, plg);
                val(arealg,0,0,0) = arealg_temp;
            }
        }
        if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0){
            coord nsf = mycs (point, css_test3);
            double alphasf = line_alpha (val(css_test3,0,0,0), nsf);
            coord psf;
            double areasf_temp = line_length_center(nsf,alphasf,&psf);
            if (metric_embed_factor)
                areasf_temp *= metric_embed_factor (point, psf);


            if(val(ff,0,0,0)>0.0){
                val(areasl,0,0,0) = areasf_temp;
            }
            if(val(ff,0,0,0)<1.0){
                    val(areasg,0,0,0) = areasf_temp;
            }
        }
    }end_foreach();}

    foreach_stencil(){
_stencil_val(css_test3,0,0,0); _stencil_val(css_test3,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{  
             _stencil_mycs (point, css_test3);     
            _stencil_val(css_test3,0,0,0);      
            
             
             
                

             _stencil_mycs (point, ff);     
            _stencil_val(ff,0,0,0);      
            
             
             
                
#line 2647 "././getsolid.h"
              
             
             


            

            
            _stencil_val_a(css_test2,0,0,0);  
            _stencil_val_a(css_test,0,0,0);  
            _stencil_val_a(arealg,0,0,0);  
            _stencil_val_a(areasl,0,0,0);  
            _stencil_val_a(areasg,0,0,0);  
#line 2676 "././getsolid.h"
            _stencil_val_a(temp27,0,0,0);
            _stencil_val_a(temp28,0,0,0);
            _stencil_val_a(temp211,0,0,0);
            _stencil_val_a(temp212,0,0,0);

            _stencil_val_a(temp25,0,0,0);
            _stencil_val_a(temp26,0,0,0);
            _stencil_val_a(temp29,0,0,0);
            _stencil_val_a(temp210,0,0,0);
#line 2697
_stencil_val(arealg,0,0,0);{
                if (metric_embed_factor){
                     _stencil_val_r(arealg,0,0,0);  
                }
            }
_stencil_val(areasg,0,0,0);{
                if (metric_embed_factor){
                     _stencil_val_r(areasg,0,0,0);  
                }
            }
_stencil_val(areasl,0,0,0);{
                if (metric_embed_factor){
                     _stencil_val_r(areasl,0,0,0);  
                }
            }
#line 2697 "././getsolid.h"
            
            
             



        
#line 2715
}
           
    
#line 2716
}end_foreach_stencil();

    {
#line 2617
foreach(){
        if(val(css_test3,0,0,0)>0.0 && val(css_test3,0,0,0)<1.0 && val(ff,0,0,0)>0.0 && val(ff,0,0,0)<1.0){
            coord nsf = mycs (point, css_test3);
            double alphasf = line_alpha (val(css_test3,0,0,0), nsf);
            coord psf;
            double areasf_temp = line_length_center(nsf,alphasf,&psf);
            if (metric_embed_factor)
                areasf_temp *= metric_embed_factor (point, psf);

            coord nlg = mycs (point, ff);
            double alphalg = line_alpha (val(ff,0,0,0), nlg);
            coord plg;
            double arealg_temp = line_length_center(nlg,alphalg,&plg);
            if (metric_embed_factor)
                arealg_temp *= metric_embed_factor (point, plg);
#line 2647 "././getsolid.h"
            double a1,b1,c1,a2,b2,c2;
            a1 = nsf.x,b1=nsf.y,c1=-0.5*(nsf.x+nsf.y)-alphasf;
            a2 = nlg.x,b2=nlg.y,c2=-0.5*(nlg.x+nlg.y)-alphalg;


            double data2[13];

            cut_line_test_in_basilisk((coord){a1,b1},c1,(coord){a2,b2},c2,data2);
            val(css_test2,0,0,0) = data2[0];
            val(css_test,0,0,0) = data2[1];
            val(arealg,0,0,0) = data2[2];
            val(areasl,0,0,0) = data2[3];
            val(areasg,0,0,0) = data2[4];
#line 2676 "././getsolid.h"
            val(temp27,0,0,0)=data2[7];
            val(temp28,0,0,0)=data2[8];
            val(temp211,0,0,0)=data2[11];
            val(temp212,0,0,0)=data2[12];

            val(temp25,0,0,0)=data2[5];
            val(temp26,0,0,0)=data2[6];
            val(temp29,0,0,0)=data2[9];
            val(temp210,0,0,0)=data2[10];
#line 2697 "././getsolid.h"
            if(fabs(val(arealg,0,0,0))>1e-30){
                if (metric_embed_factor){
                     val(arealg,0,0,0) *= y;
                }
            }
            if(fabs(val(areasg,0,0,0))>1e-30){
                if (metric_embed_factor){
                     val(areasg,0,0,0) *= y;
                }
            }
             if(fabs(val(areasl,0,0,0))>1e-30){
                if (metric_embed_factor){
                     val(areasl,0,0,0) *= y;
                }
            }



        }
    }end_foreach();}

    foreach_face_stencil()_stencil_is_face_x(){{
{
_stencil_val(temp27,-1,0,0);{
                _stencil_val_a(fss_test.x,0,0,0); _stencil_val(temp27,-1,0,0); 
            }



_stencil_val(temp211,-1,0,0);{
                _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(temp211,-1,0,0); 
            }




_stencil_val(temp25,0,0,0);{
                _stencil_val_a(fss_test.x,0,0,0); _stencil_val(temp25,0,0,0); 
            }



_stencil_val(temp29,0,0,0);{
                _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(temp29,0,0,0); 
            }
            



            




            



            



        
#line 2745
}
        
    
#line 2746
}}end__stencil_is_face_x()end_foreach_face_stencil();

    {
#line 2718
foreach_face_generic()is_face_x(){{
        if(level==level_interface){
            if(fabs(val(temp27,-1,0,0))>1e-20){
                val(fss_test.x,0,0,0) = val(temp27,-1,0,0);
            }



            if(fabs(val(temp211,-1,0,0))>1e-20){
                val(fss_test2.x,0,0,0) = val(temp211,-1,0,0);
            }




            if(fabs(val(temp25,0,0,0))>1e-20){
                val(fss_test.x,0,0,0) = val(temp25,0,0,0);
            }



            if(fabs(val(temp29,0,0,0))>1e-20){
                val(fss_test2.x,0,0,0) = val(temp29,0,0,0);
            }



        }
    }}end_is_face_x()end_foreach_face_generic();}

    foreach_face_stencil()_stencil_is_face_y(){{
{



_stencil_val(temp28,0,-1,0);{
                _stencil_val_a(fss_test.y,0,0,0); _stencil_val(temp28,0,-1,0); 
            }



_stencil_val(temp212,0,-1,0);{
                _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(temp212,0,-1,0); 
            }




_stencil_val(temp26,0,0,0);{
                _stencil_val_a(fss_test.y,0,0,0); _stencil_val(temp26,0,0,0); 
            }



_stencil_val(temp210,0,0,0);{
                _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(temp210,0,0,0); 
            }



            



            




            



            
        
#line 2775
}
        
    
#line 2776
}}end__stencil_is_face_y()end_foreach_face_stencil();

    {
#line 2748
foreach_face_generic()is_face_y(){{
        if(level==level_interface){



            if(fabs(val(temp28,0,-1,0))>1e-20){
                val(fss_test.y,0,0,0) = val(temp28,0,-1,0);
            }



            if(fabs(val(temp212,0,-1,0))>1e-20){
                val(fss_test2.y,0,0,0) = val(temp212,0,-1,0);
            }




            if(fabs(val(temp26,0,0,0))>1e-20){
                val(fss_test.y,0,0,0) = val(temp26,0,0,0);
            }



            if(fabs(val(temp210,0,0,0))>1e-20){
                val(fss_test2.y,0,0,0) = val(temp210,0,0,0);
            }
        }
    }}end_is_face_y()end_foreach_face_generic();}
}
#line 35 "template01.c"
#line 52 "template01.c"
clock_t start_time,end_time;
double during_time;
double originx=0.0,originy=0.0;
double L0_pysical;
int case_number = 3;
int sink_number=0;

int maxl= 11 , minl = 4;
bool restartsymbol = false;

int globali,outstep=1;
double out_interval=5e-7;

double out_interval2=5e-7;
double tend = 0.00022 + 0.0158541;




double Tsat0,Tsat00,T_inf,T_sup;
double bubble_radius;
double centerx,centery;
double Tsub,Twall_init;
double Tmax=0.0;
bool tune_cs_flag2=true;
double tune2_value=0.0;
double Length_heat=0.004;
double Rwater;
double omega;
double Rcc;
bool Rcc_flag_l = false;
bool Rcc_flag_g = false;
scalar  aiml_s={28}, aimg_s={29};

scalar  T={30};
scalar  Tlff={31}, Tgff={32}, T_solid={33};
vector  modphase0={{34},{35}}, modphase1={{36},{37}};
vector  modphase_s_1={{38},{39}}, modphase_s_0={{40},{41}};
vector  hhh={{42},{43}};

scalar  corner_ff={44};

vector  direction_Tfg={{45},{46}}, direction_Tfl={{47},{48}}, direction_Ts={{49},{50}};





scalar  topo_mask={51};
scalar  topo_mask_g={52};

scalar  topo_mask_s={53};

scalar  masstr={54},  source_pc={55},  vtr={56},  source_pc2={57};


scalar  poisson_source2={58};

scalar  ps={59}, psg={60};
vector  usf={{61},{62}}, usfg={{63},{64}}, ulf={{65},{66}}, ugf={{67},{68}};

 scalar  phase0Tgrad={69}, phase1Tgrad={70};

 scalar  flux_lg_l={71}, flux_lg_g={72};



double source_total,total_area;

int phase_flag3;
int level_interface;
vector  fss_test={{73},{74}};
scalar  css_test={75};
vector  fss_test2={{76},{77}};
scalar  css_test2={78};

scalar  fs_solid={79};
scalar  css_test3={80};
vector  fss_test3={{81},{82}};

scalar  css_test3_n={83};
vector  fss_test3_n={{84},{85}};
scalar  deltac={86};
double CFL_evap = 0.1;
bool dump_each_event=false;
int dump_each_event_interval=1;
bool point_trace=false;
double tracex,tracey;
double delta_min;
bool out_flag;
bool energy_advecting_flag;

bool flag_average_source=false;
bool flag_cant_smaller_than_half=false;
bool flag_get_u_ghost=false;

scalar  T_oold={87};
char Tini_file[80];
 scalar  smf={88}, ssmf={89}, sssmf={90}, ssssmf={91};

 double thickness;
 double theta0=15.0;

 bool restart_Tsat=false;
 int restart_Tsat_i=0;


 vector  smallmodl={{92},{93}}, bigmodl={{94},{95}};
 vector  smallmodg={{96},{97}}, bigmodg={{98},{99}};
 scalar  resl={100}, resg={101};
 scalar  ress={102};

 vector  flux_show={{103},{104}};

scalar  intersect_true={105};

 bool poisson_check=true;
 bool surface_heat=false;
 bool surface_heat_restart=false;



bool use_Tslg=true;


scalar  res_ps={106};



vector  Tlff_g={{107},{108}}, Tgff_g={{109},{110}}, T_solid_g={{111},{112}};
scalar  Tl={113}, Tg={114}, Ts={115};
scalar  aiml={116},  aimg={117}, T_modl={118},  T_modg={119};
scalar  flux_l={120}, flux_g={121};
scalar  areasl={122}, areasg={123}, arealg={124};

scalar  merge_to_me_s_c={125};
vector  merge_to_me_s_position={{126},{127}};
scalar  merge_to_me_s_energy={128};

scalar  merge_to_me_l_c={129};
vector  merge_to_me_l_position={{130},{131}};
scalar  merge_to_me_l_energy={132};

scalar  merge_to_me_g_c={133};
vector  merge_to_me_g_position={{134},{135}};
scalar  merge_to_me_g_energy={136};

vector  ulf_v={{137},{138}};
scalar  modify_near_region={139};
    scalar  temp27={140};
    scalar  temp28={141};
    scalar  temp211={142};
    scalar  temp212={143};

    scalar  temp25={144};
    scalar  temp26={145};
    scalar  temp29={146};
    scalar  temp210={147};

     scalar  ff_old={148}, ff_old2={149};

     scalar  div_numerical={150};
     scalar  div_numerical2={151};

     scalar  poisson_source2_f={152};
#line 249 "template01.c"
          double heat_flux;
          double range_heat_flux;

bool flag_topos_advect_uf=false;

  double thickbottom;
   double groove_h, groove_w_bottom,groove_w_top;
#line 269
static double _boundary37(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return(neumann(0.));}}static double _boundary37_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return(neumann_homogeneous());}}
static double _boundary38(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet(0.));}}static double _boundary38_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}
static double _boundary39(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet(0.));}}static double _boundary39_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}





static double _boundary40(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return(neumann(0.));}}static double _boundary40_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return(neumann_homogeneous());}}
static double _boundary41(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet(0.));}}static double _boundary41_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}
static double _boundary42(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet(0.));}}static double _boundary42_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous());}}

static double _boundary43(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet (0.));}}static double _boundary43_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous ());}}
static double _boundary44(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet (0.));}}static double _boundary44_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( dirichlet_homogeneous ());}}



static double _boundary45(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (0.));}}static double _boundary45_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann_homogeneous ());}}
static double _boundary46(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann (0.));}}static double _boundary46_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);POINT_VARIABLES;return( neumann_homogeneous ());}}



int main (int argc, char **argv)
{_init_solver();
   start_time = clock();
end_time = start_time;

  if(case_number==1){
    init_grid(1<<minl);
      DT = 0.005;
      double L0_pysical = 0.5;
      L0 = L0_pysical;
      Tkg = 0.007;
      Tkl = 0.07;
      Trhog = 0.25;
      Trhol = 2.5;
      Tcpg = 1.0;
      Tcpl = 2.5;
      hfg = 100.0;
      Tsat0 = 1.0;
      Tsat00 = Tsat0;
      T_sup = 2.0;
      T_inf = Tsat0 + T_sup;
      _attribute[ff.i].sigma = 0.001;

      bubble_radius = 0.12;
       sprintf(Tini_file,"leontest-3-5000-0.dat");
      centerx=0.0;
      centery=0.0;
  }else if(case_number==2){
          L0_pysical = 0.0045;
          L0 = L0_pysical;
          printf("before init_grid,pid=%d\n",pid());

          originx = -0.0015-L0_pysical/((1<<maxl)*2.0);
          originy=0.0;
          origin ( (struct _origin){originx, originy});
          init_grid(1<<minl);
          printf("after init,pid=%d\n",pid());
          DT = 1e-7;


          Tkg = 0.024;
          Tkl = 0.677;
          Trhog = 0.5974;
          Trhol = 958.0;
          Tcpg = 2034.0;
          Tcpl = 4216.0;
          Tsat0 = 373.12;
          Tsat00 = Tsat0;
          T_sup = 2.0;
          Tsub= Tsat00 - 10.0;

          Twall_init = Tsat0 + T_sup;

          hfg = 2.256e6;
          Trhos= 1.4;
          Tcps=1500.0;
          Tks=1.0;

          T_inf = Tkl/Tks*(Twall_init-Tsub)*(0.5/1.0) + Twall_init;
          _attribute[ff.i].sigma = 0.058;
          mu1 = 2.82*0.0001;
          mu2 = 1.228*0.00001;
          G.x = -9.8;

          k1 = Tkl/(Trhol*Tcpl);
          k0 = Tkg/(Trhog*Tcpg);

           bubble_radius = 2e-4;

          centerx=bubble_radius*cos(50.0*3.141592653589793238/180.0);;
          centery=0.0;



          thickness = 0.001;
          theta0=50.0;

          delta_min = L0_pysical/((1<<maxl)*1.0);

}else if(case_number==3){



           sink_number = 2;

          tracex = 2.14648e-5;
          tracey = 2.03711e-5;




          L0_pysical = 0.00098;
          thickness = 0.0001;
          L0 = L0_pysical;

          Length_heat=0.004;
          bool tune_cs_flag=false;
          if(tune_cs_flag){
#line 401 "template01.c"
          }else{

            originx = -thickness;
          }

          energy_advecting_flag = false;
#line 424 "template01.c"
          double cs_min_fliud = 0.9;
          if(tune_cs_flag2){

              double p=thickness/L0_pysical*(1<<maxl);
              double pp = p - round(p);
              if(pp>0.0){
                  if((1.0-pp)<cs_min_fliud){
                     tune2_value = ((1.0-pp)-cs_min_fliud)/(1<<maxl)*L0_pysical;
                  }
              }else{
                  if(-pp<cs_min_fliud){
                      tune2_value = (-pp-cs_min_fliud)/(1<<maxl)*L0_pysical;
                  }
              }

          }

          delta_min = L0_pysical/((1<<maxl)*1.0);


          originy = 0.0;
          origin ( (struct _origin){originx, originy});
      if(surface_heat){
          init_grid(1<<minl);
      }
     if(!surface_heat){
          if(maxl == 10){
              DT = 1e-7;

          }else if(maxl == 11){
              DT = 1e-8;
          }else if(maxl == 12){
              DT = 2e-9;
          }else if(maxl == 8){
              DT = 1e-6;

          }else if(maxl == 9){
              DT = 1e-6;
          }else if(maxl == 13){
              DT = 1e-8;
          }else if(maxl ==14){
              DT = 2e-9;
          }
     }else{
          if(maxl == 10){
              DT = 1e-5;
          }else if(maxl == 11){
               DT = 1e-6;
          }else if(maxl == 12){

          }else if(maxl == 8){
              DT = 1e-5;
          }else if(maxl == 9){
              DT = 1e-6;
          }else if(maxl == 13){
              DT = 1e-8;
          }else if(maxl ==14){
              DT = 2e-9;
          }
     }
          thickbottom = 5e-5;



          groove_h=2e-5, groove_w_bottom=2e-5, groove_w_top=2e-5;


          Tkg = 0.0246;
          Tkl = 0.677;
          Trhog = 0.598;
          Trhol = 958.0;
          Tcpg = 2080.0;
          Tcpl = 4220.0;
          Tsat0 = 373.15;
          Tsat00 = Tsat0;
          T_sup = 12.55;

          hfg = 2.26e6;





          Trhos = 3980.0;
          Tcps = 929.0;
          Tks = 25.1;

          T_inf = Tsat00 + T_sup;
         _attribute[ff.i].sigma = 0.0589;

          mu1 = 2.82*0.0001;
          mu2 = 1.22*0.00001;
           G.x = -9.8;

          k1 = Tkl/(Trhol*Tcpl);
          k0 = Tkg/(Trhog*Tcpg);

          Rcc_flag_l = true;
          Rcc_flag_g = false;
          Rwater = 461.52277955158064;
          omega = 0.0345;
          Rcc = sqrt(Tsat0*Tsat0*Tsat0*2.0*3.14159265358979*Rwater)/omega/hfg/hfg/Trhog;
          printf("value of pi:%g\n",3.14159265358979);
          printf("value of Rcc:%g\n",Rcc);


           bubble_radius = 5e-6;


          centery=0.0;


          theta0=15.0;
          centerx=bubble_radius*cos(theta0*3.141592653589793238/180.0);;



              if(surface_heat){
                heat_flux = 481000.0;
              }else{
                heat_flux = 425000.0;
              }


          range_heat_flux = (1+sqrt(2.0))/2*0.0015;

}

  run();
free_solver();}

double center1 (double s0, double s1, double s2) {
  return (s2-s0)/2.0;
}

static int defaults_6_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i=0);*ip=i;*tp=t;return ret;}      static int defaults_6(const int i,const double t,Event *_ev){tracing("defaults_6","template01.c",559); {
  _attribute[ff.i].tracers = list_copy (((scalar[]){Tlff,Tgff,{-1}}));
  {scalar*_i=(scalar*)( _attribute[ff.i].tracers);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{


     _attribute[s.i].gradient = center1;
  }}}
  {scalar*_i=(scalar*) ((scalar[]){Tgff,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
    _attribute[s.i].inverse = true;
    _attribute[s.i].khaki = true;
  }}}
  {scalar*_i=(scalar*) ((scalar[]){Tlff,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
    _attribute[s.i].inverse = false;
    _attribute[s.i].khaki = false;
 }}}

 {scalar*_i=(scalar*) ((scalar[]){Tg,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
    _attribute[s.i].inverse = true;
    _attribute[s.i].khaki = true;
  }}}
  {scalar*_i=(scalar*) ((scalar[]){Ts,Tl,{-1}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
    _attribute[s.i].inverse = false;
    _attribute[s.i].khaki = false;
 }}}


     _attribute[ulf.x.i].refine = refine_face;
     _attribute[usf.x.i].refine = refine_face;
     {
        _attribute[ulf.x.i].prolongation = refine_embed_face_x;
        _attribute[usf.x.i].prolongation = refine_embed_face_x;



     }
#line 587
{
        _attribute[ulf.y.i].prolongation = refine_embed_face_y;
        _attribute[usf.y.i].prolongation = refine_embed_face_y;



     }



}{end_tracing("defaults_6","template01.c",597);return 0;}end_tracing("defaults_6","template01.c",597);}
#line 667 "template01.c"
#line 1 "distance.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
#line 18 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
#line 1 "/home/xiangbin2/basilisk_new/basilisk/src/ast/std/stdint.h"
#include <stdint.h>
#line 19 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
#line 1 "PointTriangle.h"
#line 20 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
#line 28 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
     
coord * input_stl (FILE * fp)
{tracing("input_stl","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",29);
  Array * a = array_new();
  char tag[6];

  if (fgets (tag, 6, fp) != tag) {
    fprintf (ferr, "input_stl(): error reading tag\n");
    exit(1);
  }
  rewind (fp);
  if (!strcmp (tag, "solid")) {
    fprintf (ferr, "input_stl(): ASCII STL not implemented yet "
      "(use binary instead)\n");
    exit(1);
  }
  else {
    uint32_t nf;
    char header[80];
    unsigned i;

    if (fread (header, sizeof (char), 80, fp) != 80) {
      fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: incomplete header\n");
      exit (1);
    }
    if (fread (&nf, sizeof (uint32_t), 1, fp) != 1) {
      fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing number of facets\n");
      exit (1);
    }
    i = nf;
    while (i > 0) {
      float x, y, z;
      unsigned j;
      uint16_t attbytecount;

      if (fread (&x, sizeof (float), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing normal x-coordinate\n");
 exit (1);
      }
      if (fread (&y, sizeof (float), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing normal y-coordinate\n");
 exit (1);
      }
      if (fread (&z, sizeof (float), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing normal z-coordinate\n");
 exit (1);
      }

      for (j = 0; j < 3; j++) {
 if (fread (&x, sizeof (float), 1, fp) != 1) {
   fprintf (ferr, "Input file is not a valid STL file\n"
     "stdin: missing vertex x-coordinate\n");
   exit (1);
 }
 if (fread (&y, sizeof (float), 1, fp) != 1) {
   fprintf (ferr, "Input file is not a valid STL file\n"
     "stdin: missing vertex y-coordinate\n");
   exit (1);
 }
 if (fread (&z, sizeof (float), 1, fp) != 1) {
   fprintf (ferr, "Input file is not a valid STL file\n"
     "stdin: missing vertex z-coordinate\n");
   exit (1);
 }
 coord p = {x,y,z};
 array_append (a, &p, sizeof(coord));
      }

      if (fread (&attbytecount, sizeof (uint16_t), 1, fp) != 1) {
 fprintf (ferr, "Input file is not a valid STL file\n"
        "stdin: missing attribute byte count\n");
 exit (1);
      }
      i--;
    }
  }
  coord p = {HUGE};
  array_append (a, &p, sizeof(coord));
  { coord  * _ret= (coord *) array_shrink (a);end_tracing("input_stl","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",111);return _ret;}
end_tracing("input_stl","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",112);}
#line 128 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
     
coord * input_xy (FILE * fp)
{tracing("input_xy","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",129);
  Array * a = array_new();
  coord p = {0}, last, * la = NULL;
  while (!feof(fp)) {
    if (fscanf (fp, "%lf %lf", &p.x, &p.y) == 2) {
      if (la) {
 array_append (a, la, sizeof(coord));
 array_append (a, &p, sizeof(coord));
      }
      last = p, la = &last;
    }
    else {
      int c;
      while ((c = fgetc(fp)) != EOF && c != '\n');
      la = NULL;
    }
  }
  p.x = HUGE;
  array_append (a, &p, sizeof(coord));
  { coord  * _ret= (coord *) array_shrink (a);end_tracing("input_xy","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",149);return _ret;}
end_tracing("input_xy","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",150);}





void bounding_box (coord * p, coord * min, coord * max)
{
  
    (*min).x = HUGE, (*max).x = - HUGE;
    
#line 159
(*min).y = HUGE, (*max).y = - HUGE;
  while (p->x != HUGE) {
     {
      if ((*p).x < (*min).x)
 (*min).x = (*p).x;
      if ((*p).x > (*max).x)
 (*max).x = (*p).x;
    } 
#line 161
{
      if ((*p).y < (*min).y)
 (*min).y = (*p).y;
      if ((*p).y > (*max).y)
 (*max).y = (*p).y;
    }
    p++;
  }
}








#line 188 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
typedef struct {
  double d2;
  coord * v;
  int type;
} closest_t;
#line 220 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
static void update_distance (Point point, coord ** i, scalar d)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar surface = _attribute[d.i].surface;
  Array * a = array_new();
  coord c = {x,y,z}, closest = {0};
  closest_t q[2];
  for (int i = 0; i < 2; i++)
    q[i].d2 = HUGE;
  int nd = 0;
  double r2 = sq(3.*Delta/2.);
  bool first = (level == 0);
  while (*i) {
    coord * p = *i;

    coord r;
    double s, d2 = PointSegmentDistance (&c, p, p + 1, &r, &s);




    for (int i = 0; i < 2; i++)
      if (d2 < q[i].d2) {
 for (int j = 2 - 1; j > i; j--)
   q[j] = q[j-1];
 q[i].d2 = d2, q[i].v = p;


 if (s == 0.)
   q[i].type = 0;
 else if (s == 1.)
   q[i].type = 1;
 else

   q[i].type = 3;
 if (i == 0)
   closest = r;
#line 275 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
 if (i >= nd)
   nd = i + 1;
 break;
      }

    if (d2 < r2 || first)
      array_append (a, &p, sizeof(coord *));
    first = false, i++;
  }
  if (a->len) {

    coord * p = NULL;
    array_append (a, &p, sizeof(coord *));
    p = (coord *) array_shrink (a);
    if (!(sizeof(double) >= sizeof(void *))) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/distance.h", 289, "sizeof(double) >= sizeof(void *)");
    memcpy (&val(surface,0,0,0), &p, sizeof(void *));

    int orient;

    if (q[0].type == 3)

      orient = PointSegmentOrientation (&c, q[0].v, q[0].v + 1);
    else {

      if (nd == 1)

 orient = sign(bilinear_embed(point, d));
      else {
 orient = PointSegmentOrientation (&c, q[0].v, q[0].v + 1);
 if (orient != PointSegmentOrientation (&c, q[1].v, q[1].v + 1)) {
   coord n = {0};
   for (int i = 0; i < 2; i++) {




     coord ab = ((coord){(*(q[i].v + 1)).x - (*q[i].v).x, (*(q[i].v + 1)).y - (*q[i].v).y, (*(q[i].v + 1)).z - (*q[i].v).z});
     double nn = sqrt(((ab).x*(ab).x + (ab).y*(ab).y + (ab).z*(ab).z));
     if (!(nn > 0.)) qassert ("/home/xiangbin2/basilisk_new/basilisk/src/distance.h", 313, "nn > 0.");
     n.x -= ab.y/nn, n.y += ab.x/nn;
   }





   coord diff = ((coord){(closest).x - (c).x, (closest).y - (c).y, (closest).z - (c).z});
   orient = sign(((n).x*(diff).x + (n).y*(diff).y + (n).z*(diff).z));
 }
      }
    }
#line 389 "/home/xiangbin2/basilisk_new/basilisk/src/distance.h"
    val(d,0,0,0) = sqrt (q[0].d2)*orient;
  }
  else {
    pfree (a,__func__,__FILE__,__LINE__);
    val(surface,0,0,0) = 0.;
    if (level > 0)
      val(d,0,0,0) = bilinear_embed(point, d);
    else
      val(d,0,0,0) = 0.;
  }
}



static void refine_distance (Point point, scalar d)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar surface = _attribute[d.i].surface;
  if (val(surface,0,0,0) == 0.)
    {foreach_child() {
      val(surface,0,0,0) = 0.;
      val(d,0,0,0) = bilinear_embed(point, d);
    }end_foreach_child()}
  else {
    coord ** ap = (coord **) (*((void **) &(val(surface,0,0,0))));
    int s = 0;
    {foreach_child() {
      update_distance (point, ap, d);
      s += sign(val(d,0,0,0));
    }end_foreach_child()}







    if (fabs(val(d,0,0,0)) > sqrt(2)*Delta/4.) {
      if (abs(s) != 1 << 2) {
 s = sign(s);
 {foreach_child()
   val(d,0,0,0) = s*fabs(val(d,0,0,0));end_foreach_child()}
      }
      if (sign(val(d,0,0,0)) != sign(s))
 val(d,0,0,0) = - val(d,0,0,0);
    }
  }
}

static void restriction_distance (Point point, scalar d) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;}

static void coarsen_distance (Point point, scalar d) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);POINT_VARIABLES;
  scalar surface = _attribute[d.i].surface;
  {foreach_child()
    pfree ((*((void **) &(val(surface,0,0,0)))),__func__,__FILE__,__LINE__);end_foreach_child()}
}

static void delete_distance (scalar d) {
  scalar surface = _attribute[d.i].surface;
  {foreach_level (0)
    pfree (*((void **)(*((void **) &(val(surface,0,0,0))))),__func__,__FILE__,__LINE__);end_foreach_level();}
  for (int l = 0; l <= depth(); l++)
    {foreach_level (l)
      pfree ((*((void **) &(val(surface,0,0,0)))),__func__,__FILE__,__LINE__);end_foreach_level();}
  delete (((scalar[]){surface,{-1}}));
}

     
void distance (scalar d, coord * p)
{tracing("distance","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",456);
  scalar surface = _attribute[d.i].surface;
  if (surface.i)
    delete_distance (d);
  surface = new_scalar("surface");
  _attribute[surface.i].restriction = no_restriction;

  _attribute[surface.i].prolongation = no_restriction;
  _attribute[surface.i].refine = no_restriction;
  _attribute[d.i].prolongation = refine_bilinear;
  _attribute[d.i].refine = refine_distance;
  _attribute[d.i].coarsen = coarsen_distance;
  _attribute[d.i].dirty = true;

  _attribute[d.i].surface = surface;
  _attribute[d.i].delete = delete_distance;
  _attribute[d.i].restriction = restriction_distance;

  Array * a = array_new();
  while (p->x != HUGE) {






      array_append (a, &p, sizeof (coord *));
    p += 2;
  }
  p = NULL;
  array_append (a, &p, sizeof (coord *));
  p = (coord *) array_shrink (a);

  {foreach_level(0)
    update_distance (point, (coord **) p, d);end_foreach_level();}
  pfree (p,__func__,__FILE__,__LINE__);

  boundary_level (((scalar[]){d,{-1}}), 0);
  for (int l = 0; l < depth(); l++) {
    {foreach_coarse_level (l)
      refine_distance (point, d);end_foreach_coarse_level();}
    boundary_level (((scalar[]){d,{-1}}), l + 1);
  }
end_tracing("distance","/home/xiangbin2/basilisk_new/basilisk/src/distance.h",500);}
#line 668 "template01.c"
#line 731 "template01.c"
typedef struct {
    double x, y;
} PointSolid;

double crossProduct(double x1, double y1, double x2, double y2) {
    return x1 * y2 - y1 * x2;
}

void noless_than_csfluid(double* coordxy,double originxy,double x1,double y1,double x2,double y2,bool flag_modifyx){
    double deltax = x2-x1, deltay = y2-y1;
        double A,B;

        if(flag_modifyx){
              A = 1;
              B = 0;
        }else{
              A = 0;
              B = 1;
        }
        double cp = -crossProduct(deltax, deltay, A, B);

    double cs_min_fliud = 0.9;
    if(cp<0){
        cs_min_fliud = 1.0 -cs_min_fliud;
    }
    double delta_min = L0_pysical/((1<<maxl)*1.0);
    double tunevalue=0.0;
    double p=(*coordxy-originxy)/delta_min;
    double pp = p - round(p);
    if(pp>0.0){
        if(cp > 0){

              tunevalue = ((1.0-pp)-cs_min_fliud)*delta_min;

        }else{

              tunevalue = ((1.0-pp)-cs_min_fliud)*delta_min;

        }
    }else{
        if(cp > 0){

              tunevalue = (-pp-cs_min_fliud)*delta_min;

        }else{

              tunevalue = (-pp-cs_min_fliud)*delta_min;

        }

    }
    *coordxy = *coordxy + tunevalue;

}

double signedDistance(double x1, double y1, double x2, double y2, double x0, double y0) {
    double A = x0 - x1;
    double B = y0 - y1;
    double C = x2 - x1;
    double D = y2 - y1;

    double dot = A * C + B * D;
    double len_sq = C * C + D * D;
    double param = -1;
    if (len_sq != 0) {
        param = dot / len_sq;
    }

    double xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    double dx = x0 - xx;
    double dy = y0 - yy;
    double dist = sqrt(dx * dx + dy * dy);

    double cp = crossProduct(C, D, A, B);
    if (cp < 0) {
        dist = -dist;
    }

    return dist;
}

double signedDistanceToSegmentedLine(double x0, double y0, double points[][2], int numPoints) {
    double min_d = signedDistance(points[0][0], points[0][1], points[1][0], points[1][1], x0, y0);
    double d;

    for (int i = 1; i < numPoints - 1; i++) {
        d = signedDistance(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], x0, y0);
        if (fabs(d) < fabs(min_d)) {
            min_d = d;
        }
    }

    return min_d;
}


PointSolid* addPoint(PointSolid* points, int* size, double x, double y) {
    PointSolid* temp = prealloc(points, (*size + 1) * sizeof(PointSolid),__func__,__FILE__,__LINE__);
    if (!temp) {
        perror("Failed to allocate memory");
        pfree(points,__func__,__FILE__,__LINE__);
        exit(EXIT_FAILURE);
    }
    temp[*size].x = x;
    temp[*size].y = y;
    (*size)++;
    return temp;
}

void modifyPointAtIndex(PointSolid* points, int size, int index, double newX, double newY) {
    if (index >= 0 && index < size) {
        points[index].x = newX;
        points[index].y = newY;
    } else {
        printf("Invalid index. Index must be between 0 and %d.\n", size - 1);
    }
}

void modifylasttwopoints (PointSolid* points, int size) {
    bool flag_modifyx;
    double x1,y1,x2,y2;
    x1 = points[size-2].x;
    y1 = points[size-2].y;
    x2 = points[size-1].x;
    y2 = points[size-1].y;
    double origin_value;
    double deltax = x2-x1, deltay = y2-y1;
        double A,B;
        if(fabs(deltax)<1e-20){
              flag_modifyx = true;
        }else{
              flag_modifyx = false;
        }
    if(flag_modifyx){
        origin_value = originx;
        noless_than_csfluid(&x1,origin_value,x1,y1,x2,y2,flag_modifyx);
        x2 = x1;
    }else{
        origin_value = originy;
        noless_than_csfluid(&y1,origin_value,x1,y1,x2,y2,flag_modifyx);
        y2 = y1;
    }
    int indexToModify = size - 2;
    modifyPointAtIndex(points, size, indexToModify, x1, y1);
    indexToModify = size - 1;
    modifyPointAtIndex(points, size, indexToModify, x2, y2);

}

PointSolid* generatePoints(double base, double groove_h, double groove_w_bottom, double groove_w_top, double Length, int* size) {
    *size = 0;
    PointSolid* points = NULL;
    double x = base, y = 0;

    points = addPoint(points, size, x, y);
    points = addPoint(points, size, x, y += groove_w_bottom / 2.0);
    modifylasttwopoints(points,*size);

    points = addPoint(points, size, x += groove_h, y);
    modifylasttwopoints(points,*size);

    points = addPoint(points, size, x, y += groove_w_top);
    modifylasttwopoints(points,*size);

    points = addPoint(points, size, x -= groove_h, y);
    modifylasttwopoints(points,*size);

    while (y + groove_w_bottom + groove_w_top < Length) {
        points = addPoint(points, size, x, y += groove_w_bottom);
        modifylasttwopoints(points,*size);

        points = addPoint(points, size, x += groove_h, y);
        modifylasttwopoints(points,*size);

        points = addPoint(points, size, x, y += groove_w_top);
        modifylasttwopoints(points,*size);


        points = addPoint(points, size, x -= groove_h, y);
        modifylasttwopoints(points,*size);
    }

    points = addPoint(points, size, x, y += L0);
    return points;
}
#line 950 "template01.c"
void solid_phi(double base, scalar phi){







    int size;
    double length_limit;
    length_limit = min(Length_heat,L0_pysical-2*groove_w_bottom);
    PointSolid* points = generatePoints(base, groove_h, groove_w_bottom, groove_w_top, length_limit, &size);
    foreach_vertex_stencil(){            
        


        

        _stencil_val_a(phi,0,0,0);  
    }end_foreach_vertex_stencil();
    {
#line 962
foreach_vertex(){
        double x0 = x, y0 = y;


        double min_d = -signedDistanceToSegmentedLine(x0, y0, points, size);

        val(phi,0,0,0) = min_d;
    }end_foreach_vertex();}

    pfree(points,__func__,__FILE__,__LINE__);
}




static int init_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0);*ip=i;*tp=t;return ret;}      static int init_1(const int i,const double t,Event *_ev){tracing("init_1","template01.c",977);
{

  CFL = 0.4;
  if(poisson_check){
      if(pid()==0){
           char name93[80];
            sprintf(name93,"poisson_check.dat");
            FILE * fp93 = fopen(name93,"w");
            fclose(fp93);
      }
  }
  if(point_trace){
      if(pid()==0){
           char name93[80];
            sprintf(name93,"point_trace.dat");
            FILE * fp93 = fopen(name93,"w");
            fclose(fp93);
      }
  }
  _attribute[T_oold.i].nodump = true;
  printf("hello init\n");

  if((!restartsymbol)){
     printf("hello init2\n");


       if(!surface_heat){


          if(sink_number==0){


              if(restore ((struct Dump){"../pre-lub-temperature/level9-dump-final-i51777-t0.0892672",.list = all})){
                printf("hello init 3\n");
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(uf.x,0,0,0);
                  _stencil_val_a(ulf.x,0,0,0);
                  _stencil_val_a(ugf.x,0,0,0);
                }}end__stencil_is_face_x()
#line 1012
_stencil_is_face_y(){{
                  _stencil_val_a(uf.y,0,0,0);
                  _stencil_val_a(ulf.y,0,0,0);
                  _stencil_val_a(ugf.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1012
foreach_face_generic(){is_face_x(){{
                  val(uf.x,0,0,0)=0.0;
                  val(ulf.x,0,0,0)=0.0;
                  val(ugf.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 1012
is_face_y(){{
                  val(uf.y,0,0,0)=0.0;
                  val(ulf.y,0,0,0)=0.0;
                  val(ugf.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                restart_Tsat = true;
#line 1031 "template01.c"
              }
            }else if(sink_number==1){
                 if(restore ((struct Dump){"../pre-one-sink/level10-dump-final-i252970-t0.109052",.list = all})){
                  printf("hello init 3\n");
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(uf.x,0,0,0);
                    _stencil_val_a(ulf.x,0,0,0);
                    _stencil_val_a(ugf.x,0,0,0);
                  }}end__stencil_is_face_x()
#line 1035
_stencil_is_face_y(){{
                    _stencil_val_a(uf.y,0,0,0);
                    _stencil_val_a(ulf.y,0,0,0);
                    _stencil_val_a(ugf.y,0,0,0);
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 1035
foreach_face_generic(){is_face_x(){{
                    val(uf.x,0,0,0)=0.0;
                    val(ulf.x,0,0,0)=0.0;
                    val(ugf.x,0,0,0)=0.0;
                  }}end_is_face_x()
#line 1035
is_face_y(){{
                    val(uf.y,0,0,0)=0.0;
                    val(ulf.y,0,0,0)=0.0;
                    val(ugf.y,0,0,0)=0.0;
                  }}end_is_face_y()}end_foreach_face_generic();}
                  restart_Tsat = true;
                }
            }else if(sink_number==2){

                 if(restore ((struct Dump){"../pre-multi-sinks-181-smallregion1mm/level9-dump-final-i83212-t0.0158541",.list = all})){
                  printf("hello init 3\n");
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(uf.x,0,0,0);
                    _stencil_val_a(ulf.x,0,0,0);
                    _stencil_val_a(ugf.x,0,0,0);
                  }}end__stencil_is_face_x()
#line 1046
_stencil_is_face_y(){{
                    _stencil_val_a(uf.y,0,0,0);
                    _stencil_val_a(ulf.y,0,0,0);
                    _stencil_val_a(ugf.y,0,0,0);
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 1046
foreach_face_generic(){is_face_x(){{
                    val(uf.x,0,0,0)=0.0;
                    val(ulf.x,0,0,0)=0.0;
                    val(ugf.x,0,0,0)=0.0;
                  }}end_is_face_x()
#line 1046
is_face_y(){{
                    val(uf.y,0,0,0)=0.0;
                    val(ulf.y,0,0,0)=0.0;
                    val(ugf.y,0,0,0)=0.0;
                  }}end_is_face_y()}end_foreach_face_generic();}
                  restart_Tsat = true;
                }
#line 1068 "template01.c"
            }
       }else{
          if(sink_number==1 && surface_heat_restart){
             if(restore ((struct Dump){"../pre-one-sink/level10-dump-i231971-t0.1",.list = all})){
                 printf("hello init 4\n");
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(uf.x,0,0,0);
                    _stencil_val_a(ulf.x,0,0,0);
                    _stencil_val_a(ugf.x,0,0,0);
                  }}end__stencil_is_face_x()
#line 1073
_stencil_is_face_y(){{
                    _stencil_val_a(uf.y,0,0,0);
                    _stencil_val_a(ulf.y,0,0,0);
                    _stencil_val_a(ugf.y,0,0,0);
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 1073
foreach_face_generic(){is_face_x(){{
                    val(uf.x,0,0,0)=0.0;
                    val(ulf.x,0,0,0)=0.0;
                    val(ugf.x,0,0,0)=0.0;
                  }}end_is_face_x()
#line 1073
is_face_y(){{
                    val(uf.y,0,0,0)=0.0;
                    val(ulf.y,0,0,0)=0.0;
                    val(ugf.y,0,0,0)=0.0;
                  }}end_is_face_y()}end_foreach_face_generic();}

             }
          }else if(sink_number==2 && surface_heat_restart){
#line 1090 "template01.c"
          }
       }

      if(case_number==1){

          do { int refined; do { boundary_internal ((scalar *)all, "template01.c", 1095); refined = 0; ((Tree *)grid)->refined.n = 0; {foreach_leaf() if (sq(2.*bubble_radius) - sq(x) - sq(y) > 0 && level < maxl) { refine_cell (point, all, 0, &((Tree *)grid)->refined); refined++; continue; }end_foreach_leaf();} mpi_all_reduce (refined, MPI_INT, MPI_SUM); if (refined) { mpi_boundary_refine (all); mpi_boundary_update (all); } } while (refined); } while(0)
                         ;
            level_interface = maxl;



          foreach_stencil(){
            _stencil_val_a(cs,0,0,0); 
          }end_foreach_stencil();



          {
#line 1101
foreach(){
            val(cs,0,0,0) =1.0;
          }end_foreach();}
          foreach_face_stencil(){_stencil_is_face_x(){{
            _stencil_val_a(fs.x,0,0,0); 
          }}end__stencil_is_face_x()
#line 1104
_stencil_is_face_y(){{
            _stencil_val_a(fs.y,0,0,0); 
          }}end__stencil_is_face_y()}end_foreach_face_stencil();
          {
#line 1104
foreach_face_generic(){is_face_x(){{
            val(fs.x,0,0,0) =1.0;
          }}end_is_face_x()
#line 1104
is_face_y(){{
            val(fs.y,0,0,0) =1.0;
          }}end_is_face_y()}end_foreach_face_generic();}
          boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 1107);
          cm_update (cm, cs, fs);
          fm_update (fm, cs, fs);
          restriction (((scalar[]){cm, fm.x,fm.y, cs, fs.x,fs.y,{-1}}));
#line 1124 "template01.c"
              {scalar*_i=(scalar*) ((vector[]){u,{{-1},{-1}}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
                    _attribute[s.i].third = true;
              }}}
#line 1138 "template01.c"
          foreach_stencil(){
            _stencil_val_a(css_test3_n,0,0,0);  
          }end_foreach_stencil();
#line 1138 "template01.c"
          {foreach(){
            val(css_test3_n,0,0,0) = 1.0;
          }end_foreach();}


          do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);       }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = - (sq(bubble_radius) - sq(x-tune2_value) - sq(y));end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);

          foreach_stencil(){
              _stencil_val_a(css_test3_n,0,0,0);  
              _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
              _stencil_val_a(masstr,0,0,0);  
              _stencil_val_a(source_pc,0,0,0);  
              _stencil_val_a(vtr,0,0,0);  
          }end_foreach_stencil();

          {
#line 1145
foreach(){
              val(css_test3_n,0,0,0) = 1.0;
              val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
              val(masstr,0,0,0) = 0.0;
              val(source_pc,0,0,0) = 0.0;
              val(vtr,0,0,0) = 0.0;
          }end_foreach();}





          coord * pp = input_xy (fopen (Tini_file, "r"));
            coord * ii = pp;
            scalar  T_input_flag=new_scalar("T_input_flag");
            foreach_stencil(){
              _stencil_val_a(T_input_flag,0,0,0);
            }end_foreach_stencil();
            {
#line 1160
foreach(){
              val(T_input_flag,0,0,0)=0;
            }end_foreach();}
            int num1=0;
            double aa,bb;
            double aa_old,bb_old;
            while (ii->x != HUGE) {

              printf ("%g %g\n", ii->x, ii->y);
              aa=ii->x, bb=ii->y;

                foreach_stencil(){   
                    
                  if(num1==0){ 
_stencil_val(T_input_flag,0,0,0);{
                            _stencil_val_a(T_input_flag,0,0,0);  
                            _stencil_val_a(T,0,0,0);  
                        }
                         

                  
#line 1179
}else{ 
_stencil_val(T_input_flag,0,0,0);{
                      _stencil_val_a(T_input_flag,0,0,0);
                      _stencil_val_a(T,0,0,0);    

                        }
                   
                  
#line 1185
}
                }end_foreach_stencil();

                {
#line 1171
foreach(){
                    double rr = sqrt(pow(x-centerx,2.0)+pow(y-centery,2.0));
                  if(num1==0){
                        if(rr<aa && val(T_input_flag,0,0,0)==0){
                            val(T_input_flag,0,0,0) = 1;
                            val(T,0,0,0) = bb;
                        }

                  }else{
                  if(rr<aa && val(T_input_flag,0,0,0)==0){
                      val(T_input_flag,0,0,0)=1;
                      val(T,0,0,0) = (rr-aa_old)/(aa-aa_old)*bb + (aa-rr)/(aa-aa_old)*bb_old;

                        }
                  }
                }end_foreach();}



              aa_old=aa,bb_old=bb;
              ii++;
              num1++;
            }
            int check_flag=0;
            foreach_stencil(){   
              
_stencil_val(T_input_flag,0,0,0);{
                _stencil_val_a(T,0,0,0);  
                _stencil_val_a(T_input_flag,0,0,0);  
              }
                
            
#line 1201
}end_foreach_stencil();
            {
#line 1195
foreach(){
              double rr = sqrt(pow(x-centerx,2.0)+pow(y-centery,2.0));
              if(val(T_input_flag,0,0,0)==0 && rr>=aa){
                val(T,0,0,0) = bb;
                val(T_input_flag,0,0,0) = 1;
              }
            }end_foreach();}

            foreach_stencil(){
_stencil_val(T_input_flag,0,0,0);
                      
                
                  
            
#line 1207
}end_foreach_stencil();

            
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:check_flag)){
#line 1203
foreach(){
                if(val(T_input_flag,0,0,0)==0 && (check_flag==0)){
                      check_flag=1;
                }
            }end_foreach();mpi_all_reduce_array(&check_flag,int,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
            
#line 1208
if(check_flag==1){

            }

            foreach_stencil(){
_stencil_val(ff,0,0,0);{
                    _stencil_val_a(T,0,0,0);  
              }
              
            
#line 1216
}end_foreach_stencil();

            {
#line 1212
foreach(){
              if(val(ff,0,0,0)<0.5){
                    val(T,0,0,0) = Tsat00;
              }
            }end_foreach();}

            char name93[80];
            sprintf(name93,"check-initialTlff-pid%d.dat",pid());
            FILE * fp93 = fopen(name93,"w");
            int num2=0;
            foreach_stencil(){ 

_stencil_val(T,0,0,0);   

              
            
#line 1225
}end_foreach_stencil();
            {
#line 1222
foreach(){

              fprintf (fp93,"%g %g %g\n", x, y, val(T,0,0,0));
            }end_foreach();}
            fclose(fp93);
            MPI_Barrier (MPI_COMM_WORLD);
            if(pid()==0){
                      char command1[150];
                      sprintf(command1, "LC_ALL=C cat check-initialTlff-pid*.dat > outfacets/check-initialTlff-%g",t);
                      system(command1);

                      char command7[150];
                      sprintf(command7, "LC_ALL=C rm -rf check-initialTlff-pid*.dat");
                      system(command7);
                  }delete((scalar*)((scalar[]){T_input_flag,{-1}}));

        }else if((case_number==2 || (case_number==3)) && (!restart_Tsat)){

            if(case_number==2){
                    do { int refined; do { boundary_internal ((scalar *)all, "template01.c", 1241); refined = 0; ((Tree *)grid)->refined.n = 0; {foreach_leaf() if (sq(3.*bubble_radius) - sq(x-centerx) - sq(y-centery) > 0 && level < maxl) { refine_cell (point, all, 0, &((Tree *)grid)->refined); refined++; continue; }end_foreach_leaf();} mpi_all_reduce (refined, MPI_INT, MPI_SUM); if (refined) { mpi_boundary_refine (all); mpi_boundary_update (all); } } while (refined); } while(0);
                    level_interface = maxl;
                    do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);              }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (- (sq(bubble_radius) - sq(x - tune2_value - centerx) - sq(y - centery)) );end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
                    foreach_stencil(){
                            _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
                    }end_foreach_stencil();
                    {
#line 1244
foreach(){
                            val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
                    }end_foreach();}
                    boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 1247);
                    const scalar c =  new_const_scalar("c",9, theta0*3.14159265358979/180.);
                    contact_angle = c;
                    foreach_stencil(){
                          _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
                    }end_foreach_stencil();
                    {
#line 1250
foreach(){
                          val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
                    }end_foreach();}

               }else if(case_number==3 && (!restart_Tsat)){
#line 1267 "template01.c"
                  if(1==0){
                     do { int refined; do { boundary_internal ((scalar *)all, "template01.c", 1268); refined = 0; ((Tree *)grid)->refined.n = 0; {foreach_leaf() if (x < 0.0002 && level < maxl) { refine_cell (point, all, 0, &((Tree *)grid)->refined); refined++; continue; }end_foreach_leaf();} mpi_all_reduce (refined, MPI_INT, MPI_SUM); if (refined) { mpi_boundary_refine (all); mpi_boundary_update (all); } } while (refined); } while(0);
                  }else{
                       for(int ii=1;ii<=10;ii++){
                          scalar  phi_temp3=new_vertex_scalar("phi_temp3");
                          foreach_vertex_stencil(){
                              _stencil_val_a(phi_temp3,0,0,0);  
                          }end_foreach_vertex_stencil();
                          {
#line 1272
foreach_vertex(){
                              val(phi_temp3,0,0,0) = -(x-(-thickbottom+tune2_value));
                          }end_foreach_vertex();}
                          fractions ((struct Fractions){phi_temp3, poisson_source2_f});


                            scalar  phi_temp=new_vertex_scalar("phi_temp");
                            solid_phi(tune2_value, phi_temp);
                            foreach_vertex_stencil(){
                              _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
                            }end_foreach_vertex_stencil();
                            {
#line 1280
foreach_vertex(){
                              val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
                            }end_foreach_vertex();}

                            fractions ((struct Fractions){phi_temp, css_test3, fss_test3});

                          scalar  df2=new_scalar("df2"), df3=new_scalar("df3");
                          smooth_for_arm((struct smooth1){df2,css_test3});
                          smooth_for_arm((struct smooth1){df3,poisson_source2_f});
                          adapt_wavelet ((struct Adapt){((scalar[]){df2,df3,{-1}}),(double[]){0.001,0.001}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){df3,df2,phi_temp,phi_temp3,{-1}}));
                        }
                  }





                    level_interface = maxl;
                    foreach_stencil(){
                            _stencil_val_a(ff,0,0,0);  
                    }end_foreach_stencil();
                    {
#line 1298
foreach(){
                            val(ff,0,0,0) = 1.0;
                    }end_foreach();}
                    boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 1301);
                    const scalar c =  new_const_scalar("c",10, theta0*3.14159265358979/180.);
                    contact_angle = c;
                    foreach_stencil(){
                          _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
                    }end_foreach_stencil();
                    {
#line 1304
foreach(){
                          val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
                    }end_foreach();}
            }
              _attribute[ff_oppo.i].refine=_attribute[ff_oppo.i].prolongation = fraction_refine;

                  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
                      _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
                      _attribute[c.i].dirty = true;
                  }}}

               scalar  phi_temp3=new_vertex_scalar("phi_temp3");
               foreach_vertex_stencil(){
                  _stencil_val_a(phi_temp3,0,0,0);  
               }end_foreach_vertex_stencil();
               {
#line 1316
foreach_vertex(){
                  val(phi_temp3,0,0,0) = -(x-(-thickbottom+tune2_value));
               }end_foreach_vertex();}
              fractions ((struct Fractions){phi_temp3, poisson_source2_f});




               scalar  phi_temp=new_vertex_scalar("phi_temp");




              solid_phi(tune2_value, phi_temp);
              foreach_vertex_stencil(){
                _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
              }end_foreach_vertex_stencil();
              {
#line 1330
foreach_vertex(){
                val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
              }end_foreach_vertex();}

               fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
              foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
               }end_foreach_stencil();
              {
#line 1335
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
               }end_foreach();}
               foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
              }}end__stencil_is_face_x()
#line 1339
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 1339
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
              }}end_is_face_x()
#line 1339
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}), "template01.c", 1342);
              boundary_internal ((scalar *)((scalar[]){fs_solid,{-1}}), "template01.c", 1343);
              boundary_internal ((scalar *)((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}), "template01.c", 1344);
              foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
              }end_foreach_stencil();
              {
#line 1345
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
              }end_foreach();}
              foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
              }}end__stencil_is_face_x()
#line 1348
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
              {
#line 1348
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
              }}end_is_face_x()
#line 1348
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 1351);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));


               MPI_Barrier(MPI_COMM_WORLD);
              if(case_number==2){
                  foreach_stencil(){
{{
                            _stencil_val_a(T,0,0,0);      
                        }{
                            _stencil_val_a(T,0,0,0);    
                        }}
                        
                    
#line 1367
}end_foreach_stencil();
                  {
#line 1361
foreach(){
                        if(x<0.0){
                            val(T,0,0,0) = T_inf - (T_inf - Twall_init)*(x-originx)/fabs(originx);
                        }else{
                            val(T,0,0,0) = Twall_init - (Twall_init-Tsub)*(x-0.0)/fabs(L0_pysical-fabs(originx));
                        }
                    }end_foreach();}
              }else if(case_number==3){
                if(!surface_heat_restart){
                  foreach_stencil(){
                        _stencil_val_a(T,0,0,0);  
                    }end_foreach_stencil();
                  {
#line 1370
foreach(){
                        val(T,0,0,0) = Tsat0;
                    }end_foreach();}
                }
              }
                boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 1375);
                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 1380
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 1384
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;



               foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 1400
}end_foreach_stencil();



               {
#line 1388
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}
      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 1409
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 1409
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 1409
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{
                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 1420
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 1424
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1424
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 1424
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 1433
}end_foreach_stencil();
                {
#line 1428
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 1439
}}end__stencil_is_face_x()
#line 1434
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 1439
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1434
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 1434
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));
       }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 1443
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 1450
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;




                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));

                heights(ff,hhh);

                 printf("event init 482,pid=%d\n",pid());
                      foreach_stencil(){
                        _stencil_val_a(source_pc,0,0,0);  
                        _stencil_val_a(masstr,0,0,0);
                        _stencil_val_a(vtr,0,0,0);  
                }end_foreach_stencil();
                      {
#line 1463
foreach(){
                        val(source_pc,0,0,0) = 0.0;
                        val(masstr,0,0,0)=0.0;
                        val(vtr,0,0,0) = 0.0;
                }end_foreach();}delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi_temp,phi_temp3,{-1}}));


          }else if(restart_Tsat && case_number==3){
              int maxl_temp=0;
              
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:maxl_temp)){
#line 1472
foreach(){
                  if(level>maxl_temp){
                      maxl_temp = level;
                  }
              }end_foreach();mpi_all_reduce_array(&maxl_temp,int,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
              
#line 1477
if(maxl_temp<maxl){

                    scalar  ff_temp2=new_scalar("ff_temp2");
                    double max_yy=0.0;
                    double temp2=L0/(1<<maxl);

                    max_yy = 5.0*bubble_radius;
                    srand(time(0));
                    foreach_stencil(){

_stencil_val(css_test3_n,0,0,0);{{       
                        
{{     


                            
                          _stencil_val_a(ff_temp2,0,0,0);  
                        }{
                          _stencil_val_a(ff_temp2,0,0,0);  
                        }}
                        
                      
#line 1497
}{
                        _stencil_val_a(ff_temp2,0,0,0);  
                      }}

                      

                    
#line 1501
}end_foreach_stencil();
                    {
#line 1485
foreach(){

                      if(val(css_test3_n,0,0,0)>0.0){
                        double temp = sqrt(sq(max_yy) - (sq(x) + sq(y)));
                        if(temp>0.0){


                            double randomValue = ((double)rand() / RAND_MAX-0.5);
                          val(ff_temp2,0,0,0) = randomValue*0.001;
                        }else{
                          val(ff_temp2,0,0,0) = 0.0;
                        }
                      }else{
                        val(ff_temp2,0,0,0) = 0.0;
                      }

                    }end_foreach();}


                  for(int ii=1;ii<=10;ii++){
                    scalar  phi_temp3=new_vertex_scalar("phi_temp3");
                    foreach_vertex_stencil(){
                        _stencil_val_a(phi_temp3,0,0,0);  
                    }end_foreach_vertex_stencil();
                    {
#line 1506
foreach_vertex(){
                        val(phi_temp3,0,0,0) = -(x-(-thickbottom+tune2_value));
                    }end_foreach_vertex();}
                    fractions ((struct Fractions){phi_temp3, poisson_source2_f});

                    scalar  df1=new_scalar("df1"), df2=new_scalar("df2"), df3=new_scalar("df3");
                    smooth_for_arm((struct smooth1){df1,ff});
                    smooth_for_arm((struct smooth1){df2,css_test3_n});
                    smooth_for_arm((struct smooth1){df3,poisson_source2_f});
                    adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,T,ff_temp2,df3,{-1}}),(double[]){0.001,0.001,0.01,0}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){df3,df2,df1,phi_temp3,{-1}}));
                  }delete((scalar*)((scalar[]){ff_temp2,{-1}}));
              }


              fprintf(ferr,"init restart_Tsat && case_number==3\n");
              foreach_stencil(){
                _stencil_val_a(T_oold,0,0,0); _stencil_val(T,0,0,0); 
              }end_foreach_stencil();
              {
#line 1521
foreach(){
                val(T_oold,0,0,0) = val(T,0,0,0);
              }end_foreach();}
                level_interface = maxl;
                    do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);              }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (- (sq(bubble_radius) - sq(x - tune2_value - centerx) - sq(y - centery)) );end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
                    foreach_stencil(){
                            _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
                    }end_foreach_stencil();
                    {
#line 1526
foreach(){
                            val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
                    }end_foreach();}
                    boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 1529);
                    const scalar c =  new_const_scalar("c",11, theta0*3.14159265358979/180.);
                    contact_angle = c;
                    foreach_stencil(){
                          _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
                    }end_foreach_stencil();
                    {
#line 1532
foreach(){
                          val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
                    }end_foreach();}
              _attribute[ff_oppo.i].refine=_attribute[ff_oppo.i].prolongation = fraction_refine;
              foreach_stencil(){
_stencil_val(cs,0,0,0);{
_stencil_val(ff,0,0,0);{
                          _stencil_val_a(T,0,0,0);  
                      }
                      
                  
#line 1541
}
                  
              
#line 1542
}end_foreach_stencil();
              {
#line 1536
foreach(){
                  if(val(cs,0,0,0)>=1){
                      if(val(ff,0,0,0)<=0){
                          val(T,0,0,0) = Tsat00;
                      }
                  }
              }end_foreach();}

                  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
                      _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
                      _attribute[c.i].dirty = true;
                  }}}

               scalar  phi_temp=new_vertex_scalar("phi_temp");





              solid_phi(tune2_value, phi_temp);
              foreach_vertex_stencil(){
                _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
              }end_foreach_vertex_stencil();
              {
#line 1556
foreach_vertex(){
                val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
              }end_foreach_vertex();}

              fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
              foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
               }end_foreach_stencil();
              {
#line 1561
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
               }end_foreach();}
               foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
              }}end__stencil_is_face_x()
#line 1565
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 1565
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
              }}end_is_face_x()
#line 1565
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}), "template01.c", 1568);
              boundary_internal ((scalar *)((scalar[]){fs_solid,{-1}}), "template01.c", 1569);
              boundary_internal ((scalar *)((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}), "template01.c", 1570);
              foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
              }end_foreach_stencil();
              {
#line 1571
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
              }end_foreach();}
              foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
              }}end__stencil_is_face_x()
#line 1574
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
              {
#line 1574
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
              }}end_is_face_x()
#line 1574
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 1577);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));


               MPI_Barrier(MPI_COMM_WORLD);
                boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 1586);
                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 1591
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 1595
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;

      foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 1609
}end_foreach_stencil();

      {
#line 1597
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}
      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 1618
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 1618
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 1618
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{

                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 1630
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 1634
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1634
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 1634
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 1643
}end_foreach_stencil();
                {
#line 1638
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 1649
}}end__stencil_is_face_x()
#line 1644
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 1649
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1644
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 1644
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));
          }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 1653
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 1660
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;




                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));

                heights(ff,hhh);

                 printf("event init 482,pid=%d\n",pid());
                foreach_stencil(){
                        _stencil_val_a(source_pc,0,0,0);  
                        _stencil_val_a(masstr,0,0,0);
                        _stencil_val_a(vtr,0,0,0);  
                }end_foreach_stencil();
                {
#line 1673
foreach(){
                        val(source_pc,0,0,0) = 0.0;
                        val(masstr,0,0,0)=0.0;
                        val(vtr,0,0,0) = 0.0;
                }end_foreach();}delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi_temp,{-1}}));
         }




          globali = 0;
            foreach_face_stencil(){_stencil_is_face_x(){{
              _stencil_val_a(ulf.x,0,0,0); 
              _stencil_val_a(usf.x,0,0,0); 
              _stencil_val_a(uf.x,0,0,0);  

              _stencil_val_a(ugf.x,0,0,0); 
              _stencil_val_a(usfg.x,0,0,0); 
            }}end__stencil_is_face_x()
#line 1684
_stencil_is_face_y(){{
              _stencil_val_a(ulf.y,0,0,0); 
              _stencil_val_a(usf.y,0,0,0); 
              _stencil_val_a(uf.y,0,0,0);  

              _stencil_val_a(ugf.y,0,0,0); 
              _stencil_val_a(usfg.y,0,0,0); 
            }}end__stencil_is_face_y()}end_foreach_face_stencil();
            {
#line 1684
foreach_face_generic(){is_face_x(){{
              val(ulf.x,0,0,0) =0.0;
              val(usf.x,0,0,0) =0.0;
              val(uf.x,0,0,0) = 0.0;

              val(ugf.x,0,0,0) =0.0;
              val(usfg.x,0,0,0) =0.0;
            }}end_is_face_x()
#line 1684
is_face_y(){{
              val(ulf.y,0,0,0) =0.0;
              val(usf.y,0,0,0) =0.0;
              val(uf.y,0,0,0) = 0.0;

              val(ugf.y,0,0,0) =0.0;
              val(usfg.y,0,0,0) =0.0;
            }}end_is_face_y()}end_foreach_face_generic();}

           boundary_internal ((scalar *)((vector[]){uf,ulf,usf,{{-1},{-1}}}), "template01.c", 1693);
           foreach_stencil(){
              _stencil_val_a(p,0,0,0);  
           }end_foreach_stencil();
           {
#line 1694
foreach(){
              val(p,0,0,0) = 0.;
           }end_foreach();}
           foreach_stencil(){
              {
                 _stencil_val_a(g.x,0,0,0);  
              }
#line 1698
{
                 _stencil_val_a(g.y,0,0,0);  
              }
           }end_foreach_stencil();
           {
#line 1697
foreach(){
              {
                 val(g.x,0,0,0) = 0.0;
              }
#line 1698
{
                 val(g.y,0,0,0) = 0.0;
              }
           }end_foreach();}
             {scalar*_i=(scalar*) ((vector[]){u,{{-1},{-1}}});if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){{
                    _attribute[s.i].third = true;
              }}}

          _attribute[aiml.i].refine = refine_aim;
          _attribute[aiml.i].restriction = restriction_aim;
          _attribute[aimg.i].refine = refine_aim;
          _attribute[aimg.i].restriction = restriction_aim;
#line 1726 "template01.c"
    }else if(restartsymbol && case_number==3){
        if(restore((struct Dump){"filerestart/restart-n",.list=all})){
                    level_interface = maxl;
                    const scalar c =  new_const_scalar("c",12, theta0*3.14159265358979/180.);
                    contact_angle = c;
                    foreach_stencil(){
                          _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
                    }end_foreach_stencil();
                    {
#line 1731
foreach(){
                          val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
                    }end_foreach();}
              _attribute[ff_oppo.i].refine=_attribute[ff_oppo.i].prolongation = fraction_refine;

                  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
                      _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
                      _attribute[c.i].dirty = true;
                  }}}

               scalar  phi_temp=new_vertex_scalar("phi_temp");





               solid_phi(tune2_value, phi_temp);
              foreach_vertex_stencil(){
                _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
              }end_foreach_vertex_stencil();
              {
#line 1748
foreach_vertex(){
                val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
              }end_foreach_vertex();}


               fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
              foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
               }end_foreach_stencil();
              {
#line 1754
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
               }end_foreach();}
               foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
              }}end__stencil_is_face_x()
#line 1758
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 1758
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
              }}end_is_face_x()
#line 1758
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}), "template01.c", 1761);
              boundary_internal ((scalar *)((scalar[]){fs_solid,{-1}}), "template01.c", 1762);
              boundary_internal ((scalar *)((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}), "template01.c", 1763);
              foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
              }end_foreach_stencil();
              {
#line 1764
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
              }end_foreach();}
              foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
              }}end__stencil_is_face_x()
#line 1767
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
              {
#line 1767
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
              }}end_is_face_x()
#line 1767
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 1770);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));


               MPI_Barrier(MPI_COMM_WORLD);
                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 1783
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 1787
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;

       foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 1801
}end_foreach_stencil();

       {
#line 1789
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}
      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 1810
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 1810
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 1810
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{
                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 1821
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 1825
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1825
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 1825
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 1834
}end_foreach_stencil();
                {
#line 1829
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 1840
}}end__stencil_is_face_x()
#line 1835
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 1840
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 1835
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 1835
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));
        }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 1844
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 1851
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;




                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));

                heights(ff,hhh);delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi_temp,{-1}}));
        }else{
             printf("restartsymbol error\n");
        }
    }else{
       printf("restart - istep=%d:pid=%d\n",i,pid());
    }



    metric_css_test();
    metric_css_test2();
    metric_css_test3();
  }{end_tracing("init_1","template01.c",1874);return 0;}end_tracing("init_1","template01.c",1874);}
#line 1913 "template01.c"
static int before_vof_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int before_vof_0(const int i,const double t,Event *_ev){tracing("before_vof_0","template01.c",1913);{

   get_topomask((struct Topo_m2){topo_mask});
#line 1934 "template01.c"
   mass_transfer_rate();

 }{end_tracing("before_vof_0","template01.c",1936);return 0;}end_tracing("before_vof_0","template01.c",1936);}

static int vof_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int vof_1(const int i,const double t,Event *_ev){tracing("vof_1","template01.c",1938);{

    foreach_stencil(){
    _stencil_val_a(ff_old,0,0,0); _stencil_val(ff,0,0,0); 
    _stencil_val_a(ff_old2,0,0,0); _stencil_val(ff,0,0,0); 
  }end_foreach_stencil();

    {
#line 1940
foreach(){
    val(ff_old,0,0,0) = val(ff,0,0,0);
    val(ff_old2,0,0,0) = val(ff,0,0,0);
  }end_foreach();}
  boundary_internal ((scalar *)((scalar[]){ff_old,{-1}}), "template01.c", 1944);







 fprintf(ferr,"sweep2 vof 1378\n");
                scalar  phi=new_vertex_scalar("phi");





                 solid_phi(tune2_value, phi);
                boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "template01.c", 1960);
                fractions ((struct Fractions){phi, css_test3_n, fss_test3_n});
                              foreach_stencil(){
                                  _stencil_val_a(css_test3,0,0,0); _stencil_val(css_test3_n,0,0,0);   
                                  _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                                }end_foreach_stencil();
                              {
#line 1962
foreach(){
                                  val(css_test3,0,0,0) = 1.0 - val(css_test3_n,0,0,0);
                                  val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                                }end_foreach();}
                                foreach_face_stencil(){_stencil_is_face_x(){{
                                    _stencil_val_a(fss_test3.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0);   
                                }}end__stencil_is_face_x()
#line 1966
_stencil_is_face_y(){{
                                    _stencil_val_a(fss_test3.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0);   
                                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                                {
#line 1966
foreach_face_generic(){is_face_x(){{
                                    val(fss_test3.x,0,0,0) = 1.0 - val(fss_test3_n.x,0,0,0);
                                }}end_is_face_x()
#line 1966
is_face_y(){{
                                    val(fss_test3.y,0,0,0) = 1.0 - val(fss_test3_n.y,0,0,0);
                                }}end_is_face_y()}end_foreach_face_generic();}


                  foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
                  }end_foreach_stencil();


                  {
#line 1971
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
                  }}end__stencil_is_face_x()
#line 1974
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 1974
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
                  }}end_is_face_x()
#line 1974
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
                  boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 1977);

   fprintf(ferr,"sweep2 vof 1404\n");

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));

    fprintf(ferr,"sweep2 vof 1411\n");

                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 1992
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 1996
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;
       foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 2009
}end_foreach_stencil();
       {
#line 1997
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}

      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 2019
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 2019
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 2019
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 2027
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 2034
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;


   fprintf(ferr,"sweep2 vof 1462\n");
               get_css_fss_areaslg_triple_point();
    fprintf(ferr,"sweep2 vof 1464\n");




if(dump_each_event && (i%dump_each_event_interval==0)){
        char dumpname[80];

      {
        _attribute[hhh.x.i].nodump = true;

      }
#line 2047
{
        _attribute[hhh.y.i].nodump = true;

      }
      sprintf(dumpname,"outfacets/dumpbeforevof-i%d-t%g",i,t);
      dump((struct Dump){dumpname});


}
  if(point_trace){
      double dd=-1;
      foreach_stencil(){
{ 
_stencil_val(T,0,0,0); 
           
        
#line 2061
}
          
      
#line 2062
}end_foreach_stencil();
      
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:dd)){
#line 2058
foreach(){
        if(fabs(x-tracex)<1e-6 && fabs(y-tracey)<1e-6){
           dd = val(T,0,0,0);
        }
      }end_foreach();mpi_all_reduce_array(&dd,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
      
#line 2063
if(pid()==0){
           printf("you yong!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
           char name93[80];
            sprintf(name93,"point_trace.dat");
            FILE * fp93 = fopen(name93,"a");
            fprintf(fp93,"%.8f %d %g\n",t,1,dd);
            fclose(fp93);
      }
  }

    foreach_face_stencil(){_stencil_is_face_x(){{
        _stencil_val_a(ugf.x,0,0,0);  
    }}end__stencil_is_face_x()
#line 2073
_stencil_is_face_y(){{
        _stencil_val_a(ugf.y,0,0,0);  
    }}end__stencil_is_face_y()}end_foreach_face_stencil();

    {
#line 2073
foreach_face_generic(){is_face_x(){{
        val(ugf.x,0,0,0) = 0.0;
    }}end_is_face_x()
#line 2073
is_face_y(){{
        val(ugf.y,0,0,0) = 0.0;
    }}end_is_face_y()}end_foreach_face_generic();}
#line 2091 "template01.c"
     get_topomask((struct Topo_m2){topo_mask});
     event ("properties");
#line 2118 "template01.c"
   if(energy_advecting_flag){
     foreach_stencil(){
      _stencil_val_a(Tlff,0,0,0);_stencil_val(ff,0,0,0);  
      _stencil_val_a(Tgff,0,0,0);_stencil_val(ff,0,0,0);  
      _stencil_val_a(T_solid,0,0,0);
_stencil_val(css_test3_n,0,0,0);{{
        _stencil_val_a(Tlff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
        _stencil_val_a(Tgff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
      }{
        _stencil_val_a(Tlff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
        _stencil_val_a(Tgff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
      }}

_stencil_val(css_test3_n,0,0,0);{
          _stencil_val_a(T_solid,0,0,0);_stencil_val(T,0,0,0);
      }  
      

      
   
#line 2134
}end_foreach_stencil();
     {
#line 2119
foreach(){
      val(Tlff,0,0,0) = Tsat00*(val(ff,0,0,0))*Trhol*Tcpl;
      val(Tgff,0,0,0) = Tsat00*(1.0-val(ff,0,0,0))*Trhog*Tcpg;
      val(T_solid,0,0,0) = Tsat00*Trhos*Tcps;
      if(val(css_test3_n,0,0,0)>0.0){
        val(Tlff,0,0,0) = val(T,0,0,0)*val(ff,0,0,0)*Trhol*Tcpl;
        val(Tgff,0,0,0) = val(T,0,0,0)*(1.0-val(ff,0,0,0))*Trhog*Tcpg;
      }else{
        val(Tlff,0,0,0) = val(T,0,0,0)*val(ff,0,0,0)*Trhol*Tcpl;
        val(Tgff,0,0,0) = val(T,0,0,0)*(1.0-val(ff,0,0,0))*Trhog*Tcpg;
      }

      if(val(css_test3_n,0,0,0)<1.0){
          val(T_solid,0,0,0)=val(T,0,0,0)*Trhos*Tcps;
      }
   }end_foreach();}
}else{
    if((!use_Tslg) || (i<=83212)){
        foreach_stencil(){
          _stencil_val_a(Tlff,0,0,0);_stencil_val(ff,0,0,0);  
          _stencil_val_a(Tgff,0,0,0);_stencil_val(ff,0,0,0);  
          _stencil_val_a(T_solid,0,0,0);
_stencil_val(css_test3_n,0,0,0);{{
_stencil_val(ff,0,0,0);{
                _stencil_val_a(Tlff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
            }
_stencil_val(ff,0,0,0);{
                _stencil_val_a(Tgff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
            }
            
            
          
#line 2148
}{
            _stencil_val_a(Tlff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
            _stencil_val_a(Tgff,0,0,0); _stencil_val(T,0,0,0);_stencil_val(ff,0,0,0); 
          }}

_stencil_val(css_test3_n,0,0,0);{{
              _stencil_val_a(T_solid,0,0,0);_stencil_val(T,0,0,0);
          }{
              _stencil_val_a(T_solid,0,0,0);_stencil_val(T,0,0,0);
          }}  
          

          
      
#line 2158
}end_foreach_stencil();
        {
#line 2137
foreach(){
          val(Tlff,0,0,0) = Tsat00*(val(ff,0,0,0));
          val(Tgff,0,0,0) = Tsat00*(1.0-val(ff,0,0,0));
          val(T_solid,0,0,0) = Tsat00;
          if(val(css_test3_n,0,0,0)>0.5){
            if(val(ff,0,0,0)>=0.5){
                val(Tlff,0,0,0) = val(T,0,0,0)*val(ff,0,0,0);
            }
            if(val(ff,0,0,0)<0.5){
                val(Tgff,0,0,0) = val(T,0,0,0)*(1.0-val(ff,0,0,0));
            }
          }else{
            val(Tlff,0,0,0) = val(T,0,0,0)*val(ff,0,0,0);
            val(Tgff,0,0,0) = val(T,0,0,0)*(1.0-val(ff,0,0,0));
          }

          if(val(css_test3_n,0,0,0)<=0.5){
              val(T_solid,0,0,0)=val(T,0,0,0);
          }else{
              val(T_solid,0,0,0)=val(T,0,0,0);
          }
      }end_foreach();}
    }else{
         foreach_stencil(){
            _stencil_val_a(Tlff,0,0,0); _stencil_val(Tl,0,0,0);_stencil_val(ff,0,0,0); 
            _stencil_val_a(Tgff,0,0,0); _stencil_val(Tg,0,0,0);_stencil_val(ff,0,0,0); 
            _stencil_val_a(T_solid,0,0,0); _stencil_val(Ts,0,0,0); 
        }end_foreach_stencil();
         {
#line 2160
foreach(){
            val(Tlff,0,0,0) = val(Tl,0,0,0)*(val(ff,0,0,0));
            val(Tgff,0,0,0) = val(Tg,0,0,0)*(1.0-val(ff,0,0,0));
            val(T_solid,0,0,0) = val(Ts,0,0,0);
        }end_foreach();}
    }
 }

   _attribute[Tlff.i].restriction = restriction_Tlff;
   _attribute[Tgff.i].restriction = restriction_Tgff;
  _attribute[Tlff.i].refine = _attribute[Tlff.i].prolongation = conservative_refine;
  _attribute[Tgff.i].refine = _attribute[Tgff.i].prolongation = conservative_refine;


   boundary_internal ((scalar *)((scalar[]){Tlff,Tgff,{-1}}), "template01.c", 2174);delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi,{-1}}));





}{end_tracing("vof_1","template01.c",2180);return 0;}end_tracing("vof_1","template01.c",2180);}




static int after_vof_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int after_vof_0(const int i,const double t,Event *_ev){tracing("after_vof_0","template01.c",2185);{
#line 2197 "template01.c"
if(energy_advecting_flag){
    foreach_stencil(){   
      
      
      
_stencil_val(css_test3_n,0,0,0);{
_stencil_val(ff,0,0,0);{ 
_stencil_val(Tlff,0,0,0); 
             _stencil_val(ff,0,0,0); 
            
         
#line 2206
}
_stencil_val(ff,0,0,0);{ 
_stencil_val(Tgff,0,0,0);
             _stencil_val(ff,0,0,0);
              
         
#line 2210
} 
         
         
           
      
#line 2212
}



_stencil_val(css_test3_n,0,0,0);{{
          _stencil_val_a(T,0,0,0);_stencil_val(css_test3_n,0,0,0); _stencil_val(T_solid,0,0,0);_stencil_val(css_test3_n,0,0,0);   
      }{
          _stencil_val_a(T,0,0,0);  
      }}
      



      
   
#line 2221
}end_foreach_stencil();
    {
#line 2198
foreach(){
      double val_tot=0.0;
      double wei=0.0;
      double val1=0.0;
      if(val(css_test3_n,0,0,0)>0.0){
         if(val(ff,0,0,0)>0.0){
            val_tot += val(Tlff,0,0,0);
            wei += val(ff,0,0,0)*Trhol*Tcpl;
         }
         if(1.0-val(ff,0,0,0)>0.0){
            val_tot += val(Tgff,0,0,0);
            wei += (1.0-val(ff,0,0,0))*Trhog*Tcpg;
         }
          val1 = val_tot/wei;
      }



      if(val(css_test3_n,0,0,0)<1.0){
          val(T,0,0,0) = val1*val(css_test3_n,0,0,0) + val(T_solid,0,0,0)/(Trhos*Tcps)*(1.0-val(css_test3_n,0,0,0));
      }else{
          val(T,0,0,0) = val1;
      }
   }end_foreach();}
   }else{
      foreach_stencil(){   
          
          
          
_stencil_val(css_test3_n,0,0,0);{{
              _stencil_val_a(T,0,0,0); _stencil_val(T_solid,0,0,0); 
          }{
_stencil_val(ff,0,0,0);{{
                  _stencil_val_a(T,0,0,0); _stencil_val(Tlff,0,0,0);_stencil_val(ff,0,0,0); 
              }{
                  _stencil_val_a(T,0,0,0); _stencil_val(Tgff,0,0,0);_stencil_val(ff,0,0,0); 
              }}
              
          
#line 2235
}}
          
      
#line 2236
}end_foreach_stencil();
      {
#line 2223
foreach(){
          double val_tot=0.0;
          double wei=0.0;
          double val1=0.0;
          if(val(css_test3_n,0,0,0)<=0.5){
              val(T,0,0,0) = val(T_solid,0,0,0);
          }else{
              if(val(ff,0,0,0)>=0.5){
                  val(T,0,0,0) = val(Tlff,0,0,0)/val(ff,0,0,0);
              }else{
                  val(T,0,0,0) = val(Tgff,0,0,0)/(1.0-val(ff,0,0,0));
              }
          }
      }end_foreach();}
      if(use_Tslg){
          foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
_stencil_val(ff,0,0,0);{{
                    _stencil_val_a(Tl,0,0,0); _stencil_val(Tlff,0,0,0);_stencil_val(ff,0,0,0);
_stencil_val(Tl,0,0,0);{
                        _stencil_val_a(Tl,0,0,0);
                    } 
                    
                
#line 2245
}{
                  _stencil_val_a(Tl,0,0,0);
                }}
_stencil_val(ff,0,0,0);{{
                    _stencil_val_a(Tg,0,0,0); _stencil_val(Tgff,0,0,0);_stencil_val(ff,0,0,0);
_stencil_val(Tg,0,0,0);{
                        _stencil_val_a(Tg,0,0,0);
                    } 
                    
                
#line 2253
}{
                  _stencil_val_a(Tg,0,0,0);
                }}
                
                
            
#line 2256
}{
                _stencil_val_a(Tl,0,0,0);
                _stencil_val_a(Tg,0,0,0);
            }}
            
          
#line 2260
}end_foreach_stencil();
          {
#line 2238
foreach(){
            if(val(css_test3_n,0,0,0)>0.0){
                if(val(ff,0,0,0)>0.0){
                    val(Tl,0,0,0) = val(Tlff,0,0,0)/val(ff,0,0,0);
                    if(val(Tl,0,0,0)<Tsat00){
                        val(Tl,0,0,0)=Tsat00;
                    }
                }else{
                  val(Tl,0,0,0)=Tsat00;
                }
                if(val(ff,0,0,0)<1.0){
                    val(Tg,0,0,0) = val(Tgff,0,0,0)/(1.0-val(ff,0,0,0));
                    if(val(Tg,0,0,0)<Tsat00){
                        val(Tg,0,0,0)=Tsat00;
                    }
                }else{
                  val(Tg,0,0,0)=Tsat00;
                }
            }else{
                val(Tl,0,0,0)=Tsat00;
                val(Tg,0,0,0)=Tsat00;
            }
          }end_foreach();}
      }
}
 across_interface(ff_old,ff,T);
if(dump_each_event && (i%dump_each_event_interval==0)){
            char dumpname[80];

        {
          _attribute[hhh.x.i].nodump = true;

        }
#line 2267
{
          _attribute[hhh.y.i].nodump = true;

        }




        sprintf(dumpname,"outfacets/dumpaftervof-i%d-t%g",i,t);

        dump((struct Dump){dumpname});
}

  if(point_trace){
     double dd=-1;
      foreach_stencil(){
{ 
_stencil_val(T,0,0,0); 
           
        
#line 2285
}
          
      
#line 2286
}end_foreach_stencil();
      
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:dd)){
#line 2282
foreach(){
        if(fabs(x-tracex)<1e-6 && fabs(y-tracey)<1e-6){
           dd = val(T,0,0,0);
        }
      }end_foreach();mpi_all_reduce_array(&dd,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
      
#line 2287
if(pid()==0){
           char name93[80];
            sprintf(name93,"point_trace.dat");
            FILE * fp93 = fopen(name93,"a");
            fprintf(fp93,"%.8f %d %g\n",t,2,dd);
            fclose(fp93);
      }
  }

  foreach_stencil(){
    _stencil_val_a(ff_old,0,0,0); _stencil_val(ff,0,0,0); 
  }end_foreach_stencil();

  {
#line 2296
foreach(){
    val(ff_old,0,0,0) = val(ff,0,0,0);
  }end_foreach();}
  boundary_internal ((scalar *)((scalar[]){ff_old,{-1}}), "template01.c", 2299);

      boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 2301);

      event ("properties");
      get_topomask((struct Topo_m2){topo_mask});
      LevelSetShift2VOFChange(dt);


      double over_half=1e-2;
      double base=0.6;
      mov_interface_dc(flag_topos_advect_uf,flag_cant_smaller_than_half,base,over_half);



       foreach_stencil(){
          _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
      }end_foreach_stencil();



       {
#line 2314
foreach(){
          val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
      }end_foreach();}
      boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 2317);
      get_topomask_soilid((struct Topo_m3){topo_mask_s,css_test3,level_interface});
      if(flag_cant_smaller_than_half){
          foreach_stencil(){ 
              

              {foreach_neighbor(2){
_stencil_val(intersect_true,0,0,0);
                      
                  
                  
              
#line 2327
}end_foreach_neighbor()}
_stencil_val(topo_mask_s,0,0,0);{
_stencil_val(ff,0,0,0);{
_stencil_val(ff_old2,0,0,0);{{
                        _stencil_val_a(ff,0,0,0); _stencil_val(ff_old2,0,0,0); 
                      }{
_stencil_val(ff_old2,0,0,0);{{
                            _stencil_val_a(ff,0,0,0);  
                        }{
                            _stencil_val_a(ff,0,0,0);  
                        }}
                        
                      
#line 2338
}}
                      
                  
#line 2339
}
                  
              
#line 2340
}
                
          
#line 2341
}end_foreach_stencil();
          {
#line 2320
foreach(){
              bool flag=false;

              {foreach_neighbor(2){
                  if(val(intersect_true,0,0,0)==1){
                      flag=true;
                  }
              }end_foreach_neighbor()}
              if(val(topo_mask_s,0,0,0)==0 && (!flag)){
                  if(val(ff,0,0,0)<base){
                      if(val(ff_old2,0,0,0)>=base+over_half){
                        val(ff,0,0,0) = val(ff_old2,0,0,0);
                      }else{
                        if(val(ff_old2,0,0,0)<=1e-6){
                            val(ff,0,0,0) = 0.0;
                        }else{
                            val(ff,0,0,0) = base+over_half;
                        }
                      }
                  }
              }
          }end_foreach();}
      }


      foreach_stencil(){
          _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
      }end_foreach_stencil();


      {
#line 2345
foreach(){
          val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
      }end_foreach();}
      boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 2348);
       across_interface(ff_old,ff,T);
    event ("properties");
    get_topomask((struct Topo_m2){topo_mask});

if(dump_each_event && (i%dump_each_event_interval==0)){
          char dumpname2[80];

        {
          _attribute[hhh.x.i].nodump = true;

        }
#line 2356
{
          _attribute[hhh.y.i].nodump = true;

        }
        sprintf(dumpname2,"outfacets/dumpafterlevel-i%d-t%g",i,t);
        dump((struct Dump){dumpname2});
}
  if(point_trace){
      double dd=-1;
      foreach_stencil(){
{ 
_stencil_val(T,0,0,0); 
           
        
#line 2368
}
          
      
#line 2369
}end_foreach_stencil();
      
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:dd)){
#line 2365
foreach(){
        if(fabs(x-tracex)<1e-6 && fabs(y-tracey)<1e-6){
           dd = val(T,0,0,0);
        }
      }end_foreach();mpi_all_reduce_array(&dd,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
      
#line 2370
if(pid()==0){
           char name93[80];
            sprintf(name93,"point_trace.dat");
            FILE * fp93 = fopen(name93,"a");
            fprintf(fp93,"%.8f %d %g\n",t,3,dd);
            fclose(fp93);
      }
  }

    scalar  ff_remove=new_scalar("ff_remove");
    foreach_stencil(){
      _stencil_val_a(ff_remove,0,0,0);
_stencil_val(cs,0,0,0);{
        _stencil_val_a(ff_remove,0,0,0); _stencil_val(ff,0,0,0); 
      }
      
    
#line 2385
}end_foreach_stencil();
    {
#line 2380
foreach(){
      val(ff_remove,0,0,0)=0.0;
      if(val(cs,0,0,0)>0.0){
        val(ff_remove,0,0,0) = val(ff,0,0,0);
      }
    }end_foreach();}
    remove_droplets ((struct RemoveDroplets){ff_remove,3,1e-10, false});
    foreach_stencil(){
_stencil_val(cs,0,0,0);{
          _stencil_val_a(ff,0,0,0); _stencil_val(ff_remove,0,0,0); 
       }
       
    
#line 2391
}end_foreach_stencil();
    {
#line 2387
foreach(){
       if(val(cs,0,0,0)>0.0){
          val(ff,0,0,0) = val(ff_remove,0,0,0);
       }
    }end_foreach();}delete((scalar*)((scalar[]){ff_remove,{-1}}));



}{end_tracing("after_vof_0","template01.c",2395);return 0;}end_tracing("after_vof_0","template01.c",2395);}

static int diffusionT_one_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int diffusionT_one_0(const int i,const double t,Event *_ev){tracing("diffusionT_one_0","template01.c",2397);{
#line 2428 "template01.c"
   foreach_stencil(){
      _stencil_val_a(cs,0,0,0);  
    }end_foreach_stencil();
#line 2428 "template01.c"
   {foreach(){
      val(cs,0,0,0) = 1.0;
    }end_foreach();}
    foreach_face_stencil(){_stencil_is_face_x(){{
      _stencil_val_a(fs.x,0,0,0);  
    }}end__stencil_is_face_x()
#line 2431
_stencil_is_face_y(){{
      _stencil_val_a(fs.y,0,0,0);  
    }}end__stencil_is_face_y()}end_foreach_face_stencil();
    {
#line 2431
foreach_face_generic(){is_face_x(){{
      val(fs.x,0,0,0) = 1.0;
    }}end_is_face_x()
#line 2431
is_face_y(){{
      val(fs.y,0,0,0) = 1.0;
    }}end_is_face_y()}end_foreach_face_generic();}
    boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 2434);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));

  _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;

   scalar  phi30=new_vertex_scalar("phi30");
   boundary_internal ((scalar *)((scalar[]){fs_solid,{-1}}), "template01.c", 2444);
   vof2dist(fs_solid, phi30);
   fractions ((struct Fractions){phi30, css_test3, fss_test3});
   boundary_internal ((scalar *)((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}), "template01.c", 2447);
   scalar  tempfs=new_scalar("tempfs");
   foreach_stencil(){
       _stencil_val_a(tempfs,0,0,0); _stencil_val(fs_solid,0,0,0); 
       _stencil_val_a(fs_solid,0,0,0); _stencil_val(tempfs,0,0,0);   
   }end_foreach_stencil();
   {
#line 2449
foreach(){
       val(tempfs,0,0,0) = val(fs_solid,0,0,0);
       val(fs_solid,0,0,0) = 1.0 - val(tempfs,0,0,0);
   }end_foreach();}
   scalar  phi31=new_vertex_scalar("phi31");
   boundary_internal ((scalar *)((scalar[]){fs_solid,{-1}}), "template01.c", 2454);
   vof2dist(fs_solid, phi31);
   fractions ((struct Fractions){phi31, css_test3_n, fss_test3_n});
   boundary_internal ((scalar *)((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}), "template01.c", 2457);
   foreach_stencil(){
       _stencil_val_a(fs_solid,0,0,0); _stencil_val(tempfs,0,0,0); 
   }end_foreach_stencil();
   {
#line 2458
foreach(){
       val(fs_solid,0,0,0) = val(tempfs,0,0,0);
   }end_foreach();}

                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 2465
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 2469
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;

      foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 2483
}end_foreach_stencil();

      {
#line 2471
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}
      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 2492
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 2492
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 2492
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{
                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 2503
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 2507
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 2507
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 2507
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 2516
}end_foreach_stencil();
                {
#line 2511
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 2522
}}end__stencil_is_face_x()
#line 2517
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 2522
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 2517
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 2517
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));

          }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 2527
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 2534
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;




                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));

                heights(ff,hhh);
#line 2565 "template01.c"
  get_modphase01_2((struct Threephases){ff,modphase1,modphase0});
  get_css_fss_areaslg_triple_point();


    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));
    cm_css_test_update (cm_css_test, css_test, fss_test);
    fm_fss_test_update (fm_fss_test, css_test, fss_test);
    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));



    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));
    cm_css_test2_update (cm_css_test2, css_test2, fss_test2);
    fm_fss_test2_update (fm_fss_test2, css_test2, fss_test2);
    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));



    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));
    cm_css_test3_update (cm_css_test3, css_test3, fss_test3);
    fm_fss_test3_update (fm_fss_test3, css_test3, fss_test3);
    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));


  foreach_stencil(){
    {
      _stencil_val_a(smallmodl.x,0,0,0);
      _stencil_val_a(bigmodl.x,0,0,0);
      _stencil_val_a(smallmodg.x,0,0,0);
      _stencil_val_a(bigmodg.x,0,0,0);

    }
#line 2590
{
      _stencil_val_a(smallmodl.y,0,0,0);
      _stencil_val_a(bigmodl.y,0,0,0);
      _stencil_val_a(smallmodg.y,0,0,0);
      _stencil_val_a(bigmodg.y,0,0,0);

    }
}end_foreach_stencil();


  {
#line 2589
foreach(){
    {
      val(smallmodl.x,0,0,0)=-10.0;
      val(bigmodl.x,0,0,0)=-10.0;
      val(smallmodg.x,0,0,0)=-10.0;
      val(bigmodg.x,0,0,0)=-10.0;

    }
#line 2590
{
      val(smallmodl.y,0,0,0)=-10.0;
      val(bigmodl.y,0,0,0)=-10.0;
      val(smallmodg.y,0,0,0)=-10.0;
      val(bigmodg.y,0,0,0)=-10.0;

    }
}end_foreach();}



  vector  D=new_face_vector("D");

  scalar  tag_phase=new_scalar("tag_phase");
  scalar  T_old=new_scalar("T_old");
#line 2615 "template01.c"
  get_topomask((struct Topo_m2){topo_mask});
  restriction(((scalar[]){ff,{-1}}));

 event ("properties") ;
#line 2709 "template01.c"
    for(phase_flag3=0;phase_flag3<=1;phase_flag3++){
#line 2781 "template01.c"
          }
#line 2855 "template01.c"
        scalar  phi_temp2=new_vertex_scalar("phi_temp2");

               foreach_vertex_stencil(){

                  _stencil_val_a(phi_temp2,0,0,0);  

               }end_foreach_vertex_stencil();

               {
#line 2857
foreach_vertex(){

                  val(phi_temp2,0,0,0) = -(x-(-thickbottom+tune2_value));

               }end_foreach_vertex();}
        vector  poisson_source2_f_fs=new_face_vector("poisson_source2_f_fs");
               fractions ((struct Fractions){phi_temp2, poisson_source2_f, poisson_source2_f_fs});
              foreach_stencil(){
                    _stencil_val_a(poisson_source2_f,0,0,0);_stencil_val(poisson_source2_f,0,0,0);     
               }end_foreach_stencil();
              {
#line 2864
foreach(){
                    val(poisson_source2_f,0,0,0) = clamp (val(poisson_source2_f,0,0,0), 0., 1.);
               }end_foreach();}

       foreach_stencil(){
           _stencil_val_a(poisson_source2,0,0,0);  
       }end_foreach_stencil();

       {
#line 2868
foreach(){
           val(poisson_source2,0,0,0) = 0.0;
       }end_foreach();}
       double percent_s=1.0,percent_l=0.0,percent_g=0.0;
       if(surface_heat){
          foreach_stencil(){
_stencil_val(poisson_source2_f,0,0,0); _stencil_val(poisson_source2_f,0,0,0);{  
                   _stencil_mycs (point, poisson_source2_f);     
                  _stencil_val(poisson_source2_f,0,0,0);    
                  
                   
                  
                       

                  

                    _stencil_val_a(poisson_source2,0,0,0);  
            }
             
          
#line 2886
}end_foreach_stencil();
          {
#line 2873
foreach(){
            if(val(poisson_source2_f,0,0,0)>0 && val(poisson_source2_f,0,0,0)<1.0){
                  coord n = mycs (point, poisson_source2_f);
                  double alphaa = line_alpha (val(poisson_source2_f,0,0,0), n);
                  coord pp;
                  double area1 = line_length_center(n,alphaa,&pp);
                  if (metric_embed_factor){
                      area1 *= metric_embed_factor (point, pp);

                  }

                    val(poisson_source2,0,0,0) = max(heat_flux*(1.0-y/Length_heat),0.0)*area1/Delta;
            }
          }end_foreach();}
       }else{
          foreach_stencil(){
_stencil_val(poisson_source2_f,0,0,0); _stencil_val(poisson_source2_f,0,0,0);{  
                   _stencil_mycs (point, poisson_source2_f);     
                  _stencil_val(poisson_source2_f,0,0,0);    
                  
                   
                  
                       

                  


                    _stencil_val_a(poisson_source2,0,0,0);  
            }
             
          
#line 2902
}end_foreach_stencil();
          {
#line 2888
foreach(){
            if(val(poisson_source2_f,0,0,0)>0 && val(poisson_source2_f,0,0,0)<1.0){
                  coord n = mycs (point, poisson_source2_f);
                  double alphaa = line_alpha (val(poisson_source2_f,0,0,0), n);
                  coord pp;
                  double area1 = line_length_center(n,alphaa,&pp);
                  if (metric_embed_factor){
                      area1 *= metric_embed_factor (point, pp);

                  }


                    val(poisson_source2,0,0,0) = ((y<range_heat_flux?(heat_flux):0.0)*area1/Delta);
            }
          }end_foreach();}
       }
#line 2962 "template01.c"
       foreach_stencil(){

_stencil_val(css_test3_n,0,0,0);{
_stencil_val(ff,0,0,0);{
                      _stencil_val_a(T,0,0,0);  
                   }
                  
          
#line 2968
}

             
      
#line 2969
}end_foreach_stencil();
#line 2962 "template01.c"
       {foreach(){

             if(val(css_test3_n,0,0,0)>=1.0){
                  if(fabs(val(ff,0,0,0)-0.5)<1e-6){
                      val(T,0,0,0) = Tsat00;
                   }
          }
      }end_foreach();}
#line 3004 "template01.c"
    foreach_stencil(){
      _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
    }end_foreach_stencil();
#line 3004 "template01.c"
    {foreach(){
      val(cs,0,0,0) = val(css_test3_n,0,0,0);
    }end_foreach();}
    foreach_face_stencil(){_stencil_is_face_x(){{
      _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
    }}end__stencil_is_face_x()
#line 3007
_stencil_is_face_y(){{
      _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
    }}end__stencil_is_face_y()}end_foreach_face_stencil();
    {
#line 3007
foreach_face_generic(){is_face_x(){{
      val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
    }}end_is_face_x()
#line 3007
is_face_y(){{
      val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
    }}end_is_face_y()}end_foreach_face_generic();}
    boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 3010);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));


     event ("properties") ;





   get_modphase01_2((struct Threephases){css_test3,modphase_s_1,modphase_s_0});

   get_css_fss_areaslg_triple_point();

    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));
    cm_css_test_update (cm_css_test, css_test, fss_test);
    fm_fss_test_update (fm_fss_test, css_test, fss_test);
    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));


    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));
    cm_css_test2_update (cm_css_test2, css_test2, fss_test2);
    fm_fss_test2_update (fm_fss_test2, css_test2, fss_test2);
    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));


    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));
    cm_css_test3_update (cm_css_test3, css_test3, fss_test3);
    fm_fss_test3_update (fm_fss_test3, css_test3, fss_test3);
    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));


  if(!use_Tslg){
      foreach_stencil(){



            _stencil_val_a(Tl,0,0,0);  
            _stencil_val_a(Tg,0,0,0);  
            _stencil_val_a(Ts,0,0,0);
_stencil_val(css_test3,0,0,0);{{
                  _stencil_val_a(Ts,0,0,0); _stencil_val(T,0,0,0); 
            }{
_stencil_val(css_test,0,0,0);{
                    _stencil_val_a(Tl,0,0,0); _stencil_val(T,0,0,0); 
                }
_stencil_val(css_test2,0,0,0);{
                    _stencil_val_a(Tg,0,0,0); _stencil_val(T,0,0,0); 
                }
                
                
            
#line 3063
}}  
            
        
#line 3064
}end_foreach_stencil();
      {
#line 3047
foreach(){



            val(Tl,0,0,0) = Tsat00;
            val(Tg,0,0,0) = Tsat00;
            val(Ts,0,0,0) = Tsat00;
            if(val(css_test3,0,0,0)>=0.5){
                  val(Ts,0,0,0) = val(T,0,0,0);
            }else{
                if(val(css_test,0,0,0)>=0.5){
                    val(Tl,0,0,0) = val(T,0,0,0);
                }
                if(val(css_test2,0,0,0)>=0.5){
                    val(Tg,0,0,0) = val(T,0,0,0);
                }
            }
        }end_foreach();}
        boundary_internal ((scalar *)((scalar[]){Ts,Tl,Tg,{-1}}), "template01.c", 3065);
  }else{

  }
   solver_new(poisson_source2,percent_s,percent_l,percent_g);
   foreach_stencil(){
_stencil_val(css_test3,0,0,0);{{
          _stencil_val_a(T,0,0,0); _stencil_val(Ts,0,0,0); 
      }{
_stencil_val(css_test,0,0,0);_stencil_val(css_test2,0,0,0);{{
              _stencil_val_a(T,0,0,0); _stencil_val(Tl,0,0,0); 
          }{
              _stencil_val_a(T,0,0,0); _stencil_val(Tg,0,0,0); 
          }}
          
      
#line 3079
}}
      
   
#line 3080
}end_foreach_stencil();
   {
#line 3070
foreach(){
      if(val(css_test3,0,0,0)>=0.5){
          val(T,0,0,0) = val(Ts,0,0,0);
      }else{
          if(val(css_test,0,0,0)>=val(css_test2,0,0,0)){
              val(T,0,0,0) = val(Tl,0,0,0);
          }else{
              val(T,0,0,0) = val(Tg,0,0,0);
          }
      }
   }end_foreach();}
   boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 3081);delete((scalar*)((scalar[]){poisson_source2_f_fs.x,poisson_source2_f_fs.y,phi_temp2,T_old,tag_phase,D.x,D.y,fs_temp.x,fs_temp.y,phi31,tempfs,phi30,{-1}}));

}{end_tracing("diffusionT_one_0","template01.c",3083);return 0;}end_tracing("diffusionT_one_0","template01.c",3083);}




static int poisson_ps_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int poisson_ps_0(const int i,const double t,Event *_ev){tracing("poisson_ps_0","template01.c",3088);{




 get_topomask((struct Topo_m2){topo_mask});
 event ("properties");




 foreach_face_stencil(){_stencil_is_face_x(){{
    _stencil_val_a(usf.x,0,0,0);  
    _stencil_val_a(usfg.x,0,0,0);  
 }}end__stencil_is_face_x()
#line 3099
_stencil_is_face_y(){{
    _stencil_val_a(usf.y,0,0,0);  
    _stencil_val_a(usfg.y,0,0,0);  
 }}end__stencil_is_face_y()}end_foreach_face_stencil();




 {
#line 3099
foreach_face_generic(){is_face_x(){{
    val(usf.x,0,0,0) = 0.0;
    val(usfg.x,0,0,0) = 0.0;
 }}end_is_face_x()
#line 3099
is_face_y(){{
    val(usf.y,0,0,0) = 0.0;
    val(usfg.y,0,0,0) = 0.0;
 }}end_is_face_y()}end_foreach_face_generic();}

if(i>=0){
   if(!restartsymbol){

        if(!(case_number==3 && (!restart_Tsat))){
             if(1==1){

                    foreach_stencil() {
                      _stencil_val_a(div_numerical,0,0,0);
_stencil_val(cs,0,0,0); _stencil_val(topo_mask,0,0,0);{
                          
                            {_stencil_val_r(div_numerical,0,0,0); _stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);  }
                            
#line 3114
{_stencil_val_r(div_numerical,0,0,0); _stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);  }

                          _stencil_val_r(div_numerical,0,0,0);  
                      }  
                       
                    
#line 3118
}end_foreach_stencil();

                    {
#line 3110
foreach() {
                      val(div_numerical,0,0,0) = 0.;
                      if(val(cs,0,0,0)>0.0 && val(topo_mask,0,0,0)==0){
                          
                            val(div_numerical,0,0,0) += val(uf.x,1,0,0) - val(uf.x,0,0,0);
                            
#line 3114
val(div_numerical,0,0,0) += val(uf.y,0,1,0) - val(uf.y,0,0,0);

                          val(div_numerical,0,0,0) /= Delta;
                      }
                    }end_foreach();}




                      poisson_ps_usf1((struct Linear_ps){alpha,ps,usf,topo_mask,div_numerical,level_interface,dt});
                    foreach_stencil() {
                      _stencil_val_a(div_numerical2,0,0,0);
_stencil_val(cs,0,0,0); _stencil_val(topo_mask,0,0,0);{
                          
                            {_stencil_val_r(div_numerical2,0,0,0); _stencil_val(usf.x,1,0,0); _stencil_val(usf.x,0,0,0);  }
                            
#line 3128
{_stencil_val_r(div_numerical2,0,0,0); _stencil_val(usf.y,0,1,0); _stencil_val(usf.y,0,0,0);  }

                          _stencil_val_r(div_numerical2,0,0,0);  
                      }  
                       
                    
#line 3132
}end_foreach_stencil();
                    {
#line 3124
foreach() {
                      val(div_numerical2,0,0,0) = 0.;
                      if(val(cs,0,0,0)>0.0 && val(topo_mask,0,0,0)==0){
                          
                            val(div_numerical2,0,0,0) += val(usf.x,1,0,0) - val(usf.x,0,0,0);
                            
#line 3128
val(div_numerical2,0,0,0) += val(usf.y,0,1,0) - val(usf.y,0,0,0);

                          val(div_numerical2,0,0,0) /= Delta;
                      }
                    }end_foreach();}

            }else{
              poisson_ps_usf1((struct Linear_ps){alpha,ps,usf,topo_mask,source_pc2,level_interface,dt});

            }
        }else{
          foreach_stencil(){
            _stencil_val_a(ps,0,0,0);  
            _stencil_val_a(source_pc,0,0,0);  
            _stencil_val_a(source_pc2,0,0,0);  
          }end_foreach_stencil();
          {
#line 3139
foreach(){
            val(ps,0,0,0) = 0.0;
            val(source_pc,0,0,0) = 0.0;
            val(source_pc2,0,0,0) = 0.0;
          }end_foreach();}
          foreach_face_stencil(){_stencil_is_face_x(){{
            _stencil_val_a(usf.x,0,0,0);  
            _stencil_val_a(usfg.x,0,0,0);  
          }}end__stencil_is_face_x()
#line 3144
_stencil_is_face_y(){{
            _stencil_val_a(usf.y,0,0,0);  
            _stencil_val_a(usfg.y,0,0,0);  
          }}end__stencil_is_face_y()}end_foreach_face_stencil();
          {
#line 3144
foreach_face_generic(){is_face_x(){{
            val(usf.x,0,0,0) = 0.0;
            val(usfg.x,0,0,0) = 0.0;
          }}end_is_face_x()
#line 3144
is_face_y(){{
            val(usf.y,0,0,0) = 0.0;
            val(usfg.y,0,0,0) = 0.0;
          }}end_is_face_y()}end_foreach_face_generic();}
        }
   }else{
        poisson_ps_usf1((struct Linear_ps){alpha,ps,usf,topo_mask,source_pc2,level_interface,dt});
   }
}

 foreach_stencil(){
    _stencil_val_a(topo_mask_g,0,0,0);_stencil_val(topo_mask,0,0,0);  
 }end_foreach_stencil();

 {
#line 3154
foreach(){
    val(topo_mask_g,0,0,0) = -val(topo_mask,0,0,0);
 }end_foreach();}
#line 3176 "template01.c"
}{end_tracing("poisson_ps_0","template01.c",3176);return 0;}end_tracing("poisson_ps_0","template01.c",3176);}




static int get_ulf_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int get_ulf_0(const int i,const double t,Event *_ev){tracing("get_ulf_0","template01.c",3181);{

  if(i==51840){
      dump((struct Dump){"i51840"});
  }
  if(i>=1){
    ulf_ugf_function(topo_mask,topo_mask_g);
  }
}{end_tracing("get_ulf_0","template01.c",3189);return 0;}end_tracing("get_ulf_0","template01.c",3189);}







static int update_Tl_Tg_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int update_Tl_Tg_0(const int i,const double t,Event *_ev){ {



}return 0;}




double smff(double cc[3][3][3]){
    double value;







     value = (8.*cc[1][1][1] +
      4.*(cc[0][1][1] + cc[2][1][1] + cc[1][2][1] + cc[1][0][1] + cc[1][1][2] + cc[1][1][0]) +
      2.*(cc[0][2][1] + cc[0][1][2] + cc[0][1][0] + cc[0][0][1] +
   cc[1][2][2] + cc[1][2][0] + cc[1][0][2] + cc[1][0][0] +
   cc[2][2][1] + cc[2][1][2] + cc[2][0][1] + cc[2][1][0]) +
      cc[2][0][2] + cc[0][2][2] + cc[0][2][0] + cc[2][2][2] +
      cc[2][2][0] + cc[0][0][0] + cc[2][0][0] + cc[0][0][2])/64.;

        return value;
}



static int extract1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t+=out_interval);*ip=i;*tp=t;return ret;}static int extract1_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t=0.0158541);*ip=i;*tp=t;return ret;}      static int extract1(const int i,const double t,Event *_ev){tracing("extract1","template01.c",3228);


{
  char name33[80];
  sprintf(name33,"mass_record2-pid%d.dat",pid());
  FILE * fp33 = fopen(name33,"w");
  foreach_stencil(){

_stencil_val(ff,0,0,0);_stencil_val(T,0,0,0);_stencil_val(source_pc,0,0,0);_stencil_val(topo_mask,0,0,0);_stencil_val(phase0Tgrad,0,0,0);_stencil_val(phase1Tgrad,0,0,0);_stencil_val(aiml,0,0,0);_stencil_val(aimg,0,0,0);

    
  
#line 3238
}end_foreach_stencil();
  {
#line 3235
foreach(){

    fprintf(fp33,"%g %g %g %g %g %g %g %g %g %g\n",x,y,val(ff,0,0,0),val(T,0,0,0),val(source_pc,0,0,0),val(topo_mask,0,0,0),val(phase0Tgrad,0,0,0),val(phase1Tgrad,0,0,0),val(aiml,0,0,0),val(aimg,0,0,0));
  }end_foreach();}

  fclose(fp33);
   MPI_Barrier(MPI_COMM_WORLD);
   if(pid()==0){
                  char command1[150];
                  sprintf(command1, "LC_ALL=C cat mass_record2-pid*.dat > outfacets/mass_record2-%g",t);
                  system(command1);

                  char command7[150];
                  sprintf(command7, "LC_ALL=C rm -rf mass_record2-pid*.dat");
                  system(command7);
    }


        char names[80];
 sprintf(names, "interface%d", pid());
 FILE * fp = fopen (names, "w");
 output_facets ((struct OutputFacets){ff,fp});
 fclose(fp);

  MPI_Barrier(MPI_COMM_WORLD);
  if(pid()==0){
    char command[80];
    sprintf(command, "LC_ALL=C  cat interface* > outfacets/interface_%d_%g.dat",i,t);
    system(command);
  }


  during_time = (clock() - end_time)/(double)CLOCKS_PER_SEC;
end_time = clock();
      if(pid()==0){
              char name117[80];
              sprintf(name117,"time-performance.dat");
              FILE * fp117 = fopen(name117,"a");
              fprintf(fp117,"%d %g %g %g\n",i,t,during_time,(end_time-start_time)/(double)CLOCKS_PER_SEC);
              fclose(fp117);
      }

}{end_tracing("extract1","template01.c",3277);return 0;}end_tracing("extract1","template01.c",3277);}



static int pictures_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t+=out_interval2);*ip=i;*tp=t;return ret;}static int pictures_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t=0.0158541);*ip=i;*tp=t;return ret;}      static int pictures(const int i,const double t,Event *_ev){tracing("pictures","template01.c",3281);


{
  foreach_stencil(){
      _stencil_val_a(ulf_v.x,0,0,0);_stencil_val(ulf.x,0,0,0);_stencil_val(ulf.x,1,0,0);  
      _stencil_val_a(ulf_v.y,0,0,0);_stencil_val(ulf.y,0,0,0);_stencil_val(ulf.y,0,1,0);  
  }end_foreach_stencil();
  {
#line 3285
foreach(){
      val(ulf_v.x,0,0,0) = (val(ulf.x,0,0,0)/y+val(ulf.x,1,0,0)/y)/2.0;
      val(ulf_v.y,0,0,0) = (val(ulf.y,0,0,0)/max(1e-20,y-Delta/2.0)+val(ulf.y,0,1,0)/max(1e-20,y+Delta/2.0))/2.0;
  }end_foreach();}

  printf("t=%g\n",t);
    char dumpname[80];

  {
     _attribute[hhh.x.i].nodump = true;

  }
#line 3293
{
     _attribute[hhh.y.i].nodump = true;

  }



  sprintf(dumpname,"dump-i%d-t%g",i,t);
  dump((struct Dump){dumpname});
#line 3331 "template01.c"
}{end_tracing("pictures","template01.c",3331);return 0;}end_tracing("pictures","template01.c",3331);}


static int adapt_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int adapt_0(const int i,const double t,Event *_ev){tracing("adapt_0","template01.c",3334); {

if(dump_each_event && (i%dump_each_event_interval==0)){
        char dumpname[80];

      {
        _attribute[hhh.x.i].nodump = true;

      }
#line 3339
{
        _attribute[hhh.y.i].nodump = true;

      }
      sprintf(dumpname,"outfacets/dumpbeforeadapt-i%d-t%g",i,t);
      dump((struct Dump){dumpname});


}



  scalar  df1=new_scalar("df1"), df2=new_scalar("df2"), df3=new_scalar("df3");
 scalar  phi_temp3=new_vertex_scalar("phi_temp3");
        foreach_vertex_stencil(){
            _stencil_val_a(phi_temp3,0,0,0);  
        }end_foreach_vertex_stencil();
        {
#line 3353
foreach_vertex(){
            val(phi_temp3,0,0,0) = -(x-(-thickbottom+tune2_value));
        }end_foreach_vertex();}
        fractions ((struct Fractions){phi_temp3, poisson_source2_f});





boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 3362);
  smooth_for_arm((struct smooth1){df1,ff});
  smooth_for_arm((struct smooth1){df2,css_test3_n});
  smooth_for_arm((struct smooth1){df3,poisson_source2_f});

  _attribute[ff.i].refine = fraction_refine;
if(!restartsymbol){
      if(case_number == 1){
        adapt_wavelet ((struct Adapt){((scalar[]){df1,{-1}}),(double[]){0.001}, .maxlevel = maxl, .minlevel = minl});
      }else if(case_number==2){
        adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,{-1}}),(double[]){0.001,0.001}, .maxlevel = maxl, .minlevel = minl});

        }else if(case_number == 3 && (!restart_Tsat)){


                 scalar  T_adapt=new_scalar("T_adapt");
                foreach_stencil(){
                  _stencil_val_a(T_adapt,0,0,0); _stencil_val(T,0,0,0); 
                }end_foreach_stencil();
                {
#line 3378
foreach(){
                  val(T_adapt,0,0,0) = val(T,0,0,0);
                }end_foreach();}
                _attribute[T_adapt.i].refine = bilinear_no_cs2;
                _attribute[T_adapt.i].restriction = restriction_average;
        adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,T_adapt,df3,{-1}}),(double[]){0.001,0.001,0.1,0.001}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){T_adapt,{-1}}));


      }else if((case_number == 3 && restart_Tsat)){
           scalar  T_adapt=new_scalar("T_adapt");
        foreach_stencil(){
          _stencil_val_a(T_adapt,0,0,0); _stencil_val(T,0,0,0); 
        }end_foreach_stencil();
        {
#line 3388
foreach(){
          val(T_adapt,0,0,0) = val(T,0,0,0);
        }end_foreach();}
        _attribute[T_adapt.i].refine = bilinear_no_cs2;
        _attribute[T_adapt.i].restriction = restriction_average;


         scalar  ff_temp2=new_scalar("ff_temp2");
        double max_yy=0.0;
        double temp2=L0/(1<<maxl);
        foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); 
                     
                
                   
            
#line 3403
}
            
        
#line 3404
}end_foreach_stencil();
        
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:max_yy)){
#line 3398
foreach(){
            if(val(css_test3_n,0,0,0)>0.0){
                if(val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0 && (y>max_yy)){
                    max_yy = y;
                }
            }
        }end_foreach();mpi_all_reduce_array(&max_yy,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
        
#line 3405
max_yy = 1.1*max_yy;
#line 3430 "template01.c"
         adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,T_adapt,df3,{-1}}),(double[]){0.001,0.001,0.1,0.001}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){ff_temp2,T_adapt,{-1}}));
#line 3439 "template01.c"
      }else{
        printf("case error\n");
        exit(1);
      }
}else{

   scalar  T_adapt=new_scalar("T_adapt");
        foreach_stencil(){
          _stencil_val_a(T_adapt,0,0,0); _stencil_val(T,0,0,0); 
        }end_foreach_stencil();
        {
#line 3446
foreach(){
          val(T_adapt,0,0,0) = val(T,0,0,0);
        }end_foreach();}
        _attribute[T_adapt.i].refine = bilinear_no_cs2;
        _attribute[T_adapt.i].restriction = restriction_average;




        scalar  ff_temp2=new_scalar("ff_temp2");
        double max_yy=0.0;
        double temp2=L0/(1<<maxl);
        foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); 
                     
                
                   
            
#line 3463
}
            
        
#line 3464
}end_foreach_stencil();
        
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel reduction(max:max_yy)){
#line 3458
foreach(){
            if(val(css_test3_n,0,0,0)>0.0){
                if(val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0 && (y>max_yy)){
                    max_yy = y;
                }
            }
        }end_foreach();mpi_all_reduce_array(&max_yy,double,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
        
#line 3465
max_yy = 1.1*max_yy;
#line 3485 "template01.c"
         adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,T_adapt,df3,{-1}}),(double[]){0.001,0.001,0.1,0.001}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){ff_temp2,T_adapt,{-1}}));
}
  if(!restartsymbol){
    if(case_number==2 && i==0){
      for(int ii=1;ii<=5;ii++){
          do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);            }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (- (sq(bubble_radius) - sq(x - tune2_value- centerx) - sq(y - centery)));end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
              foreach_stencil(){
                  _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
              }end_foreach_stencil();
              {
#line 3491
foreach(){
                  val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
              }end_foreach();}
              boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 3494);
          smooth_for_arm((struct smooth1){df1,ff});
                scalar  phi_temp=new_vertex_scalar("phi_temp");
                foreach_vertex_stencil(){



                      _stencil_val_a(phi_temp,0,0,0);  
                  }end_foreach_vertex_stencil();
                {
#line 3497
foreach_vertex(){



                      val(phi_temp,0,0,0) = -(x-tune2_value);
                  }end_foreach_vertex();}
                  fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
                  foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
                  }end_foreach_stencil();
                  {
#line 3504
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
                  }}end__stencil_is_face_x()
#line 3508
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 3508
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
                  }}end_is_face_x()
#line 3508
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
          smooth_for_arm((struct smooth1){df2,css_test3_n});

          adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,{-1}}),(double[]){0.001,0.001}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){phi_temp,{-1}}));

   }

               level_interface = maxl;
               do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);              }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (- (sq(bubble_radius) - sq(x - tune2_value - centerx) - sq(y - centery)) );end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
               foreach_stencil(){
                      _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
               }end_foreach_stencil();
               {
#line 3519
foreach(){
                      val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
               }end_foreach();}
               boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 3522);
               const scalar c =  new_const_scalar("c",13, theta0*3.14159265358979/180.);
               contact_angle = c;
               foreach_stencil(){
                    _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
               }end_foreach_stencil();
               {
#line 3525
foreach(){
                    val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
               }end_foreach();}

              _attribute[ff_oppo.i].refine=_attribute[ff_oppo.i].prolongation = fraction_refine;

                  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
                      _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
                      _attribute[c.i].dirty = true;
                  }}}
#line 3559 "template01.c"
                scalar  phi=new_vertex_scalar("phi");
                do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);  }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = x-tune2_value;end_foreach_vertex();} fractions ((struct Fractions){phi, css_test3_n});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
                foreach_stencil(){
                  _stencil_val_a(css_test3_n,0,0,0);_stencil_val(css_test3_n,0,0,0);     
                }end_foreach_stencil();
                {
#line 3561
foreach(){
                  val(css_test3_n,0,0,0) = clamp (val(css_test3_n,0,0,0), 0., 1.);
                }end_foreach();}
                vof2dist(css_test3_n,phi);
                boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "template01.c", 3565);
                fractions ((struct Fractions){phi, css_test3_n, fss_test3_n});
                              foreach_stencil(){
                                  _stencil_val_a(css_test3,0,0,0); _stencil_val(css_test3_n,0,0,0);   
                                  _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                                }end_foreach_stencil();
                              {
#line 3567
foreach(){
                                  val(css_test3,0,0,0) = 1.0 - val(css_test3_n,0,0,0);
                                  val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                                }end_foreach();}
                                foreach_face_stencil(){_stencil_is_face_x(){{
                                    _stencil_val_a(fss_test3.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0);   
                                }}end__stencil_is_face_x()
#line 3571
_stencil_is_face_y(){{
                                    _stencil_val_a(fss_test3.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0);   
                                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                                {
#line 3571
foreach_face_generic(){is_face_x(){{
                                    val(fss_test3.x,0,0,0) = 1.0 - val(fss_test3_n.x,0,0,0);
                                }}end_is_face_x()
#line 3571
is_face_y(){{
                                    val(fss_test3.y,0,0,0) = 1.0 - val(fss_test3_n.y,0,0,0);
                                }}end_is_face_y()}end_foreach_face_generic();}


                  foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
                  }end_foreach_stencil();


                  {
#line 3576
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
                  }}end__stencil_is_face_x()
#line 3579
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 3579
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
                  }}end_is_face_x()
#line 3579
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
                  boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 3582);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));
#line 3596 "template01.c"
               if(case_number==2){
                  foreach_stencil(){
{{
                            _stencil_val_a(T,0,0,0);      
                        }{
                            _stencil_val_a(T,0,0,0);    
                        }}
                        
                    
#line 3603
}end_foreach_stencil();
                  {
#line 3597
foreach(){
                        if(x<0.0){
                            val(T,0,0,0) = T_inf - (T_inf - Twall_init)*(x-originx)/fabs(originx);
                        }else{
                            val(T,0,0,0) = Twall_init - (Twall_init-Tsub)*(x-0.0)/fabs(L0_pysical-fabs(originx));
                        }
                    }end_foreach();}
              }else if(case_number==3){
                  foreach_stencil(){
                        _stencil_val_a(T,0,0,0);  
                    }end_foreach_stencil();
                  {
#line 3605
foreach(){
                        val(T,0,0,0) = Tsat00;
                    }end_foreach();}
              }
                boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 3609);
                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 3614
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 3618
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;

        foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 3632
}end_foreach_stencil();

        {
#line 3620
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}

        vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 3642
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 3642
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 3642
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{

                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 3654
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 3658
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 3658
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 3658
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 3667
}end_foreach_stencil();
                {
#line 3662
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 3673
}}end__stencil_is_face_x()
#line 3668
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 3673
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 3668
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 3668
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));
    }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 3677
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 3684
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;



                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));


               get_css_fss_areaslg_triple_point();


    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));
    cm_css_test_update (cm_css_test, css_test, fss_test);
    fm_fss_test_update (fm_fss_test, css_test, fss_test);
    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));


    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));
    cm_css_test2_update (cm_css_test2, css_test2, fss_test2);
    fm_fss_test2_update (fm_fss_test2, css_test2, fss_test2);
    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));


    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));
    cm_css_test3_update (cm_css_test3, css_test3, fss_test3);
    fm_fss_test3_update (fm_fss_test3, css_test3, fss_test3);
    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));




                heights(ff,hhh);

                 printf("event init 482,pid=%d\n",pid());
                      foreach_stencil(){
                        _stencil_val_a(source_pc,0,0,0);  
                        _stencil_val_a(masstr,0,0,0);
                        _stencil_val_a(vtr,0,0,0);  
                      }end_foreach_stencil();
                      {
#line 3720
foreach(){
                        val(source_pc,0,0,0) = 0.0;
                        val(masstr,0,0,0)=0.0;
                        val(vtr,0,0,0) = 0.0;
                      }end_foreach();}





          globali = 0;
            foreach_face_stencil(){_stencil_is_face_x(){{
              _stencil_val_a(ulf.x,0,0,0); 
              _stencil_val_a(usf.x,0,0,0); 
              _stencil_val_a(uf.x,0,0,0);  

              _stencil_val_a(ugf.x,0,0,0); 
              _stencil_val_a(usfg.x,0,0,0); 

            }}end__stencil_is_face_x()
#line 3731
_stencil_is_face_y(){{
              _stencil_val_a(ulf.y,0,0,0); 
              _stencil_val_a(usf.y,0,0,0); 
              _stencil_val_a(uf.y,0,0,0);  

              _stencil_val_a(ugf.y,0,0,0); 
              _stencil_val_a(usfg.y,0,0,0); 

            }}end__stencil_is_face_y()}end_foreach_face_stencil();
            {
#line 3731
foreach_face_generic(){is_face_x(){{
              val(ulf.x,0,0,0) =0.0;
              val(usf.x,0,0,0) =0.0;
              val(uf.x,0,0,0) = 0.0;

              val(ugf.x,0,0,0) =0.0;
              val(usfg.x,0,0,0) =0.0;

            }}end_is_face_x()
#line 3731
is_face_y(){{
              val(ulf.y,0,0,0) =0.0;
              val(usf.y,0,0,0) =0.0;
              val(uf.y,0,0,0) = 0.0;

              val(ugf.y,0,0,0) =0.0;
              val(usfg.y,0,0,0) =0.0;

            }}end_is_face_y()}end_foreach_face_generic();}
            foreach_stencil(){
              _stencil_val_a(p,0,0,0);
              _stencil_val_a(pf,0,0,0);
              {
                _stencil_val_a(u.x,0,0,0);
                _stencil_val_a(g.x,0,0,0);
              }
#line 3743
{
                _stencil_val_a(u.y,0,0,0);
                _stencil_val_a(g.y,0,0,0);
              }
            }end_foreach_stencil();
            {
#line 3740
foreach(){
              val(p,0,0,0)=0.;
              val(pf,0,0,0)=0.0;
              {
                val(u.x,0,0,0)=0.0;
                val(g.x,0,0,0)=0.0;
              }
#line 3743
{
                val(u.y,0,0,0)=0.0;
                val(g.y,0,0,0)=0.0;
              }
            }end_foreach();}
            boundary_internal ((scalar *)((scalar[]){u.x,u.y,{-1}}), "template01.c", 3748);delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi,{-1}}));

  }else if(case_number==3 && restart_Tsat_i==0 && restart_Tsat){
    restart_Tsat_i=1;
    fprintf(ferr,"event adapt=%d t=%g restart_Tsat_i=%d\n",i,t,restart_Tsat_i);
    for(int ii=1;ii<=0;ii++){

          do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);              }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (- (sq(bubble_radius) - sq(x - tune2_value - centerx) - sq(y - centery)) );end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
              foreach_stencil(){
                  _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
              }end_foreach_stencil();
              {
#line 3756
foreach(){
                  val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
              }end_foreach();}
              boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 3759);
          smooth_for_arm((struct smooth1){df1,ff});
                scalar  phi_temp=new_vertex_scalar("phi_temp");







                 solid_phi(tune2_value, phi_temp);
              foreach_vertex_stencil(){
                _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
              }end_foreach_vertex_stencil();
              {
#line 3770
foreach_vertex(){
                val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
              }end_foreach_vertex();}
                  fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
                  foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
                  }end_foreach_stencil();
                  {
#line 3774
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
                  }}end__stencil_is_face_x()
#line 3778
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 3778
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
                  }}end_is_face_x()
#line 3778
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
          smooth_for_arm((struct smooth1){df2,css_test3_n});

           scalar  phi_temp3=new_vertex_scalar("phi_temp3");
               foreach_vertex_stencil(){
                  _stencil_val_a(phi_temp3,0,0,0);  
               }end_foreach_vertex_stencil();
               {
#line 3784
foreach_vertex(){
                  val(phi_temp3,0,0,0) = -(x-(-thickbottom+tune2_value));
               }end_foreach_vertex();}
              fractions ((struct Fractions){phi_temp3, poisson_source2_f});
               smooth_for_arm((struct smooth1){df3,poisson_source2_f});




          adapt_wavelet ((struct Adapt){((scalar[]){df1,df2,df3,{-1}}),(double[]){0.001,0.001,0.001}, .maxlevel = maxl, .minlevel = minl});delete((scalar*)((scalar[]){phi_temp3,phi_temp,{-1}}));

   }

               level_interface = maxl;

              do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);              }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (- (sq(bubble_radius) - sq(x - tune2_value - centerx) - sq(y - centery)) );end_foreach_vertex();} fractions ((struct Fractions){phi, ff});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
               foreach_stencil(){
                      _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);     
               }end_foreach_stencil();
               {
#line 3800
foreach(){
                      val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
               }end_foreach();}
               boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 3803);
               const scalar c =  new_const_scalar("c",14, theta0*3.14159265358979/180.);
               contact_angle = c;
               foreach_stencil(){
                    _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
               }end_foreach_stencil();
               {
#line 3806
foreach(){
                    val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
               }end_foreach();}

              _attribute[ff_oppo.i].refine=_attribute[ff_oppo.i].prolongation = fraction_refine;

                  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
                      _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
                      _attribute[c.i].dirty = true;
                  }}}
#line 3849 "template01.c"
scalar  phi=new_vertex_scalar("phi");





                solid_phi(tune2_value, phi);
                boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "template01.c", 3856);
                fractions ((struct Fractions){phi, css_test3_n, fss_test3_n});
                              foreach_stencil(){
                                  _stencil_val_a(css_test3,0,0,0); _stencil_val(css_test3_n,0,0,0);   
                                  _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                                }end_foreach_stencil();
                              {
#line 3858
foreach(){
                                  val(css_test3,0,0,0) = 1.0 - val(css_test3_n,0,0,0);
                                  val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                                }end_foreach();}
                                foreach_face_stencil(){_stencil_is_face_x(){{
                                    _stencil_val_a(fss_test3.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0);   
                                }}end__stencil_is_face_x()
#line 3862
_stencil_is_face_y(){{
                                    _stencil_val_a(fss_test3.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0);   
                                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                                {
#line 3862
foreach_face_generic(){is_face_x(){{
                                    val(fss_test3.x,0,0,0) = 1.0 - val(fss_test3_n.x,0,0,0);
                                }}end_is_face_x()
#line 3862
is_face_y(){{
                                    val(fss_test3.y,0,0,0) = 1.0 - val(fss_test3_n.y,0,0,0);
                                }}end_is_face_y()}end_foreach_face_generic();}


                  foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
                  }end_foreach_stencil();


                  {
#line 3867
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
                  }}end__stencil_is_face_x()
#line 3870
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 3870
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
                  }}end_is_face_x()
#line 3870
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
                  boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 3873);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));

                  foreach_stencil(){
                        _stencil_val_a(T,0,0,0);_stencil_val(T_oold,0,0,0);
                    }end_foreach_stencil();

                  {
#line 3880
foreach(){
                        val(T,0,0,0)=val(T_oold,0,0,0);
                    }end_foreach();}

                boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 3884);
                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 3889
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 3893
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;

       foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 3907
}end_foreach_stencil();

       {
#line 3895
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}
      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 3916
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 3916
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 3916
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{
                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 3927
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 3931
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 3931
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 3931
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 3940
}end_foreach_stencil();
                {
#line 3935
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 3946
}}end__stencil_is_face_x()
#line 3941
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 3946
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 3941
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 3941
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));
            }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 3950
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 3957
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;


               get_css_fss_areaslg_triple_point();
                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));



    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));
    cm_css_test_update (cm_css_test, css_test, fss_test);
    fm_fss_test_update (fm_fss_test, css_test, fss_test);
    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));


    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));
    cm_css_test2_update (cm_css_test2, css_test2, fss_test2);
    fm_fss_test2_update (fm_fss_test2, css_test2, fss_test2);
    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));


    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));
    cm_css_test3_update (cm_css_test3, css_test3, fss_test3);
    fm_fss_test3_update (fm_fss_test3, css_test3, fss_test3);
    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));




                heights(ff,hhh);

                 printf("event init 482,pid=%d\n",pid());
                      foreach_stencil(){
                        _stencil_val_a(source_pc,0,0,0);  
                        _stencil_val_a(masstr,0,0,0);
                        _stencil_val_a(vtr,0,0,0);  
                      }end_foreach_stencil();
                      {
#line 3991
foreach(){
                        val(source_pc,0,0,0) = 0.0;
                        val(masstr,0,0,0)=0.0;
                        val(vtr,0,0,0) = 0.0;
                      }end_foreach();}





          globali = 0;
#line 4019 "template01.c"
            boundary_internal ((scalar *)((scalar[]){u.x,u.y,{-1}}), "template01.c", 4019);delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi,{-1}}));

    }else if(case_number==3 && i==0 && (!restart_Tsat)){
         for(int ii=1;ii<=5;ii++){
              foreach_stencil(){
                  _stencil_val_a(ff,0,0,0);  
              }end_foreach_stencil();
              {
#line 4023
foreach(){
                  val(ff,0,0,0) = 1.0;
              }end_foreach();}
              boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 4026);
          smooth_for_arm((struct smooth1){df1,ff});
                scalar  phi_temp=new_vertex_scalar("phi_temp");







                solid_phi(tune2_value, phi_temp);
              foreach_vertex_stencil(){
                _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
              }end_foreach_vertex_stencil();
              {
#line 4037
foreach_vertex(){
                val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
              }end_foreach_vertex();}
                  fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
                  foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
                  }end_foreach_stencil();
                  {
#line 4041
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
                  }}end__stencil_is_face_x()
#line 4045
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 4045
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
                  }}end_is_face_x()
#line 4045
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
          smooth_for_arm((struct smooth1){df2,css_test3_n});delete((scalar*)((scalar[]){phi_temp,{-1}}));



   }

               level_interface = maxl;
               foreach_stencil(){
                      _stencil_val_a(ff,0,0,0);  
               }end_foreach_stencil();
               {
#line 4055
foreach(){
                      val(ff,0,0,0) = 1.0;
               }end_foreach();}
               boundary_internal ((scalar *)((scalar[]){ff,{-1}}), "template01.c", 4058);
               const scalar c =  new_const_scalar("c",15, theta0*3.14159265358979/180.);
               contact_angle = c;
               foreach_stencil(){
                    _stencil_val_a(ff_oppo,0,0,0); _stencil_val(ff,0,0,0);   
               }end_foreach_stencil();
               {
#line 4061
foreach(){
                    val(ff_oppo,0,0,0) = 1.0 - val(ff,0,0,0);
               }end_foreach();}

              _attribute[ff_oppo.i].refine=_attribute[ff_oppo.i].prolongation = fraction_refine;

                  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
                      _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
                      _attribute[c.i].dirty = true;
                  }}}

                scalar  phi=new_vertex_scalar("phi");
                do { scalar  phi=new_vertex_scalar("phi"); foreach_vertex_stencil() {_stencil_val_a(phi,0,0,0);  }end_foreach_vertex_stencil(); {foreach_vertex() val(phi,0,0,0) = (x-tune2_value);end_foreach_vertex();} fractions ((struct Fractions){phi, css_test3_n});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
                foreach_stencil(){
                  _stencil_val_a(css_test3_n,0,0,0);_stencil_val(css_test3_n,0,0,0);     
                }end_foreach_stencil();
                {
#line 4074
foreach(){
                  val(css_test3_n,0,0,0) = clamp (val(css_test3_n,0,0,0), 0., 1.);
                }end_foreach();}
                vof2dist(css_test3_n,phi);
                boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "template01.c", 4078);
                fractions ((struct Fractions){phi, css_test3_n, fss_test3_n});
                              foreach_stencil(){
                                  _stencil_val_a(css_test3,0,0,0); _stencil_val(css_test3_n,0,0,0);   
                                  _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                                }end_foreach_stencil();
                              {
#line 4080
foreach(){
                                  val(css_test3,0,0,0) = 1.0 - val(css_test3_n,0,0,0);
                                  val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                                }end_foreach();}
                                foreach_face_stencil(){_stencil_is_face_x(){{
                                    _stencil_val_a(fss_test3.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0);   
                                }}end__stencil_is_face_x()
#line 4084
_stencil_is_face_y(){{
                                    _stencil_val_a(fss_test3.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0);   
                                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                                {
#line 4084
foreach_face_generic(){is_face_x(){{
                                    val(fss_test3.x,0,0,0) = 1.0 - val(fss_test3_n.x,0,0,0);
                                }}end_is_face_x()
#line 4084
is_face_y(){{
                                    val(fss_test3.y,0,0,0) = 1.0 - val(fss_test3_n.y,0,0,0);
                                }}end_is_face_y()}end_foreach_face_generic();}


                  foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
                  }end_foreach_stencil();


                  {
#line 4089
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
                  }end_foreach();}
                  foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
                  }}end__stencil_is_face_x()
#line 4092
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
                  }}end__stencil_is_face_y()}end_foreach_face_stencil();
                  {
#line 4092
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
                  }}end_is_face_x()
#line 4092
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
                  }}end_is_face_y()}end_foreach_face_generic();}
                  boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 4095);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));

              if(!(surface_heat && surface_heat_restart)){
                  foreach_stencil(){
                        _stencil_val_a(T,0,0,0);
                    }end_foreach_stencil();
                  {
#line 4103
foreach(){
                        val(T,0,0,0)=Tsat00;
                    }end_foreach();}
              }

                boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 4108);
                _attribute[fs_solid.i].prolongation = _attribute[fs_solid.i].refine = fraction_refine;
                _attribute[css_test3.i].refine = embed_fraction_refine_s;
                _attribute[css_test3.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3.x.i].prolongation = embed_face_fraction_refine_s_x;
                  
#line 4113
_attribute[fss_test3.y.i].prolongation = embed_face_fraction_refine_s_y;
                _attribute[css_test3_n.i].refine = embed_fraction_refine_s_n;
                _attribute[css_test3_n.i].prolongation = fraction_refine;
                
                  _attribute[fss_test3_n.x.i].prolongation = embed_face_fraction_refine_s_n_x;
                  
#line 4117
_attribute[fss_test3_n.y.i].prolongation = embed_face_fraction_refine_s_n_y;
       foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);
                  } {_stencil_val(css_test3_n,0,0,0);{{
                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);
                  }{

                      _stencil_val_a(css_test,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                      _stencil_val_a(css_test2,0,0,0);_stencil_val(ff,0,0,0);_stencil_val(css_test3_n,0,0,0);
                  }}}}
                  
               
#line 4130
}end_foreach_stencil();
       {
#line 4118
foreach(){
                  if(val(css_test3_n,0,0,0)<=0){
                      val(css_test,0,0,0)=0;
                      val(css_test2,0,0,0)=0;
                  }else if(val(css_test3_n,0,0,0)>=1){
                      val(css_test,0,0,0)=val(ff,0,0,0);
                      val(css_test2,0,0,0)=1.0-val(ff,0,0,0);
                  }else{

                      val(css_test,0,0,0)=val(ff,0,0,0)*val(css_test3_n,0,0,0);
                      val(css_test2,0,0,0)=(1.0-val(ff,0,0,0))*val(css_test3_n,0,0,0);
                  }
               }end_foreach();}

      vector  fs_temp=new_face_vector("fs_temp");
       if(1==1){
               scalar  phi21=new_vertex_scalar("phi21");
               vof2dist(css_test,phi21);
               scalar  ff_temp=new_scalar("ff_temp");
               fractions((struct Fractions){phi21, ff_temp, fss_test});
               vof2dist(css_test2,phi21);
               fractions((struct Fractions){phi21, ff_temp, fss_test2});
               foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fs_temp.x,0,0,0); _stencil_val(fss_test.x,0,0,0); 
               }}end__stencil_is_face_x()
#line 4140
_stencil_is_face_y(){{
                  _stencil_val_a(fs_temp.y,0,0,0); _stencil_val(fss_test.y,0,0,0); 
               }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 4140
foreach_face_generic(){is_face_x(){{
                  val(fs_temp.x,0,0,0) = val(fss_test.x,0,0,0);
               }}end_is_face_x()
#line 4140
is_face_y(){{
                  val(fs_temp.y,0,0,0) = val(fss_test.y,0,0,0);
               }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));


       }else{
                scalar  phi21=new_vertex_scalar("phi21");
                scalar  ff_temp=new_scalar("ff_temp");
                vof2dist(ff, phi21);
                fractions ((struct Fractions){phi21, ff_temp, fs_temp});

                foreach_stencil(){
                  _stencil_val_a(css_test,0,0,0);  
                  _stencil_val_a(css_test2,0,0,0);  
                }end_foreach_stencil();

                {
#line 4151
foreach(){
                  val(css_test,0,0,0) = 0.0;
                  val(css_test2,0,0,0) = 0.0;
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
                  _stencil_val_a(fss_test.x,0,0,0);  
                  _stencil_val_a(fss_test2.x,0,0,0);
                }}end__stencil_is_face_x()
#line 4155
_stencil_is_face_y(){{
                  _stencil_val_a(fss_test.y,0,0,0);  
                  _stencil_val_a(fss_test2.y,0,0,0);
                }}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 4155
foreach_face_generic(){is_face_x(){{
                  val(fss_test.x,0,0,0) = 0.0;
                  val(fss_test2.x,0,0,0)=0.0;
                }}end_is_face_x()
#line 4155
is_face_y(){{
                  val(fss_test.y,0,0,0) = 0.0;
                  val(fss_test2.y,0,0,0)=0.0;
                }}end_is_face_y()}end_foreach_face_generic();}
                foreach_stencil(){
_stencil_val(css_test3_n,0,0,0);{
                    _stencil_val_a(css_test,0,0,0); _stencil_val(ff_temp,0,0,0); 
                    _stencil_val_a(css_test2,0,0,0); _stencil_val(ff_temp,0,0,0);   
                  }
                  
                
#line 4164
}end_foreach_stencil();
                {
#line 4159
foreach(){
                  if(val(css_test3_n,0,0,0)>0.0){
                    val(css_test,0,0,0) = val(ff_temp,0,0,0);
                    val(css_test2,0,0,0) = 1.0 - val(ff_temp,0,0,0);
                  }
                }end_foreach();}
                foreach_face_stencil(){_stencil_is_face_x(){{
_stencil_val(fss_test3_n.x,0,0,0);{
                      _stencil_val_a(fss_test.x,0,0,0); _stencil_val(fs_temp.x,0,0,0); 
                      _stencil_val_a(fss_test2.x,0,0,0); _stencil_val(fs_temp.x,0,0,0);   
                  }
                  
                
#line 4170
}}end__stencil_is_face_x()
#line 4165
_stencil_is_face_y(){{
_stencil_val(fss_test3_n.y,0,0,0);{
                      _stencil_val_a(fss_test.y,0,0,0); _stencil_val(fs_temp.y,0,0,0); 
                      _stencil_val_a(fss_test2.y,0,0,0); _stencil_val(fs_temp.y,0,0,0);   
                  }
                  
                
#line 4170
}}end__stencil_is_face_y()}end_foreach_face_stencil();
                {
#line 4165
foreach_face_generic(){is_face_x(){{
                  if(val(fss_test3_n.x,0,0,0)>0.0){
                      val(fss_test.x,0,0,0) = val(fs_temp.x,0,0,0);
                      val(fss_test2.x,0,0,0) = 1.0 - val(fs_temp.x,0,0,0);
                  }
                }}end_is_face_x()
#line 4165
is_face_y(){{
                  if(val(fss_test3_n.y,0,0,0)>0.0){
                      val(fss_test.y,0,0,0) = val(fs_temp.y,0,0,0);
                      val(fss_test2.y,0,0,0) = 1.0 - val(fs_temp.y,0,0,0);
                  }
                }}end_is_face_y()}end_foreach_face_generic();}delete((scalar*)((scalar[]){ff_temp,phi21,{-1}}));
          }
                 _attribute[css_test.i].refine = embed_fraction_refine_css_test;
                _attribute[css_test.i].prolongation = embed_fraction_refine_css_test;
                {
                          _attribute[fss_test.x.i].refine = _attribute[fss_test.x.i].prolongation = embed_face_fraction_fss_test_refine_x;

                }
#line 4174
{
                          _attribute[fss_test.y.i].refine = _attribute[fss_test.y.i].prolongation = embed_face_fraction_fss_test_refine_y;

                }
                _attribute[css_test2.i].refine = embed_fraction_refine_css_test2;
                _attribute[css_test2.i].prolongation = embed_fraction_refine_css_test2;
                
                          _attribute[fss_test2.x.i].prolongation = embed_face_fraction_fss_test2_refine_x;
                          
#line 4181
_attribute[fss_test2.y.i].prolongation = embed_face_fraction_fss_test2_refine_y;


               get_css_fss_areaslg_triple_point();

                restriction(((scalar[]){css_test,fss_test.x,fss_test.y,{-1}}));
                restriction(((scalar[]){css_test2,fss_test2.x,fss_test2.y,{-1}}));
                restriction(((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}));
                restriction(((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}));

    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));
    cm_css_test_update (cm_css_test, css_test, fss_test);
    fm_fss_test_update (fm_fss_test, css_test, fss_test);
    restriction (((scalar[]){cm_css_test, fss_test.x,fss_test.y,{-1}}));


    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));
    cm_css_test2_update (cm_css_test2, css_test2, fss_test2);
    fm_fss_test2_update (fm_fss_test2, css_test2, fss_test2);
    restriction (((scalar[]){cm_css_test2, fss_test2.x,fss_test2.y,{-1}}));


    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));
    cm_css_test3_update (cm_css_test3, css_test3, fss_test3);
    fm_fss_test3_update (fm_fss_test3, css_test3, fss_test3);
    restriction (((scalar[]){cm_css_test3, fss_test3.x,fss_test3.y,{-1}}));



                heights(ff,hhh);

                 printf("event init 482,pid=%d\n",pid());
                      foreach_stencil(){
                        _stencil_val_a(source_pc,0,0,0);  
                        _stencil_val_a(masstr,0,0,0);
                        _stencil_val_a(vtr,0,0,0);  
                      }end_foreach_stencil();
                      {
#line 4213
foreach(){
                        val(source_pc,0,0,0) = 0.0;
                        val(masstr,0,0,0)=0.0;
                        val(vtr,0,0,0) = 0.0;
                      }end_foreach();}





          globali = 0;
            foreach_face_stencil(){_stencil_is_face_x(){{
              _stencil_val_a(ulf.x,0,0,0); 
              _stencil_val_a(usf.x,0,0,0); 
              _stencil_val_a(uf.x,0,0,0);  

              _stencil_val_a(ugf.x,0,0,0); 
              _stencil_val_a(usfg.x,0,0,0); 

            }}end__stencil_is_face_x()
#line 4224
_stencil_is_face_y(){{
              _stencil_val_a(ulf.y,0,0,0); 
              _stencil_val_a(usf.y,0,0,0); 
              _stencil_val_a(uf.y,0,0,0);  

              _stencil_val_a(ugf.y,0,0,0); 
              _stencil_val_a(usfg.y,0,0,0); 

            }}end__stencil_is_face_y()}end_foreach_face_stencil();
            {
#line 4224
foreach_face_generic(){is_face_x(){{
              val(ulf.x,0,0,0) =0.0;
              val(usf.x,0,0,0) =0.0;
              val(uf.x,0,0,0) = 0.0;

              val(ugf.x,0,0,0) =0.0;
              val(usfg.x,0,0,0) =0.0;

            }}end_is_face_x()
#line 4224
is_face_y(){{
              val(ulf.y,0,0,0) =0.0;
              val(usf.y,0,0,0) =0.0;
              val(uf.y,0,0,0) = 0.0;

              val(ugf.y,0,0,0) =0.0;
              val(usfg.y,0,0,0) =0.0;

            }}end_is_face_y()}end_foreach_face_generic();}
            foreach_stencil(){
              _stencil_val_a(p,0,0,0);
              _stencil_val_a(pf,0,0,0);
              {
                _stencil_val_a(u.x,0,0,0);
                _stencil_val_a(g.x,0,0,0);
              }
#line 4236
{
                _stencil_val_a(u.y,0,0,0);
                _stencil_val_a(g.y,0,0,0);
              }
            }end_foreach_stencil();
            {
#line 4233
foreach(){
              val(p,0,0,0)=0.;
              val(pf,0,0,0)=0.0;
              {
                val(u.x,0,0,0)=0.0;
                val(g.x,0,0,0)=0.0;
              }
#line 4236
{
                val(u.y,0,0,0)=0.0;
                val(g.y,0,0,0)=0.0;
              }
            }end_foreach();}
            boundary_internal ((scalar *)((scalar[]){u.x,u.y,{-1}}), "template01.c", 4241);delete((scalar*)((scalar[]){fs_temp.x,fs_temp.y,phi,{-1}}));
  }
}


     level_interface = maxl;




             scalar  phi_temp=new_vertex_scalar("phi_temp");





              solid_phi(tune2_value, phi_temp);
              foreach_vertex_stencil(){
                _stencil_val_a(phi_temp,0,0,0);_stencil_val(phi_temp,0,0,0);  
              }end_foreach_vertex_stencil();
              {
#line 4258
foreach_vertex(){
                val(phi_temp,0,0,0) = -val(phi_temp,0,0,0);
              }end_foreach_vertex();}
               fractions ((struct Fractions){phi_temp, css_test3, fss_test3});
              foreach_stencil(){
                    _stencil_val_a(fs_solid,0,0,0); _stencil_val(css_test3,0,0,0); 
                    _stencil_val_a(css_test3_n,0,0,0); _stencil_val(css_test3,0,0,0);   
               }end_foreach_stencil();
              {
#line 4262
foreach(){
                    val(fs_solid,0,0,0) = val(css_test3,0,0,0);
                    val(css_test3_n,0,0,0) = 1.0 - val(css_test3,0,0,0);
               }end_foreach();}
               foreach_face_stencil(){_stencil_is_face_x(){{
                      _stencil_val_a(fss_test3_n.x,0,0,0); _stencil_val(fss_test3.x,0,0,0);   
              }}end__stencil_is_face_x()
#line 4266
_stencil_is_face_y(){{
                      _stencil_val_a(fss_test3_n.y,0,0,0); _stencil_val(fss_test3.y,0,0,0);   
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
               {
#line 4266
foreach_face_generic(){is_face_x(){{
                      val(fss_test3_n.x,0,0,0) = 1.0 - val(fss_test3.x,0,0,0);
              }}end_is_face_x()
#line 4266
is_face_y(){{
                      val(fss_test3_n.y,0,0,0) = 1.0 - val(fss_test3.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){css_test3,fss_test3.x,fss_test3.y,{-1}}), "template01.c", 4269);
              boundary_internal ((scalar *)((scalar[]){fs_solid,{-1}}), "template01.c", 4270);
              boundary_internal ((scalar *)((scalar[]){css_test3_n,fss_test3_n.x,fss_test3_n.y,{-1}}), "template01.c", 4271);
              foreach_stencil(){
                    _stencil_val_a(cs,0,0,0); _stencil_val(css_test3_n,0,0,0); 
              }end_foreach_stencil();
              {
#line 4272
foreach(){
                    val(cs,0,0,0) = val(css_test3_n,0,0,0);
              }end_foreach();}
              foreach_face_stencil(){_stencil_is_face_x(){{
                    _stencil_val_a(fs.x,0,0,0); _stencil_val(fss_test3_n.x,0,0,0); 
              }}end__stencil_is_face_x()
#line 4275
_stencil_is_face_y(){{
                    _stencil_val_a(fs.y,0,0,0); _stencil_val(fss_test3_n.y,0,0,0); 
              }}end__stencil_is_face_y()}end_foreach_face_stencil();
              {
#line 4275
foreach_face_generic(){is_face_x(){{
                    val(fs.x,0,0,0) = val(fss_test3_n.x,0,0,0);
              }}end_is_face_x()
#line 4275
is_face_y(){{
                    val(fs.y,0,0,0) = val(fss_test3_n.y,0,0,0);
              }}end_is_face_y()}end_foreach_face_generic();}
              boundary_internal ((scalar *)((scalar[]){cs,fs.x,fs.y,{-1}}), "template01.c", 4278);

                  restriction (((scalar[]){cs, fs.x,fs.y,{-1}}));
                  cm_update (cm, cs, fs);
                  fm_update (fm, cs, fs);
                  restriction (((scalar[]){cm, fm.x,fm.y,{-1}}));



     if(case_number==3 && (restart_Tsat || restartsymbol)){
           double Delta_min = L0_pysical/(1<<maxl);
           foreach_stencil(){
_stencil_val(cs,0,0,0);_stencil_val(ff,0,0,0); {

                      _stencil_val_a(ff,0,0,0);  
                }
                    
           
#line 4294
}end_foreach_stencil();
           {
#line 4289
foreach(){
                if(val(cs,0,0,0)<=0 && fabs(val(ff,0,0,0))>1e-6 && x<-3*Delta_min) {

                      val(ff,0,0,0) = 1.0;
                }
           }end_foreach();}

           foreach_stencil(){
              _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);
_stencil_val(ff,0,0,0);{{
                    _stencil_val_a(ff,0,0,0);
              } {_stencil_val(ff,0,0,0);{
                    _stencil_val_a(ff,0,0,0);  
              }}}     
              
          
#line 4303
}end_foreach_stencil();

           {
#line 4296
foreach(){
              val(ff,0,0,0) = clamp (val(ff,0,0,0), 0., 1.);
              if(fabs(val(ff,0,0,0))<1e-12){
                    val(ff,0,0,0)=0.0;
              }else if(fabs(1-val(ff,0,0,0))<1e-12){
                    val(ff,0,0,0) = 1.0;
              }
          }end_foreach();}
          foreach_stencil(){
_stencil_val(cs,0,0,0);{
_stencil_val(ff,0,0,0);{{
                        _stencil_val_a(ff,0,0,0);
                     } {_stencil_val(ff,0,0,0);{
                        _stencil_val_a(ff,0,0,0);
                     }}}
                     
                
#line 4311
}
                
           
#line 4312
}end_foreach_stencil();
          {
#line 4304
foreach(){
                if(fabs(val(cs,0,0,0))>=0){
                     if(val(ff,0,0,0)<1e-10){
                        val(ff,0,0,0)=0;
                     }else if(val(ff,0,0,0)>1-1e-10){
                        val(ff,0,0,0)=1.0;
                     }
                }
           }end_foreach();}
           foreach_stencil(){
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0);{
                        _stencil_val_a(ff,0,0,0);_stencil_val(ff,0,0,0);  
                }
                     
           
#line 4317
}end_foreach_stencil();
           {
#line 4313
foreach(){
                if((level != level_interface) && (val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0)){
                        val(ff,0,0,0) = (val(ff,0,0,0)>0.5?1.0:0.0);
                }
           }end_foreach();}
#line 4378 "template01.c"
          foreach_stencil(){
_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); _stencil_val(cs,0,0,0);{
_stencil_val(T,0,0,0);{
                  _stencil_val_a(T,0,0,0);
                }
                
            
#line 4383
}
              
          
#line 4384
}end_foreach_stencil();
#line 4378 "template01.c"
          {foreach(){
            if(val(ff,0,0,0)<1.0 && val(ff,0,0,0)>0.0 && val(cs,0,0,0)>0){
                if(val(T,0,0,0)<Tsat00){
                  val(T,0,0,0)=Tsat00;
                }
            }
          }end_foreach();}
          boundary_internal ((scalar *)((scalar[]){T,{-1}}), "template01.c", 4385);
#line 4426 "template01.c"
     }delete((scalar*)((scalar[]){phi_temp,phi_temp3,df3,df2,df1,{-1}}));

}{end_tracing("adapt_0","template01.c",4428);return 0;}end_tracing("adapt_0","template01.c",4428);}





static int logfile_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}      static int logfile(const int i,const double t,Event *_ev){tracing("logfile","template01.c",4434);{
    double sb = 0.;
    double sb2 = 0.0;
    double area=0.;
  int number2=0;

  double radius3D ;
  double dd=-1;
  foreach_stencil() {    
    _stencil_val(cm,0,0,0); _stencil_val(ff,0,0,0); 
     
    

_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,0); {   
       _stencil_mycs (point, ff);     
      _stencil_val(ff,0,0,0); 

          
    }

{
_stencil_val(T,0,0,0);
        
    
#line 4456
}

            

        
  
#line 4457
}end_foreach_stencil();
  
#line 4442
if(!is_constant(cm)){
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(max:dd) reduction(+:area) reduction(+:number2)reduction(+:sb)){
#line 4442
foreach() {
    double dv = (1. - val(ff,0,0,0))*(sq(Delta)*val(cm,0,0,0));
    sb += dv;
    number2++;

    if (val(ff,0,0,0) > 1e-6 && val(ff,0,0,0) < 1. - 1e-6) {
      coord n = mycs (point, ff), p;
      double alpha = line_alpha (val(ff,0,0,0), n);

      area += y*pow(Delta, 2 - 1)*line_length_center(n,alpha,&p);
    }

    if(fabs(x - tracex)<1e-6 && fabs(y-tracey)<1e-6){
        dd=val(T,0,0,0);
    }
  }end_foreach();mpi_all_reduce_array(&dd,double,MPI_MAX,1);mpi_all_reduce_array(&area,double,MPI_SUM,1);mpi_all_reduce_array(&number2,int,MPI_SUM,1);mpi_all_reduce_array(&sb,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 4457
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(max:dd) reduction(+:area) reduction(+:number2)reduction(+:sb)){
#line 4442
foreach() {
    double dv = (1. - val(ff,0,0,0))*(sq(Delta)*_const_cm);
    sb += dv;
    number2++;

    if (val(ff,0,0,0) > 1e-6 && val(ff,0,0,0) < 1. - 1e-6) {
      coord n = mycs (point, ff), p;
      double alpha = line_alpha (val(ff,0,0,0), n);

      area += y*pow(Delta, 2 - 1)*line_length_center(n,alpha,&p);
    }

    if(fabs(x - tracex)<1e-6 && fabs(y-tracey)<1e-6){
        dd=val(T,0,0,0);
    }
  }end_foreach();mpi_all_reduce_array(&dd,double,MPI_MAX,1);mpi_all_reduce_array(&area,double,MPI_SUM,1);mpi_all_reduce_array(&number2,int,MPI_SUM,1);mpi_all_reduce_array(&sb,double,MPI_SUM,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
#line 4457
}

  sb2 = 2.0*3.141592653589793238*sb*2.0;
  radius3D = pow(3.0/(4.0*3.141592653589793238)*sb2,1.0/3.0);


  if(pid()==0){
       char name82[80];
       sprintf(name82,"volume.dat");
       FILE * fp82 = fopen(name82,"a");

      fprintf (fp82,
        "%.8f %.8f %.8f %.8f %d %g %g\n",
        t, sb, sb2, radius3D, number2, area, dd);

        fclose(fp82);
  }



 if(!restartsymbol){
      if((!restart_Tsat) && case_number==3){
          int flag_stop = 0;
          double Delta_min = L0_pysical/(1<<maxl);
          Tmax = 0.0;
          foreach_stencil(){

_stencil_val(topo_mask_s,0,0,0);{

_stencil_val(aiml,0,0,0);{ 
                      
_stencil_val(T,0,0,0); 
                    
                    
                
#line 4490
}

                
              
#line 4491
}

              
          
#line 4492
}end_foreach_stencil();
          
#undef OMP_PARALLEL
#define OMP_PARALLEL()
OMP(omp parallel  reduction(max:Tmax)reduction(max:flag_stop)){
#line 4482
foreach(){

              if(val(topo_mask_s,0,0,0)>=0){

                if(val(aiml,0,0,0)>=T_inf){
                    flag_stop = 1;
                    Tmax = val(T,0,0,0);
                    printf("flag_stop=1 t=end=%g origin_T=%g\n",t,Tmax);
                }
              }
          }end_foreach();mpi_all_reduce_array(&Tmax,double,MPI_MAX,1);mpi_all_reduce_array(&flag_stop,int,MPI_MAX,1);
#undef OMP_PARALLEL
#define OMP_PARALLEL() OMP(omp parallel)
}
          
#line 4493
if(flag_stop==1){
                    char dumpname[80];
                    {
                      _attribute[hhh.x.i].nodump = true;

                    }
#line 4495
{
                      _attribute[hhh.y.i].nodump = true;

                    }
                    sprintf(dumpname,"dump-final-i%d-t%g",i,t);
                    dump((struct Dump){dumpname});



                exit(1);
          }
      }
 }

if(dump_each_event && (i%dump_each_event_interval==0)){
        char dumpname[80];

      {
        _attribute[hhh.x.i].nodump = true;

      }
#line 4512
{
        _attribute[hhh.y.i].nodump = true;

      }
      sprintf(dumpname,"outfacets/dumpafteradapt-i%d-t%g",i,t);
      dump((struct Dump){dumpname});


}
}{end_tracing("logfile","template01.c",4521);return 0;}end_tracing("logfile","template01.c",4521);}
#line 4540 "template01.c"
static int end_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 1234567890);*ip=i;*tp=t;return ret;}      static int end(const int i,const double t,Event *_ev){tracing("end","template01.c",4540); {

  if(case_number==3 && (!restart_Tsat)){
   printf("t=end=%g\n",t);
  }
}{end_tracing("end","template01.c",4545);return 0;}end_tracing("end","template01.c",4545);}

static int stop_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = tend);*ip=i;*tp=t;return ret;}      static int stop(const int i,const double t,Event *_ev){tracing("stop","template01.c",4547); {
  {end_tracing("stop","template01.c",4548);return 1;}
}{end_tracing("stop","template01.c",4549);return 0;}end_tracing("stop","template01.c",4549);}
#line 2 "ast/init_solver.h"

static void _init_solver (void)
{
  void init_solver();
  datasize=153*sizeof(double);init_solver();
  embed=new_bid();quadtree_methods();{  event_register((Event){0,1,metric,{metric_expr0},((int *)0),((double *)0),"././embed-update-2.h",1052,"metric"});
  event_register((Event){0,1,defaults,{defaults_expr0},((int *)0),((double *)0),"././embed-update-2.h",1095,"defaults"});
  event_register((Event){0,1,metric_0,{metric_0_expr0},((int *)0),((double *)0),"././axi-official-update.h",166,"metric"});
  event_register((Event){0,1,defaults_0,{defaults_0_expr0},((int *)0),((double *)0),"/home/xiangbin2/basilisk_new/basilisk/src/run.h",42,"defaults"});
  event_register((Event){0,1,defaults_1,{defaults_1_expr0},((int *)0),((double *)0),"././axi-centered.h",148,"defaults"});
  event_register((Event){0,1,default_display,{default_display_expr0},((int *)0),((double *)0),"././axi-centered.h",207,"default_display"});
  event_register((Event){0,1,init,{init_expr0},((int *)0),((double *)0),"././axi-centered.h",235,"init"});
  event_register((Event){0,1,defaults_2,{defaults_2_expr0},((int *)0),((double *)0),"././my-vof-css-test.h",176,"defaults"});
  event_register((Event){0,1,defaults_3,{defaults_3_expr0},((int *)0),((double *)0),"././my-vof-css-test.h",196,"defaults"});
  event_register((Event){0,1,defaults_4,{defaults_4_expr0},((int *)0),((double *)0),"./axi-two-phase.h",48,"defaults"});
  event_register((Event){0,1,tracer_advection,{tracer_advection_expr0},((int *)0),((double *)0),"./axi-two-phase.h",93,"tracer_advection"});
  event_register((Event){0,1,init_0,{init_0_expr0},((int *)0),((double *)0),"././embed-solid.h",15,"init"});
  event_register((Event){0,1,defaults_5,{defaults_5_expr0},((int *)0),((double *)0),"/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",30,"defaults"});
  event_register((Event){0,1,contact,{contact_expr0},((int *)0),((double *)0),"././my-contact-embed-triple.h",307,"contact"});
  event_register((Event){0,1,defaults_6,{defaults_6_expr0},((int *)0),((double *)0),"template01.c",559,"defaults"});
  event_register((Event){0,1,init_1,{init_1_expr0},((int *)0),((double *)0),"template01.c",977,"init"});
  event_register((Event){0,2,extract1,{extract1_expr0,extract1_expr1},((int *)0),((double *)0),"template01.c",3228,"extract1"});
  event_register((Event){0,2,pictures,{pictures_expr0,pictures_expr1},((int *)0),((double *)0),"template01.c",3281,"pictures"});
  event_register((Event){0,1,end,{end_expr0},((int *)0),((double *)0),"template01.c",4540,"end"});
  event_register((Event){0,1,stop,{stop_expr0},((int *)0),((double *)0),"template01.c",4547,"stop"});


    

    init_const_vector((vector){{_NVARMAX+0},{_NVARMAX+1}},"zerof",(double[]) {0.,0.,0.});
  init_const_vector((vector){{_NVARMAX+2},{_NVARMAX+3}},"unityf",(double[]) {1.,1.,1.});
  init_const_scalar((scalar){_NVARMAX+4},"unity", 1.);
  init_const_scalar((scalar){_NVARMAX+5},"zeroc", 0.);
  init_scalar((scalar){0},"cs");
  init_face_vector((vector){{1},{2}},"fs");
  event_register((Event){0,1,cleanup,{cleanup_expr0},((int *)0),((double *)0),"/home/xiangbin2/basilisk_new/basilisk/src/run.h",50,"cleanup"});
  init_scalar((scalar){3},"p");
  init_vector((vector){{4},{5}},"u");
  init_vector((vector){{6},{7}},"g");
  init_scalar((scalar){8},"pf");
  init_face_vector((vector){{9},{10}},"uf");
  event_register((Event){0,1,set_dtmax,{set_dtmax_expr0},((int *)0),((double *)0),"././axi-centered.h",299,"set_dtmax"});
  event_register((Event){0,1,stability,{stability_expr0},((int *)0),((double *)0),"././axi-centered.h",307,"stability"});
  event_register((Event){0,1,before_vof,{before_vof_expr0},((int *)0),((double *)0),"././axi-centered.h",369,"before_vof"});
  event_register((Event){0,1,vof,{vof_expr0},((int *)0),((double *)0),"././axi-centered.h",375,"vof"});
  event_register((Event){0,1,after_vof,{after_vof_expr0},((int *)0),((double *)0),"././axi-centered.h",380,"after_vof"});
  event_register((Event){0,1,properties,{properties_expr0},((int *)0),((double *)0),"././axi-centered.h",390,"properties"});
  event_register((Event){0,1,diffusionT_one,{diffusionT_one_expr0},((int *)0),((double *)0),"././axi-centered.h",391,"diffusionT_one"});
  event_register((Event){0,1,advection_term,{advection_term_expr0},((int *)0),((double *)0),"././axi-centered.h",501,"advection_term"});
  event_register((Event){0,1,viscous_term,{viscous_term_expr0},((int *)0),((double *)0),"././axi-centered.h",545,"viscous_term"});
  event_register((Event){0,1,acceleration,{acceleration_expr0},((int *)0),((double *)0),"././axi-centered.h",581,"acceleration"});
  event_register((Event){0,1,projection,{projection_expr0},((int *)0),((double *)0),"././axi-centered.h",621,"projection"});
  event_register((Event){0,1,poisson_ps,{poisson_ps_expr0},((int *)0),((double *)0),"././axi-centered.h",671,"poisson_ps"});
  event_register((Event){0,1,get_ulf,{get_ulf_expr0},((int *)0),((double *)0),"././axi-centered.h",677,"get_ulf"});
  event_register((Event){0,1,end_timestep,{end_timestep_expr0},((int *)0),((double *)0),"././axi-centered.h",723,"end_timestep"});
  event_register((Event){0,1,update_Tl_Tg,{update_Tl_Tg_expr0},((int *)0),((double *)0),"././axi-centered.h",734,"update_Tl_Tg"});
  event_register((Event){0,1,adapt,{adapt_expr0},((int *)0),((double *)0),"././axi-centered.h",738,"adapt"});
  init_scalar((scalar){11},"cc_css_test");
  event_register((Event){0,1,stability_0,{stability_0_expr0},((int *)0),((double *)0),"././my-vof-css-test.h",209,"stability"});
  event_register((Event){0,1,vof_0,{vof_0_expr0},((int *)0),((double *)0),"././my-vof-css-test.h",1557,"vof"});
  init_scalar((scalar){12},"ff");
  init_scalar((scalar){13},"ff_oppo");
  init_scalar((scalar){14},"f_height");
  init_scalar((scalar){15},"rhocp");
  init_face_vector((vector){{16},{17}},"alphav");
  init_scalar((scalar){18},"rhov");
  event_register((Event){0,1,properties_0,{properties_0_expr0},((int *)0),((double *)0),"./axi-two-phase.h",132,"properties"});
  event_register((Event){0,1,acceleration_0,{acceleration_0_expr0},((int *)0),((double *)0),"/home/xiangbin2/basilisk_new/basilisk/src/iforce.h",43,"acceleration"});
  event_register((Event){0,1,stability_1,{stability_1_expr0},((int *)0),((double *)0),"././my-tension.h",37,"stability"});
  event_register((Event){0,1,acceleration_1,{acceleration_1_expr0},((int *)0),((double *)0),"././my-tension.h",78,"acceleration"});
  event_register((Event){0,1,acceleration_2,{acceleration_2_expr0},((int *)0),((double *)0),"././reduced.h",36,"acceleration"});
  init_scalar((scalar){19},"cm_css_test");
  init_face_vector((vector){{20},{21}},"fm_fss_test");
  init_scalar((scalar){22},"cm_css_test2");
  init_face_vector((vector){{23},{24}},"fm_fss_test2");
  init_scalar((scalar){25},"cm_css_test3");
  init_face_vector((vector){{26},{27}},"fm_fss_test3");
  init_scalar((scalar){28},"aiml_s");
  init_scalar((scalar){29},"aimg_s");
  init_scalar((scalar){30},"T");
  init_scalar((scalar){31},"Tlff");
  init_scalar((scalar){32},"Tgff");
  init_scalar((scalar){33},"T_solid");
  init_face_vector((vector){{34},{35}},"modphase0");
  init_face_vector((vector){{36},{37}},"modphase1");
  init_face_vector((vector){{38},{39}},"modphase_s_1");
  init_face_vector((vector){{40},{41}},"modphase_s_0");
  init_vector((vector){{42},{43}},"hhh");
  init_scalar((scalar){44},"corner_ff");
  init_vector((vector){{45},{46}},"direction_Tfg");
  init_vector((vector){{47},{48}},"direction_Tfl");
  init_vector((vector){{49},{50}},"direction_Ts");
  init_scalar((scalar){51},"topo_mask");
  init_scalar((scalar){52},"topo_mask_g");
  init_scalar((scalar){53},"topo_mask_s");
  init_scalar((scalar){54},"masstr");
  init_scalar((scalar){55},"source_pc");
  init_scalar((scalar){56},"vtr");
  init_scalar((scalar){57},"source_pc2");
  init_scalar((scalar){58},"poisson_source2");
  init_scalar((scalar){59},"ps");
  init_scalar((scalar){60},"psg");
  init_face_vector((vector){{61},{62}},"usf");
  init_face_vector((vector){{63},{64}},"usfg");
  init_face_vector((vector){{65},{66}},"ulf");
  init_face_vector((vector){{67},{68}},"ugf");
  init_scalar((scalar){69},"phase0Tgrad");
  init_scalar((scalar){70},"phase1Tgrad");
  init_scalar((scalar){71},"flux_lg_l");
  init_scalar((scalar){72},"flux_lg_g");
  init_face_vector((vector){{73},{74}},"fss_test");
  init_scalar((scalar){75},"css_test");
  init_face_vector((vector){{76},{77}},"fss_test2");
  init_scalar((scalar){78},"css_test2");
  init_scalar((scalar){79},"fs_solid");
  init_scalar((scalar){80},"css_test3");
  init_face_vector((vector){{81},{82}},"fss_test3");
  init_scalar((scalar){83},"css_test3_n");
  init_face_vector((vector){{84},{85}},"fss_test3_n");
  init_scalar((scalar){86},"deltac");
  init_scalar((scalar){87},"T_oold");
  init_scalar((scalar){88},"smf");
  init_scalar((scalar){89},"ssmf");
  init_scalar((scalar){90},"sssmf");
  init_scalar((scalar){91},"ssssmf");
  init_vector((vector){{92},{93}},"smallmodl");
  init_vector((vector){{94},{95}},"bigmodl");
  init_vector((vector){{96},{97}},"smallmodg");
  init_vector((vector){{98},{99}},"bigmodg");
  init_scalar((scalar){100},"resl");
  init_scalar((scalar){101},"resg");
  init_scalar((scalar){102},"ress");
  init_vector((vector){{103},{104}},"flux_show");
  init_scalar((scalar){105},"intersect_true");
  init_scalar((scalar){106},"res_ps");
  init_vector((vector){{107},{108}},"Tlff_g");
  init_vector((vector){{109},{110}},"Tgff_g");
  init_vector((vector){{111},{112}},"T_solid_g");
  init_scalar((scalar){113},"Tl");
  init_scalar((scalar){114},"Tg");
  init_scalar((scalar){115},"Ts");
  init_scalar((scalar){116},"aiml");
  init_scalar((scalar){117},"aimg");
  init_scalar((scalar){118},"T_modl");
  init_scalar((scalar){119},"T_modg");
  init_scalar((scalar){120},"flux_l");
  init_scalar((scalar){121},"flux_g");
  init_scalar((scalar){122},"areasl");
  init_scalar((scalar){123},"areasg");
  init_scalar((scalar){124},"arealg");
  init_scalar((scalar){125},"merge_to_me_s_c");
  init_vector((vector){{126},{127}},"merge_to_me_s_position");
  init_scalar((scalar){128},"merge_to_me_s_energy");
  init_scalar((scalar){129},"merge_to_me_l_c");
  init_vector((vector){{130},{131}},"merge_to_me_l_position");
  init_scalar((scalar){132},"merge_to_me_l_energy");
  init_scalar((scalar){133},"merge_to_me_g_c");
  init_vector((vector){{134},{135}},"merge_to_me_g_position");
  init_scalar((scalar){136},"merge_to_me_g_energy");
  init_vector((vector){{137},{138}},"ulf_v");
  init_scalar((scalar){139},"modify_near_region");
  init_scalar((scalar){140},"temp27");
  init_scalar((scalar){141},"temp28");
  init_scalar((scalar){142},"temp211");
  init_scalar((scalar){143},"temp212");
  init_scalar((scalar){144},"temp25");
  init_scalar((scalar){145},"temp26");
  init_scalar((scalar){146},"temp29");
  init_scalar((scalar){147},"temp210");
  init_scalar((scalar){148},"ff_old");
  init_scalar((scalar){149},"ff_old2");
  init_scalar((scalar){150},"div_numerical");
  init_scalar((scalar){151},"div_numerical2");
  init_scalar((scalar){152},"poisson_source2_f");
  event_register((Event){0,1,before_vof_0,{before_vof_0_expr0},((int *)0),((double *)0),"template01.c",1913,"before_vof"});
  event_register((Event){0,1,vof_1,{vof_1_expr0},((int *)0),((double *)0),"template01.c",1938,"vof"});
  event_register((Event){0,1,after_vof_0,{after_vof_0_expr0},((int *)0),((double *)0),"template01.c",2185,"after_vof"});
  event_register((Event){0,1,diffusionT_one_0,{diffusionT_one_0_expr0},((int *)0),((double *)0),"template01.c",2397,"diffusionT_one"});
  event_register((Event){0,1,poisson_ps_0,{poisson_ps_0_expr0},((int *)0),((double *)0),"template01.c",3088,"poisson_ps"});
  event_register((Event){0,1,get_ulf_0,{get_ulf_0_expr0},((int *)0),((double *)0),"template01.c",3181,"get_ulf"});
  event_register((Event){0,1,update_Tl_Tg_0,{update_Tl_Tg_0_expr0},((int *)0),((double *)0),"template01.c",3197,"update_Tl_Tg"});
  event_register((Event){0,1,adapt_0,{adapt_0_expr0},((int *)0),((double *)0),"template01.c",3334,"adapt"});
  event_register((Event){0,1,logfile,{logfile_expr0},((int *)0),((double *)0),"template01.c",4434,"logfile"});

#line 13
}  _attribute[p.i].dirty=1,_attribute[p.i].boundary[right]=_boundary8,_attribute[p.i].boundary_homogeneous[right]=_boundary8_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[left]=_boundary9,_attribute[p.i].boundary_homogeneous[left]=_boundary9_homogeneous;
  _attribute[uf.x.i].dirty=1,_attribute[uf.x.i].boundary[bottom]=_boundary10,_attribute[uf.x.i].boundary_homogeneous[bottom]=_boundary10;
  _attribute[uf.y.i].dirty=1,_attribute[uf.y.i].boundary[bottom]=_boundary11,_attribute[uf.y.i].boundary_homogeneous[bottom]=_boundary11_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[top]=_boundary12,_attribute[p.i].boundary_homogeneous[top]=_boundary12_homogeneous;
  _attribute[u.x.i].dirty=1,_attribute[u.x.i].boundary[right]=_boundary37,_attribute[u.x.i].boundary_homogeneous[right]=_boundary37_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[right]=_boundary38,_attribute[p.i].boundary_homogeneous[right]=_boundary38_homogeneous;
  _attribute[pf.i].dirty=1,_attribute[pf.i].boundary[right]=_boundary39,_attribute[pf.i].boundary_homogeneous[right]=_boundary39_homogeneous;
  _attribute[u.x.i].dirty=1,_attribute[u.x.i].boundary[top]=_boundary40,_attribute[u.x.i].boundary_homogeneous[top]=_boundary40_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[top]=_boundary41,_attribute[p.i].boundary_homogeneous[top]=_boundary41_homogeneous;
  _attribute[pf.i].dirty=1,_attribute[pf.i].boundary[top]=_boundary42,_attribute[pf.i].boundary_homogeneous[top]=_boundary42_homogeneous;
  _attribute[u.x.i].dirty=1,_attribute[u.x.i].boundary[embed]=_boundary43,_attribute[u.x.i].boundary_homogeneous[embed]=_boundary43_homogeneous;
  _attribute[u.y.i].dirty=1,_attribute[u.y.i].boundary[embed]=_boundary44,_attribute[u.y.i].boundary_homogeneous[embed]=_boundary44_homogeneous;
  _attribute[ps.i].dirty=1,_attribute[ps.i].boundary[embed]=_boundary45,_attribute[ps.i].boundary_homogeneous[embed]=_boundary45_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[embed]=_boundary46,_attribute[p.i].boundary_homogeneous[embed]=_boundary46_homogeneous;

  
#line 14
set_fpe();
}
